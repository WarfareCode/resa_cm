include "ptcolor.inc"
include "bbagd.inc"                # clk 12/95 (E1456/E1530) - DISPLAY ALSP STAT
include "bbalz.inc"
include "bbctl.inc"
include "bbboy.inc"
include "bbcode.inc"
include "bbunt.inc"
include "bbsta.inc"
include "bbsbi.inc"
include "bbsat.inc"
include "bbrmt.inc"
include "bbplc.inc"
include "bbpim.inc"
include "bbown.inc"
include "bbmrk.inc"
include "bblin.inc"                     # jb    11/14/89
include "orders.inc"
include "bbrte.inc"
include "bbprt.inc"
include "ascii.inc"
include "bbrth.inc"
include "wgmdrot.inc"
include "bbler.inc"
include "bbswb.inc"
include "bbacc.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbshc.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbbml.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbspa.inc"                # clk 10/91 for Submarine Patrol Areas (SPAs)
include "bbpsp.inc"                # clk 10/91 for plotting SPAs
include "bbpat.inc"                # clk 9/92  for display reporting policy
include "bbrvu.inc"                # clk 9/92  for display reporting policy
include "bbcmc.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbctm.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbhfd.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbird.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbsos.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbssr.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbswd.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbtrp.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbvue.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbnrt.inc"                # SMM 12/92 PER #E1101
include "bbrad.inc"                # bmb 3/30/93 for SUPPRESS command (H1082)
include "bbmc.inc"                 # clk 9/95 (E1456) - PLOT/ERASE GROUND SAM
include "bbmfd.inc"
include "bbswp.inc"
include "plplay.inc"
 
define (BBImplicit, Implicit None) # MJC 4/19/2000 - (E2145)
define($no$vue,)                   # clk 4/96 - (E1467)  This define needed for including
#include "wixprint.rin"             # wixprint.rin for DISPLAY FUEL command.

 
include "alsp.inc"                    # clk 12/95 (E1456/E1530)
Subroutine PL_Disply_ALSP_Stats
#########################################################################
#$%
#$% Purpose:    PL_Disply_ALSP_Stats processes the DISPLAY ALSP STATISTICS
#$%             command.  The number of ghosted and RESA owned units are
#$%             counted (for comparison with the ACM numbers).
#$%
#$% Called By:  PL_Disply_ALSP
#$%
#$% Calls:      Echo..
#$%
#$% Tables:     UNT     ACC     SHC
#$%
#$% Date:       January 1994
#$%
#$% Author:     Carol L. Kropp
#$%
#$% Modified:   Carol Kropp - 12/95 (E1456/E1530)
#$%             Added info for ghosted ALSP ground data (BBAGD.DEF).
#$%
#$%             Carol Kropp - 11/96 (E1672)
#$%             Added info for number of available UNT slots and number
#$%             of slots marked for deletion.
#$%
#$%             James Allen - 8/98 (E2024)
#$%             Moved the AGD data from the total ghost count to
#$%             a separate total - 7th Fleet controller were not
#$%             satisfied with the number of UNT slots available line.
#$%
#########################################################################
BBcommon
 
integer  total_non_alsp_units
integer  total_ghost_count, total_owned_count
integer  total_ground_units
integer  ghost_fixedwing_count, owned_fixedwing_count
integer  ghost_helo_count, owned_helo_count
integer  ghost_ship_count, owned_ship_count
integer  ghost_sub_count, owned_sub_count
integer  ghost_boat_count, owned_boat_count
integer  ghost_cm_count, owned_cm_count
integer  ghost_tbm_count, owned_tbm_count
integer  ghost_base_count, owned_base_count
integer  ghost_torpedo_count, owned_torpedo_count
integer  ghost_sonobuoy_count, owned_sonobuoy_count
integer  ghost_minefield_count, owned_minefield_count
integer  ghost_ctm_count, owned_ctm_count
integer  ghost_allrad_count
integer  ghost_himad_count
integer  ghost_radar_count
integer  ghost_tel_count
integer  ghost_combat_count
integer  ghost_support_convoy_count
integer  ghost_support_unit_count
integer  nbr_available_unt_slots
integer  nbr_unt_slots_being_deleted
integer  NBR_AVAILABLE_GROUND_SLOTS                                 # MJC 4/20/2000
integer  UNT$Pointer, UNT$GhostedUnit$I, UNT$ALSPid$I, UNT$Type$I,
         UNT$SuperType$I
integer  ACC$Pointer, ACC$Category$I
integer  SHC$Pointer, SHC$SmallBoat$I
integer  CMC$Pointer, CMC$Cat$I
integer  AGD$Pointer, AGD$ALSPClass$I
integer  BOY$Pointer, BOY$Type$I
integer  MFD$Pointer, MFD$InUse$I
 
  total_non_alsp_units = 0
  total_ghost_count = 0
  total_owned_count = 0
  ghost_fixedwing_count = 0
  owned_fixedwing_count = 0
  ghost_helo_count = 0
  owned_helo_count = 0
  ghost_ship_count = 0
  owned_ship_count = 0
  ghost_sub_count = 0
  owned_sub_count = 0
  ghost_boat_count = 0
  owned_boat_count = 0
  ghost_cm_count = 0
  owned_cm_count = 0
  ghost_tbm_count = 0
  owned_tbm_count = 0
  ghost_sonobuoy_count = 0
  owned_sonobuoy_count = 0
  ghost_minefield_count = 0
  owned_minefield_count = 0
  ghost_base_count = 0
  owned_base_count = 0
  ghost_torpedo_count = 0
  owned_torpedo_count = 0
  ghost_ctm_count = 0
  owned_ctm_count = 0
  ghost_allrad_count = 0
  ghost_himad_count = 0
  ghost_radar_count = 0
  ghost_tel_count = 0
  ghost_combat_count = 0
  ghost_support_convoy_count = 0
  ghost_support_unit_count = 0
  nbr_available_unt_slots = 0
  nbr_unt_slots_being_deleted = 0
 
  for (UNT$Pointer$First; UNT$Pointer$Valid; UNT$Pointer$Next)
    {
     if (xUNT$InUse$I == $no)
       {
        nbr_available_unt_slots = nbr_available_unt_slots + 1
        next
       }
     else if (xUNT$Status$I == $BeingDeleted$Code)
       {
        nbr_unt_slots_being_deleted = nbr_unt_slots_being_deleted + 1
        next
       }
 
     UNT$GhostedUnit$I = xUNT$GhostedUnit$I
     UNT$ALSPid$I = xUNT$ALSPid$I
 
     if ((ALSP$Active == $yes) &  # if joined to ALSP and unit is
         (UNT$ALSPid$I != 0))     # assigned an ALSP id, count it for ALSP totals
       {
         if (xUNT$Status$I == $BeingDeleted$Code)
           next
 
         UNT$Type$I = xUNT$Type$I
         UNT$SuperType$I = xUNT$SuperType$I
         if (UNT$GhostedUnit$I == $yes)   # if unit is a ghost
           {
             if (UNT$Type$I == $Air$Code)
               {
                 ACC$Pointer = xUNT$ACCPntr$I
                 ACC$Category$I = xACC$Category$I
                 if (ACC$Category$I == $Helo$Code)
                   ghost_helo_count = ghost_helo_count + 1
                 else
                   ghost_fixedwing_count = ghost_fixedwing_count + 1
               }    # end of unit is an aircraft
             else if (UNT$SuperType$I == $Submarine$SuperCode    |
                      UNT$SuperType$i == $FalseContact$SuperCode |
                      UNT$SuperType$i == $MarkerSub$SuperCode)
               {
                 ghost_sub_count = ghost_sub_count + 1
               }    # end of unit is a submarine unit
             else if (UNT$SuperType$I == $Torpedo$SuperCode)
               {
                 ghost_torpedo_count = ghost_torpedo_count + 1
               }    # end of unit is a torpedo unit
             else if (UNT$SuperType$I == $CtrMeasure$SuperCode)
               {
                 ghost_ctm_count = ghost_ctm_count + 1
               }    # end of unit is a countermeasure unit
             else if (UNT$Type$I == $Surface$Code)
               {
                 SHC$Pointer = xUNT$SHCPntr$I
                 SHC$SmallBoat$I = xSHC$SmallBoat$I
                 if (SHC$SmallBoat$I == $yes)
                     ghost_boat_count = ghost_boat_count + 1
                 else
                     ghost_ship_count = ghost_ship_count + 1
               }    # end of unit is a surface unit
             else if (UNT$Type$I == $CruiseMissile$Code)
               {
                 CMC$Pointer = xUNT$CMCPntr$I
                 CMC$Cat$I = xCMC$Cat$I
                 if (CMC$Cat$I == $Ball$Code)
                   ghost_tbm_count = ghost_tbm_count + 1
                 else
                   ghost_cm_count = ghost_cm_count + 1
               }    # end of unit is a cruise missile unit
             else if (UNT$Type$I == $ShoreBase$Code)
               {
                 ghost_base_count = ghost_base_count + 1
               }    # end of unit is a base
           }     # end of unit is a ghost
         else    # unit is RESA owned
           {
             if (UNT$Type$I == $Air$Code)
               {
                 ACC$Pointer = xUNT$ACCPntr$I
                 ACC$Category$I = xACC$Category$I
                 if (ACC$Category$I == $Helo$Code)
                   owned_helo_count = owned_helo_count + 1
                 else
                   owned_fixedwing_count = owned_fixedwing_count + 1
               }    # end of unit is an aircraft
             else if (UNT$SuperType$I == $Submarine$SuperCode    |
                      UNT$SuperType$i == $FalseContact$SuperCode |
                      UNT$SuperType$i == $MarkerSub$SuperCode)
               {
                 owned_sub_count = owned_sub_count + 1
               }    # end of unit is a submarine unit
             else if (UNT$SuperType$I == $Torpedo$SuperCode)
               {
                 owned_torpedo_count = owned_torpedo_count + 1
               }    # end of unit is a torpedo unit
             else if (UNT$SuperType$I == $CtrMeasure$SuperCode)
               {
                 owned_ctm_count = owned_ctm_count + 1
               }    # end of unit is a countermeasure unit
             else if (UNT$Type$I == $Surface$Code)
               {
                 SHC$Pointer = xUNT$SHCPntr$I
                 SHC$SmallBoat$I = xSHC$SmallBoat$I
                 if (SHC$SmallBoat$I == $yes)
                     owned_boat_count = owned_boat_count + 1
                 else
                     owned_ship_count = owned_ship_count + 1
               }    # end of unit is a surface unit
             else if (UNT$Type$I == $CruiseMissile$Code)
               {
                 CMC$Pointer = xUNT$CMCPntr$I
                 CMC$Cat$I = xCMC$Cat$I
                 if (CMC$Cat$I == $Ball$Code)
                   owned_tbm_count = owned_tbm_count + 1
                 else
                   owned_cm_count = owned_cm_count + 1
               }    # end of unit is a cruise missile unit
             else if (UNT$Type$I == $ShoreBase$Code)
               {
                 owned_base_count = owned_base_count + 1
               }      # end of unit is a base
           }     # end of if unit is RESA owned
       }    # end of unit is registered to ALSP
 
     else   # unit is not assigned an ALSP id
       {
        total_non_alsp_units = total_non_alsp_units + 1
       }
    }    # end of loop through the unit table
 
  for (AGD$Pointer$First; AGD$Pointer$Valid; AGD$Pointer$Next)
    {
     if (xAGD$Inuse$I != $no)
       {
        AGD$ALSPClass$I = xAGD$ALSPClass$I
        if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_allrad)
          ghost_allrad_count = ghost_allrad_count + 1
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_himad)
          ghost_himad_count = ghost_himad_count + 1
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_radar)
          ghost_radar_count = ghost_radar_count + 1
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_tel)
          ghost_tel_count = ghost_tel_count + 1
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_combat)
          ghost_combat_count = ghost_combat_count + 1
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_convoy)
          ghost_support_convoy_count = ghost_support_convoy_count + 1
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_unit |
              AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_unit_tcu)
          ghost_support_unit_count = ghost_support_unit_count + 1
       }    # end of if slot is in use
    }    # end of loop through the ALSP Ground Data Table
 
  for (BOY$Pointer$First; BOY$Pointer$OK; BOY$Pointer$Next)
    {
     BOY$Type$I = xBOY$Type$I
     if (BOY$Type$I != $null)
       {
        if (XBOY$GhostedUnit$I == $YES)
        {
            if (BOY$Type$I == $ActiveBarrier$Code)
                ghost_sonobuoy_count = ghost_sonobuoy_count + 1
        }
        else
        {
            if (BOY$Type$I == $ActiveBarrier$Code)
                owned_sonobuoy_count = owned_sonobuoy_count + 1
        }
       }
    }    # end of loop through BOY table
 
  for (MFD$Pointer$First; MFD$Pointer$OK; MFD$Pointer$Next)
    {
     MFD$InUse$I = xMFD$InUse$I
     if (MFD$InUse$I != 0)
       {
        if (XMFD$GhostedUnit$I == $YES)
        {
            ghost_minefield_count = ghost_minefield_count + 1
        }
        else
        {
            owned_minefield_count = owned_minefield_count + 1
        }
       }
    }    # end of loop through MFD table
 
  total_owned_count = owned_fixedwing_count + owned_helo_count +
                           owned_ship_count + owned_sub_count +
                           owned_torpedo_count + owned_ctm_count +
                           owned_boat_count + owned_cm_count +
                           owned_tbm_count + owned_base_count
 
  # joa 8/98 (E2024) Moved the allrad, himan and radar to a separate total
  total_ghost_count = ghost_fixedwing_count + ghost_helo_count +
                      ghost_ship_count + ghost_sub_count +
                      ghost_torpedo_count + ghost_ctm_count +
                      ghost_boat_count + ghost_cm_count +
                      ghost_tbm_count + ghost_base_count
 
  call echor
  call echov  ("                           Owned   Ghosted")
  call echor
  call echov  ("  AIR.CRUISE_MISSILE       ")
  call echoib (owned_cm_count, 5)
  call echoib (ghost_cm_count, 10)
  call echor
  call echov  ("  AIR.FIXEDWING            ")
  call echoib (owned_fixedwing_count, 5)
  call echoib (ghost_fixedwing_count, 10)
  call echor
  call echov  ("  AIR.HELICOPTER           ")
  call echoib (owned_helo_count, 5)
  call echoib (ghost_helo_count, 10)
  call echor
  call echov  ("  AIR.TBM                  ")
  call echoib (owned_tbm_count, 5)
  call echoib (ghost_tbm_count, 10)
  call echor
  call echov  ("  GROUND.BASE              ")
  call echoib (owned_base_count, 5)
  call echoib (ghost_base_count, 10)
  call echor
  call echov  ("  SEA.SUBSURFACE           ")
  call echoib (owned_sub_count, 5)
  call echoib (ghost_sub_count, 10)
  call echor
  call echov  ("  SEA.TORPEDO              ")
  call echoib (owned_torpedo_count, 5)
  call echoib (ghost_torpedo_count, 10)
  call echor
  call echov  ("  SEA.COUNTERMEASURE       ")
  call echoib (owned_ctm_count, 5)
  call echoib (ghost_ctm_count, 10)
  call echor
  call echov  ("  SEA.SURFACE.BOAT         ")
  call echoib (owned_boat_count, 5)
  call echoib (ghost_boat_count, 10)
  call echor
  call echov  ("  SEA.SURFACE.SHIP         ")
  call echoib (owned_ship_count, 5)
  call echoib (ghost_ship_count, 10)
  call echor
  call echov  ("TOTAL                      ")
  call echoib (total_owned_count, 5)
  call echoib (total_ghost_count, 10)
  call echor
  call echor
  call echov  ("Number of units not registered to ASLP:  ")
  call echoib (total_non_alsp_units, 5)
  call echor
  call echov  ("Number of available UNT slots:           ")  # JA 8/98 (E2024)
  call echoib (nbr_available_unt_slots, 5)                   # separate count
  call echor                                                 # for AGD data
  call echov  ("Number of UNT slots marked for deletion  ")
  call echoib (nbr_unt_slots_being_deleted, 5)
  call echor
  call echor
  call echov  ("  SEA.SONOBUOY             ")
  call echoib (owned_sonobuoy_count, 5)
  call echoib (ghost_sonobuoy_count, 10)
  call echor
  call echov  ("  SEA.MINE                 ")
  call echoib (owned_minefield_count, 5)
  call echoib (ghost_minefield_count, 10)
  call echor
  call echor
  call echov  ("                              Ghosted")
  call echor
  call echov  ("  GROUND.MANEUVER.ALLRAD            ")
  call echoib (ghost_allrad_count, 10)
  call echor
  call echov  ("  GROUND.MANEUVER.HIMAD             ")
  call echoib (ghost_himad_count, 10)
  call echor
  call echov  ("  GROUND.MANEUVER.RADAR             ")
  call echoib (ghost_radar_count, 10)
  call echor
  call echov  ("  GROUND.MANEUVER.TEL               ")
  call echoib (ghost_tel_count, 10)
  call echor
  call echov  ("  GROUND.MANEUVER.COMBAT            ")
  call echoib (ghost_combat_count, 10)
  call echor
  call echov  ("  GROUND.SUPPORT.CONVOY             ")
  call echoib (ghost_support_convoy_count, 10)
  call echor
  call echov  ("  GROUND.SUPPORT.UNIT               ")
  call echoib (ghost_support_unit_count, 10)
  call echor
 
  total_ground_units = ghost_allrad_count + ghost_himad_count +
                       ghost_radar_count + ghost_combat_count +
                       ghost_support_convoy_count + ghost_tel_count +
                       ghost_support_unit_count
 
  nbr_available_ground_slots = AGD$Slots - total_ground_units
 
  call echov  ("TOTAL                      ")
  call echoib (total_ground_units, 10)
  call echor
 
  call echov  ("Available GROUND slots:    ")
  call echoib (nbr_available_ground_slots, 10)
  call echor
 
return
end

 
Subroutine pl_plot_jtids (STA$Pointer,   # in: pointer for station
                          nargs,         # in: number of arguments in command
                          args)          # in: array of command arguments
#########################################################################
#$%
#$% Purpose:    pl_plot_jtids processes the PLOT JTIDS and ERASE JTIDS
#$%             commands.
#$% Note:       Code was removed from pl_plot and expanded to allow
#$%             for specification of track designation/type (rather
#$%             than all or nothing).
#$%
#$%             PLOT JTIDS (tracks for platform) <force-name>
#$%                        (of type) [ ALL | ENEMY | FRIENDLY | NEUTRAL | UNKNOWN ]
#$%                                  [ | AIR | LAND | SURFACE ]
#$%                        (display locally held tracks) [ YES | NO ];
#$%             ERASE JTIDS (tracks of type) [ ALL | ENEMY | FRIENDLY | NEUTRAL | UNKNOWN ]
#$%                                          [ | AIR | LAND | SURFACE ];
#$%
#$% Called By:  PL_plot
#$%
#$% Calls:
#$%
#$% Tables:     STA     UNT
#$%
#$% Date:       December 1996 (E1707)
#$%
#$% Author:     Carol L. Kropp
#$%
#########################################################################
BBcommon
 
integer  STA$Pointer, nargs
literal  args[nargs]
integer  STA$View$I, STA$PlotL16ForceIndx$I
integer  UNT$Pointer
integer  ok_to_process_flag
integer  unit_unt_index
integer  set_value
integer  designation_lex_value  # for [ ALL | ENEMY | ... ] specification
integer  class_lex_value        # for [ | AIR | LAND | SURFACE ] specification,
                                # if nothing specified it is set to $lex$All$
integer  plot_local_tracks_flag
literal  CSTRIP8    # MJC 4/20/2000
 
  STA$View$I = xSTA$View$I
  if (JTIDS$Capable$Game != $yes) # if not a JTIDS game
    {
     call echov ("This is not a JTIDS Capable Game.")
     call echo  ($BELL)
     call echor
     return
    }
  else if (STA$View$I > $LastBlue$View)  # if not a control or blue station
    {
     call echov ("There is no JTIDS capability for Orange.")
     call echo  ($BELL)
     call echor
     return
    }
  else  # then it is ok to process the command
    {
     ok_to_process_flag = $no
     unit_unt_index = 0
 
     if (args[1] == $lex$Erase$)
       {
        ok_to_process_flag = $yes
        set_value = NO
        designation_lex_value = args[3]
        if (nargs < 4)
          class_lex_value = $lex$All$
        else
          class_lex_value = args[4]
        plot_local_tracks_flag = $no
       }
     else                          # if a PLOT command find
       {                           # specified unit
        set_value = !NO
        for (UNT$Pointer$First; UNT$Pointer$Ok; UNT$Pointer$Next)
          {
           if (args[3] == xUNT$Name$C)
             {
              if (STA$View$I == $Neutral$View | STA$View$I == xUNT$View$I)
                {
                 if (xUNT$JTIDSCapable$I == $yes)
                   {
                    ok_to_process_flag = $yes
                    unit_unt_index = UNT$Pointer$Index
                    break
                   }
                 else
                   {
                    call echohn (args[3], $$MaxLit)
                    call echov  (" is not capable of sending/receiving JTIDS data.");
                    call echo   ($Bell)
                    call echor
                    return
                   }   # end unit is not JTIDS capable
                }   # end the unit is in the view or this is control
             }   # end of if a name match
          }   # end of loop through the unit table looking for specified unit
 
        designation_lex_value = args[4]
        if (nargs < 6)
          {
           class_lex_value = $lex$All$
           if (args[5] == $lex$No$)
             plot_local_tracks_flag = $no
           else
             plot_local_tracks_flag = $yes
          }
        else
          {
           class_lex_value = args[5]
           if (args[6] == $lex$No$)
             plot_local_tracks_flag = $no
           else
             plot_local_tracks_flag = $yes
          }
       }   # end of if a PLOT command
 
     if (ok_to_process_flag == $yes)
       {
        if (args[1] == $lex$Plot$)                         # if plotting for
          {                                                # a new unit, clear
           if (xSTA$PlotL16ForceIndx$I != unit_unt_index)  # old settings first
             {
              putSTA$PlotL16Data$I  ($no)
              STA$PlotL16ForceIndx$I = unit_unt_index
              putSTA$PlotL16ForceIndx$I
             }
           putSTA$PlotL16Local$I (plot_local_tracks_flag)
          }
 
        if (designation_lex_value == $lex$All$)
          {
           if (class_lex_value == $lex$All$)
             {
              if (args[1] == $lex$Erase$)
                putSTA$PlotL16Data$I  (set_value)
              putSTA$PlotL16All$I  (set_value)
             }
           else if (class_lex_value == $lex$Air$)
             {
              putSTA$PlotL16EnemyAir$I     (set_value)
              putSTA$PlotL16FriendlyAir$I  (set_value)
              putSTA$PlotL16NeutralAir$I   (set_value)
              putSTA$PlotL16UnknownAir$I   (set_value)
             }
           else if (class_lex_value == $lex$Land$)
             {
              putSTA$PlotL16EnemyLand$I     (set_value)
              putSTA$PlotL16FriendlyLand$I  (set_value)
              putSTA$PlotL16NeutralLand$I   (set_value)
              putSTA$PlotL16UnknownLand$I   (set_value)
             }
           else if (class_lex_value == $lex$Surface$)
             {
              putSTA$PlotL16EnemySurf$I     (set_value)
              putSTA$PlotL16FriendlySurf$I  (set_value)
              putSTA$PlotL16NeutralSurf$I   (set_value)
              putSTA$PlotL16UnknownSurf$I   (set_value)
             }
          }   # end of if [ PLOT | ERASE ] JTIDS ALL
        else if (designation_lex_value == $lex$Enemy$)
          {
           if (class_lex_value == $lex$All$)
              putSTA$PlotL16Enemy$I  (set_value)
           else if (class_lex_value == $lex$Air$)
              putSTA$PlotL16EnemyAir$I  (set_value)
           else if (class_lex_value == $lex$Land$)
              putSTA$PlotL16EnemyLand$I  (set_value)
           else if (class_lex_value == $lex$Surface$)
              putSTA$PlotL16EnemySurf$I  (set_value)
          }   # end of if [ PLOT | ERASE ] JTIDS ENEMY
        else if (designation_lex_value == $lex$Friendly$)
          {
           if (class_lex_value == $lex$All$)
              putSTA$PlotL16Friendly$I  (set_value)
           else if (class_lex_value == $lex$Air$)
              putSTA$PlotL16FriendlyAir$I  (set_value)
           else if (class_lex_value == $lex$Land$)
              putSTA$PlotL16FriendlyLand$I  (set_value)
           else if (class_lex_value == $lex$Surface$)
              putSTA$PlotL16FriendlySurf$I  (set_value)
          }   # end of if [ PLOT | ERASE ] JTIDS FRIENDLY
        else if (designation_lex_value == $lex$Neutral$)
          {
           if (class_lex_value == $lex$All$)
              putSTA$PlotL16Neutral$I  (set_value)
           else if (class_lex_value == $lex$Air$)
              putSTA$PlotL16NeutralAir$I  (set_value)
           else if (class_lex_value == $lex$Land$)
              putSTA$PlotL16NeutralLand$I  (set_value)
           else if (class_lex_value == $lex$Surface$)
              putSTA$PlotL16NeutralSurf$I  (set_value)
          }   # end of if [ PLOT | ERASE ] JTIDS NEUTRAL
        else if (designation_lex_value == $lex$Unknown$)
          {
           if (class_lex_value == $lex$All$)
              putSTA$PlotL16Unknown$I  (set_value)
           else if (class_lex_value == $lex$Air$)
              putSTA$PlotL16UnknownAir$I  (set_value)
           else if (class_lex_value == $lex$Land$)
              putSTA$PlotL16UnknownLand$I  (set_value)
           else if (class_lex_value == $lex$Surface$)
              putSTA$PlotL16UnknownSurf$I  (set_value)
          }   # end of if [ PLOT | ERASE ] JTIDS UNKNOWN
       }   # end of if the comand passed rejection checks
     else
       {
        call echohn (args[3], $$MaxLit)
        call echov  (" was not located - cannot plot JTIDS information.")
        call echo   ($BELL)
        call echor
        return
       }   # end of if unit was not located
    }   # end of if this is a JTIDS Game and the station is Blue or Control
 
return
end    # end of pl_plot_jtids

 
Subroutine pl_label_routes (station_nbr, # in: station number
                            nargs,       # in: number arguments in command
                            args)        # in: command arguments
###########################################################################
#$%
#$% Purpose:    PL_label_routes process the command:
#$%                           LABEL ROUTE  [ ALL | NAMED <name> ]
#$%             If no matching route was found in the RTE and PRT table
#$%             then an error message will be sent.
#$%
#$% Called by:  pl_label
#$%
#$% Calls:      echo..
#$%
#$% Tables:     STA     RTE     PRT
#$%
#$% Date:       November 1996 (E1677)
#$%
#$% Author:     Carol Kropp
#$%
############################################################################
BBcommon
 
integer   station_nbr, nargs, iarg
literal   args[20]
literal   CSTRIP8                                               # MJC 4/20/2000
integer   label_all_routes, label_value
literal   label_this_route
integer   send_error
integer   STA$Pointer, STA$View$I
integer   RTE$Pointer, RTE$View$I
literal   RTE$Name$C
integer   current_route_index
integer   PRT$Pointer, PRT$RTE_Index$I, PRT$STA_Index$I
 
if (args[1] == $lex$LABEL$)
    iarg = 2
else
    iarg = 3
 
  if (args[iarg+1] == $lex$ALL$)   # if [ PLOT/ERASE LABEL | LABEL] ROUTE ALL
    {
     label_all_routes = $yes
     label_this_route = $Blank_Literal
    }
  else
    {
     label_all_routes = $no
     label_this_route = args[iarg+2]
    }
 
# Setup label value for erase and plot
if (args[1] == $LEX$ERASE$)
 
    label_value = $no
else
    label_value = $yes
 
  STA$Pointer$To  (station_nbr)
  STA$View$I = xSTA$View$I
 
  send_error = $yes
  for (RTE$Pointer$First; RTE$Pointer$Valid; RTE$Pointer$Next)
    {
     RTE$Name$C = xRTE$Name$C
     if (RTE$Name$C == label_this_route | label_all_routes == $yes)
       {
        RTE$View$I = xRTE$View$I
        if ((STA$View$I == $Neutral$View)                                 |
            (STA$View$I <= $LastBlue$View & RTE$View$I <= $LastBlue$View) |
            (STA$View$I >  $LastBlue$View & RTE$View$I >  $LastBlue$View) )
          {
           current_route_index = RTE$Pointer$Index
           for (PRT$Pointer$First; PRT$Pointer$Ok; PRT$Pointer$Next)
             {
              PRT$RTE_Index$I = xPRT$RTE_Index$I
              PRT$STA_Index$I = xPRT$STA_Index$I
              if (PRT$RTE_Index$I == current_route_index &
                  PRT$STA_Index$I == station_nbr         )
                {
                 putPRT$LabelRouteFlag$I  (label_value)
                 send_error = $no
                 break
                }   # end of if this station is plotting the route
             }   # end of loop through the plotted route table
          }   # end of if view can see the route
       }   # end of if name matches or label all
    }   # end of loop through the route table
 
  if (send_error == $yes)
    {
     call echov ("Unable to LABEL ROUTE ")
     if (label_all_routes == $yes)
        call echov ("ALL - No plotted routes located.")
     else
       {
        call echov  ("NAMED ")
        call echohn (label_this_route, $$MaxLit)
        call echov  (" - No plotted route by that name located.")
       }
     call echor
    }   # end of if an error message needs to be sent
 
return
end   # end of pl_label_routes

 
Subroutine pl_label_spas  (station_nbr, # in: station number
                            nargs,       # in: number arguments in command
                            args)        # in: command arguments
###########################################################################
#$%
#$% Purpose:    PL_label_spaw process the command:
#$%                           LABEL SPA  [ ALL | NAMED <name> ]
#$%             If no matching route was found in the SPA and PSP table
#$%             then an error message will be sent.
#$%
#$% Called by:  pl_label
#$%
#$% Calls:      echo..
#$%
#$% Tables:     STA     SPA     PSS
#$%
#$% Date:       May 2005 per_ordsyntax
#$%
#$% Author:     James O. Allen
#$%
############################################################################
BBcommon
 
integer   station_nbr, nargs, iarg
literal   args[20]
literal   CSTRIP8                                               # MJC 4/20/2000
integer   label_all_spas, label_value
literal   label_this_spa
integer   send_error
integer   STA$Pointer, STA$View$I
integer   SPA$Pointer, SPA$View$I
literal   SPA$Name$C
integer   current_spa_index
integer   PSP$Pointer, PSP$SPA_Index$I, PSP$STA_Index$I
 
if (args[1] == $lex$LABEL$)
    iarg = 2
else
    iarg = 3
 
  if (args[iarg+1] == $lex$ALL$)   # if [ PLOT/ERASE LABEL | LABEL] ROUTE ALL
    {
     label_all_spas = $yes
     label_this_spa = $Blank_Literal
    }
  else
    {
     label_all_spas = $no
     label_this_spa = args[iarg+2]
    }
 
# Setup label value for erase and plot
if (args[1] == $LEX$ERASE$)
 
    label_value = $no
else
    label_value = $yes
 
  STA$Pointer$To  (station_nbr)
  STA$View$I = xSTA$View$I
 
  send_error = $yes
  for (SPA$Pointer$First; SPA$Pointer$Valid; SPA$Pointer$Next)
    {
     SPA$Name$C = xSPA$Name$C
     if (SPA$Name$C == label_this_spa | label_all_spas == $yes)
       {
        SPA$View$I = xSPA$View$I
        if ((STA$View$I == $Neutral$View)                                 |
            (STA$View$I <= $LastBlue$View & SPA$View$I <= $LastBlue$View) |
            (STA$View$I >  $LastBlue$View & SPA$View$I >  $LastBlue$View) )
          {
           current_spa_index = SPA$Pointer$Index
           for (PSP$Pointer$First; PSP$Pointer$Ok; PSP$Pointer$Next)
             {
              PSP$SPA_Index$I = xPSP$SPA_Index$I
              PSP$STA_Index$I = xPSP$STA_Index$I
              if (PSP$SPA_Index$I == current_spa_index &
                  PSP$STA_Index$I == station_nbr         )
                {
                 putPSP$LabelFlag$I  (label_value)
                 send_error = $no
                 break
                }   # end of if this station is plotting the spa
             }   # end of loop through the plotted spa table
          }   # end of if view can see the spa
       }   # end of if name matches or label all
    }   # end of loop through the spa table
 
  if (send_error == $yes)
    {
     call echov ("Unable to LABEL SPA ")
     if (label_all_spas == $yes)
        call echov ("ALL - No plotted SPAs located.")
     else
       {
        call echov  ("NAMED ")
        call echohn (label_this_spa, $$MaxLit)
        call echov  (" - No plotted SPA by that name located.")
       }
     call echor
    }   # end of if an error message needs to be sent
 
return
end   # end of pl_label_spas
 

Subroutine pl_label_lines  (station_nbr, # in: station number
                            nargs,       # in: number arguments in command
                            args)        # in: command arguments
###########################################################################
#$%
#$% Purpose:    PL_label_lines process the command:
#$%                           LABEL [LINE | POLYGON]  [ ALL | NAMED <name> ]
#$%
#$% Called by:  pl_label
#$%
#$% Calls:      echo..
#$%
#$% Tables:     STA     LIN
#$%
#$% Date:       May 2005
#$%
#$% Author:     James O. Allen
#$%
############################################################################
BBcommon
 
integer   station_nbr, nargs, iarg
literal   args[20]
literal   CSTRIP8                                               # MJC 4/20/2000
integer   label_all_lines, label_value
literal   label_this_line
integer   send_error
BBDeclare  ( LIN$Pointer, LIN$View$I, LIN$Line$i,
             STA$Pointer, STA$View$i)
 
if (args[1] == $lex$LABEL$)
{
    iarg = 2
}
else
{
    iarg = 3
}
 
if (args[iarg+1] == $lex$ALL$)   # if [ PLOT/ERASE LABEL | LABEL] LINE ALL
{
     label_all_lines = $yes
     label_this_line = $Blank_Literal
}
else
{
     label_all_lines = $no
     label_this_line = args[iarg+2]
}
 
# Setup label value for erase and plot
if (args[1] == $LEX$ERASE$)
 
    label_value = $no
else
    label_value = $yes
 
 
STA$Pointer$To  (station_nbr)
STA$View$I = xSTA$View$I
 
send_error = $yes
for (LIN$Pointer$First; LIN$Pointer$OK; LIN$Pointer$Next)
{
    # matching type of shape
    lin$line$i = xLIN$LINE$i
    if (args[iarg] == $Lex$LINE$ & lin$line$i != $YES)  NEXT
    if (args[iarg] != $Lex$LINE$ & lin$line$i == $YES)  NEXT
 
    # Don't erase plan fire polygon - joa 2/98 (E1864)
    if (LIN$Pointer$Index == xSTA$PlanCMPolygonIndx$I)
        next
 
    if (label_all_lines == $yes | xLIN$Name$C == label_this_line)
    {
        PUTlin$LabelFlag$i (label_value)
        send_error = $no
    }
}    # End FOR thru LIN table
 
if (send_error == $yes)
{
     call echov ("Unable to FIND ")
     if (args[iarg] == $lex$LINE$) call echov ("LINE ")
     else                          call echov ("POLYGON")
 
     if (label_all_lines == $yes)
        call echov ("ALL - None defined.")
     else
       {
        call echov  ("NAMED ")
        call echohn (label_this_line, $$MaxLit)
        call echov  (" - None defined by that name.")
       }
     call echor
}
 
 
return
end

Subroutine pl_label_landings  (station_nbr, # in: station number
                            nargs,       # in: number arguments in command
                            args)        # in: command arguments
###########################################################################
#$%
#$% Purpose:    PL_label_landings process the command:
#$%                           LABEL LANDING [ ALL | NAMED <name> ]
#$%
#$% Called by:  pl_label
#$%
#$% Calls:      echo..
#$%
#$% Tables:     STA     ALZ
#$%
#$% Date:       May 2005
#$%
#$% Author:     James O. Allen
#$%
############################################################################
BBcommon
 
integer   station_nbr, nargs, iarg
literal   args[20]
literal   CSTRIP8                                               # MJC 4/20/2000
integer   all_landings, label_value
literal   this_landing
integer   send_error
BBDeclare  ( ALZ$Pointer, ALZ$View$I,
             STA$Pointer, STA$View$i)
 
if (args[1] == $lex$LABEL$)
{
    iarg = 2
}
else
{
    iarg = 3
}
 
  if (args[iarg+1] == $lex$ALL$)   # if [ PLOT/ERASE LABEL | LABEL] LANDING ALL
    {
     all_landings = $yes
     this_landing = $Blank_Literal
    }
  else
    {
     all_landings = $no
     this_landing = args[iarg+2]
    }
 
# Setup label value for erase and plot
if (args[1] == $LEX$ERASE$)
 
    label_value = $no
else
    label_value = $yes
 
 
STA$Pointer$To  (station_nbr)
STA$View$I = xSTA$View$I
 
send_error = $yes
for (ALZ$Pointer$First; ALZ$Pointer$OK; ALZ$Pointer$Next)
{
    if (all_landings == $yes | xALZ$Name$C == this_landing)
    {
        send_error = $no
        PUTALZ$LabelFlag$i (label_value)
    }
}    # End FOR thru ALZ table
 
if (send_error == $yes)
{
     call echov ("Unable to FIND LANDING ")
     if (all_landings == $yes)
        call echov ("ALL - No defined landing zones.")
     else
       {
        call echov  ("NAMED ")
        call echohn (this_landing, $$MaxLit)
        call echov  (" - No defined landing zone by that name.")
       }
     call echor
}
 
return
end

include "dwdraw.inc"
define(bbimplicit, implicit none)
 
#$% housekeeping related to plot symbology of game units
subroutine pl_symbols(_
                  nord,                       # in, order number
                  ista,                       # in, station
                  nargs,                      # in, number words
                  args)                       # in, parameters
BBcommon
 
integer*4   ista
integer*4   nargs, nord
literal     args[nargs]
integer*4   i_switch_1
integer*4   LEX_Symbol
integer*4   STA$Pointer
integer*4   STA$Symbology$i
 
STA$Pointer$To ista                             #get view pointer
 
LEX_Symbol = args[2]
 
if (LEX_Symbol != $LEX$NTDS$ &
    LEX_Symbol != $LEX$TOP$ &
    LEX_Symbol != $LEX$SIDE$)
    {
    return
    }
 
#$% if we are not setting all station's symbology
if (args[3] != $LEX$ALL$)
    {
    STA$Symbology$i = xSTA$Symbology$i
 
    #$% if we don't need to reset the station symbology
    if ( (LEX_Symbol == $LEX$NTDS$ &
          STA$Symbology$i == $NTDS$Symbology) |
         (LEX_Symbol == $LEX$TOP$ &
          STA$Symbology$i == $TopView$Symbology) |
         (LEX_Symbol == $LEX$SIDE$ &
          STA$Symbology$i == $SideView$Symbology) )
        {
        return
        }
    } # end if not setting all station's symbology
 
SWITCH (LEX_Symbol)
    {
    CASE $LEX$NTDS$ : STA$Symbology$i = $NTDS$Symbology
    CASE $LEX$TOP$  : STA$Symbology$i = $TopView$Symbology
    CASE $LEX$SIDE$ : STA$Symbology$i = $SideView$Symbology
    default         : STA$Symbology$i = $NTDS$Symbology
    }
 
if (args[3] != $LEX$ALL$)
    {
    putSTA$Symbology$i
    }
#$% else set all stations
else
    {
    for (STA$Pointer$First; STA$Pointer$OK; STA$Pointer$Next)
        {
        putSTA$Symbology$i
        }
    }
 
return
end   # end of pl_symbols
 

 
# Find polygon created by player
subroutine find_polygon (sta$pointer, name, linpntr)
BBcommon
BBDeclare(sta$pointer, lin$pointer)
BBDeclare(LIN$Station$i, LIN$Line$i, LIN$Name$C)
literal name
literal   CSTRIP8
integer ista, linpntr, iview
 
ista = STA$Pointer$Index
 
iview = Xsta$View$i
 
for(LIN$POINTER$FIRST;LIN$POINTER$OK;LIN$POINTER$NEXT)
{
    LIN$Station$i = xLIN$Station$i
 
    if (LIN$Station$i == 0) NEXT
 
    if (IView != $Neutral$view)
    {
        if (LIN$Station$i != ista) NEXT
    }
 
    # Skip lines
    LIN$LINE$i = xLIN$LINE$i
    if (LIN$LINE$i == $YES)  NEXT
 
    LIN$Name$C = xLIN$Name$C
    if (LIN$Name$C == name) break
}
 
linpntr = lin$pointer
 
return
end
 

 
vaxcharacter*ARB function Ground_class_to_Char (class_code)
implicit none
integer class_code
integer  kk, strlen
integer  i_switch_1
 
kk = 0
ground_class_to_char = ""
 
switch (class_code)
{
    case $ground_base:
        call vmovv ("GROUND.BASE", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver:
        call vmovv ("GROUND.MANEUVER", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_himad:
        call vmovv ("GROUND.MANEUVER.HIMAD", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_shorad:
        call vmovv ("GROUND.MANEUVER.SHORAD", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_allrad:
        call vmovv ("GROUND.MANEUVER.ALLRAD", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_combat:
        call vmovv ("GROUND.MANEUVER.COMBAT", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_support:
        call vmovv ("GROUND.MANEUVER.SUPPORT", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_support_convoy:
        call vmovv ("GROUND.MANEUVER.SUPPORT.CONVOY", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_support_unit:
        call vmovv ("GROUND.MANEUVER.SUPPORT.UNIT", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_support_unit_tcu:
        call vmovv ("GROUND.MANEUVER.SUPPORT.UNIT.TCU", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_radar:
        call vmovv ("GROUND.MANEUVER.RADAR", Ground_class_to_Char, kk)
    case $alsp_class_ground_maneuver_tel:
        call vmovv ("GROUND.MANEUVER.TEL", Ground_class_to_Char, kk)
    case $alsp_class_ground_facility:
        call vmovv ("GROUND.FACILITY", Ground_class_to_Char, kk)
    default:
        call vmovv ("GROUND.???", Ground_class_to_Char, kk)
}
 
return
end

integer function find_mfd_slot (alspid)
bbcommon
integer alspid
integer i, k
bbdeclare (mfd$pointer, mfd$alspid$i)
 
for (mfd$pointer$first; mfd$pointer$valid; mfd$pointer$next)
{
    if (Xmfd$Inuse$i == 0) next
 
    mfd$ALSPID$i = Xmfd$ALSPID$i
    if (mfd$ALSPID$i == alspid) break
}
 
i = 0
if (mfd$pointer$valid) i = mfd$pointer$index
 
return (i)
end


integer function find_mfd_name (name)
bbcommon
Literal cstrip8, name
integer i, k, litcmp
bbdeclare (mfd$pointer)
 
for (mfd$pointer$first; mfd$pointer$valid; mfd$pointer$next)
{
    if (Xmfd$Inuse$i == 0) next
 
    if (litcmp(Xmfd$Name$c, name) == 0) break
}
 
i = 0
if (mfd$pointer$valid) i = mfd$pointer$index
 
return (i)
end
  

integer function find_swp_slot (alspid)
bbcommon
integer alspid
integer i, k
bbdeclare (swp$pointer, swp$alspid$i)
 
for (swp$pointer$first; swp$pointer$valid; swp$pointer$next)
{
    if (Xswp$Inuse$i == 0) next
 
    swp$ALSPID$i = Xswp$ALSPID$i
    if (swp$ALSPID$i == alspid) break
}
 
i = 0
if (swp$pointer$valid) i = swp$pointer$index
 
return(i)
end
 

integer function find_swp_name (name)
bbcommon
Literal cstrip8, name
integer i, k, litcmp
bbdeclare (swp$pointer)
 
for (swp$pointer$first; swp$pointer$valid; swp$pointer$next)
{
    if (Xswp$Inuse$i == 0) next
 
    if (litcmp(Xswp$Name$c, name) == 0) break
}
 
i = 0
if (swp$pointer$valid) i = swp$pointer$index
 
return (i)
end


integer function find_agd_name (name)
bbcommon
Literal cstrip8, name
integer i, k, litcmp
bbdeclare (agd$pointer)
 
for (agd$pointer$first; agd$pointer$valid; agd$pointer$next)
{
    if (Xagd$Inuse$i == 0) next
 
    if (litcmp(Xagd$Name$c, name) == 0) break
}
 
i = 0
if (agd$pointer$valid) i = agd$pointer$index
 
return (i)
end
