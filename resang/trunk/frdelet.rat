 
#####   version 3.1  dated-  7apr81
 
 
#####   version 3.0  dated- 22dec80
 
 
 
 
#$%     MODULE                        UTILITY                  DATA
#$%   SUBROUTINES                   SUBROUTINES               TABLES
#$%   ===========                   ===========               ======
#$%
#$%     FDCOMM                        ECHOI                   PATH
#$%     FDESM                         ECHOH                   MEMBER
#$%     FDMEM                         ECHOR                   EMCON
#$%     FDMEM1                        ECHOV                   FORCE
#$%     FDFORC                        FSMOVE                  EMITTER
#$%     FDORDR                        FSLEFT                  NAME
#$%     FDPLAN                        FFMEM                   WET
#$%     FDSEAR                        SMOVHN                  SOS
#$%     FDEMCO                        SMOVIZ                  SST
#$%     FDWET                                                 HFD
#$%     FDSOS                                                 AML
#$%     FDHFD                                                 BML
#$%     FDAIR                                                 LDR
#$%     FDSST                                                 SWB
#$%     FDLIDAR
#$%     FDBOAT
#$%     FDSWABS
#$%     FDCBI
#$%
#$%   NOTES
#$%   =====
#$%
#$%   1.  <FILENAME> INDICATES WHERE SUBROUTINE IS LOCATED.
#$%
#$%   2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%   3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%   FLOWCHART FOR FILE FDELET
#$%   =========================
#$%
#$%   FORCE - ORDPRC - EXEORD - FRDELET - FDCOMM*
#$%                                     - FDESM *
#$%                                     - FDMEMB - FDMEM1*
#$%                                     - FDFORC - FDMEM1*
#$%                                     - FDORDR*
#$%                                     - FDPLAN*
#$%                                     - FDSEAR*
#$%                                     - FDEMCO*
#$%                                     - FDWET *
#$%                                     - FDSOS *
#$%                                     - FDSWABS *
#$%                                     - FDHFD *
#$%                                     - FDAIR *
#$%                                     - FDSST *
#$%                                     - FDLIDAR *
#$%                                     - FDBOAT*
 
 
define ($DEBUG,$DEBUGD)
include "bbcode.inc"
include "plplay.inc"
include "frmain.inc"
include "ascii.inc"
define (ForceImplicit, Implicit None)                # MJC 6/12/2K (E2145)
 
subroutine fsleft (array,lo,hi,last)    # shift left
 
########################################################
#$%
#$% Purpose:   FSLEFT moves a working array to the left.
#$%
#$% Called By: FDCOMM     FDESM      FDMEM1
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
# Implicit None               # implicit integer (a-z) # MJC 6/9/2K (E2145)
integer LAST,
        K,
        I1,
        I2                                           # MJC 6/9/2K (E2145)
integer range,lo,hi
literal array[arb],arrayword
 
#$% compute range
range = last - hi + 1
 
#$% for each entry
for (k=0; k < range; k=k+1)
   {
    #$% compute index
    i1 = lo + k
    i2 = hi + k
    #$% if second index is greater than last, set data value to zero,
    if (i2 > last) arrayword = 0
    #$% else set data value
    else           arrayword = array[i2]
    #$% load data value
    array[i1] = arrayword
   }
 
return
end
 

 
subroutine fsrite (array,lo,hi,last)    # shift right
 
###########################################################
#$%
#$% Purpose:   FSRITE moves a working array to the right.
#$%
#$% Called By: FEMEMB     FPFORC
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################
 
# Implicit None               # implicit integer (a-z) # MJC 6/9/2K (E2145)
integer LAST,
        K,
        I2,
        I1,
        DELTA,
        RANGE                                      # MJC 6/9/2K (E2145)
integer lo,hi
literal arrayword,array[arb]
 
#$% compute delta and range
delta = hi - lo
range = last - lo + 1
 
#$% for each entry
for (k=0; k < range; k=k+1)
   {
    #$% compute index
    i2 = last + delta - k
    i1 = i2 - delta
    #$% if index is less than one, set data value to zero, else set data value
    if (i1 < 1) arrayword = 0
    else        arrayword = array[i1]
    #$% if next index is greater than zero, load data value
    if (i2 > 0) array[i2] = arrayword
   }
 
return
end
 

 
subroutine fsmove (s,d,len)             # move
 
########################################################
#$%
#$% Purpose:   FSMOVE moves data to a working array.
#$%
#$% Called By: FDCOMM     FDFORC     FDORDR
#$%            FDPLAN     FDSEAR     FEORDR
#$%            FEPLAN     FESEAR     FLEMIT
#$%            FLMEMB     FSAVEM     FSAVMB
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
integer len
literal s[arb],d[arb]
integer K                                               # MJC 6/9/2K (E2145)
 
#$% for each entry
for (k=1; k <= len; k=k+1)
   {
    #$% move data
    d[k] = s[k]
   }
 
return
end
 

 
subroutine fdcomm (nargs,args)
 
###############################################################
#$%
#$% Purpose:   FDCOMM allows user to delete a commpath from
#$%            the scenario file.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     FSMOVE     ECHOH     ECHOR
#$%            FFMEM      FSLEFT
#$%
#$% Tables:    PATH       MEMBER
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
ForceCommon
integer nargs
literal args[$max$args],path
integer KPATH,
        K,
        J,
        ISTAT,
        KMEMBR,
        ILEN,
        ILO,
        IHI                                         # MJC 6/9/2K (E2145)
 
#$% for each commpath
for (path$index = 1; path$index<=npaths; path$index = path$index + 1)
   {
    #$% if not same path, get next path
    if (args[3] != path$name) next
    #$% for remaining path
    for (k = path$index; k < npaths; k=k+1)
       {
        #$% get next index and move path data left
        j = k+1
        call fsmove (wrpaths[1,1,j],wrpaths[1,1,k],6*8)
       }
    #$% decrement number of paths and send detection message
    npaths = npaths - 1
    call echov ("Commpath deleted.")
    call echor
    #$% find path members
    call FFmem (path,istat)                # is the path present?
    #$% if members exist
    if (istat != 0)
       {
        #$% set index and length
        member$index = istat
        ilen = member$len
        #$% set low and high index
        ilo = istat
        ihi = istat + ilen
        #$% shift data left
        call fsleft (wrmembr,ilo,ihi,nmembr)     # shift left
        #$% decrement number of members
        nmembr = nmembr - ilen
        #$% send members deleted message
        call echov ("Memberships deleted.")
        call echor
       }
 
    return
   }
 
#$% if path not found, send message
call echov ("Commpath not found.")
call echor
 
return
end
 

 
subroutine fdesm  (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDESM allows user to delete an ESM entry from the
#$%            scenario file.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      FSLEFT     ECHOR
#$%
#$% Tables:    EMITTER
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#####################################################################
 
ForceCommon
integer nargs
literal args[$max$args],name,esm
integer IPNT,
        ISTAT,
        KEMITR,
        ILO,
        IHI                                             # MJC 6/9/2K (E2145)
 
#$% for each detection
for (ipnt = 3; ipnt <= nargs; ipnt = ipnt + 2)
   {
    #$% get ESM and platform name
    esm  = args[ipnt]
    name = args[ipnt+1]
    #$% display ESM and platform
    call echohn (esm,$$MaxLit)
    call echov (" for ")
    call echohN (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
    #$% set status flag to NO
    istat = $no
    #$% for each ESM entry
    for (emitter$index = 1; emitter$index<=nemit; emitter$index=emitter$index+1)
       {
        #$% if not same ESM or not same platform, get next ESM
        if (emitter$name != esm | emitter$plat != name) next
        #$% set low and high index
        ilo = (emitter$index-1)*2 + 1
        ihi = (emitter$index  )*2 + 1
        #$% shift data to left
        call fsleft (wremit,ilo,ihi,$emitters)
        #$% decrement number of entries
        nemit = nemit - 1
        #$% send message - ESM deleted
        call echov (" deleted.")
        call echor
        #$% set status flag to YES and break loop
        istat = $yes
        break
       }
    #$% if deletion found, get next deletion
    if (istat == $yes) next
    #$% send not found message
    call echov (" not found.")
    call echor
   }
 
return
end
 

 
subroutine fdmemb (nargs,args)
 
##########################################################################
#$%
#$% Purpose:   FDMEMB initializes data to delete member from commpath.
#$%
#$% Called By: FDELET
#$%
#$% Calls:     FRDMEM1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##########################################################################
 
ForceCommon
integer nargs
literal args[$max$args],name,path
integer IPNT                                            # MJC 6/9/2K (E2145)
 
#$% get member name
name = args[3]
 
#$% for each path
for (ipnt = 4; ipnt <= nargs; ipnt = ipnt + 1)
   {
    #$% get path name
    path = args[ipnt]
    #$% delete number from path
    call fdmem1 (name,path)           # delete 1 combo
   }
 
return
end
 

 
subroutine fdmem1 (name,path)         # delete one path/name combo
 
###########################################################################
#$%
#$% Purpose:   FDMEM1 deletes a specific member from the named commpath.
#$%
#$% Called By: FDMEMB
#$%
#$% Calls:     FFMEM      FSLEFT
#$%
#$% Tables:    MEMBER     NAME
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
ForceCommon
integer ISTAT,
        KMEMBR,
        KMEMNM,
        ILO,
        IHI                                         # MJC 6/9/2K (E2145)
literal path,name
 
#$% find path
call FFmem (path,istat)                # is the path present?
#$% if not found, return
if (istat == 0) return                  # no .... get the next one
 
member$index = istat                    # found path. check for name
#$% for each member
for (name$index=1; name$index<name$index$limit; name$index=name$index+1)
   {
    #$% if match, break loop
    if (member$name == name) break
   }
#$% if no match, return
if (member$name != name) return        # can't find entry.... skip it
#$% set high and low index
ilo = member$index+name$index+1
ihi = member$index+name$index+2
#$% get number of members
member$len  = member$len - 1
 
#$% if only two
if (member$len < 3)                     # remove path entry also
   {
    #$% delete corresponding path too
    ilo = member$index
   }
 
#$% move data to left
call fsleft (wrmembr,ilo,ihi,nmembr)     # shift left
#$% decrement member count
nmembr = nmembr - (ihi - ilo)
 
return
end
 

 
subroutine fdforc (nargs,args)
 
##########################################################
#$%
#$% Purpose:   FDFORC delates unit from scenario file.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     FSMOVE     FDMEM1     ECHOH
#$%            ECHOR
#$%
#$% Tables:    FORCE      PATH
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##########################################################
 
ForceCommon
integer nargs
literal args[$max$args],name,path
integer KFORCE,
        K,
        J,
        KPATH,
        IHOLD,
        KORG                                        # MJC 6/9/2K (E2145)
 
#$% for each force entry
for (force$index = 1; force$index<=nforce; force$index = force$index + 1)
   {
    #$% if not correct one, get next entry
    if (args[3] != force$task) next
    #$% get force name
    name = force$name
    #$% for remaining force entries
    for (k = force$index; k < nforce; k=k+1)
       {
        #$% set index
        j = k+1
        #$% move force data to left       #JFR  5/10/91  (32 vice 11)
        call fsmove (wrforce[1,j],wrforce[1,k],32)
       }
    #$% decrement force counter and send deletion message
    nforce = nforce - 1
    call echov ("Force deleted.")
    call echor
#---------------------------------------------------------------------------
 
    call fdton1 (name)          # Delete the Recognized Tonal List when
                                # the unit is deleted from scenario
#---------------------------------------------------------------------------
    #$% for each commpath
    for (path$index = 1; path$index <= npaths; path$index = path$index + 1)
       {
        #$% get path name and number of path members
        ihold = nmembr
        path = path$name
        #$% delete path member
        call fdmem1(name,path)
        #$% if fewer members
        if (ihold != nmembr)
            #$% send message - unit deleted from path
           {
            call echov ("Path ")
            call echohN (path,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
            call echov (" membership removed.")
            call echor
           }
       }
 
#    return  -- removed -- JFR 6/4/91
   }
 
#$% for each org entry    --- JFR 6/4/91 // DELETE ORGANIZATIONS
for (org$index = 1; org$index<=norg; org$index = org$index + 1)
   {
    #$% if not correct one, get next entry
    if (args[3] != org$task) next
    #$% get org name
    name = org$name
    #$% for remaining org entries
    for (k = org$index; k < norg; k=k+1)
       {
        #$% set index
        j = k+1
        #$% move org data to left       #JFR  5/10/91  (32 vice 11)
        call fsmove (wrorg[1,j],wrorg[1,k],32)
       }
    #$% decrement org counter and send deletion message
    norg = norg - 1
    call echov ("Organization deleted.")
    call echor
 
    #$% for each commpath
    for (path$index = 1; path$index <= npaths; path$index = path$index + 1)
       {
        #$% get path name and number of path members
        ihold = nmembr
        path = path$name
        #$% delete path member
        call fdmem1(name,path)
        #$% if fewer members
        if (ihold != nmembr)
            #$% send message - unit deleted from path
           {
            call echov ("Path ")
            call echohN (path,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
            call echov (" membership removed.")
            call echor
           }
       }
 
    return
   }
 
#$% send message - unit not found
call echov ("Force not found.")
call echor
 
return
end
 

 
subroutine FDTON1 (name)
 
##########################################################
#$%
#$% Purpose:   FDTON1 deletes the Recognized Tonal List
#$%            when a unit is deleted from a scenario file.
#$%
#$% Called By: FDFORC
#$%
#$% Calls:     ECHOH   ECHOR
#$%
#$% Tables:    NONE
#$%
#$% Date:      JULY 83
#$%
#$% Author:    T.D. BURZETTE
#$%
##########################################################
 
ForceCommon
literal name
integer I,
        KTON,
        KTONA,
        J,
        M,
        IPNT,
        ITONXX                                      # MJC 6/9/2K (E2145)
 
for (i = 1; i <= nton; i = i + 1)               # Loop for all the ton entries
    {
    ton$pointer$to i                            # Set pointer to each entry
    ton$map                                     # and map into memory
 
    if (name == ton$name) break                 # If the target name is found
    }                                           # break out of loop
#---------------------------------------------------------------------------
for (j = i; j < nton; j = j + 1)                # For each entry starting at
    {                                           # at the target entry
    ton$pointer$to j                            # Set pointer to each remaining
    ton$map                                     # entry and map
 
    for (m = 0; m < ton$entry; m = m + 1)       # For each data item, move the
        {                                       # remaining entries to replace
        ipnt = ton$address + m                  # the target entry being delete
        work$file$r[ipnt] = work$file$r[ipnt+ton$entry]
        }
    }
#---------------------------------------------------------------------------
ton$pointer$to nton                             # Set pointer to the number of
ton$map                                         # entries and remap the new
ton$zap                                         # entries in memory
 
nton = nton - 1                                 # Decrement the total number of
                                                # entries to reflect the
return                                          # deleted target entry
end
 

 
subroutine fdordr (nargs,args)
 
###################################################
#$%
#$% Purpose:   FDORDR deletes specified order.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     FSMOVE     ECHOH      ECHOI
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer K,
        I,
        N,
        J                                               # MJC 6/9/2K (E2145)
 
#$% for each order
for (k = norder; k > 0; k = k - 1)
   {
    #$% if not right one, get next entry
    if (k > norder) next
    #$% for each deletion entry
    for (i = 3; i <= nargs; i = i +1)
       {
        #$% get order number
        n = args[i]
        #$% if wrong one, get next entry
        if (n != k) next
        #$% if order found, send message
        call echov ("Order # ")
        call echoi (n)
        #$% for remaining entries
        for (j = n; j < norder; j=j+1)
           {
            #$% move data to left
            call fsmove (wrorder[1,j+1],wrorder[1,j],$ParserRecLen)
           }
        #$% decrement order counter
        norder = norder - 1
        #$% send deleted message and break loop
        call echov (" deleted.")
        call echor
        break
       }
   }
 
return
end
 

 
subroutine fdplan (nargs,args)
 
##################################################################
#$%
#$% Purpose:   FDPLAN deletes specific force contingency plan.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     FSMOVE     ECHOH      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##################################################################
 
ForceCommon
integer nargs
literal args[$max$args],side,name
integer IPLAN,
        KPLANS,
        J                                           # MJC 6/9/2K (E2145)
 
#$% get force name and display
if (args[3] == $lex$blue$)
   {
    side = 'BLUE'
    call echov ("Blue")
   }
else
   {
    side = 'ORANG'
    call echov ("Orange")
   }
 
#$% get plan name and display
name = args[4]
 
call echov (" Plan ")
call echohN (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
#$% zero plan pointer
iplan = 0
 
#$% for each plan entry
for (plans$index = 1; plans$index <= nplans;
                      plans$index = plans$index + 1)
   {
    #$% if same force and plan name
    if (plans$side == side &
        plans$name == name )
       {
        #$% save pointer and break loop
        iplan = plans$index
        break
       }
   }
 
#$% if plan not found, send message and return
if (iplan == 0)
   {
    call echov (" cannot be found.")
    call echor
    return
   }
 
#$% for remaining plans
for (j = iplan; j < nplans; j=j+1)
   {
    #$% move data to left
    call fsmove (wrplan[1,1,j+1],wrplan[1,1,j],$ParserRecLen*$plansize)
   }
 
#$% decrement plan counter
nplans = nplans - 1
 
#$% send deleted message
call echov (" deleted.")
call echor
 
return
end
 

 
subroutine fdsear (nargs,args)
 
###########################################################################
#$%
#$% Purpose:   FDSEAR deletes named search plan for the force specified.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     FSMOVE     ECHOH      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
ForceCommon
integer nargs
literal args[$max$args],side,name
integer IPLAN,
        KSEARC,
        J                                               # MJC 6/9/2K (E2145)
 
#$% determine force and output
if (args[3] == $lex$blue$)
   {
    side = 'BLUE'
    call echov ("Blue")
   }
else
   {
    side = 'ORANG'
    call echov ("Orange")
   }
 
#$% get plan name
name = args[4]
 
#$% output plan name
call echov (" Search plan ")
call echohN (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
#$% zero pointer
iplan = 0
#$% for each search plan
for (search$index = 1; search$index <= nsearc;
                       search$index = search$index + 1)
   {
    #$% if force name and plan name match
    if (search$side == side &
        search$name == name )
       {
        #$% save pointer and break
        iplan = search$index
        break
       }
   }
 
#$% if plan not found
if (iplan == 0)
   {
    #$% send message and return
    call echov (" cannot be found.")
    call echor
    return
   }
 
#$% for remaining search plans
for (j = iplan; j < nsearc; j=j+1)
   {
    #$% move data to left
    call fsmove (wrsearc[1,1,j+1],wrsearc[1,1,j],$ParserRecLen*$searchsize)
   }
 
#$% decrement search plan counter
nsearc = nsearc - 1
 
#$% send deletion message
call echov (" deleted.")
call echor
 
return
end
 

 
subroutine fdact (nargs,args)
 
###########################################################################
#$%
#$% Purpose:   FDACT deletes named action plan for the force specified.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     FSMOVE     ECHOH      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
###########################################################################
 
ForceCommon
integer nargs
literal args[$max$args],side,name
integer IPLAN,
        KACT,
        J                                               # MJC 6/9/2K (E2145)
 
#$% determine force and output
if (args[3] == $lex$blue$)
   {
    side = 'BLUE'
    call echov ("Blue")
   }
else
   {
    side = 'ORANG'
    call echov ("Orange")
   }
 
#$% get plan name
name = args[4]
 
#$% output plan name
call echov (" Action plan ")
call echohN (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
#$% zero pointer
iplan = 0
#$% for each action plan
for (act$index = 1; act$index <= nact;
     act$index = act$index + 1        )
   {
    #$% if force name and plan name match
    if (act$side == side &
        act$name == name  )
       {
        #$% save pointer and break
        iplan = act$index
        break
       }
   }
 
#$% if plan not found
if (iplan == 0)
   {
    #$% send message and return
    call echov (" cannot be found.")
    call echor
    return
   }
 
#$% for remaining action plans
for (j = iplan; j < nact; j=j+1)
   {
    #$% move data to left
    call fsmove (wract[1,1,j+1],wract[1,1,j],$ParserRecLen*$actsize)
   }
 
#$% decrement action plan counter
nact = nact - 1
 
#$% send deletion message
call echov (" deleted.")
call echor
 
return
end
 

 
subroutine fdemco (nargs,args)
 
###########################################################################
#$%
#$% Purpose:   FDEMCO deletes named EMCON plan entry for specified force.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    EMCON
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
ForceCommon
 
integer nargs
literal args[$max$args],side,name,tname,tside
integer IPLAN,
        KEMCON,
        J,
        I3                                          # MJC 6/9/2K (E2145)
 
#$% determine force and display
if (args[3] == $lex$blue$)
   {
    side = 'BLUE'              #which ever one it is  print it on
    call echov ("Blue")       #the screen
   }
else
   {
    side = 'ORANG'
    call echov ("Orange")
   }
 
#$% get plan name
name = args[4]
 
#$% display plan name
call echov (" Emcon Plan ")
call echohn (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
#$% zero pointer
iplan = 0
                ####search through the emcon index to find
                  ##  the correct plan
#$% for each EMCON plan
for (emcon$index = 1 ; emcon$index <= nemcon ;emcon$index = emcon$index + 1)
   {
    #$% if not same force or not same plan, get next entry
    if (emcon$side != side |  emcon$name != name) next
 
    #$% else save pointer and break loop
    iplan = emcon$index         #when the correct index is found
    break                       #get out of the search
   }
 
#$% if plan not found
if (iplan == 0)
   {
    #$% send message
    call echov (" can't be found.")
   }
else
   {
    #$% for remaining EMCON plans
    for (j = iplan ; j < nemcon ; j=j+1 )
       {
        emcon$index = j + 1
        tname = emcon$name
        tside = emcon$side
        i3 = emcon$codes
 
        emcon$index = j
 
        emcon$name  = tname
        emcon$side  = tside
        emcon$codes = i3
       }
 
    #$% decrement EMCON plan counter
    nemcon = nemcon - 1
 
    #$% send deletion message
    call echov (" deleted.")
   }
 
call echor
 
return
end
 

 
subroutine fdwet (nargs,args)
 
###############################################################
#$%
#$% Purpose:   FDWET deletes specified weather region data.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    WET
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer KWET,
        KWETA                                       # MJC 6/9/2K (E2145)
 
#$% set pointer for weather table
wet$pointer$to (args[3]+1)
 
call echov (" Weather region # ")
call echoi (int(args[3]))
 
#$% if pointer not valid
if (! wet$pointer$valid)
   {
    #$% send message and return
 
    call echov (" does not exist.")
    call echor
    return
   }
 
wet$map
 
#$% if slot in use flag is NO
if (wet$InUse == $no)
   {
    #$% send message
    call echov (" was not defined.")
    call echor
    return
   }
 
#$% set in use flag to NO
wet$InUse = $no
 
#$% decrement weather region counter
nweath = nweath - 1
 
#$% send deletion message
call echov (" deleted.")
call echor
 
return
end
 

 
subroutine fdsos (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FDSOS deletes specified SOSUS region data.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR      ECHOI
#$%
#$% Tables:    SOS
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer IC,
        KSOS,
        KSOSA,
        IDEL,
        M,
        IPNT,
        ISOSXX,
        NFOUND,
        KSOSX2                                      # MJC 6/9/2K (E2145)
 
#$% get region number
if (args[3] == $lex$region$)                    #delete sosus region
   {
    call echov (" Sosus region #")
    call echoi (int(args[4]))
 
    #$% if invalid region number, send message and return
    if (args[4]<1 | args[4]>$sosus)
       {
        call echov (" does not exist.")
        call echor
        return
       }
    #$% for each SOSUS region
    for (ic = 1; ic <= nsos; ic = ic + 1)
       {
        #$% set pointer
        sos$pointer$to ic
        sos$map
 
        #$% if wrong one get next entry
        if (args[4] != sos$regnumber) next
 
        #$% for remaining entries
        for (idel=ic; idel<nsos; idel=idel+1)   #found the region
           {                                    #move sosus data left
            #$% set SOS pointer
            sos$pointer$to idel
            sos$map
 
            for (m=0; m<sos$entry; m=m+1)
               {
                #$% set pointer and move data
                ipnt = sos$address + m
                work$file$r[ipnt] = work$file$r[ipnt+sos$entry]
               }
           }
 
        #$% delete last data entry
        sos$pointer$to nsos
        sos$map
        sos$zap
 
        #$% decrement SOSUS region counter
        nsos = nsos - 1
 
        #$% send deletion message and return
        call echov (" deleted.")
        call echor
 
        return
       }
 
    #$% if not found, send message
    call echov (" does not exist.")
    call echor
 
    return
   }
 
else                                            #delete sosus sub class
 
    #$% if sub region number invalid, send message and return
   {
    call echov (" Sosus sub class ")
    call echohN(args[4],$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
    call echov (" in region #")
    call echoi (int(args[5]))           ## tpa 4/4/83
 
    if (args[5]<1 | args[5]>$sosus)
       {
        call echov (" does not exist.")
        call echor
        return
       }
 
    #$% set found flag to NO
    nfound = $no
 
    #$% search sub region
    for (ic = 1; ic <= nsos; ic=ic+1)
       {
        #$% set SOS pointer
        sos$pointer$to ic
        sos$map
 
        #$% if wrong region, get next entry
        if (args[5] != sos$regnumber) next      ## tpa 4/4/83
        sos$sub$index = 1                       #found the region
        repeat
           {
            #$% if end of loop, break loop
            if (sos$sub$index > sos$numberofsets) break
            if (sos$sub$class == args[4])
               {                                #delete class and pack
                nfound = $yes
                #$% for each SOS subset                      ## tpa 4/6/83
                for (idel=sos$sub$index; idel<sos$numberofsets; idel=idel+1)
                   {
                    #$% for each data entry
                    for (m=0; m<15; m=m+1)
                       {
                        #$% set pointer and move data
                        ipnt = sos$sub$address + m
                        work$file$r[ipnt]   =
                        work$file$r[ipnt+3+sos$det$slots]
                       }
                   }
                #$% increment counter
                sos$numberofsets = sos$numberofsets - 1
               }
            else
               {
                #$% set pointer for next subset
                sos$sub$index = sos$sub$index + 1
               }
           }
 
        #$% break loop
        break
       }
 
    #$% if all of region deleted
    if (sos$numberofsets == 0    &   #if no class data & move region data
        nfound           == $yes &   #   something removed &
        sos$regdefined   == $no   )  #   no region data
       {
        for (idel=ic; idel<nsos; idel=idel+1)
           {
            #$% for each entry
            for (m=0; m<sos$entry; m=m+1)
               {
                #$% set pointer and move data
                ipnt = sos$address + m
                work$file$r[ipnt] = work$file$r[ipnt+sos$entry]
               }
           }
 
        #$% set SOSUS pointer
        sos$pointer$to nsos
        sos$map
        sos$zap
        #$% decrement SOSUS region counter
        nsos = nsos - 1
 
        call echov (" has been deleted (w/region)")
       }
 
    #$% if not found, send message - does not exist
    else if (nfound == $no)
       {
        call echov (" does not exist.")
       }
    else
       {
        #$% else send deletion message
        call echov (" has been deleted.")
       }
 
    call echor
   }
return
end
 

subroutine fdbistatic (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FDBISTATIC deletes specified BISTATIC region
#$%            and pair data.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR      ECHOI
#$%
#$% Tables:    SOS        BIS
#$%
#$% Date:      June 91
#$%
#$% Author:    C. Leaf
#$%
#############################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer I,
        KSOS,
        KSOSA,
        KBIS,
        KBISA,
        IBISXX,
        IDEL,
        M,
        IPNT                                        # MJC 6/9/2K (E2145)
 
#$% if region
if (args[3] == $lex$REGION$)             # delete BISTATIC region
   {
    if (args[4] == $lex$ALL$)            # delete all BISTATIC regions
      {
       call echov (" BISTATIC Characteristics for all Sosus regions deleted")
       call echor
 
       #$% for each SOSUS region
       for (i = 1; i <= nsos; i = i + 1)
         {
          #$% set pointer
          sos$pointer$to i
          sos$map
 
          #$% delete Bistatic characteristics
          sos$bis$regionarea = 0
          sos$bis$nodedensity = 0
          sos$bis$range = 0
         }
      }
    else                # delete a specific region
      {
       call echov (" BISTATIC Characteristics for Sosus region #")
       call echoi (int(args[4]))
 
       #$% if invalid region number, send message and return
       if (args[4]<1 | args[4]>$sosus)
         {
          call echov (" do not exist.")
          call echor
          return
         }
      #$% for each SOSUS region
      for (i = 1; i <= nsos; i = i + 1)
         {
          #$% set pointer
          sos$pointer$to i
          sos$map
 
          #$% if wrong one get next entry
          if (args[4] != sos$regnumber) next
 
          #$% delete Bistatic characteristics
          sos$bis$regionarea = 0
          sos$bis$nodedensity = 0
          sos$bis$range = 0
         }
      }
   }
else         # delete Bistatic pair
   {
    if (args[4] == $lex$ALL$)         # delete all pairs
      {
       call echov (" All BISTATIC Pairs Deleted")
       call echor
       for (i = 1; i < nbis; i = i + 1)
         {
          BIS$Pointer$To i
          BIS$map
          BIS$zap
         }
       nbis = 0
      }
    else            # delete a specific pair
      {
       call echov (" BISTATIC Pair (active source) ")
       call echohN (args[5], $$MAXname) # 5 jb E2141 /8-char.names 12/29/99
       call echov (" (passive receiver) ")
 
       if (args[6] == $lex$BDS$)
         call echov ("BDS")
       else
         call echohN (args[7], $$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
       for (i = 1; i < nbis; i = i + 1)
         {
          BIS$Pointer$To i
          BIS$map
 
          if (BIS$ActiveSource != args[5] |
              BIS$PassiveReceiver != args[7])
            next
 
          #$% for remaining entries
          for (idel = i; idel < nbis; idel = idel + 1)   # found the pair
           {                                             # move remaining pairs
            #$% set BIS pointer
            BIS$Pointer$To idel
            BIS$map
 
            for (m = 0; m < BIS$Entry; m = m + 1)
               {
                #$% set pointer and move data
                ipnt = BIS$address + m
                Work$File$R [ipnt] = Work$File$R [ipnt+bis$entry]
               }
           }
 
          #$% delete last data entry
          BIS$Pointer$To nbis
          BIS$map
          BIS$zap
 
          #$% decrement BISTATIC PAIR region counter
          nbis = nbis - 1
 
          #$% send deletion message and return
          call echov (" deleted.")
          call echor
 
          return
         }
 
       #$% if not found, send message
       call echov (" does not exist.")
       call echor
      }
   }
 
return
end
 

 
subroutine fdswabs (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FDSWABS deletes specified SWABS region data.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR      ECHOI
#$%
#$% Tables:    SWB
#$%
#$% Date:      February 1991
#$%
#$% Author:    Carol Kropp and Susan Miller
#$%
#############################################################
ForceCommon
integer KSWB,
        KSWBA,
        ISWBXX,
        NFOUND,
        KSWBX2,
        M                                               # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
integer ipnt, region_number
 
  #$% get region number
  if (args[3] == $lex$region$)                    #delete SWABS region
    {
     if (args[5] == $lex$blue$)
       {
        call echov (" Blue SWABS Region #")
        region_number = args[4]
       }
     else   # Orange SWABS region
       {
        call echov (" Orange SWABS Region #")
        region_number = args[4] + $SWABS$Orange$offset
       }
 
     #$% if invalid region number, send message and return
     if (args[4] < 1 | args[4] >= ($SWABSregions - $SWABS$Orange$offset))
       {
        call echov (" does not exist.")
        call echor
        return
       }
 
     swb$pointer$to region_number
     swb$map
 
     if (swb$InUse == $no)
       {
        call echov (" has not been entered.")
        call echor
        return
       }
 
     swb$zap             # zap the region data
 
     #$% decrement SWABS region counter
     nswb = nswb - 1
 
     #$% send deletion message and return
     call echov (" deleted.")
     call echor
     return
    }
 
  else                                    #  delete SWABS sub class
    {
     call echov (" SWABS sub class ")
     call echohN (args[4], $$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
     if (args[5] == $lex$blue$)
       {
        call echov (" in Blue region #")
        region_number = args[6]
       }
    else   # Orange SWABS region
       {
        call echov (" in Orange region #")
        region_number = args[6] + $SWABS$Orange$offset
       }
 
     call echoi (int(args[6]))
 
     if (args[6] < 1 | args[6] >= ($SWABSregions - $SWABS$Orange$offset))
       {
        call echov (" does not exist.")
        call echor
        return
       }
 
     #$% set found flag to NO
     nfound = $no
 
     #$% search the SWABS region
     swb$pointer$to  region_number
     swb$map
 
     for (swb$sub$index = 1; swb$sub$index <= swb$numberofsets;
                             swb$sub$index = swb$sub$index + 1)
       {
        if (swb$sub$class != args[4])
          next
 
        nfound = $yes
        break
       }
 
     #$% if not found, send message - does not exist
     if (nfound == $no)
       call echov (" does not exist.")
 
     else
       {
        #$% for each remaining SWB sub entry
        while (swb$sub$index <= swb$numberofsets)
          {
           #$% for each data entry
           for (m = 0; m < 7; m = m + 1)
             {
              #$% set pointer and move data
              ipnt = swb$sub$address + m
              work$file$r[ipnt] = work$file$r[ipnt+7]
             }
           swb$sub$index = swb$sub$index + 1
          }
 
        #$% delete last data entry
        swb$numberofsets = swb$numberofsets - 1
 
        call echov (" has been deleted.")
 
        if (swb$numberofsets == 0 & swb$regdefined == $no)
          swb$InUse = $no    # if the region has not been entered
                             # and there are no more subs defined
                             # then the slot is no longer in use
       }
 
     call echor
    }
return
end
 

 
subroutine fdhfd (nargs,args)
 
#####################################################
#$%
#$% Purpose:   FDHFD deletes specified HFDF entry.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    HFD
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#####################################################
 
ForceCommon
PlayCommon
integer nargs
literal args[$max$args]
integer NOHFDF,
        KHFD,
        KHFDA,
        I,
        IDEL,
        M,
        IPNT,
        IHFDXX                                      # MJC 6/9/2K (E2145)
 
#$% display HFDF base name
call echov (" HFDF Base ")
call echohN (args[3],$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
#$% get number of HFDF entries
nohfdf = nhfdf
 
#$% set HFD table pointer
hfd$pointer$first
hfd$map
 
for (i=1; i<=nhfdf; i=i+1)              #loop thru hfdf entries
   {
    #$% if same base name
    if (hfd$basename == args[3])
       {
        #$% for each HFD entry
        for (idel=i; idel<nhfdf; idel=idel+1)  #delete and pack
           {
            #$% set pointer and move data
            hfd$pointer$to idel
            hfd$map
            #$% for each data item
            for (m=0; m<hfd$entry; m=m+1)
               {
                ipnt = hfd$address+m
                work$file$r[ipnt] = work$file$r[ipnt+hfd$entry]
               }
           }
 
        #$% clear last entry
        hfd$zap
        #$% decrement HFDF counter and send deletion message
        nhfdf = nhfdf - 1
        call echov (" has been deleted.")
        break
       }
 
    #$% set HFD pointer to next entry
    hfd$pointer$next
    hfd$map
   }
 
#$% if not found, send message
if (nhfdf == nohfdf) call echov (" does not exist.")
 
return
end
 

 
subroutine fdair (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDAIR deletes specified Air Maintenance Log entry.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     SMOVHN     SMOVIZ     ECHOH
#$%            ECHOR
#$%
#$% Tables:    AML
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#####################################################################
 
ForceCommon
integer nargs
literal args[$max$args],name
integer K,
        ILEN,
        IFLG,
        ISRCH,
        KAML,
        KAMLA,
        LITCMP,
        IDEL,
        M,
        IPNT                                        # MJC 6/9/2K (E2145)
 
#$% for each entry
for (k=0; k<args[5]; k=k+1)
   {
    ilen = 0
    name = $BLANKLIT
    call smovhn (args[3],2,name,ilen)
    call smoviz (int(args[4])+k,3,name,ilen)
    call echohN (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
    #$% set search flag to zero
    iflg = 0
    #$% for each entry
    for (isrch = 1; isrch <= naml; isrch = isrch + 1)
       {
        #$% set AML pointer
        aml$pointer$to isrch
        aml$map
        #$% if less than this side number, break loop
        if (litcmp(name,aml$sidenumber) < 0) break
#       if (name < aml$sidenumber) break
        #$% if wrong one, get next entry
        if (name != aml$sidenumber) next
        #$% for each data item
        for (idel = isrch; idel <= naml; idel = idel + 1)
           {
            #$% set pointer
            aml$pointer$to idel
            aml$map
            #$% for each entry
            for (m=0; m<aml$entry; m=m+1)
               {
                #$% move data to left
                ipnt = aml$address+m
                work$file$r[ipnt] = work$file$r[ipnt+aml$entry]
               }
           }
        #$% set AML pointer
        aml$pointer$to naml
        aml$map
        #$% set slot in-use flag to NO
        aml$InUse = $no
        #$% decrement counter and break loop
        naml = naml - 1
        iflg = 1
        break
       }
 
    #$% if not found, send message
    if (iflg == 0) call echov (" does not exist.")
    #$% else send deletion message
    else           call echov (" deleted.")
 
    call echor
   }
 
return
end
 

 
subroutine fdsst (nargs,args)
 
#########################################################
#$%
#$% Purpse:    FDSST deletes specified SURVSAT entry.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    SST
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#########################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer I,
        KSST,
        KSSTA,
        J,
        M,
        IPNT,
        ISSTXX                                      # MJC 6/9/2K (E2145)
 
#$% output SURVSAT name
call echov (" Survsat ")
call echohN (args[3],$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
 
#$% for each SST entry
for (i=1; i<=nssts; i=i+1)
   {
    #$% set SST pointer
    sst$pointer$to i
    sst$map
   #$% if correct entry, break loop
    if (args[3] == sst$name)break
   }
 
#$% if not found, send message
if (i>nssts) call echov (" does not exist.")
 
else
   {
    #$% for each SST entry
    for (j=i; j<nssts; j=j+1)
       {
        #$% set SST table pointer
        sst$pointer$to j
        sst$map
        #$% for each data item
        for (m=0; m<sst$entry; m=m+1)
           {
            #$% set pointer and move data to left
            ipnt = sst$address + m
            work$file$r[ipnt] = work$file$r[ipnt+sst$entry]
           }
       }
 
    #$% set SST table pointer
    sst$pointer$to nssts
    sst$map
    sst$zap
    #$% decrement SURVSAT counter
    nssts = nssts - 1
    #$% send deletion message
    call echov (" has been deleted.")
   }
 
call echor
 
return
end
 

 
subroutine fdeph (nargs,args)
 
#########################################################
#$%
#$% Purpse:    FDEPH deletes a specified PROBHIT entry.
#$%
#$% Date:      December 82
#$%
#$% Author:    Jim Kvederis
#$%
#########################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer I,
        KEPH,
        KEPHA,
        J,
        M,
        IPNT,
        IEPHXX                                      # MJC 6/9/2K (E2145)
 
#$% output PROBHIT target name
call echov (" Probhit against target ")
call echohN (args[3],$$MAXname) # 8 jb E2141 /8-char.names 12/29/99
call echov (" with weapon ")
call echohN (args[4],$$MAXname) # 8 jb E2141 /8-char.names 12/29/99
 
#$% for each PROBHIT entry
for (i=1; i<=neph; i=i+1)
   {
    #$% set PROBHIT pointer
    eph$pointer$to i
    eph$map
    #$% if correct entry, break loop
    if (args[3] == eph$target & args[4] == eph$weapon) break
   }
 
#$% if not found, send message
if (i>neph) call echov (" is not an entry.")
 
else
   {
    #$% for each PROBHIT entry
    for (j=i; j<neph; j=j+1)
       {
        #$% set PROBHIT table pointer
        eph$pointer$to j
        eph$map
        #$% for each data item
        for (m=0; m<eph$entry; m=m+1)
           {
            #$% set pointer and move data to left
            ipnt = eph$address + m
            work$file$r[ipnt] = work$file$r[ipnt+eph$entry]
           }
       }
 
    #$% set PROBHIT table pointer
    eph$pointer$to neph
    eph$map
    eph$zap
    #$% decrement PROBHIT counter
    neph = neph - 1
    #$% send deletion message
    call echov (" has been deleted.")
   }
 
call echor
 
return
end
 

 
subroutine FDSON (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FDSON deletes specified SONAR Environment
#$%            region data.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH      ECHOR      ECHOI
#$%
#$% Tables:
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
#############################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer IC,
        KSON,
        KSONA,
        IDEL,
        M,
        IPNT,
        ISONXX                                      # MJC 6/9/2K (E2145)
 
call echov (" Sonar Environment Region #")
call echoi (int(args[3]))
 
#$% if invalid region number, send message and return
if (args[3]<1 | args[3]>$sonev)
    {
    call echov (" does not exist.")
    call echor
    return
    }
#$% for each SONAR region
for (ic = 1; ic <= nson; ic = ic + 1)           # Loop for each reg number
    {
    #$% set pointer
    son$pointer$to ic                           # Set pointer to index
    son$map
 
    #$% if wrong one get next entry
    if (args[3] != son$regnumber) next          # Skip if not right number
 
    #$% for remaining entries
    for (idel=ic; idel<nson; idel=idel+1)       # found the region
        {                                       # move sosus data left
        #$% set SON pointer
        son$pointer$to idel                     # Set pointer to index
        son$map
 
        for (m=0; m<son$entry; m=m+1)           # For each entry
            {
            #$% set pointer and move data
            ipnt = son$address + m
            work$file$r[ipnt] = work$file$r[ipnt+son$entry]
            }
        }
 
    #$% delete last data entry
    son$pointer$to nson                         # ZAP it
    son$map
    son$zap
 
    #$% decrement SONAR region counter
    nson = nson - 1
 
    #$% send deletion message and return
    call echov (" deleted.")
    call echor
 
    return
    }
 
#$% if not found, send message
call echov (" does not exist.")
call echor
 
return
end
 

subroutine FDLIDAR (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FDLIDAR deletes specified LIDAR Region Data.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOV      ECHOR      ECHOI
#$%
#$% Tables:
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
#############################################################
ForceCommon
integer KLDR,
        KLDRA,
        ILDRXX                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
  call echov (" LIDAR Region #")
  call echoi (int(args[3]))
 
  #$% if invalid region number, send message and return
  if (args[3] < 1 | args[3] >= $LIDARRegions)
    {
     call echov (" does not exist.")
     call echor
     return
    }
 
 ldr$pointer$to args[3]
 ldr$map
 
 if (ldr$InUse == $no)
   {
    call echov (" has not been entered.")
    call echor
    return
   }
 
 ldr$zap             # zap the region data
 
 #$% decrement LIDAR region counter
 nldr = nldr - 1
 
 #$% send deletion message and return
 call echov (" deleted.")
 call echor
 
return
end

 
subroutine FDTONE (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDTONE controls the deletion of the Recognized Tonal
#$%            List for a specified ship.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     ECHOH    ECHOR
#$%
#$% Tables:    NONE
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
#####################################################################
 
Forcecommon
integer I,
        KTON,
        KTONA,
        J,
        M,
        IPNT,
        ITONXX                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args], name
 
name = args[3]                                  # Put arg into local variable
#------------------------------------------------------------------------------
for (i = 1; i <= nton; i = i + 1)               # Loop for all the ton entries
    {
    ton$pointer$to i                            # Set pointer to each entry
    ton$map                                     # and map into memory
 
    if (name == ton$name) break                 # If the target name is found
    }                                           # break out of loop
#------------------------------------------------------------------------------
if (i > nton)                                   # If no match is found, display
   {                                            # error message to user
    call echov ("The ship ")
    call echohN (name,$$MAXname) # 5 jb E2141 /8-char.names 12/29/99
    call echov (" is not in the Scenario.")
    call echor
    return
   }
#------------------------------------------------------------------------------
for (j = i; j < nton; j = j + 1)                # For each entry starting at
    {                                           # at the target entry
    ton$pointer$to j                            # Set pointer to each remaining
    ton$map                                     # entry and map
 
    for (m = 0; m < ton$entry; m = m + 1)       # For each data item, move the
        {                                       # remaining entries to replace
        ipnt = ton$address + m                  # the target entry being delete
        work$file$r[ipnt] = work$file$r[ipnt+ton$entry]
        }
    }
#------------------------------------------------------------------------------
ton$pointer$to nton                             # Set pointer to the number of
ton$map                                         # entries and remap the new
ton$zap                                         # entries in memory
 
nton = nton - 1                                 # Decrement the total number of
                                                # entries to reflect the
                                                # deleted target entry
call echov ("The Recognized Tonal List for ")
call echohN (name,$$MAXname) # jb E2141 12/29/99# Display the deletion message
call echov (" has been deleted.")            # to the user
call echor
 
return
end
 

 
subroutine fdboat (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDBOAT deletes specified Boat Maintenance Log entry.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     SMOVHN     ECHOH     ECHOR
#$%
#$% Tables:    BML
#$%
#$% Date:      MAY 1989
#$%
#$% Author:    Arturo Ma
#$%
#####################################################################
 
ForceCommon
integer nargs
literal args[$max$args],name
integer ILEN,
        IFLG,
        ISRCH,
        KBML,
        KBMLA,
        LITCMP,
        IDEL,
        M,
        IPNT                                        # MJC 6/9/2K (E2145)
 
ilen = 0
name = $BLANKLIT
call smovhn (args[3],$$MAXname,name,ilen) # 5 jb E2141 /8-char.names 12/29/99
call echohn (name,$$MaxName) # Maxlit jb E2141 /8-char.names 12/29/99
#$% set search flag to zero
iflg = 0
#$% for each entry
for (isrch = 1; isrch <= nbml; isrch = isrch + 1)
    {
    #$% set BML pointer
    bml$pointer$to isrch
    bml$map
    #$% BML sorted by name
    #$% if less than boat name, break loop
    if (litcmp(name,bml$name) < 0) break
    #$% if wrong one, get next entry
    if (bml$name != name) next
    #$% for each data item beyond the item marked for deletion
    for (idel = isrch; idel <= nbml; idel = idel + 1)
        {
        bml$pointer$to idel
        bml$map
        #$% for each entry
        for (m = 0; m < bml$entry; m = m + 1)
            {
            #$% move data to left
            ipnt = bml$address + m
            work$file$r[ipnt] = work$file$r[ipnt+bml$entry]
            }
        }
    bml$pointer$to nbml                    # set bml pointer
    bml$map
    bml$class = $no
    bml$basename = $no
    bml$InUse = $no                        # set slot in-use flag to NO
    nbml = nbml - 1                        # decrement counter & break loop
    iflg = 1
    break
    } # End of BML entries
 
#$% if not found, send message
if (iflg == 0) call echov (" does not exist.")
#$% else send deletion message
else           call echov (" deleted.")
 
call echor
 
return
end
 

 
subroutine fduvp (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDuvp deletes specified Unmanned Aerial Vehicle
#$%     probabilities
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     SMOVHN     ECHOH     ECHOR
#$%
#$% Tables:    uvp
#$%
#$% Date:      2/5/90
#$%
#$% Author:    R. Hundt
#$%
#####################################################################
 
ForceCommon
integer   nargs
literal   args[$max$args]
integer   ILEN,
          IFLG,
          KUVP,
          K,
          J                                           # MJC 6/9/2K (E2145)
integer*4 itype
 
itype = args [ 3 ]
 
ilen = 0
call echov("Target Type Index ")
call echoi(itype)
 
#$% set search flag to zero
iflg = 0
#$% for each entry
for (uvp$Index = 1; uvp$Index <= nuvp; uvp$Index = uvp$Index + 1)
    {
    #$% if this is the entry to be deleted
    IF ( args [ 3 ] == UVP$TargTypeIndex)
        {
        #$% for remaining uvp slots
        for (k = uvp$index; k < nuvp; k=k+1)
           {
            #$% get next index and move uvp data left
            j = k+1
            call fsmove (wruvp[1,j],wruvp[1,k],$UVPLen)
           }
 
        #$%set up to  clear last entry
        uvp$Index = nuvp
 
        UVP$TargTypeIndex = $no
        UVP$Type = $no
 
        FOR (UVP$NumRanges = 1; UVP$NumRanges <= $UAV$NumRangesPerType;
             UVP$NumRanges = UVP$NumRanges + 1)
            {
            #$% clear UAV Range and PROBABILITIES data
            UVP$Range         = $no
            UVP$DetectPb      = $no
            UVP$RecognitionPb = $no
            UVP$IdentPb       = $no
            }
        UVP$NumRanges = 0   # reset
 
        iflg = 1
        nuvp = nuvp - 1                        # decrement counter & break loop
        break
        }
    } # End of uvp entries
 
#$% if not found, send message
if (iflg == 0) call echov (" does not exist.")
#$% else send deletion message
else           call echov (" deleted.")
 
call echor
 
return
end
 

subroutine fdmdr (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDMDR deletes specified Sonobuoy Median detection Range
#$%     entries
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     SMOVHN     ECHOH     ECHOR
#$%
#$% Tables:    mdr
#$%
#$% Date:      6/90
#$%
#$% Author:    R. Hundt
#$%
#####################################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer ILEN,
        IFLG,
        KMDR,
        K,
        J                                           # MJC 6/9/2K (E2145)
 
ilen = 0
call echov("MDR for Sonobuoy ")
call echohn(args [ 3 ], $$MAXname) # jb E2141 /8-char.names 1/3/00
call echov(" and Class ")
call echohn(args [ 4 ], $$MAXname) # jb E2141 /8-char.names 1/3/00
 
#$% set search flag to zero
iflg = 0
#$% for each entry
for (mdr$Index = 1; mdr$Index <= nmdr; mdr$Index = mdr$Index + 1)
    {
    #$% if this is the entry to be deleted
    IF ( args [ 3 ] == MDR$SonobuoyName &
         args [ 4 ] == MDR$SubClass)
        {
        #$% for remaining mdr slots
        for (k = mdr$index; k < nmdr; k=k+1)
           {
            #$% get next index and move mdr data left
            j = k+1
            call fsmove (wrmdr[1,j],wrmdr[1,k],$MDRLen)
           }
 
        #$%set up to  clear last entry
        mdr$Index = nmdr
 
        MDR$SubClass = $BLANKLIT
        MDR$SonobuoyName = $BLANKLIT
        MDR$GoodENVDetectRange = 0
        MDR$FairENVDetectRange = 0
        MDR$PoorENVDetectRange = 0
        MDR$DefaultENVDetectRange = 0
 
        iflg = 1
        nmdr = nmdr - 1                        # decrement counter & break loop
        break
        }
    } # End of mdr entries
 
#$% if not found, send message
if (iflg == 0) call echov (" does not exist.")
#$% else send deletion message
else           call echov (" deleted.")
 
call echor
 
return
end

subroutine fdintra (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDINTRA deletes specified Intra platform EMI
#$%     entries
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     SMOVHN     ECHOH     ECHOR
#$%
#$% Tables:    intra
#$%
#$% Date:      8/90
#$%
#$% Author:    hfisher - CSC
#$%
#####################################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer ILEN,
        IFLG,
        KINTRA,
        LEN                                         # MJC 6/9/2K (E2145)
 
ilen = 0
call echov("Class for EMI ")
call echohn(args [ 3 ], $$MAXname) # jb E2141 /8-char.names 1/3/00
call echov(" Victim ")
call echohn(args [ 4 ], $$MAXname) # jb E2141 /8-char.names 1/3/00
call echov(" Culprit ")
call echohn(args [ 5 ], $$MAXname) # jb E2141 /8-char.names 1/3/00
 
#$% set search flag to zero
iflg = 0
#$% for each entry
for (INTRA$Index = 1; INTRA$Index <= nintra; INTRA$Index = INTRA$Index + 1)
    {
    #$% if this is the entry to be deleted
    IF ( args [ 3 ] == INTRA$Class &
         args [ 4 ] == INTRA$Victim &
         args [ 5 ] == INTRA$Culprit)
        {                               #$% move rest of table up one slot
        Len = ($Intralen * (Nintra - INTRA$Index)) * 8
        Call LIB$MOVC3 (len,NextINTRA$Entry,INTRA$Entry)
 
        #$%set up to  clear last entry
        Intra$Index = nintra
 
        INTRA$Class   = $BLANKLIT
        INTRA$Victim  = $BLANKLIT
        INTRA$Percent = 0
        INTRA$Culprit = $BLANKLIT
 
        Nintra = Nintra - 1
        iflg = 1
        BREAK
        }
    } # End of intra entries
 
#$% if not found, send message
if (iflg == 0) call echov (" does not exist.")
#$% else send deletion message
else           call echov (" deleted.")
 
call echor
 
return
end
 

subroutine fdfom (nargs,args)
 
#####################################################################
#$%
#$% Purpose:   FDfom deletes specified frequency omission plan entry or
#$%             frequency bound or both.
#$%
#$% Called By: FRDELET
#$%
#$% Calls:     SMOVHN     ECHOH     ECHOR
#$%
#$% Tables:    freq_omission
#$%
#$% Date:      6/91
#$%
#$% Author:    hundt
#$%
#####################################################################
 
ForceCommon
integer nargs
literal args[$max$args]
integer IFLG,
        KFREQ_OMISSION,
        ITEM_NUM,
        KFREQ_OMISSION_ITEM,
        LEN,
        KFREQ2_OMISSION                            # MJC 6/9/2K (E2145)
literal Name
 
Name = args [ 3 ]
 
call echov("Frequency omission plan ")
call echohn(Name, $$MAXname) # jb E2141 /8-char.names 1/3/00
 
#$% set search flag to zero
iflg = 0
#$% for each entry
for (freq_omission$Index = 1;
     freq_omission$Index <= nfom;
     freq_omission$Index = freq_omission$Index + 1)
    {
    #$% if this is the entry to be deleted
    IF ( args [ 3 ] == freq_omission$Plan_Name )
        {
        #$% if a frequency boundary is to be deleted
        if ( nargs  > 3 )
            {
            item_num = args[5]
 
            if (item_num > $MaxFomItems |
                item_num <= 0 )
                {
                #$% display warning message and return
                call echov (", Item number is out of range.")
                call echor
                return
                }
 
            freq_omission$item_index = item_num
 
            call echov (", Item number ")
            call echoi(freq_omission$item_index)
 
            #$% if a frequency bound exists
            if ( freq_omission$HiFreq != 0 )
                {
                freq_omission$HiFreq = 0
                freq_omission$LowFreq = 0
 
                iflg = 1
 
                call echov (" is deleted ")
                call echor
                }
            else
                {
                call echov (" does not exist.")
                call echor
                return
                }
            }# end if a frequency boundary is to be deleted
        else # else the entire entry is to be deleted
            {
            #$% if anything to move up in table
            if ( Nfom != freq_omission$Index )
                {
                Len = ($fomplanlen * (Nfom - freq_omission$Index)) * 8
 
                freq_omission$Index2 = freq_omission$Index + 1
 
                #$% move rest of table up one slot
                Call LIB$MOVC3 (len,
                                freq_omission$Plan_Name2,
                                freq_omission$Plan_Name)
                }
 
            #$%set up to  clear last entry
            freq_omission$Index = nfom
 
            #$% clear last entry
            call LIB$MOVC5(0,0,0,$fomplanlen * 8, freq_omission$plan_name)
 
            Nfom = Nfom - 1
            iflg = 1
 
            #$% send deletion message
            call echov (" (entry deleted).")
 
            BREAK
            } # end the entry is to be deleted
        }# if this entry is to be partially or entirely deleted
    } # End of freq_omission entries
 
#$% if not found, send message
if (iflg == 0) call echov (" does not exist.")
 
call echor
 
return
end
 
