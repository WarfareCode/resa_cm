######################################################################
#$%
#$% Information on the programs and subroutines located in FRMAIN.RAT
#$% along with those that are called is provided in DOC.WHO.
#$%
#$% Flowcharts illustrating the interrelationships of the programs
#$% and subprograms for this program are contained in FRMAIN.HIR
#$%
######################################################################
 
#####   version 3.1  dated-  7apr81
 
###
### mod to version 3.0          dated 07-jan-1981
###
### smn prog    module  comments
### === ====    ======  =====================================================
### 002 dew     exeord  Chg- Added call to ferpm  for reporting policy matrix
###             finit   Chg- Added call to flrpm   "      "       "      "
###             fdelet  Chg- Added call to fdrpm   "      "       "      "
###             fprint  Chg- Added call to fprpm   "      "       "      "
###                          Added call to fprpma  "      "       "      "
###             fbyevr  Chg- Added call to fvrrpm  "      "       "      "
###             fbyegn  Chg- Added call to fsavrp  "      "       "      "
###             fputil  Moved code from fprint.rat
###
 
 
#####   version 3.0  dated- 22dec80
 
 
# 
 
 
define  ($DEBUGM,)
include "bbcode.inc"
include "plplay.inc"
include "frmain.inc"
include "ascii.inc"
 
define (ForceImplicit, Implicit None)                  # MJC 6/9/2K (E2145)
 
program force
 
#######################################################################
#$%
#$% Purpose:   FORCE is an interactive stand-alone program that
#$%            allows the user to create the SCENARIO File using
#$%            input from the CHARACTRERISTICS File (BUILD).
#$%
#$% Called By: None
#$%
#$% Calls:     FINIT      ECHOR
#$%            ORDINT     ORDPRC
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################################
 
# Implicit None           # implicit literal (a,c) # MJC 6/8/2K (E2145)
ForceCommon
PLAYcommon
integer   MAX_USED,
          MAX_AVAIL,
          IHANDLE,
          ICHAN_IN,
          ICHAN_OUT,
          IVIEW                                    # MJC 6/8/2K (E2145)
character PROMPT[4] / 0,0,0,0 /                    # MJC 6/8/2K (E2145)
EXTERNAL ERROR_HANDLER
 
# begin logic   ############################################################
 
map$work$file
 
#$% initialize all standard files and common variables
call initr4
 
#call help_pgm(1,
#              "force: Create forces for scenario",
#              "force Tags: Build, Scenario",
#              "Usage: force [|<force order file[|.txt]>]",
#              "",
#              "",
#              "",
#              "",
#              "Example: force port.txt")
 
call tty_set_echo (NO)          # do not display on terminal
 
call get_command_line
 
#______________________________________________________________________
# check for work file overflow
 
max_used = ZZZ$base
max_avail = $WORKFILESIZE
 
if (max_used > max_avail)
    {
    call echov ("FORCE has been compiled with a work file size smaller")
    call echor
    call echov ("than that required to operate properly.  Contact Progammers.")
    call echor
    call echov ("  (")
    call echoi  (max_used)
    call echov (" needed, with only")
    call echoi  (max_avail)
    call echov (" available)")
    call echor
    call exit
    }
 
#______________________________________________________________________
# initialize for NEW, RELINK and UPDATE runs
 
call finit
 
curfor = $NULL                          # initialize FOR <addressee> process
 
call echor
 
ihandle = 0
 
CALL Recall_Init (iHandle, ichan_in, 20, 260)
 
PARSE$SET$RECALL(ihandle)
 
 
repeat                                  # loop for input
    {
    PARSE$SET$GROUP($GRP$FORCE)
    call ordprc (iview,1,prompt)        # input and validate orders
    }
 
end
 

 
 
subroutine get_ch (char,itime)
 
################################################
#$%
#$% Purpose:   GET_CH gets input character.
#$%
#$% Called By: GETLNH     VIEW     VIEW2
#$%            DBREAK     DDEBUG   DMODEL
#$%            DVALUE     WGPAUS   WHAMO
#$%            WARGAM
#$%
#$% Calls:     GETFCH
#$%
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################
 
integer char,itime
external ttyin
 
repeat
    {
    #$% get a character
    call getfch (char,$yes,0)
    #call ttyin (char,itime)
      #$% continue until a null is received
    } until(char!=$null)
 
return
end

 
subroutine chkflt (_             # search for aircraft/display options
                   itype,        # aircraft type name
                   istat,        # returned status $YES=ok(found it)
                   icnt)         # number of slots available
 
##################################################################
#$%
#$% Purpose:   CHKFLT searches for and checks aircraft equipment and
#$%            displays options available options. This is currently
#$%            a dummy routine.
#$%
#$% Called By: HANLNC <PLAY.RAT>
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##################################################################
 
integer lstflt,eq[2,16]
common /cckflt/ lstflt,eq
integer ISTAT,
        ICNT,
        MQTY,
        MNAME,
        ITYPE                               # MJC 6/8/2K (E2145)
 
#$% intialize flag
istat = $yes
#$% max equipments per aircraft is eight
icnt = 8
 
return
#$% check equipment
entry chkeq (itype,mqty,mname,istat)            # istat vice istast 3/12/82
#$% set flag to indicate check is OK
istat = $yes
 
return
end

 
subroutine exeord                # execute orders from the stack
                                 # the first order is thebasic command
                                 # if it was for entering plans,
                                 # there will be additional entries
                                 # in the stack
 
########################################################################
#$%
#$% Purpose:   EXEORD controls processing of SCENARIO development
#$%            commands entered by the user.
#$%
#$% Called By: ORDPRC
#$%
#$% Calls:     FEBASE     FESHIP     FECOMM
#$%            FECKT      FEMEMB     FEESM
#$%            FEPLAN     FEORDR     FESEAR
#$%            FEEMCO     FEWET      FEAIR
#$%            FESOS      FESWABS    FEHFD
#$%            FESST      FERPM      FDELET
#$%            FBYE       FPRINT     FSTOP
#$%            FGLEX      ECHOR      ECHOH
#$%            FEHOI      FESON      FEACT
#$%            FETONE     FEMRV      FEBOAT
#$%            FELIDAR    FEBISTATIC FESITE
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed references to subroutines fetbls, feunit,
#$%            and fecbi - ground unit data removed from build.
#$%
########################################################################
 
# Implicit None           # implicit literal (a,c)            # MJC 6/8/2K (E2145)
PLAYcommon
integer nargs
literal args[$max$args],addr
integer ITIME,
        ISEQ,
        LNORD                                               # MJC 6/8/2K (E2145)
 
$DEBUGM    call echov ("S-")
$DEBUGM    call echoi (stkpnt)
$DEBUGM    call echor
 
#$% if no orders, return
if (stkpnt == $NULL) return
 
$DEBUGM  for (i=1; i <= stkpnt; i=i+1)           # this section is to dump the
$DEBUGM    {                                     # stack info
$DEBUGM  #   break
$DEBUGM     call echov ("# ")
$DEBUGM     call echoi (i)
$DEBUGM
$DEBUGM     call echov (": Length = ")
$DEBUGM     call echoi (stack[$stk$length,i])
$DEBUGM
$DEBUGM     call echov (", Order # = ")
$DEBUGM     call echoi (stack[$stk$nord,i])
$DEBUGM
$DEBUGM     call echov (", Start = ")
$DEBUGM     call echoi (stack[$stk$start,i])
$DEBUGM
$DEBUGM     call echov (", Addressee = ")
$DEBUGM     call echoh (stack[$stk$addressee,i],5)
$DEBUGM
$DEBUGM     call echov (", ")
$DEBUGM     call echoi (stack[$stk$seq,i])
$DEBUGM     call echov (" of ")
$DEBUGM     call echoi (stack[$stk$cnt,i])
$DEBUGM     call echor
$DEBUGM    }
 
#$% get input order
call FgLEX (stack,1,addr,itime,iseq,nargs,args)        # get LEX codes
 
#$% determine data type to be entered or process to be executed
if      (stack[$stk$nord,1] == ENTERBASE$order    ) call febase (nargs,args)
else if (stack[$stk$nord,1] == ENTERSHIP$order    ) call feship (nargs,args)
else if (stack[$stk$nord,1] == ENTERSITE$order    ) call fesite (nargs,args)#KHC 05/26/92
else if (stack[$stk$nord,1] == ENTERBOAT$order    ) call feboat (nargs,args)
else if (stack[$stk$nord,1] == ENTERCLASS$order   ) call fetone (nargs,args)
else if (stack[$stk$nord,1] == ENTERCOMMPATH$order) call fecomm (nargs,args)
else if (stack[$stk$nord,1] == ENTERCOMJAMMER$order) call femrv (nargs,args)#REH 03/08/88
else if (stack[$stk$nord,1] == ENTERCIRCUIT$order ) call feckt  (nargs,args)
else if (stack[$stk$nord,1] == ENTERMEMBER$order  ) call fememb (nargs,args)
else if (stack[$stk$nord,1] == ENTERESM$order     ) call feesm  (nargs,args)
else if (stack[$stk$nord,1] == ENTERPLAN$order    ) call feplan (nargs,args)
else if (stack[$stk$nord,1] == ENTERORDERS$order  ) call feordr (nargs,args)
else if (stack[$stk$nord,1] == ENTERSEARCH$order  ) call fesear (nargs,args)
else if (stack[$stk$nord,1] == ENTERACTION$order  ) call feact  (nargs,args)#TB
else if (stack[$stk$nord,1] == ENTEREMCON$order   ) call feemco (nargs,args)
else if (stack[$stk$nord,1] == ENTERWEATHER$order ) call fewet  (nargs,args)
else if (stack[$stk$nord,1] == ENTERAIR$order     ) call feair  (nargs,args)
else if (stack[$stk$nord,1] == ENTERSOSUSREG$order) call fesos  (nargs,args)
else if (stack[$stk$nord,1] == ENTERSOSUSSUB$order) call fesos  (nargs,args)
else if (stack[$stk$nord,1] == ENTERSWABSREG$order) call feswabs (nargs,args)
else if (stack[$stk$nord,1] == ENTERSWABSSUB$order) call feswabs (nargs,args)
else if (stack[$stk$nord,1] == ENTERSONAR$order   ) call feson  (nargs,args)
else if (stack[$stk$nord,1] == ENTERDIFFUSE$order ) call felidar (nargs,args)#2/91 smm & clk
else if (stack[$stk$nord,1] == ENTERHFDF$order    ) call fehfd  (nargs,args)
else if (stack[$stk$nord,1] == ENTERSURVSAT$order ) call fesst  (nargs,args)
else if (stack[$stk$nord,1] == ENTERREPORT$order  ) call ferpm  (nargs,args)
else if (stack[$stk$nord,1] == ENTERPROBHIT$order ) call fephit (nargs,args)
else if (stack[$stk$nord,1] == ENTERFREQUENCY$order ) call fenter_fom (nargs,args)
else if (stack[$stk$nord,1] == ENTERBISTATICPAIR$order) call febistatic (nargs,args) # CML 6/91
else if (stack[$stk$nord,1] == ENTERBISTATICREG$order) call febistatic (nargs,args) # CML 6/91
else if (stack[$stk$nord,1] == ENTERMDR$order     ) call femdr  (nargs,args)#6/19/90
else if (stack[$stk$nord,1] == ENTERROTHR$order   ) call ferothr(nargs,args)
else if (stack[$stk$nord,1] == ENTERDIR$order     ) call fedir  (nargs,args)
else if (stack[$stk$nord,1] == ENTERUAV$order     ) call feuav  (nargs,args)
else if (stack[$stk$nord,1] == DELETE$order       ) call fdelet (nargs,args)
else if (stack[$stk$nord,1] == PRINT$order        ) call fprint (nargs,args)
else if (stack[$stk$nord,1] == BYE$order          ) call fbye   (nargs,args)
else if (stack[$stk$nord,1] == STOP$order         ) call fstop  (Lnord)
 
#$% else if order not one of the above
else
   {
    call echov ("Sorry, but that order is not enabled yet.")
   }
#$% save last order
Lnord = stack[$stk$nord,1]
call echor
 
return
end
 
 
subroutine finit
 
##################################################################
#$%
#$% Purpose:   FINIT controls program initialization process
#$%            for NEW, RELINK, or UPDATE runs.
#$%
#$% Called By: FORCE
#$%
#$% Calls:     ECHOH      GETLIN     ECHOR
#$%            FLORDR     FLEMIT     FLSOS
#$%            FLPLAN     FLEMCO     FLSWABS
#$%            FLSEAR     FLWET      FLHFDF
#$%            FLMEMB     FLAML      FLSST
#$%            FLFORC     FLPATH     FLRPM
#$%            FGVFOR     FGVPAT     FLALLC
#$%            FLMRV      FLBML      FLTON
#$%            FLTBLS                FLLIDAR
#$%            FLBPAIR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##################################################################
 
# Implicit None           # implicit literal (a,c)   # MJC 6/8/2K (E2145)
ForceCommon
literal nameA[1500], typeA[1500], type
integer nnames, istat, i, almostequal_hv
integer nargs
character line[80]
integer K,
        KMURHO                                   # MJC 6/8/2K (E2145)
# define formats ###########################################################
 
9001 format (a10)
 
#______________________________________________________________________
 
# turn WRAPAROUND ON (assuming I/O is to a VT100)
call echo ($ESC)
call echov ("[?7h")
 
## turn OFF Sloooooow Scroll (assuming I/O is to a VT100)    # Removed by
#call echo ($ESC)                                            # DEW 8/17/88
#call echov ("[?4l")
#call echor
 
#______________________________________________________________________
 
repeat
   {
    #$% prompt user for BUILD File name
    call echov ("What is the BUILD file name?....")
 
    #$% get user input
    call getlin (nargs,line)
    if (nargs == -1) call fr_exit (1)
 
    #$% if no input get next entry
    if (nargs < 1) next
 
    #$% save BUILD File name
	call fold(line)
	build$name = $BLANKLIT
	k = 0
	call smovhn(line, $$maxlit, build$name, k)
 
 
    repeat
       {
        #$% prompt user to check name entered
        call echov ("Is ")
        call echoh (build$name,5)
        call echov (" correct?...")
 
        #$% get user input
        call getlin (nargs,line)
 
        #$% accept all versions of YES/NO
		if (almostequal_hv(line, "YES") == YES |
            almostequal_hv(line, "NO") == YES) break
 
        }
 
    #$% if response is straightforward YES, break loop
	if (almostequal_hv(line, "YES") == YES) break
	}
call echor
 
repeat
   {
    #$% prompt user for SCENARIO File name
    call echov ("What is the SCENARIO file name?....")
 
    #$% get user input
    call getlin (nargs,line)
    if (nargs == -1) call fr_exit (1)
 
    #$% if no input get next entry
    if (nargs < 1) next
 
    #$% save SCENARIO name
	call fold(line)
	scenario$name = $BLANKLIT
	k = 0
	call smovhn(line, $$maxlit, scenario$name, k)
 
    repeat
       {
        #$% prompt user to check name entered
        call echov ("Is ")
        call echoh (scenario$name,5)
        call echov (" correct?...")
 
        #$% get user input
        call getlin (nargs,line)
 
        #$% accept all versions of YES/NO
		if (almostequal_hv(line, "YES")== YES |
            almostequal_hv(line, "NO") == YES) break
        }
 
    #$% if response is straightforward YES, break loop
	if (almostequal_hv(line, "YES") == YES) break
 
   }
call echor
 
#$% prompt user input for run type and validate for NEW, LOAD, RELINK or UPDATE
repeat
   {
    #$% prompt user input for run type
    call echov ("Is this a NEW, RELINK, UPDATE, or LOAD run?...")
 
    #$% get user input
    call getlin (nargs,line)
    if (nargs == -1) call fr_exit (1)
 
    #$% if no input get next entry
    if (nargs < 1) next
 
    #$% accept all forms of NEW, UPDAFTE, RELINK, or LOAD
	if      (almostequal_hv(line,"NEW") == YES)     typrun = 'NEW'
	else if (almostequal_hv(line,"UPDATE")  == YES) typrun = 'UPDAT'
	else if (almostequal_hv(line,"RELINK") == YES)  typrun = 'RELIN'
	else if (almostequal_hv(line,"LOAD") == YES)    typrun = 'LOAD'
	else next
	break
   }
call echor
 
#$% initialize files table
fuse   = 0
do k = 1, $files
   {
    itbl[1,k] = -1
    ftbl  [k] = -1
   }
 
#$% initialize counters
errcnt = 0
nforce = 0
npaths = 0
nemit  = 0
nemcon = 0
nmembr = 0
norder = 0
nplans = 0
nsearc = 0
nact   = 0                                                      # TDB 6/83
nshore = 0
nsite  = 0                                                      # MJF 3/26/92
nclass = 0
nair   = 0
nbml   = 0                                                      # reh 5/10/89
ncruis = 0
ncommb = 0
ncomms = 0
ncommp = 0
njamme = 0
nnavad = 0
nsenso = 0
nsat   = 0
nsonar = 0
nson   = 0                                                      # TDB 6/83
nton   = 0                                                      # Tpa 7/28/83
nsonob = 0
nweap  = 0
nweath = 0
nsos   = 0
nswb   = 0
nhfdf  = 0
nssts  = 0
naml   = 0
nrpm   = 0                                                            #smn002
neph   = 0                                                        # JPK 12/5/83
nMuRho = 0                                      # REH 03/01/88
ncomjm = 0                                      # REH 03/01/88
nground = 0                                     # REH 03/01/88
nchaff = 0                                     # jb    7/10/90
nrothr = 0                                      # RJS 08/27/86, CML 02/08/90
ntrpdo = 0                                      # SMM 4/90
nctrme = 0                                      # SMM 4/90
nldr = 0                                      # CLK & SMM 2/91
niff   = 0                                      # CML 3/91
ngroundunit = 0   #JFR 5/13/91
ncbi = 0          #JFR 5/13/91
natt = 0          #JFR 5/13/91
nbis = 0          #CML 6/91
 
##INITIALIZE THE UTM CONSTANTS (CONVERT.RAT) --- JFR 6/4/91
#origlat = 0.0               #JFR 6/4/91
#origlon = 0.0               #JFR 6/4/91
#origelev = 0.0              #JFR 6/4/91
#origorient = 0.0            #JFR 6/4/91
#call initialize_constants(origlat,origlon,origelev,origorient) #JFR 6/4/91
 
#$% initialize MuRho values     #REH   03/16/88
do MuRho$ptr = 1 , MuRho$Last$value$ptr
 {
  MuRho$mrv = $EntryNotUsed
 }
 
#$% if not NEW  or LOAD run
if (typrun != 'NEW' & typrun != 'LOAD')
   {
    #$% display information message to user
    call echov ("Loading scenario files......")
 
    #$% reload appropriate data
    call flordr                # reload prestored orders
    call flplan                # reload contingency plans
    call flsear                # reload search plans
    call flact                 # reload action plans                 # TDB 6/83
    call flmemb                # reload membership matrix
    call flemit                # reload recognized emitters
    call flemco                # reload emcon plans
    call flwet                 # reload weather data
    call flaml                 # reload air maintenance log data
    call flsqd                 # reload squadron name information - clk 4/95
    call flbml                 # reload boat maintenance log data    # REH 5/89
    call flsos                 # reload sosus data
    call flswabs               # reload SWABS data       clk & smm 2/26/91
    call flson                 # reload sonar environment regions    # TDB 6/83
    call flhfdf                # reload hfdf data
    call flsst                 # reload sst data
    call flrpm                 # reload rpm data             #smn002
    call flton                 # reload recognized tonal list data
    call fleph                 # reload probability of hit data  # JPK 12/5/83
    call flmrv      # reload MuRho data used in comm jammer model # REH 03/01/88
    call fluvp                 # reload UAV probability data     # reh 2/6/90
    call flrothr               # reload ROTHR sites data    # RJS 8/86, CML 2/90
    call flmdr                 # reload Sonobuoy median detection range reh 6/90
    call flintra               # reload intra platfor EMI data hdf 8/90
    call fllidar               # reload LIDAR regions  # SMM/CLK 2/91
    call fltbls                # reload Attrition table data-JFR 5/13/91
    call flfom                 # reload frequency omission table
    call flbpair               # reload bistatic pair data  # CML 6/91
 
    call echor
   }
 
#$% if RELINK run
if (typrun == 'RELIN')
   {
    #$% display information message to user
    call echor
    call echov ("Reloading forces......")
    call echor
    call fgvfor           # get and verify force / equipment
    call fgvpat           # get path info
    call fl_boatclass     # load boat class into class table  5/15/89 reh
    call echor
   }
 
#$% if UPDATE run
else if (typrun == 'UPDAT')
   {
    #$% display information message to user
    call echov ("Loading forces......")
 
    #$% load appropriate data
    call flforc
    call flpath
    call flallc
    call fsuse
    call echor
   }
else if (typrun == 'LOAD')
{
    # Load all ship classes
    call echov ("Loading all ship classes......")
 
    nclass = 0
    call fflchar (build$name,$litc,class$file,nameA,typeA,nnames)
    for (i = 1; i <= nnames; i = i + 1)
    {
        call add_ship_class(nameA[i], typeA[i], istat )
    }
    call echor
 
    # Load all aircraft types
    call echov ("Loading all aircraft types......")
    nair = 0
    nnames = 0
    call fflchar (build$name,$litc,air$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
         call Finseq (nair,wrair,$air,nameA[i],typeA[i],"Aircraft  ")
    }
    call echor
 
    # Load all cruise missile types
    call echov ("Loading all cruise missile types......")
    ncruis = 0
    nnames = 0
    call fflchar (build$name,$litc,cruise$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
        call Finseq (ncruis,wrcruis,$cruise,nameA[i],typeA[i],"Missile   ")
    }
    call echor
 
    # Load all torpedo types
    call echov ("Loading all torpedo types......")
    ntrpdo = 0
    nnames = 0
    call fflchar (build$name,$litc,trpdo$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
        type = 0
        call Finseq (ntrpdo,wrtrpdo,$trpdo,nameA[i],  type,"Torpedo   ")
    }
    call echor
 
    # Load all weapon types
    call echov ("Loading all weapon types......")
    nweap = 0
    nnames = 0
    call fflchar (build$name,$litc,weapon$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
        call Finseq(nweap,wrweap,$weapons,nameA[i],typeA[i],"Weapon    ")
    }
    call echor
 
    # Load all sensor types
    call echov ("Loading all sensor types......")
    nsenso = 0
    nnames = 0
    call fflchar (build$name,$litc,sensor$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
        call Finseq(nsenso,wrsenso,$sensors,nameA[i],typeA[i],"Radar/ESM ")
    }
    call echor
 
    # Load all jammer types
    call echov ("Loading all jammer types......")
    njamme = 0
    nnames = 0
    call fflchar (build$name,$litc,jammer$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
        type = 0
        call Finseq (njamme,wrjamme,$jammers,nameA[i],type,"Jammer    ")
    }
    call echor
 
    # Load all sonar types
    call echov ("Loading all sonar types......")
    nsonar = 0
    nnames = 0
    call fflchar (build$name,$litc, sonar$file,nameA,typeA,nnames)
 
    for (i = 1; i <= nnames; i = i + 1)
    {
        type = 0
        call Finseq (nsonar,wrsonar,$sonar,nameA[i],type,"Sonars    ")
    }
 
    call echor
 
    call echov ("Type of run changing from LOAD to NEW")
    typrun = 'NEW'                        # Load becomes new
    call echor
}
 
call echor
 
return
end

 
subroutine getlin (nargs,line)
 
############################################################################
#$%
#$% Purpose:   GETLIN accepts line of input and converts to upper case.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     ANALYZ
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################################
 
integer nargs
character line[80]
integer I                                                # MJC 6/8/2K (E2145)
 
#$% accept user input
call getlnh(line,$$Maxlit)
call upper(line)
call trim_trailing_blanks(line)
 
if (line[1] == -1)              # was input a CNTL-K or CNTL-C
    {
    nargs   = -1
    }
else
	{
	if (length(line) > 0) nargs = 1
	else                  nargs = 0
	}
 
return
end

 
Subroutine trim_trailing_blanks (line)
character line[ARB]
integer k
k = length(line)
while (k > 0)
{
	if (line[k] != BLANK) break
	k = k - 1
}
line[k+1] = EOS
 
return
end
 

 
 
subroutine flallc
 
####################################################
#$%
#$% Purpose:   FLALLC loads all Characteristic scenario data.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FLCHAR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
####################################################
 
ForceCommon
integer ISTAT                                        # MJC 6/8/2K (E2145)
#$% load appropriate data
call FLCHAR (scenario$name,nclass,wrclass,$class,class$file,istat,
"Ship Class")
call FLCHAR (scenario$name,nshore,wrshore,$shore,shore$file,istat,
"Shore Base")
call FLCHAR (scenario$name,nsite,wrsite,$site,site$file,istat,
"Site      ")                                                     # MJF 3/26/92
call FLCHAR (scenario$name,nair,wrair,$air,air$file,istat,
"Aircraft  ")
call FLCHAR (scenario$name,ncruis,wrcruis,$cruise,cruise$file,istat,
"Cruz Miss ")
call FLCHAR (scenario$name,ncommb,wrcommb,$commbuoy,commb$file,istat,
"Commbuoy  ")
call FLCHAR (scenario$name,ncomms,wrcomms,$commsuite,comms$file,istat,
"Commsuite ")
call FLCHAR (scenario$name,ncommp,wrcommp,$commpair,commp$file,istat,
"Commpair  ")
call FLCHAR (scenario$name,nctrme,wrctrme,$ctrme,ctrme$file,istat,
"Countermea")
call FLCHAR (scenario$name,njamme,wrjamme,$jammers,jammer$file,istat,
"Jammer    ")
call FLCHAR (scenario$name,nnavad,wrnavad,$navaid,navaid$file,istat,
"Navaid    ")
call FLCHAR (scenario$name,nsenso,wrsenso,$sensors,sensor$file,istat,
"Radar/ESM ")
call FLCHAR (scenario$name,nsat,wrsat,$sats,sat$file,istat,
"Survsat   ")
call FLCHAR (scenario$name,nsonar,wrsonar,$sonar,sonar$file,istat,
"Sonar     ")
call FLCHAR (scenario$name,nsonob,wrsonob,$sonobuoy,sonob$file,istat,
"Sonobuoy  ")
call FLCHAR (scenario$name,ntrpdo,wrtrpdo,$trpdo,trpdo$file,istat,
"Torpedo   ")
call FLCHAR (scenario$name,nweap,wrweap,$weapons,weapon$file,istat,
"Weapon    ")
 
# REH 03/01/88
call FLCHAR (scenario$name,ncomjm,wrcomjm,$comjm,comjm$file,istat,"CommJamr  ")
# reh 11/30/89
call FLCHAR (scenario$name,nground,wrground,$ground,ground$file,istat,"Ground Unit")
call FLCHAR (scenario$name,nchaff,wrchaff,$chaff,chaff$file,istat,"Chaff     ")
# cml 3/1/91
call FLCHAR (scenario$name,niff,wriff,$iffs,iff$file,istat,"IFF     ")
call FLCHAR (scenario$name,ngroundunit,wrgroundunit,$groundunit,
             groundunit$file,istat,"GroundUnit")        #JFR 5/13/91
call FLCHAR (scenario$name,nvehicle,wrvehicle,$vehicle,
             vehicle$file,istat,"Vehicle   ")    # JFR 5/24/91
 
return
end

 
subroutine fdelet (nargs,args)
 
############################################################
#$%
#$% Purpose:   FDELET processes user command to delete
#$%            a specific data entry.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FDCOMM     FDORDR     FDWET
#$%            FDESM      FDPLAN     FDAIR
#$%            FDMEMB     FDSEAR     FDSOS
#$%            FDFORC     FDEMCO     FDHFD
#$%            FDSST      FDRPM      FDSON
#$%            ECHOH      ECHOR      FDACT
#$%            FDTONE     FDMRV      FDBOAT
#$%            FDLIDAR    FDSWABS    FDBISTATIC
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed references to fdtbls and fdcbi since
#$%            ground units removed from build.
#$%
############################################################
 
ForceCommon
 
integer nargs
literal args[$max$args]
 
#$% determine entry to be deleted and call appropriate subroutine
if      (args[2] == $lex$commpath$      ) call fdcomm (nargs,args)
else if (args[2] == $lex$ESM$           ) call fdesm  (nargs,args)
else if (args[2] == $lex$MEMBER$        ) call fdmemb (nargs,args)
else if (args[2] == $lex$FORCE$         ) call fdforc (nargs,args)
else if (args[2] == $lex$ORDERS$        ) call fdordr (nargs,args)
else if (args[2] == $lex$PLAN$          ) call fdplan (nargs,args)
else if (args[2] == $lex$SEARCH$        ) call fdsear (nargs,args)
else if (args[2] == $lex$ACTION$        ) call fdact  (nargs,args) #TDB 6/83
else if (args[2] == $lex$EMCON$         ) call fdemco (nargs,args)
else if (args[2] == $lex$WEATHER$       ) call fdwet  (nargs,args)
else if (args[2] == $lex$AIR$           ) call fdair  (nargs,args)
else if (args[2] == $lex$BOAT$          ) call fdboat  (nargs,args) # 5/10/89
else if (args[2] == $lex$SOSUS$         ) call fdsos  (nargs,args)
else if (args[2] == $lex$SWABS$         ) call fdswabs (nargs,args)
else if (args[2] == $lex$SONAR$         ) call fdson  (nargs,args)
else if (args[2] == $lex$HFDF$          ) call fdhfd  (nargs,args)
else if (args[2] == $lex$SURVSAT$       ) call fdsst  (nargs,args)
else if (args[2] == $lex$REPORT$        ) call fdrpm  (nargs,args)
else if (args[2] == $lex$CLASSIFICATION$) call fdtone (nargs,args)
else if (args[2] == $lex$PROBHIT$       ) call fdeph  (nargs,args)
else if (args[2] == $lex$COMMJAMMER$    ) call fdmrv  (nargs,args) # REH 03/15/88
else if (args[2] == $lex$UAV$           ) call fduvp  (nargs,args) # reh 2/5/90
else if (args[2] == $lex$ROTHR$         ) call fdrothr(nargs,args) # RJS 8/27/86, CML 2/8/90
else if (args[2] == $lex$MDR$           ) call fdmdr  (nargs,args) # reh 6/90
else if (args[2] == $lex$INTRA$         ) call fdintra(nargs,args) # hdf 8/90
else if (args[2] == $lex$DIFFUSE$       ) call fdlidar(nargs,args) # smm/clk 2/91
else if (args[2] == $lex$FREQUENCY$     ) call fdFOM (nargs,args)  # reh 6/91
else if (args[2] == $lex$BISTATIC$      ) call fdbistatic (nargs,args)  # cml 6/91
 
#$% if user entry not one of the above
else
   {
    #$% send message that delete function not available
    call echov ("Sorry, but that delete function is not ready yet.")
    call echor
   }
return
end

 
subroutine fprint (nargs,args)
 
############################################################
#$%
#$% Purpose:   FPRINT processes user command to print all or
#$%            a specific data entry.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FPCOMM     FPORDR     FPWET
#$%            FPESM      FPPLAN     FPAIR
#$%            FPMEMB     FPSEAR     FPSOS
#$%            FPFORC     FPEMCO     FPHFD
#$%            FPSST      FPRPM      FPSON
#$%            ECHOH      ECHOR      FPACT
#$%            FPTONE     FPMRV      FPBML
#$%            FPLIDAR    FPSWABS    FPBISTATIC
#$%
#$% Tables:    NONE
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed references to bptbls and fpcbi since
#$%            ground units were removed from build.
#$%
############################################################
 
ForceCommon
integer KK                                       # MJC 6/8/2K (E2145)
integer nargs
literal args[$max$args]
character       pname[64]
character       mydate[10]
character       mytime[9]
character       mydatetime[17]
vmschar*17      mydatetimeV
equivalence     (mydatetime, mydatetimeV)
 
vaxcharacter*64 v_pname
equivalence (pname, v_pname)
 
#$% get date and time for header
call gdate(mydate)
call gtime(mytime)
kk = 0
call smovh (mydate,9,mydatetime,kk)
call smovh (mytime,8, mydatetime,kk)
mdate = mydatetimeV
 
#$% if input is NO, run a force.lis file
if (args[nargs] == $lex$NO$)
   {
    kk = 0
    call smovhn(scenario$name, 5, pname, kk)
    if (args[2] == $lex$GAMEBOOK$)          # 9/92 clk
      {
      call smovv ("s.", pname, kk)
 
      # allow each side to have its own file                        DEW 8/99
      if      (args[3] == $lex$blue$)    call smovv ("blue",    pname, kk)
      else if (args[3] == $lex$orange$)  call smovv ("orange",  pname, kk)
      else if (args[3] == $lex$control$) call smovv ("control", pname, kk)
 
      call smovv ("_book", pname, kk)
      }
    else
      {
      call smovv ("s.lis", pname, kk)
      }
    call smov  (EOS, pname, kk)
 
    open (unit    = 35,                 # open disk file
          access  = "sequential",
          form    = "formatted",
          status  = "UNKNOWN",
          file    = v_pname)
 
    inquire (unit=35, NAME=v_pname) # get full name
 
    call echor
    call echov  ('Listing written to ')
    call echovn (v_pname)
    call echor
   }
#$% if input is YES, display data on the user's terminal
else
   {
    open (unit    = 35,                 # open tty file
          access  = "sequential",
          form    = "formatted",
          status  = "UNKNOWN",
          file    = "SYS$OUTPUT")
    }
 
#$% determine print routine to be called
if      (args[2] == $lex$ALL$           ) call fpall  (nargs,args)
else if (args[2] == $lex$GAMEBOOK$      ) call fpgamebook (nargs,args) #added 7/92
else if (args[2] == $lex$COMMPATH$      ) call fpcomm (nargs,args)
else if (args[2] == $lex$ESM$           ) call fpesm  (nargs,args)
else if (args[2] == $lex$FORCES$        ) call fpforc (nargs,args)
else if (args[2] == $lex$ORDERS$        ) call fpordr (nargs,args)
else if (args[2] == $lex$PLAN$          ) call fpplan (nargs,args)
else if (args[2] == $lex$SEARCH$        ) call fpsear (nargs,args)
else if (args[2] == $lex$ACTION$        ) call fpact  (nargs,args)  # TDB 6/83
else if (args[2] == $lex$UTILIZATION$   ) call fputil (nargs,args)
else if (args[2] == $lex$EMCON$         ) call fpemco (nargs,args)
else if (args[2] == $lex$WEATHER$       ) call fpwet  (nargs,args)
else if (args[2] == $lex$AIR$           ) call fpaml  (nargs,args)
else if (args[2] == $lex$BOAT$          ) call fpbml  (nargs,args)  # REH 5/89
else if (args[2] == $lex$SOSUS$         ) call fpsosr (nargs,args)  # trs 2/91
else if (args[2] == $lex$SWABS$         ) call fpswabs(nargs,args)  # clk 2/91
else if (args[2] == $lex$SONAR$         ) call fpsona (nargs,args)
else if (args[2] == $lex$HFDF$          ) call fphfd  (nargs,args)
else if (args[2] == $lex$SURVSAT$       ) call fpsst  (nargs,args)
else if (args[2] == $lex$REPORT$        ) call fprpm  (nargs,args)      #smn002
else if (args[2] == $lex$CLASSIFICATION$) call fptone (nargs,args)  # TDB 6/83
else if (args[2] == $lex$PROBHIT$       ) call fpeph  (nargs,args)  # JPK 12/83
else if (args[2] == $lex$COMMJAMMER$    ) call fpmrv  (nargs,args)  # REH 03/09/88
else if (args[2] == $lex$UAV$           ) call fpuvp  (nargs,args)  # REH 2/5/90
else if (args[2] == $lex$ROTHR$         ) call fprothr(nargs,args)  # RJS 8/86, CML 2/8/90
else if (args[2] == $lex$MDR$           ) call fpmdr  (nargs,args)  # reh 6/90
else if (args[2] == $lex$INTRA$         ) call fpintra(nargs,args)  # hdf 8/90
else if (args[2] == $lex$DIFFUSE$       ) call fplidar(nargs,args) #smm/clk 2/91
else if (args[2] == $lex$FREQUENCY$     ) call fp_freq_omission (nargs,args)
else if (args[2] == $lex$BISTATIC$      ) call fpbistatic (nargs,args) #cml 6/91
 
#$% else if non of the above
else
   {
    #$% warn user that print function not available
    call echov ("Sorry, but that print function is not ready yet.")
    call echor
   }
 
#$% close file
close (unit = 35)
 
return
end

 
subroutine fwrit (hstrg,len)
 
#######################################################################
#$%
#$% Purpose:   FWRIT writes a string of characters to TTY or disk.
#$%
#$% Called By:
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################################
 
ForceCommon
integer M                                        # MJC 6/8/2K (E2145)
integer len
character hstrg[arb]
 
9000 format (133a1)
 
#$% output character string to TTY/disk
write (35,9000) (hstrg[m],m=1,len)
 
return
end
 
subroutine fwritR (num)
 
#######################################################################
#$%
#$% Purpose:   FWRIT writes a string of characters to TTY or disk.
#$%
#$% Called By:
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################################
 
ForceCommon
integer K,NUM                                            # MJC 6/8/2K (E2145)
9000 format (1x)
 
#$% write num carriage return/linefeeds to TTY/disk
for (k=1; k<=num; k=k+1) write (35,9000)
 
return
end
subroutine fwritF
 
############################################################
#$%
#$% Purpse:    FWRITF writes a formfeed to TTY or disk.
#$%
#$% Called By:
#$%
#$% Calls:     IPBYTE     ECHO       ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################
 
ForceCommon
 
integer ifeed
data ifeed/0/
 
9000 format (a3)
 
#$% if ifeed string empty
if (ifeed == 0)
   {
    #$% set ifeed string to ASCII blank
    ifeed = $BLANKI4
    #$% move formfeed to third position in ifeed string
    call ipbyte (ifeed,3,$formfeed)
   }
#$% write formfeed to TTY of disk
write (35,9000) ifeed
 
return
end

 
subroutine fmovT
 
#######################################################
#$%
#$% Purpose:   FMOVT moves heading data to buffer.
#$%
#$% Called By:
#$%
#$% Calls:     FMOVX      SMOVH
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################
 
ForceCommon
## jb Note:  Mdate now declared vaxcharacter*17 in ForceCommon  1/2/00
 
start$line
 
#$% move scenario name, date and time to buffer
space$over 3; call fmovx ($minus,6) # jb  over 3 vice 4         1/3/00
space$over 1; call smovh (scenario$name,5,linebf,lenbf)
 
##space$over 1; call smovh (mdate        ,9,linebf,lenbf) # jb  1/3/00
space$over 1; call smovV (mdate        ,linebf,lenbf)     # jb  1/3/00
##space$over 2; call smovh (mtime        ,5,linebf,lenbf) # jb delete 1/3/00
 
space$over 1; call fmovx ($minus,6)
space$over 1
 
return
end
 

subroutine fmovv (str)
 
#######################################################
#$%
#$% Purpose:   FMOVV moves Character string to output buffer.
#$%
#$% Called By:
#$%
#$% Calls:     SMOVV
#$%
#$% Tables:    None
#$%
#$% Date:      August 99
#$%
#$% Author:    D Wills
#$%
#######################################################
ForceCommon
 
vaxcharacter*(*) str
 
#$% move vaxcharacter string to buffer
call smovv (str,linebf,lenbf)
 
return
end
 
subroutine fmovh (line,len)
 
#######################################################
#$%
#$% Purpose:   FMOVH moves string to output buffer.
#$%
#$% Called By:
#$%
#$% Calls:     SMOVH
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################
 
ForceCommon
 
integer len
character line[ARB]
 
#$% move character string to buffer
call smovh (line,len,linebf,lenbf)
 
return
end
 
subroutine fmovhn (line,len)
ForceCommon
 
integer len
character line[ARB]
 
#$% move character string to buffer
call smovhn (line,len,linebf,lenbf)
 
return
end

subroutine fmovib (ival,len)
 
############################################################
#$%
#$% Purpose:   FMOVIB moves formatted integer to buffer.
#$%
#$% Called By:
#$%
#$% Calls:     SMOVIB
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################
 
ForceCommon
integer IVAL,LEN                                 # MJC 6/8/2K (E2145)
#$% move integer ival to buffer
call smovib (ival,len,linebf,lenbf)
 
return
end
 
 
subroutine fmovx (ichar,len)
 
#######################################################
#$%
#$% Purpose:   FMOVX moves N character to buffer.
#$%
#$% Called By:
#$%
#$% Calls:     SMOV
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################
 
ForceCommon
integer K,
        LEN,
        ICHAR                                    # MJC 6/8/2K (E2145)
 
#$% move len characters to buffer
for (k=1; k<=len; k=k+1) call smov (ichar,linebf,lenbf)
 
return
end

 
subroutine fpall  (nargs,args)
 
#######################################################
#$%
#$% Purpose:   FPALL prints all scenario file data.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPUTIL     FPFORC     FPCOMA
#$%            FPESM      FPEMCO     FPWET
#$%            FPSOA      FPHFA      FPAML
#$%            FPSST      FPRPMA     FPORDR
#$%            FPPLNA     FPSERA     FPCHAR
#$%            FPACTA     FPTONE     FPBML
#$%            FPROTHR    FPLIDAR
#$%            FPFW1      FPFW2      FPFW3
#$%            FPFW4      FPFW5
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed references to fpcbi and fpatt
#$%            since ground units were removed from build.
#$%
#######################################################
 
ForceCommon
 
integer nargs
literal args[$max$args]
 
 
#$% print utilization sumarizing SCENARIO File data entered
top$page; call fputil (nargs,args)
 
#$% print forces
top$page; call fpforc (nargs,args)
 
#$% print commpaths
top$page; call fpcoma
 
#$% print fingerprinted emmiters
top$page; call fpesm  (nargs,args)
 
#$% print EMCON plans
top$page; call fpemco (nargs,args)
 
#$% print Weather Regions
top$page; call fpwet (nargs,args)
 
#$% print SOSUS regions
top$page; call fpsoa (nargs,args)
 
#$% print BISTATIC SOSUS regions
top$page; call fpbistatic (nargs,args)
 
#$% print SWABS regions
top$page; call fpswabs (nargs,args)
 
#$% print Sonar Environment Regions
top$page; call fpsona (nargs,args)
 
#$% print HFDF regions
top$page; call fphfa (nargs,args)
 
#$% print aircraft maintenance logs
top$page; call fpaml (nargs,args)
 
#$% print boat maintenance logs
top$page; call fpbml (nargs,args)
 
#$% print suveillence satellite data
top$page; call fpsst (nargs,args)
 
#$% print reporting policies
top$page; call fprpma                                                 #smn002
 
#$% print prestored orders
top$page; call fpordr (nargs,args)
 
#$% print contingency plans
top$page; call fpplna (nargs,args)
 
#$% print search plans
top$page; call fpsera (nargs,args)
 
#$% print action plans
top$page; call fpacta (nargs,args)                              # TDB 6/83
 
#$% print sonar tonal values
top$page; call fptone (nargs,args)                              # TDB 6/83
 
#$% print probability of hit values
top$page; call fpeph (nargs,args)                               # JPK 12/83
 
#$% print commjammer MuRho values
top$page; call fpmrv (nargs,args)                               # REH 05/88
 
#$% print characteristics
call fpchar (nargs,args)
 
#$% print ROTHR sites
top$page; call fprothr (nargs,args)                    # RJS 8/86, CML 2/90
 
#$% print LIDAR regions and K values
top$page; call fplidar (nargs,args)                    # SMM & CLK 2/91
 
return
end
 

 
subroutine fpgamebook(nargs,args)
 
########################################################
#$%
#$% Purpose:   FPGAMEBOOK prints specific data of most
#$%            frequently asked questions about blue
#$%            and orange forces
#$%
#%$ Called By: FPRINT
#$%
#$%
#$% Calls:     FPBLUE   FPORANGE    FPCONTROL
#$%
#$%
#$%
#$% Tables:    none
#$%
#$% Date:      July 92
#$%
#$% Author:    Alex Vagus
#$%
#########################################################
ForceCommon
 
integer nargs
literal args[$max$args]
 
#$% Determine print routine to be called
 
if      (args[3] == $lex$BLUE$      ) call fpblue(nargs,args)
else if (args[3] == $lex$ORANGE$    ) call fporange(nargs,args)
else if (args[3] == $lex$CONTROL$   ) call fpcontrol(nargs,args)
 
#$% else if none of the above
else
   {
    #$% warn user that print function is not available
    call echov ("Sorry, but that print function is not ready yet.")
    call echor
    }
 
 
return
end
 
 
subroutine fputil (nargs,args)
 
#######################################################
#$%
#$% Purpose:   FPUTIL prints table utilization
#$%            data for each type of system.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed Munit, Mcbi, Matt, and Morg
#$%            since ground units were removed from
#$%            build.
#$%
#######################################################
 
ForceCommon
 
integer nargs
literal args[$max$args]
integer MFORCE,MPATHS,MMEMBR,MEMIT,MEMCON,MWEATH,MSOSUS,
        NSWABS,MSWABS,MLIDAR,MHFDF,MAML,MBML,MSSTS,MRPM,MPLANS,
        MSEARC,MACT,MSHORE,MSITE,MCLASS,MAIR,MCRUIS,MCHAFF,MCOMMB,
        MCOMMS,MCOMMP,MJAMME,MCOMJAM,MGROUND,MNAVAD,MSENSO,MSAT,
        MSONAR,MSONOB,MWEAP,MSONEV,MTON,MEPH,MMURHO,MUVP,MINTRA,
        MROTHR,MTRPDO,MCTRME,MIFF,MFOM,MORDER,MFILES,MBPAIR       # MJC 6/8/2K (E2145)
 
data    Mforce /$forces    /
data    Mpaths /$paths     /
data    Mmembr /$members   /
data    Memit  /$emitters  /
data    Memcon /$emcon     /
data    Mweath /$weather   /
data    Msosus /$sosus     /
data    Mswabs /$swabsregions/
data    Mhfdf  /$hfdf      /
data    Maml   /$airlog    /
data    Mbml   /$boatlog   /
data    Mssts  /$survsats  /
data    Mrpm   /$policy    /
data    Morder /$orders    /
data    Mplans /$plans     /
data    Msearc /$search    /
data    Mact   /$action    /
data    Mshore /$shore     /
data    Msite  /$site      /                                # MJF 3/26/92
data    Mclass /$class     /
data    Mair   /$air       /
data    Mcruis /$cruise    /
data    Mcommb /$commbuoy  /
data    Mcomms /$commsuite /
data    Mcommp /$commpair  /
data    Mjamme  /$jammers  /
data    Mcomjam /$comjm    /                                    # reh 10/89
data    Mground /$ground   /                                    # reh 11/89
data    Mchaff  /$chaff    /                                    # jb 7/10/90
data    Mnavad /$navaid    /
data    Msenso /$sensors   /
data    Msat   /$sats      /
data    Msonar /$sonar     /
data    Msonob /$sonobuoy  /
data    Mweap  /$weapons   /
data    Msonev /$sonev     /                                    # TDB 6/83
data    Mton   /$ton       /                                    # TDB 6/83
data    Mfiles /$files     /
data    Meph   /$eph       /                                    # JPK 12/83
data    MMuRho /$MuRho     /
data    Muvp   /$uvp       /
data    Mintra /$Intra     /                           # hdf 9/90
data    Mrothr /$rothr     /                           # RJS 8/86, CML 2/90
data    Mtrpdo /$trpdo     /                                    # SMM 4/90
data    Mctrme /$ctrme     /                                    # SMM 4/90
data    Mlidar /$lidarregions/                           # SMM & CLK 2/91
data    Miff   /$iffs      /                           # CML 3/91
data    MFOM   /$fomplan   /
data    Mbpair /$bpairs    /            # CML 6.91
 
#$% display header
skip$lines (2)start$head
mv$v(" Table Utilization ------")
write$line  skip$lines (1)
 
#$% display data
start$line mv$n(Nforce,5) mv$v(" of") mv$n(Mforce,6)
           mv$v(" Forces              ") write$line
start$line mv$n(Npaths,5) mv$v(" of") mv$n(Mpaths,6)
           mv$v(" Commpaths           ") write$line
start$line mv$n(Nmembr,5) mv$v(" of") mv$n(Mmembr,6)
           mv$v(" Path Members        ") write$line
start$line mv$n(Nemit ,5) mv$v(" of") mv$n(Memit ,6)
           mv$v(" Emitters            ") write$line
start$line mv$n(Nemcon,5) mv$v(" of") mv$n(Memcon,6)
           mv$v(" Emcon Plans         ") write$line
start$line mv$n(Nweath,5) mv$v(" of") mv$n(Mweath,6)
           mv$v(" Weather Regions     ") write$line
start$line mv$n(Nsos  ,5) mv$v(" of") mv$n(Msosus,6)
           mv$v(" Sosus Regions       ") write$line
start$line mv$n(Nswabs,5) mv$v(" of") mv$n(Mswabs,6)
           mv$v(" SWABS Regions       ") write$line
start$line mv$n(Nldr  ,5) mv$v(" of") mv$n(Mlidar,6)
           mv$v(" LIDAR Regions       ") write$line
start$line mv$n(Nhfdf ,5) mv$v(" of") mv$n(Mhfdf ,6)
           mv$v(" HFDF Bases          ") write$line
start$line mv$n(Naml  ,5) mv$v(" of") mv$n(Maml  ,6)
           mv$v(" Aircraft Log        ") write$line
start$line mv$n(Nbml  ,5) mv$v(" of") mv$n(Mbml  ,6)
           mv$v(" Boat Log           ") write$line
start$line mv$n(Nssts ,5) mv$v(" of") mv$n(Mssts ,6)
           mv$v(" Survsats            ") write$line
start$line mv$n(Nrpm  ,5) mv$v(" of") mv$n(Mrpm  ,6)
           mv$v(" Reporting Policies  ") write$line
start$line mv$n(Norder,5) mv$v(" of") mv$n(Morder,6)
           mv$v(" Orders              ") write$line
start$line mv$n(Nplans,5) mv$v(" of") mv$n(Mplans,6)
           mv$v(" Plans               ") write$line
start$line mv$n(Nsearc,5) mv$v(" of") mv$n(Msearc,6)
           mv$v(" Search plans        ") write$line
start$line mv$n(Nact  ,5) mv$v(" of") mv$n(Mact  ,6)
           mv$v(" Action plans        ") write$line
start$line mv$n(Nshore,5) mv$v(" of") mv$n(Mshore,6)
           mv$v(" Shore Bases         ") write$line
start$line mv$n(Nsite ,5) mv$v(" of") mv$n(Msite ,6)    # MJF 4/9/92
           mv$v(" Site                ") write$line    # MJF 4/9/92
start$line mv$n(Nclass,5) mv$v(" of") mv$n(Mclass,6)
           mv$v(" Ship Classes        ") write$line
start$line mv$n(Nair  ,5) mv$v(" of") mv$n(Mair  ,6)
           mv$v(" Aircraft Types      ") write$line
start$line mv$n(Ncruis,5) mv$v(" of") mv$n(Mcruis,6)
           mv$v(" Cruise Missile Types") write$line
start$line mv$n(Nchaff,5) mv$v(" of") mv$n(Mchaff,6)    # jb 7/10/90
           mv$v(" Chaff Types         ") write$line
start$line mv$n(Ncommb,5) mv$v(" of") mv$n(Mcommb,6)
           mv$v(" Commbuoy Types      ") write$line
start$line mv$n(Ncomms,5) mv$v(" of") mv$n(Mcomms,6)
           mv$v(" Commsuite Types     ") write$line
start$line mv$n(Ncommp,5) mv$v(" of") mv$n(Mcommp,6)
           mv$v(" Commpair Types      ") write$line
start$line mv$n(Njamme,5) mv$v(" of") mv$n(Mjamme,6)
           mv$v(" Jammer Types        ") write$line
start$line mv$n(Ncomjm,5) mv$v(" of") mv$n(Mcomjam,6)     # reh 10/89
           mv$v(" Comm. Jammer Types  ") write$line
start$line mv$n(Nground,5) mv$v(" of") mv$n(Mground,6)    # reh 11/89
           mv$v(" Ground Unit Types   ") write$line
start$line mv$n(Nnavad,5) mv$v(" of") mv$n(Mnavad,6)
           mv$v(" Nav Aid Types       ") write$line
start$line mv$n(Nsenso,5) mv$v(" of") mv$n(Msenso,6)
           mv$v(" Radar/ESM Types     ") write$line
start$line mv$n(Nsat  ,5) mv$v(" of") mv$n(Msat  ,6)
           mv$v(" Survsat Types       ") write$line
start$line mv$n(Nsonar,5) mv$v(" of") mv$n(Msonar,6)
           mv$v(" Sonar Types         ") write$line
start$line mv$n(Nsonob,5) mv$v(" of") mv$n(Msonob,6)
           mv$v(" Sonobuoy Types      ") write$line
start$line mv$n(Nweap ,5) mv$v(" of") mv$n(Mweap ,6)
           mv$v(" Weapon Types        ") write$line
start$line mv$n(Nson  ,5) mv$v(" of") mv$n(Msonev,6)          # TDB 6/83
           mv$v(" Sonar Envirn Regions") write$line
start$line mv$n(Nton  ,5) mv$v(" of") mv$n(Mton  ,6)          # TDB 6/83
           mv$v(" Sonar Tonal Values  ") write$line
start$line mv$n(Neph  ,5) mv$v(" of") mv$n(Meph  ,6)          # JPK 12/83
           mv$v(" Prob of Hit Values  ") write$line
start$line mv$n(NMuRho,5) mv$v(" of") mv$n(MMuRho,6)          # REH 03/15/88
           mv$v(" Comm. Jammer MuRho Values  ") write$line
start$line mv$n(Nuvp,5) mv$v(" of") mv$n(Muvp,6)              # REH 2/6/90
           mv$v(" UAV probability Values ") write$line
start$line mv$n(Nintra,5) mv$v(" of") mv$n(Mintra,6)              # hdf 8/90
           mv$v(" Intra platform EMI data") write$line
start$line mv$n(Nrothr,5) mv$v(" of") mv$n(Mrothr,6)    # RJS 8/86, CML 2/90
           mv$v(" ROTHR Sites         ") write$line
start$line mv$n(Ntrpdo,5) mv$v(" of") mv$n(Mtrpdo,6)          # SMM 4/90
           mv$v(" Torpedo Types       ") write$line
start$line mv$n(Nctrme,5) mv$v(" of") mv$n(Mctrme,6)          # SMM 4/90
           mv$v(" Countermeasure Types") write$line
start$line mv$n(Niff  ,5) mv$v(" of") mv$n(Miff  ,6)          # CML 3/91
           mv$v(" IFF Types           ") write$line
start$line mv$n(Nfom  ,5) mv$v(" of") mv$n(Mfom  ,6)     	# JFR 5/14/91
           mv$v(" Frequency Omission Table ") write$line
 
$DEBUGP write (35,9201) Nfiles, Mfiles,
$DEBUGP                 (itbl[1,m],ftbl[m],itbl[2,m],m=1,$files)
$DEBUGP 9201 format (1x,i5," of",i7," Files          ",/,
$DEBUGP              10x,"     Use","  Name ","  L-id",/,
$DEBUGP              20(10x,i8,a7,i6,/))
$DEBUGP
 
skip$lines (1)
 
return
end

 
subroutine fbye (nargs,args)
 
######################################################################
#$%
#$% Purpose:   FBYE controls verification of data entries (FBYEVR) and
#$%            generation of SCENARIO Files (FBYEGN).
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FBYEVR     FBYEGN     ECHOR
#$%            ECHOH
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################################
 
ForceCommon
integer ISTAT,
        I                                            # MJC 6/8/2K (E2145)
 
integer nargs
literal args[$max$args]
 
call fbyeVR (istat)              # verify commpaths/forces/.... etc.
 
call echor
 
$debugb  if (istat == $no)
$debugb     {
$debugb      call echov ("Errors Overriden")
$debugb      call echor
$debugb     }
$debugb  istat = $yes
 
#$% if SCENARIO File data verified
if (istat == $yes)
   {
    call fbyeGN                         # generate scenario files.....
 
    for (i=1; i <= $files; i=i+1) call fdclos (i+40)  # close all files
 
    call echor
 
    unmap$work$file
    #$% stop program
 
    call fr_exit (1)
 
    map$work$file
 
    call echor
    call echov ("FORCE ....")
    call echor
   }
#$% else if files not verified
else
   {
    #$% display warning message to user
    call echov ("You must correct the indicated")
    call echov (" errors to save the scenario.")
    call echor
   }
 
return
end

 
subroutine fbyevr (istat)
 
###############################################################
#$%
#$% Purpose:   FBYEVR controls verification of scenario data.
#$%
#$% Called By: FBYE
#$%
#$% Calls:     FVRPAT     FVRMEM     FVRG
#$%            FVREMT     FVRWET     FVRSOS
#$%            FVRHFD     FVRSST     FVRAIR
#$%            FVRRPM     FVRMRV     FVRboat
#$%            FVRroth    FVRLIDAR   FVRSWABS
#$%            FVRATT
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################################
 
ForceCommon
integer ISTAT,
        JSTAT                                        # MJC 6/8/2K (E2145)
 
istat = $yes
 
#$% verify the following files
call FVRpat (jstat)                     # commpaths
if (jstat == $no) istat = $no
 
call FVRmem (jstat)                     # membership matrix
if (jstat == $no) istat = $no
 
call FVRg   (jstat)                     # station guides
if (jstat == $no) istat = $no
 
call FVRemt (jstat)                     # fingerprinted emitters
if (jstat == $no) istat = $no
 
call FVRwet (jstat)                     # default weather region
if (jstat == $no) istat = $no
 
call FVRsos (jstat)                     # sosus regions and submarines
if (jstat == $no) istat = $no
 
call FVRswabs (jstat)                   # SWABS regions and submarines
if (jstat == $no) istat = $no
 
call FVRson (jstat)                     # sonar environment regions  # TDB 6/83
if (jstat == $no) istat = $no
 
call FVRton (jstat)                     # sonar tonal values         # TDB 6/83
if (jstat == $no) istat = $no
 
call FVRhfd (jstat)                     # hfdf bases
if (jstat == $no) istat = $no
 
call FVRsst (jstat)                     # survsat data
if (jstat == $no) istat = $no
 
call FVReph (jstat)                     # prob of hit data
if (jstat == $no) istat = $no
 
call FVRair (jstat)                     # air maintenance log
if (jstat == $no) istat = $no
 
call FVRboat (jstat)                    # boat maintenance log
if (jstat == $no) istat = $no
 
call FVRrpm (jstat)                     # reporting policy matrix     #smn002
if (jstat == $no) istat = $no                                         #smn002
 
call FVRmrv (jstat)                     # comm jammer MuRho Table   REH 03/17/88
if (jstat == $no) istat = $no
 
call FVRuvp (jstat)                     # verify UAV probability data, reh 2/6/90
if (jstat == $no) istat = $no
 
call FVRroth (jstat)                    # ROTHR site data  # RJS 8/86, CML 2/90
if (jstat == $no) istat = $no                              # RJS 8/86, CML 2/90
 
call FVRmdr (jstat)                     # verify sonobuoy median detection range
if (jstat == $no) istat = $no           # 6/90
 
call FVRintra (jstat)                   # verify intra platform EMI data
if (jstat == $no) istat = $no           # 8/90
 
call FVRlidar (jstat)                   # verify LIDAR regions
if (jstat == $no) istat = $no           # 2/91
 
call FVRatt (jstat)                     # Attrition Coef. table -JFR 5/23/91
if (jstat == $no) istat = $no
 
call FVRfom (jstat)                     # frequency omission, reh 6/91
if (jstat == $no) istat = $no
 
return
end
 

 
subroutine fbyegn
 
############################################################################
#$%
#$% Purpose:   FBYEGN controls the saving of input data in the SCENARIO File.
#$%
#$% Called By: FBYE
#$%
#$% Calls:     FSAVEC     ECHOR      ECHOH
#$%            FSAVFC     FSAVPT     FSAVEM
#$%            FSAVEP     FSAVMB     FSAVOR
#$%            FSAVPN     FSAVSR     FSAVWT
#$%            FSAVAL     FSAVSO     FSAVHF
#$%            FSAVSS     FSAVRP     FSAVTN
#$%            FSAVMRV    FSAVBML    FSAVLDR
#$%            FSAVBPAIR
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed references to fsavcbi and fsavatt since ground
#$%            units were removed from build.
#$%
##############################################################################
 
ForceCommon
 
call echor
 
call echov ("Outputting Characteristics.....")
call fsavec (nclass,wrclass,class$file, "Ship Class")
call fsavec (nshore,wrshore,shore$file, "Shore Base")
call fsavec (nsite ,wrsite ,site$file,  "Site      ")  # MJF 3/26/92
call fsavec (nair,  wrair,  air$file,   "Aircraft  ")
call fsavec (ncruis,wrcruis,cruise$file,"Cruz Miss ")
call fsavec (nchaff,wrchaff,chaff$file, "Chaff     ")  # fb 7/10/90
call fsavec (ncommb,wrcommb,commb$file, "Commbuoys ")
call fsavec (ncomms,wrcomms,comms$file, "Commsuites")
call fsavec (ncommp,wrcommp,commp$file, "Commpairs ")
call fsavec (njamme,wrjamme,jammer$file,"Jammers   ")
call fsavec (nnavad,wrnavad,navaid$file,"Navaids   ")
call fsavec (nsenso,wrsenso,sensor$file,"Radar/ESM ")
call fsavec (nsat,  wrsat,  sat$file,   "Survsats  ")
call fsavec (nsonar,wrsonar,sonar$file, "Sonars    ")
call fsavec (nsonob,wrsonob,sonob$file, "Sonobuoys ")
call fsavec (nweap, wrweap, weapon$file,"Weapons   ")
call fsavec (ncomjm,wrcomjm,comjm$file, "CommJammer")  # REH 03/88
call fsavec (nground,wrground,ground$file, "GroundUnts")  # REH 11/89
call fsavec (ntrpdo,wrtrpdo,trpdo$file, "Torpedo   ")  # SMM 4/90
call fsavec (nctrme,wrctrme,ctrme$file, "Countermea")  # SMM 4/90
call fsavec (niff,  wriff,  iff$file,   "IFFs      ")  # SMM 3/91
call fsavec (ngroundunit,wrgroundunit,groundunit$file,"GroundUnit") #JFR 5/13/91
call fsavec (nvehicle,wrvehicle,vehicle$file,"Vehicle   ") # JFR 6/11/91
call echor                                    # end of characteristics
call echov ("Outputting Forces .............")
call fsavfc                                   # save force file
call echor
call echov ("Outputting Commpaths...........")
call fsavpt                                   # save commpaths
call echor
call echov ("Outputting Emitters ...........")
call fsavem                                   # save emitters
call echor
call echov ("Outputting Emcon Plans.........")
call fsavep                                   # save emcon plans
call echor
call echov ("Outputting Members ............")
call fsavmb                                   # save members
call echor
call echov ("Outputting Orders .............")
call fsavor                                   # save orders
call echor
call echov ("Outputting Plans ..............")
call fsavpn                                   # save plans
call echor
call echov ("Outputting Search plans .......")
call fsavsr                                   # save search
call echor
call echov ("Outputting Action plans .......")
call fsavac                                   # save action          # TDB 6/83
call echor
call echov ("Outputting Weather regions.....")
call fsavwt                                    # save weather
call echor
call echov ("Outputting Air Maintenance Log.")
call fsaval                                    # save aml data
call echor
call echov ("Outputting Aircraft Squadron Names.")
call fsave_squadrons
call echor
call echov ("Outputting Boat Maintenance Log")
call fsavbml                                    # save bml data
call echor
call echov ("Outputting Sosus Data..........")
call fsavso                                    # save sosus data
call echor
call echov ("Outputting SWABS Data..........")
call fsavswabs                                 # save SWABS data
call echor
call echov ("Outputting Bistatic Pair Data..")
call fsavbpair                                 # save bistatic pair data
call echor
call echov ("Outputting Sonar Environ Data..")
call fsavsn                                    # save sonar env data # TDB 6/83
call echor
call echov ("Outputting Sonar Tonal Values..")
call fsavtn                                    # save sonar tonals   # TDB 6/83
call echor
call echov ("Outputting HFDF Data...........")
call fsavhf                                    # save hfdf data
call echor
call echov ("Outputting Prob of Hit Data....")
call fsavph                                    # save prob of hit data
call echor
call echov ("Outputting Survsat Data........")
call fsavss                                    # save survsat data
call echor                                                            #smn002
call echov ("Outputting Reporting Policies..")                     #smn002
call fsavrp                                             # save rpm    #smn002
call echor                                                            #REH
call echov ("Outputting CommJammer Data.....")                     #REH
call fsavmrv                                            # save mrv    #REH 03/18/88
call echor
call echov("Outputting UAV Prob. Data.......")       # save UAV prob. data
call fsavuvp                                            # reh 2/6/90
call echor
call echov("Outputting Sonobuoy MDR Data....")       # save MDR data
call fsavmdr                                            # reh 6/90
call echor
call echov("Outputting Intraplatform EMI ...")       # save Intra EMI data
call fsavintra                                          # hdf 8/90
call echor
call echov("Outputting ROTHR Sites..........")       # save ROTHR site data
call fsavrr                                             # RJS 8/86, CML 2/90
call echor
call echov("Outputting LIDAR Regions........")       # save LIDAR region data
call fsavldr                                            # SMM CLK 2/91
call echor
call echov("Outputting Frequency Omission...")       # save freq omission
call fsavfom                                            #
 
call echor
 
return
end
 

 
subroutine fstop (Lnord)
 
#######################################################
#$%
#$% Purpose:   FSTOP terminates scenario session
#$%            without saving files.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     ECHOR      ECHOH     HLTSLF
#$%            FDCLOS
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################
 
# Implicit None           # implicit literal (a,c,p) # MJC 6/8/2K (E2145)
FORCEcommon
PLAYcommon
integer LNORD,
        I                                          # MJC 6/8/2K (E2145)
#external       force$_INVSTOP
#integer        force$_INVSTOP
 
#$% if user enters stop order
if (Lnord == stop$order)
   {
    #$% for each file entry
    for (i=1; i <= $files; i=i+1) call fdclos (i+40) # close all files
 
    call echor
 
    unmap$work$file
 
    #$% stop program
#    call fr_exit (%%loc(force$_INVSTOP))
     stop "Force stopped without saving files"
    map$work$file
    Lnord = 0
    return
   }
 
#$% prompt user to verify stop command
call echov ("If you really want to exit without saving any of this")
call echor
call echov ("session, then re-enter the STOP command.")
call echor
 
return
end

 
 
subroutine fr_exit (status)
integer status
 
#______________________________________________________________________
 
## turn OFF Sloooooow Scroll (assuming I/O is to a VT100)    # Removed by
#call echo ($ESC)                                            # DEW 8/17/88
#call echov ("[?4l")
#call echor
#call echor
 
 
#call exit (status)
if (status == 1)
	STOP
else
	STOP "Abnornal Termination"
#pause "$ "
 
return
end

 
 
subroutine ordprc(iview,itime,prom) # input and process orders
                                    # return if nothing input within
                                    # ITIME minutes.
 
############################################################
#$%
#$% Purpose:   ORDPRC inputs and processes user commands.
#$%
#$% Called By: FORCE
#$%
#$% Calls:     ORDPAR     ORDCHK     EXEORD
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  SMM 2/93 changed parameters for ORDCHK,
#$%            used in Handle_NRT called by WSMAIN
#$%
############################################################
 
# Implicit None           # implicit literal (a,c,p) # MJC 6/8/2K (E2145)
PLAYcommon
string prompt "Command: "
integer NORD,
        NARGS,
        ISTAT,
        IVIEW,
        ITIME                                      # MJC 6/8/2K (E2145)
character PROM[10]                                 # MJC 6/8/2K (E2145)
 
 
stkpnt = 0
 
 call ordpar (100,prompt,nord,nargs)    # call orders parser
 
 if (nord == -1) return                 # test for CANCEL COMMAND
 
 #$% if null (no orders), return
 if (nord == $null) return
 
 repeat
   {
    call ordchk (nord,nargs,istat,0)   # verify order & bld order stack
 
    if (nord == -1) return           # test for CANCEL COMMAND
 
    #$% if user input is YES
    if (istat == $YES)
       {
        call exeord                  # execute the orders in the stack
        break
       }
 
     #$% until blank order received
   } until (nord == blank$order)
 
 return
 end
 

 
subroutine fstbl (nchar,wrchar,name,istat)
 
############################################################
#$%
#$% Purpose:   FSTBL searches WRCHAR array for named value.
#$%            Returns ISTAT=NV if not found.
#$%
#$% Called By: FXBASE     FXSHIP
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################
 
ForceCommon
 
integer nchar,istat
literal wrchar[5,$weapons],name
 
#$% if characters present
if (nchar != 0)
   {
#$% for each entry
    for (istat=1; istat<= nchar; istat=istat+1)
       {
        #$% if exact match return
        if (wrchar[1,istat] == name) return
       }
   }
#$% if not found return NO
istat = $no
return
end

 
subroutine fsuse
 
############################################################
#$%
#$% Purpose:   FSUSE sets slot-in-use flag for each slot.
#$%
#$% Called By: FGVFOR     FESHIP     FEBASE     FESITE
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################
 
ForceCommon
integer K                                         # MJC 6/8/2K (E2145)
#$% for each entry, set flag to YES
for (k=1; k<=nclass; k=k+1) wrclass[3,k] = $yes
for (k=1; k<=nshore; k=k+1) wrshore[3,k] = $yes
for (k=1; k<=nsite ; k=k+1) wrsite [3,k] = $yes   # MJF 3/26/92
for (k=1; k<=nair  ; k=k+1) wrair  [3,k] = $yes
for (k=1; k<=ncruis; k=k+1) wrcruis[3,k] = $yes
for (k=1; k<=nchaff; k=k+1) wrchaff[3,k] = $yes   # jb    7/10/90
for (k=1; k<=ncommb; k=k+1) wrcommb[3,k] = $yes
for (k=1; k<=ncomms; k=k+1) wrcomms[3,k] = $yes
for (k=1; k<=ncommp; k=k+1) wrcommp[3,k] = $yes
for (k=1; k<=njamme; k=k+1) wrjamme[3,k] = $yes
for (k=1; k<=nnavad; k=k+1) wrnavad[3,k] = $yes
for (k=1; k<=nsenso; k=k+1) wrsenso[3,k] = $yes
for (k=1; k<=nsat  ; k=k+1) wrsat  [3,k] = $yes
for (k=1; k<=nsonar; k=k+1) wrsonar[3,k] = $yes
for (k=1; k<=nsonob; k=k+1) wrsonob[3,k] = $yes
for (k=1; k<=nweap ; k=k+1) wrweap [3,k] = $yes
for (k=1; k<=ncomjm; k=k+1) wrcomjm[3,k] = $yes    # REH 03/23/88
for (k=1; k<=nground; k=k+1) wrground[3,k] = $yes   # REH 11/89
for (k=1; k<=ntrpdo; k=k+1) wrtrpdo[3,k] = $yes     # SMM 4/90
for (k=1; k<=nctrme; k=k+1) wrctrme[3,k] = $yes     # SMM 4/90
for (k=1; k<=niff  ; k=k+1) wriff  [3,k] = $yes     # CML 3/91
for (k=1; k<=ngroundunit; k=k+1) wrgroundunit[3,k] = $yes # JFR 5/13/91
 
return
end
 

subroutine fcuse
 
###################################################
#$%
#$% Purpose:   FCUSE clears slot-in-use flag.
#$%
#$% Called By: FGVFOR     FESHIP     FEBASE
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###################################################
 
ForceCommon
integer K                                    # MJC 6/8/2K (E2145)
#$% for each entry, if entry is NO, decrement and break loop
for (k=1; k<=nclass; k=k+1) if (wrclass[3,k] == $no)
                               {nclass = k-1; break}
for (k=1; k<=nshore; k=k+1) if (wrshore[3,k] == $no)
                               {nshore = k-1; break}
for (k=1; k<=nsite ; k=k+1) if (wrsite [3,k] == $no)  # MJF 3/26/92
                               {nsite = k-1; break}   # MJF 3/26/92
for (k=1; k<=nair  ; k=k+1) if (wrair  [3,k] == $no)
                               {nair   = k-1; break}
for (k=1; k<=ncruis; k=k+1) if (wrcruis[3,k] == $no)
                               {ncruis = k-1; break}
for (k=1; k<=nchaff; k=k+1) if (wrchaff[3,k] == $no)  # jb    7/10/90
                               {nchaff = k-1; break}
for (k=1; k<=ncommb; k=k+1) if (wrcommb[3,k] == $no)
                               {ncommb = k-1; break}
for (k=1; k<=ncomms; k=k+1) if (wrcomms[3,k] == $no)
                               {ncomms = k-1; break}
for (k=1; k<=ncommp; k=k+1) if (wrcommp[3,k] == $no)
                               {ncommp = k-1; break}
for (k=1; k<=njamme; k=k+1) if (wrjamme[3,k] == $no)
                               {njamme = k-1; break}
for (k=1; k<=nnavad; k=k+1) if (wrnavad[3,k] == $no)
                               {nnavad = k-1; break}
for (k=1; k<=nsenso; k=k+1) if (wrsenso[3,k] == $no)
                               {nsenso = k-1; break}
for (k=1; k<=nsat  ; k=k+1) if (wrsat  [3,k] == $no)
                               {nsat   = k-1; break}
for (k=1; k<=nsonar; k=k+1) if (wrsonar[3,k] == $no)
                               {nsonar = k-1; break}
for (k=1; k<=nsonob; k=k+1) if (wrsonob[3,k] == $no)
                               {nsonob = k-1; break}
for (k=1; k<=nweap ; k=k+1) if (wrweap [3,k] == $no)
                               {nweap  = k-1; break}
for (k=1; k<=ncomjm; k=k+1) if (wrcomjm [3,k] == $no)  #REH 03/23/88
                               {ncomjm  = k-1; break}
for (k=1; k<=nground; k=k+1) if (wrground [3,k] == $no)  #REH 11/89
                               {nground  = k-1; break}
for (k=1; k<=ntrpdo; k=k+1) if (wrtrpdo [3,k] == $no)  # SMM 4/90
                               {ntrpdo = k-1; break}
for (k=1; k<=nctrme; k=k+1) if (wrctrme [3,k] == $no)  # SMM 4/90
                               {nctrme = k-1; break}
for (k=1; k<=niff  ; k=k+1) if (wriff   [3,k] == $no)  # CML 3/91
                               {niff   = k-1; break}
for (k=1; k<=ngroundunit; k=k+1) if (wrgroundunit [3,k] == $no) # JFR 5/13/91
                                    {ngroundunit  = k-1; break}
 
return
end
 

 
subroutine ffchar (base,code,opt,name,work,iadd)
 
#######################################################
#$%
#$% Purpose:   FFCHAR searches file and returns
#$%            characteristics data if found.
#$%
#$% Called By: FVAIR      FVCRU      FXBASE
#$%            FXSHIP
#$%
#$% Calls:     FDOPEN     ECHOR      ECHOH
#$%            ECHOI
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################
 
ForceCommon
integer NXTREC,
        LEN,
        LFC,
        ISTAT,
        NREC,
        LOOP,
        IADD,
        M,
        ICNT                                 # MJC 6/8/2K (E2145)
 
integer code,cur
VMSchar*(*) opt
literal base,name
literal work[1500]
 
# Define finger print variables (to discern D_Float from G_Float)
integer           finger_p1, finger_p2, mlen
VMSchar           msg*ARB
#external          force$_WRONGARCH
 
 
nxtrec(cur,len) = cur + (len+15)/16            # statment function
 
work[1] = 0
call FDopen ($read,base,code,opt,16*8,lfc,istat) # get the lfc for the
                                               # file.
$DEBUGM call echor
$DEBUGM call echov ("File=")
$DEBUGM call echov (opt)
$DEBUGM call echov (" obj=")
$DEBUGM call echoh (name,5)
$DEBUGM call echov (" LFC=")
$DEBUGM call echoi (lfc)
 
mlen = 0
#$% get number of records
read (lfc,rec=1,err=8010) nrec, finger_p1, finger_p2
 
$DEBUGM call echov (" Cnt=")
$DEBUGM call echoi (nrec)
 
 
for (loop = 2; loop <= nrec; loop = nxtrec(loop,len) )  #search file
   {
    iadd = loop
 
    $DEBUGM call echor
    $DEBUGM call echov ("  id=")
    $DEBUGM call echoi (loop)
 
    #$% read record
    read (lfc,rec=loop,err=8010) (work[m],m=1,16)
 
    len = work[1] + 1                    # length doesn't include VLI
    work[1] = len                        # update length
    icnt = 16
 
    #$% if wrong record, get next entry
    if (work[3] != name) next            # found it ?
 
    $DEBUGM call echov (" Name=")
    $DEBUGM call echoh (work[3],5)
    $DEBUGM call echov (" HIT!")
 
    loop = loop + 1
 
    while (icnt <= len)                  # get the info
       {
 
        $DEBUGM call echov (" read")
 
        read (lfc,rec=loop,err=8010) (work[m],m=icnt+1,icnt+16)
        icnt = icnt + 16
        loop = loop + 1
       }
 
    $DEBUGM call echor
    return                              # return the record
   }
 
$DEBUGM call echov (" ERR!")
 
iadd = 0
work[1] = 0
 
8010 continue
 
$DEBUGM call echov (" Derr")
$DEBUGM call echor
 
return
end

 
subroutine fglex (stack,index,addr,itime,iseq,nargs,args)
 
#######################################################
#$%
#$% Purpose:   FGLEX loads orders for processing.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#######################################################
 
integer    index,itime,iseq,nargs
literal    stack[$stk$lastarg,$play$stack$max],args[$max$args],addr
integer K                                         # MJC 6/8/2K (E2145)
#$% get stack length, start time, address and sequence
nargs = stack[$stk$length,index] - 6
itime = stack[$stk$start,index]
addr = stack[$stk$addressee,index]
iseq = stack[$stk$seq,index]
 
#$% for each etry
for (k=1; k<=$max$args; k=k+1)
   {
    #$% if orders present, get them
    if (k <= nargs) args[k] = stack[k+6,index]
    #$% else enter zero
    else            args[k] = 0
   }
 
return
end

 
define($debugx,#)
 
subroutine mappnt (ipntr,iaddr)
 
###################################################
#$%
#$% Purpose:   MAPPNT creates a mapping workfile.
#$%
#$% Called By: None
#$%
#$% Calls:     FPMAP      FCLOF      FGTJEN
#$%            ECHOR      ECHOH      TYPERR
#$%            TRACE      HLTSLF     FOPENF
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###################################################
 
FORCEcommon
 
integer iaddr
integer IPNTR,IMAX,IBEYND                        # MJC 6/8/2K (E2145)
$debugx call echoi (ipntr)
 
iaddr = ipntr
 
return
 
############################################################################
 
entry mapwrk (imax,ibeynd)            # Map/Unmap work file
return
end

 
subroutine fflchar (base,code,opt,nameA,typeA,nnames)
 
#######################################################
#$%
#$% Purpose:   FFLCHAR reads file and returns
#$%            list of characteristic names
#$%
#$% Called By: FINIT
#$%
#$%
#$% Calls:     FDOPEN     ECHOR      ECHOH
#$%            ECHOI
#$%
#$% Tables:    None
#$%
#$% Date:      MARCH 04
#$%
#$% Author:    James O. Allen
#$%
#######################################################
 
ForceCommon
integer NXTREC,
        LEN,
        LFC,
        ISTAT,
        NREC,
        LOOP,
        LOOP2,
        IADD,
        M,
        ICNT,                                 # MJC 6/8/2K (E2145)
        nnames
 
integer code,cur
VMSchar*(*) opt
literal base
literal work[1500]
literal nameA[1500], typeA[1500]
 
# Define finger print variables (to discern D_Float from G_Float)
integer           finger_p1, finger_p2, mlen
VMSchar           msg*ARB
#external          force$_WRONGARCH
 
 
nxtrec(cur,len) = cur + (len+15)/16            # statment function
 
work[1] = 0
call FDopen ($read,base,code,opt,16*8,lfc,istat) # get the lfc for the
                                               # file.
$DEBUGM call echor
$DEBUGM call echov ("File=")
$DEBUGM call echov (opt)
$DEBUGM call echov (" obj=")
$DEBUGM call echoh (name,5)
$DEBUGM call echov (" LFC=")
$DEBUGM call echoi (lfc)
 
mlen = 0
#$% get number of records
read (lfc,rec=1,err=8010) nrec, finger_p1, finger_p2
 
$DEBUGM call echov (" Cnt=")
$DEBUGM call echoi (nrec)
 
nnames = 0
for (loop = 2; loop <= nrec; loop = nxtrec(loop,len) )  #search file
   {
    iadd = loop
    nnames = nnames + 1
 
    $DEBUGM call echor
    $DEBUGM call echov ("  id=")
    $DEBUGM call echoi (loop)
 
    #$% read record
    read (lfc,rec=loop,err=8010) (work[m],m=1,16)
 
    len = work[1] + 1                    # length doesn't include VLI
    work[1] = len                        # update length
    icnt = 16
 
    nameA[nnames] = work[3]                # Save name
    typeA[nnames] = work[5]
 
    $DEBUGM call echov (" Name=")
    $DEBUGM call echoh (work[3],5)
    $DEBUGM call echov (" HIT!")
 
    loop2 = loop + 1
 
    while (icnt <= len)                  # get the info
       {
 
        $DEBUGM call echov (" read")
 
        read (lfc,rec=loop2,err=8010) (work[m],m=icnt+1,icnt+16)
        icnt = icnt + 16
        loop2 = loop2 + 1
       }
 
   }
 
$DEBUGM call echov (" ERR!")
 
iadd = 0
work[1] = 0
 
8010 continue
 
$DEBUGM call echov (" Derr")
$DEBUGM call echor
 
return
end
