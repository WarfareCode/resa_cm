#####   version 3.1  dated-  7apr81
 
#####   version 3.0  dated- 22dec80
 
#$%     MODULE                     UTILITY                     DATA
#$%   SUBROUTINE                 SUBROUTINES                  TABLES
#$%   ==========                 ===========                  ======
#$%
#$%     FLCHAR                     IPBYTE                     FORCE
#$%     FDOPEN                     WGCAT                      PATH
#$%     FDCLOS                     ECHOR                      ORDERS
#$%     FGETR                      ECHOH                      PLANS
#$%     FPUTR                      ECHOI                      SEARCH
#$%     FLFORC                     FSMOVE                     MEMBER
#$%     FLPATH                     FCHSAT                     EMITTER
#$%     FLORDR                     FSUSE                      EMCON
#$%     FLPLAN                     FCUSE                      NODE
#$%     FLSEAR                     FINSEQ                     BUILD
#$%     FLMEMB                     FVOTHR                     COMMP
#$%     FLEMIT                     FGTASK                     WET
#$%     FLEMCO                                                HFD
#$%     FLWET                                                 SST
#$%     FLHFDF                                                SOS
#$%     FLSST                                                 LDR
#$%     FLSOS                                                 AML
#$%     FLLIDAR                                               BML
#$%     FLAML                                                 SWB
#$%     FGVFOR                                                BIS
#$%     FGVPAT
#$%     FXBASE<FORCE>
#$%     FXSHIP<FORCE>
#$%     FLBML
#$%     FLSWABS
#$%     FLTBLS
#$%     FLBPAIR
#$%
#$%
#$%   NOTES
#$%   =====
#$%
#$%   1.  <FILENAME> INDICATES WHERE SUBROUTINE IS LOCATED.
#$%
#$%   2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%   3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%
#$%   FLOWCHART FOR FINIT
#$%   ===================
#$%
#$%   FINIT<STDISP> - FLALLC - FLCHAR - FDOPEN*
#$%                                   - FGETR *
#$%                                   - FDCLOS*
#$%                 - FLFORC - FDOPEN*
#$%                          - FDCLOS*
#$%                 - FLORDR - FDOPEN*
#$%                          - FDCLOS*
#$%                 - FLSEAR - FDOPEN*
#$%                          - FDCLOS*
#$%                 - FLMEMB - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FDEMIT - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLEMCO - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLWET  - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLHFDF - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLSST  - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLSOS  - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLSWABS- FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLBPAIR- FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLLIDAR- FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - FLAML  - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
#$%                 - #$%                          - FXBASE*
#$%                          - FXSHIP*
#$%                          - FXSITE*
#$%                          - FDCLOS*
#$%                 - FGVPAT - FDOPEN*
#$%                          - FDCLOS*
#$%                 - FLBML  - FDOPEN*
#$%                          - FGETR *
#$%                          - FDCLOS*
 
# 
 
 
define ($DEBUGI,#)
define ($DEBUGF,#)
 
include "bbcode.inc"
include "frmain.inc"
include "plplay.inc"
include "ascii.inc"
define (ForceImplicit, Implicit None)    # MJC 6/12/2K (E2145)
 
subroutine FOShip (force$index)
 
ForceCommon
integer Force$Index                      # MJC 6/7/2K (E2145)
return
end
 
 
subroutine FOBase (force$index)
ForceCommon
integer Force$Index                      # MJC 6/7/2K (E2145)
 
return
end
 

 
 
Subroutine FLCHAR (base,nchar,wchar,maxchr,opt,istat,title)
 
###########################################################################
#$%
#$% Purpose:   FLCHAR loads equipment data that was previously defined.
#$%
#$% Called By: FLALLC
#$%
#$% Calls:     FDOPEN      FGETR      FDCLOS
#$%
#$% Tables:    None
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
ForceCommon
 
integer K,
        K5,
        LFC,
        JSTAT,
        NREC,
        LOOP                                # MJC 6/7/2K (E2145)
 
integer  nchar,istat,maxchr,wichar[$IntRealMatch,5,$sensors] #180 vs 140 2/2/89
literal  base,wrchar[5,$sensors],wchar[5,$sensors]  #jb 180 vice 140 2/2/89
VMSchar*(*) opt,title
equivalence (wichar,wrchar)
 
#$% move to a local array with integer and real overlay
for (k = 1; k <= nchar; k=k+1)
   {
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wrchar[k5,k] = wchar[k5,k]
       }
   }
 
#$% set status flag to NO
istat = $no
 
#$% open scenario file
call FDopen ($read,base,$lits,opt,32*4,lfc,jstat)
 
#$% read record count
read (lfc,rec=1,err=8010) nrec
 
#$% set counter to zero
nchar = 0
#$% for each characteristic
for (loop=2; loop <= nrec; )
   {
    #$% increment counter and load data
    nchar = nchar +  1
    wichar[$halfquad,2,nchar] = 0
    wichar[$halfquad,3,nchar] = $yes
    wichar[$halfquad,4,nchar] = loop
                                                                        #**-3
    #$% get record
    call fgetr (lfc,loop,16,rrec)
 
    wrchar[1,nchar] = rrec[3]
    if (rrec[4] == 'CAT') wrchar[5,nchar] = rrec[5]
    else                    wrchar[5,nchar] = 0
                                                                        #**-3
    #$% if table is ful, break loop
    if (nchar >= maxchr) break
   }
 
#$% close scenario file
8010 call FDclos (lfc)
 
for (k = 1; k <= nchar; k=k+1)                  # move to local array with
   {                                            # integer and real overlay
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wchar[k5,k] = wrchar[k5,k]
       }
   }
return
end
 

 
 
Subroutine FLVEHC (base,nchar,wchar,maxchr,opt,istat,title)
 
###########################################################################
#$%
#$% Purpose:   FLVEH loads equipment data that was not previously defined.
#$%
#$% Called By: Fgvfor
#$%
#$% Calls:     FDOPEN      FGETR      FDCLOS
#$%
#$% Tables:    None
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
ForceCommon
integer K,
        K5,
        LFC,
        JSTAT,
        NREC,
        LOOP                                    # MJC 6/7/2K (E2145)
 
integer  nchar,istat,maxchr,wichar[$IntRealMatch,5,$sensors] #180 vs 140 2/2/89
literal  base,wrchar[5,$sensors],wchar[5,$sensors]  #jb 180 vice 140 2/2/89
equivalence (wichar,wrchar)
VMSchar*(*) opt,title
 
#$% move to a local array with integer and real overlay
for (k = 1; k <= nchar; k=k+1)
   {
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wrchar[k5,k] = wchar[k5,k]
       }
   }
 
#$% set status flag to NO
istat = $no
 
#$% open scenario file
call FDopen ($read,base,$litc,opt,32*4,lfc,jstat)
 
#$% read record count
read (lfc,rec=1,err=8010) nrec
 
#$% set counter to zero
nchar = 0
#$% for each characteristic
for (loop=2; loop <= nrec; )
   {
    #$% increment counter and load data
    nchar = nchar +  1
    wichar[$halfquad,2,nchar] = 0
    wichar[$halfquad,3,nchar] = $yes
    wichar[$halfquad,4,nchar] = loop
                                                                        #**-3
    #$% get record
    call fgetr (lfc,loop,16,rrec)
 
    wrchar[1,nchar] = rrec[3]
    if (rrec[4] == 'CAT') wrchar[5,nchar] = rrec[5]
    else                    wrchar[5,nchar] = 0
                                                                        #**-3
    #$% if table is ful, break loop
    if (nchar >= maxchr) break
   }
 
#$% close scenario file
8010 call FDclos (lfc)
 
for (k = 1; k <= nchar; k=k+1)                  # move to local array with
   {                                            # integer and real overlay
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wchar[k5,k] = wrchar[k5,k]
       }
   }
return
end

 
 
Subroutine FDopen (iread,base,code,opt,isize,lfc,istat)
 
######################################################################
#$%
#$% Purpose:   FDOPEN opens the specified data file for the user.
#$%
#$% Called By: FLORDR     FSAVFC     FLPLAN
#$%            FSAVEM     FLSEAR     FSAVEP
#$%            FLMEMB     FSAVMB     FLEMIT
#$%            FSAVOR     FLEMCO     FSAVPN
#$%            FLWET      FSAVSR     FGVFOR
#$%            FSAVWT     FLFORC     FPCHR1
#$%            FLCHAR     FSAVEC     FLBPAIR
#$%
#$% Calls:     IPBYTE     ECHOR      ECHOI
#$%            WGCAT      ECHOH
#$%
#$% Tables:    None
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
######################################################################
 
ForceCommon
integer    JSIZE,
           IOLD,
           IMIN,
           J,
           ITBLHOLD                                # MJC 6/7/2K (E2145)
integer    iread,lfc,istat,isize,len, code, lenbuf, trnlog_v, equal_hv
literal    base, type
character  typeC[8], tbuf[ARB]
equivalence (type, typeC)
 
character  cfile[ARB]
vaxcharacter*ARB v_cfile
equivalence (cfile, v_cfile)
 
VMSchar*(*) opt
 
#$% set size
 
jsize = isize / 4 #for Intel Fortran, undo factor of 4
type = $BLANKLIT
 
#$% set length to zero
len = 0
 
lenbuf = trnlog_v("BUILD_BASE",tbuf)        # Translate Input TTY to device name
if (equal_hv(tbuf, "BUILD_BASE") == YES ) lenbuf = 0
 
call smovv (opt[1:5],type,len)
call ipbyte (type,1,code)
len = 0
if (typeC[1] == $LITC & lenbuf > 0)       # E2282 JOA UFL02 8/02 - add logical
    call smovh  (tbuf,lenbuf,cfile,len) #   name for build file directory
call smovhn (base,5,cfile,len)
call smovh (type,5,cfile,len)
call smov  (EOS, cfile, len)
 
#$% increment counter
fuse = fuse + 1
 
iold = 1
imin = fuse
 
#$% for each entry
for (j=1; j<=$files;  j=j+1)
   {
    if (FTbl[j] == type)
       {
        itbl[1,j] = fuse
        lfc = j + 40                                                    #**-3
        return
       }
    if (ITbl[1,j] < imin)
       {
        imin = ITbl[1,j]
        iold = j                                                        #**-3
       }
   }
 
lfc = iold+40
 
if (imin > 0)
   {
 
$debugF call echor
$debugF call echov ("Closing ")
$debugF call echoh (ftbl[iold],5)
$debugF call echov (" lfc=")                                          #**-1
$debugF call echoi (lfc)
 
    close (unit = lfc)
   }
 
$debugF call echor
$debugF call echov ("Opening ")
$debugF call echoh (cfile,20)
$debugF call echov (" lfc=")
$debugF call echoi (lfc)
$debugF call echov (" siz=")
$debugF call echoi (jsize)
 
#$% open file and load data
open(unit               = lfc,
     access             = 'direct',
     form               = 'unformatted',
     file               = v_cfile,
     recl               = jsize,
#     associatevariable  = itblhold,
#     carriage control   = 'none',
     status             = 'unknown')
 
itbl[2,iold] = 1
#itbl[2,iold] = itblhold
ITbl[1,iold] = fuse
FTbl[iold]  = type
                                                                        #**-10
$debugF call echov ("FDopen X")
$debugF call echor
 
return
end

 
Subroutine FDclos (lfc)
 
################################################################
#$%
#$% Purpose:   FDCLOS closes the specified data file for the user.
#$%
#$% Called By: FLORDR     FSAVEC     FLPLAN
#$%            FSAVFC     FLSEAR     FSAVEM
#$%            FLMEMB     FSAVEP     FLEMIT
#$%            FSAVMB     FLEMCO     FSAVOR
#$%            FLWET      FSAVPN     FGVFOR
#$%            FSAVSR     FLFORC     FSAVWT
#$%            FLCHAR     FSTOP      FLBPAIR
#$%
#$% Calls:     ECHOR      ECHOI      ECHOH
#$%
#$% Tables:    None
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
################################################################
 
ForceCommon
integer J                               # MJC 6/7/2K (E2145)
integer lfc
 
j = lfc - 40
if (j<1 | j>$files) return
if (ITbl[1,j] < 0) return
                                                                        #**-1
$debugF call echor
$debugF call echov ("Closing ")
$debugF call echoh (ftbl[iold],5)
$debugF call echov (" lfc=")                                          #**-1
$debugF call echoi (lfc)
 
close (unit = lfc)
 
ITbl[1,j] = -1
FTbl[j] = -1
                                                                        #**-2
return
end

 
Subroutine Fgetr (lfc,loop,recsz,rrec)
 
##################################################################
#$%
#$% Purpose:   FGETR retrieves data records from a specified
#$%            file and loads the data into a working array.
#$%
#$% Called By: FLMEMB     FPCHR1     FLEMIT
#$%            FSAVEC     FLEMCO     FLWET
#$%            FLCHAR     FLBPAIR
#$%
#$% Calls:     ECHOH      ECHOR      ECHOI
#$%
#$% Tables:    None
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##################################################################
 
integer  lfc,loop,recsz,len
literal  rrec[1500]
integer M,
        ICNT                                # MJC 6/7/2K (E2145)
 
#$% read file
read (lfc,rec=loop,err=8011) (rrec[m],m=1,recsz)
 
#$% set length
len = rrec[1] + 1                        # length doesn't include VLI
#$% update length
rrec[1] = len                            # update length
 
#$% set counter
icnt = recsz
 
#$% increment record address
loop = loop + 1
 
#$% while counter is less than length
while (icnt < len)
   {
    #$% read file
    read (lfc,rec=loop,err=8011) (rrec[m],m=icnt+1,icnt+recsz)
 
    #$% increment counter
    icnt = icnt + recsz
 
    #$% increment record address
    loop = loop + 1                     # inc record address
   }
 
return
 
#$% send message - error while reading file
8011 call echov ("Error while reading file")
     call echor
     call echov ("REC ID= ")  ; call echoi (loop)     ; call echor
     call echov ("REC Lg= ")  ; call echoi (len )     ; call echor
     call echov ("REC[2&3]= "); call echoh (rrec[2],10); call echor
stop                                                                    #**-2
 
end

 
 
Subroutine Fputr (lfc,loop,recsz,rrec)
 
################################################################
#$%
#$% Purpose:   FPUTR removes specific data from a working
#$%            array and inserts it on a specific file.
#$%
#$% Called By: FSAVEC     FSAVMB     FSAVEM
#$%            FSAVWT
#$%
#$% Calls:     ECHOH      ECHOI      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
################################################################
 
integer  lfc,loop,recsz,len
literal  rrec[1500]
integer  ICNT,
         M1,
         M2,
         M                               # MJC 6/7/2K (E2145)
 
#$% set counter to zero
icnt = 0
#$% set length
len = rrec[1] - 1                      # length shouldn't include VLI
#$% update length
rrec[1] = len
                                                                        #**-5
#$% while counter is less than length
while (icnt <= len)
   {
    m1=icnt+1
    m2=icnt+recsz
    if (m2 > len+1) m2 = len+1
 
    #$% write file
    write (lfc,rec=loop,err=8011) (rrec[m],m=m1,m2)
 
    #$% increment counter
    icnt = icnt + recsz                                                 #**-2
    #$% increment record address
    loop = loop + 1                     # inc record address
   }
 
#$% update and increment
rrec[1] = len + 1
return                                                                  #**-2
 
#$% send message - error while writing file
8011 call echov ("Error while Writing file")
     call echor
     call echov ("REC ID= ")  ; call echoi (loop)     ; call echor
     call echov ("REC Lg= ")  ; call echoi (len )     ; call echor
     call echov ("REC[2&3]= "); call echoh (rrec[2],10); call echor
 
stop                                                                    #**-2
end

 
 
Subroutine FLFORC                             # load force file as is
 
#########################################################################
#$%
#$% Purpose:   FLFORC loads force data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:    FORCE
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#########################################################################
 
ForceCommon                                                             #**-1
integer LFCS,
        ISTAT,
        NREC,
        KREC,
        KFORCE,
        M,
        KORG                                # MJC 6/7/2K (E2145)
 
#literal forcdata[11],orgdata[21]
literal forcdata[12],orgdata[21]       # KHC 6/2/92
 
#$% set force to zero
nforce = 0
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,force$file,24*4,lfcS,istat)    # KHC 6/2/92
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec        #  get old rec count
 
#$% decrement counter
krec = nrec - 1                                                         #**-3
 
#$% set record count to two
nrec = 2
 
#$% for each force entry
for (force$index=1; force$index<=krec; force$index=force$index+1)
   {
    #$% read scenario file
    #read (lfcS,rec=nrec,err=8010)(forcdata[m],m=1,11)
    read (lfcS,rec=nrec,err=8010)(forcdata[m],m=1,12)      # KHC 6/2/92
 
    #$% load force data
    force$task    = forcdata[1]
    if (force$task <= 9999) force$task = force$task * 10 # convert to 5 digit
    force$name    = forcdata[2]
    force$class   = forcdata[3]
    force$lat     = forcdata[4]
    force$long    = forcdata[5]
    force$course  = forcdata[6]
    force$speed   = forcdata[7]
    force$guide   = forcdata[8]
    force$range   = forcdata[9]
    force$bearing = forcdata[10]
    force$depth   = forcdata[11]
    force$indicator = forcdata[12]            # KHC 6/2/92
 
    #$% increment force counter
    nforce = nforce + 1                                                 #**-2
 
    #$% increment counter
    nrec = nrec + 1
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
#NOW DO THE ORGANIZATIONS -JFR 3/6/91
 
#$% set org to zero
norg = 0
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,org$file,42*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8020) nrec        #  get old rec count
 
#$% decrement counter
krec = nrec - 1                                                         #**-3
 
#$% set record count to two
nrec = 2
 
#$% for each org entry
for (org$index=1; org$index<=krec; org$index=org$index+1)
   {
    #$% read scenario file
    read (lfcS,rec=nrec,err=8020)(orgdata[m],m=1,21)
 
    org$task                  = orgdata[1]          #JFR 3/6/91
    org$name                  = orgdata[2]          #JFR 3/6/91
    org$groundunit$name     = orgdata[3]         #JFR 3/6/91
    org$source$zone$number  = orgdata[4]         #JFR 3/6/91
    org$source$zone$letter  = orgdata[5]         #JFR 3/6/91
    org$source$easting      = orgdata[6]         #JFR 3/6/91
    org$source$northing     = orgdata[7]         #JFR 3/6/91
    org$source$latitude     = orgdata[8]         #JFR 3/6/91
    org$source$longitude    = orgdata[9]         #JFR 3/6/91
    org$destination$latitude    = orgdata[10]    #JFR 3/6/91
    org$destination$longitude   = orgdata[11]    #JFR 3/6/91
    org$destination$zone$number = orgdata[12]    #JFR 3/6/91
    org$destination$zone$letter = orgdata[13]    #JFR 3/6/91
    org$destination$easting = orgdata[14]        #JFR 3/6/91
    org$destination$northing = orgdata[15]       #JFR 3/6/91
    org$formation           = orgdata[16]        #JFR 3/6/91
    org$parent$name         = orgdata[17]        #JFR 3/6/91
    org$xoffset             = orgdata[18]        #JFR 3/6/91
    org$yoffset             = orgdata[19]        #JFR 3/6/91
    org$course                = orgdata[20]         #JFR 3/6/91
    org$speed                 = orgdata[21]         #JFR 3/6/91
 
    #$% increment org counter
    norg = norg + 1                                                 #**-2
 
    #$% increment counter
    nrec = nrec + 1
   }
 
8020 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
 
Subroutine FLPATH
 
########################################################################
#$%
#$% Purpose:   FLPATH loads path data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:    PATH
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################################
 
forceCommon
integer LFCS,
        ISTAT,
        MPATHS,
        NREC,
        KPATH,
        KNODE,
        M                                   # MJC 6/7/2K (E2145)
 
literal pathdata[6]
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,path$file,12*4,lfcS,istat)
 
#$% set path to zero
npaths = 0                                                              #**-2
 
#$% read scenario file for path count
read (lfcS,rec=1,err=8010) mpaths        # read path count
 
#$% set count to two
nrec = 2
 
#$% for each path entry
for (path$index=1; path$index<=mpaths; path$index=path$index+1)
   {
    #$% set path index to one
    node$index = 1
 
    #$% read scenario file for new path count
    read (lfcs,rec=nrec,err=8010) (pathdata[m],m=1,6)
 
    #$% increment counter
    nrec = nrec + 1
 
    #$% load path data
    path$name  = pathdata[1]
    path$nodes = pathdata[2]
    path$rho   = pathdata[3]
    path$mu    = pathdata[4]
    path$pair  = pathdata[5]
    path$ckt   = pathdata[6]
 
    #$% for each entry
    for (node$index=2; node$index<=path$nodes;
         node$index=node$index+1)
       {
        #$% read scenario file for new path count
        read (lfcS,rec=nrec,err=8010) (pathdata[m],m=1,6)
 
        #$% increment counter
        nrec = nrec + 1
 
        #$% load path data
        path$cat   = pathdata[1]
        path$class = pathdata[2]
        path$rho   = pathdata[3]
        path$mu    = pathdata[4]
        path$pair  = pathdata[5]
        path$roger = pathdata[6]
       }                                                                #**-4
 
    #$% increment path count
    npaths = npaths + 1
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
 
Subroutine FLORDR                              # load prestored orders
 
##############################################################################
#$%
#$% Purpose:   FLORDR loads prestored orders that were previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:    ORDERS
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##############################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        MREC,
        NREC,
        KREC,
        M                                   # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,orders$file,$ParserRecLen*2*4,lfcS,istat)
                                                                        #**-4
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) mrec         # read rec count
 
#$% set orders to zero
norder = 0
 
#$% for each record entry
for (nrec=1; nrec<= mrec; nrec=nrec+1)
   {
    #$% increment record count
    krec = nrec + 1
    #$% read scenario file for new orders
    read (lfcS,rec=krec,err=8010) (wrorder[m,nrec],m=1,$ParserRecLen)
    #$% increment order counter
    norder = norder + 1                                                 #**-1
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
Subroutine FLPLAN
 
##############################################################################
#$%
#$% Purpose:   FLPLAN loads contingency plan that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:    PLANS
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##############################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        MREC,
        KREC,
        IPLAN,
        M,
        ISIZE,
        K                                       # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,plans$file,$ParserRecLen*2*4,lfcS,istat)
                                                                        #**-1
#$% read scenario file for plan count
read (lfcS,rec=1,err=8010) mrec         # read plan count
#$% set plans to zero
nplans = 0
krec = 2
 
#$% for each plan entry
for (iplan=1; iplan<= mrec; iplan=iplan+1)
   {
    #$% read scenario file for new plan count
    read (lfcS,rec=krec,err=8010) (wrplan[m,1,iplan],m=1,$ParserRecLen)
    #$% increment counter
    krec = krec + 1
 
    #$% set size
    isize = wiplan[$halfquad,3,1,iplan]
 
    #$% for each size entry
    for (k = 2; k <= isize; k=k+1)
       {
        #$% if entry greater than plan size, get next
        if (k > $plansize) next
 
        #$% read scenario file
        read (lfcS,rec=krec,err=8010) (wrplan[m,k,iplan],m=1,$ParserRecLen)
 
        #$% increment counter
        krec = krec + 1                                                 #**-1
       }
 
    #$% increment plan counter
    nplans = nplans + 1
 
    #$% if plans table is full, break loop
    if (nplans >= $plans) break
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

Subroutine FLSEAR
 
###########################################################################
#$%
#$% Purpose:   FLSEAR loads search plans that were previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:    SEARCH
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        MREC,
        KREC,
        IPLAN,
        M,
        ISIZE,
        K                                       # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,search$file,$ParserRecLen*2*4,lfcS,istat)
                                                                        #**-1
#$% read scenario file for search plan count
read (lfcS,rec=1,err=8010) mrec          # read plan count
#$% set search to zero
nsearc = 0
krec = 2
 
#$% for each search plan entry
for (iplan=1; iplan<= mrec; iplan=iplan+1)
   {
    #$% read scenario file for new search plan count
    read (lfcS,rec=krec,err=8010)(wrsearc[m,1,iplan],m=1,$ParserRecLen)
    #$% increment counter
    krec = krec + 1
 
    #$% set size
    isize = wisearc[$halfquad,3,1,iplan]
 
    #$% for each entry
    for (k = 2; k <= isize; k=k+1)                                      #**-5
       {
        #$% if entry greater than search size, get next
        if (k > $searchsize) next
 
        #$% read scenario file
        read (lfcS,rec=krec,err=8010)(wrsearc[m,k,iplan],m=1,$ParserRecLen)
 
        #$% increment counter
        krec = krec + 1                                                 #**-1
       }
 
    #$% increment search plan counter
    nsearc = nsearc + 1
 
    #$% if search plan table is full, break loop
    if (nsearc >= $search) break
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLACT
 
###########################################################################
#$%
#$% Purpose:   FLACT loads action plans that were previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
###########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        MREC,
        KREC,
        IPLAN,
        M,
        ISIZE,
        K                                           # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,action$file,$ParserRecLen*2*4,lfcS,istat)
                                                                        #**-1
#$% read scenario file for action plan count
read (lfcS,rec=1,err=8010) mrec          # read plan count
#$% set counter to zero
nact = 0
krec = 2
 
#$% for each action plan entry
for (iplan=1; iplan<= mrec; iplan=iplan+1)
   {
    #$% read scenario file for new action plan count
    read (lfcS,rec=krec,err=8010)(wract[m,1,iplan],m=1,$ParserRecLen)
    #$% increment counter
    krec = krec + 1
 
    #$% set size
    isize = wiact[$halfquad,3,1,iplan]
 
    #$% for each entry
    for (k = 2; k <= isize; k=k+1)                                      #**-5
       {
        #$% if entry greater than action size, get next
        if (k > $actsize) next
 
        #$% read scenario file
        read (lfcS,rec=krec,err=8010)(wract[m,k,iplan],m=1,$ParserRecLen)
 
        #$% increment counter
        krec = krec + 1                                                 #**-1
       }
 
    #$% increment action plan counter
    nact = nact + 1
 
    #$% if action plan table is full, break loop
    if (nact >= $action) break
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLMEMB
 
################################################################
#$%
#$% Purpose:   FLMEMB loads communication membership matrix
#$%            that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FSMOVE     FGETR
#$%            FDCLOS
#$%
#$% Tables:    MEMBER
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC                                    # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,member$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec        # read rec count
 
#$% set record
nrec = 2
 
#$% get scenario file record
call fgetr (lfcS,nrec,16,rrec)
 
#$% load membership data
nmembr = rrec [1] - 1
#$% move membership data
call fsmove (rrec[2],wrmembr,nmembr)
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLEMIT
 
############################################################
#$%
#$% Purpose:   FLEMIT loads the fingerprinted emitter
#$%            list that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FSMOVE     FGETR
#$%            FDCLOS
#$%
#$% Tables:    EMITTER
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC                                        # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,emitter$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec         # read rec count
                                                                        #**-3
#$% set record
nrec = 2
 
#$% get record
call fgetr (lfcS,nrec,16,rrec)
 
#$% load emitter data
nemit = (rrec[1] - 1)/2
#$% move emitter data
call fsmove (rrec[2],wremit,nemit*2)
                                                                        #**-2
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLEMCO
 
############################################################
#$%
#$% Purpose:   FLEMCO loads emission control plans that
#$%            were previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    EMCON
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
############################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC,
        KEMCON,
        KEMCOX                              # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,emcon$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec              # read rec count
                                                                        #**-3
#$% decrement record count
nemcon = nrec - 1
nrec = 2
 
#$% for each EMCON entry
for (emcon$index = 1 ;emcon$index <= nemcon; emcon$index = emcon$index + 1)
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% load EMCON data
    emcon$side = rrec[2]
    emcon$name = rrec[3]
                                                                        #**-6
    #$% for each EMCON option entry
    for (emcon$option$index = 1 ;emcon$option$index <= 8;
         emcon$option$index = emcon$option$index + 1)
       {
        #$% if option entry is YES, set option to on
        if (rrec[3+emcon$option$index] == 'YES') emcon$option$on
        #$% else set option to NO
        else                                    emcon$option$off        #**-1
       }
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLWET
 
#########################################################################
#$%
#$% Purpose:   FLWET loads weather data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    WET
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC,
        I,
        KWET,
        KWETA                                   # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,wet$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec             # read rec count
 
#$% decrement record count
nweath = nrec - 1
#$% set record
nrec = 2
 
#$% for each weather entry
for (i = 1 ;i <= nweath; i = i+1)
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% set WET pointer
    wet$pointer$to (rrec[2]+1)                # region number (index)
                                                                        #**-3
    #$% if WET pointer is valid, get next
    if (! wet$pointer$valid) next
    wet$map
 
    #$% load WET table
    wet$waveheight    = rrec[3]
    wet$wavedirection = rrec[4]
    wet$windspeed     = rrec[5]
    wet$winddirection = rrec[6]
    wet$cloudcover    = rrec[7]
    wet$ceiling       = rrec[8]
    wet$clouddepth    = rrec[9]
    wet$visibility    = rrec[10]
    wet$category      = rrec[11]
   }                                                                    #**-9
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLHFDF
 
###############################################################
#$%
#$% Purpose:   FLHFDF loads High Frequency Detection data
#$%            that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    HFD
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KHFD,
        KHFDA,
        KHFDX,
        K                                   # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,hfd$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count        #**-2
 
#$% set HFDF to zero
nhfdf = 0
 
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment HFDF counter
    nhfdf = nhfdf + 1                                                   #**-2
 
    #$% set pointer to HFDF
    hfd$pointer$to nhfdf
    hfd$map
 
    #$% set HFD index to zero
    hfd$index = 0
 
    #$% load basename
    hfd$basename    = rrec[2]
 
    #$% for each entry
    for (k=1; k<=100; k=k+1)                                            #**-2
       {
        #$% increment index
        hfd$index = hfd$index + 1
        #$% load HFD prob
        hfd$prob = rrec[2+k]
       }                                                                #**-2
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
 
Subroutine FLSST
 
###############################################################
#$%
#$% Purpose:   FLSST loads surveillance satellite data
#$%            that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FCHSAT     ECHOI
#$%            FDCLOS     FGETR      ECHOH
#$%            ECHOR
#$%
#$% Tables:    SST
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
ForceCommon
 
literal  stype
integer  LFCS,
         ISTAT,
         KREC,
         NREC,
         KSST,
         KSSTA,
         IEFLAG                              # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,sst$file,32*4,lfcS,istat)
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count
 
#$% set SST to zero
nssts = 0                                                               #**-3
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment SST counter
    nssts = nssts + 1
 
    #$% set SST pointer
    sst$pointer$to nssts
    sst$map
 
    #$% load SURVSAT data
    sst$name          = rrec[2]
    sst$type          = rrec[3]
    sst$period        = rrec[4]
    sst$altitude      = rrec[5]
    sst$inclination   = rrec[6]
    sst$xtime         = rrec[7]
    sst$xlongitude    = rrec[8]
    sst$dutycycle     = rrec[9]
    sst$groundstation = rrec[10]
    sst$latitude      = rrec[11]
    sst$longitude     = rrec[12]
    sst$orbit         = rrec[13]
 
    #$% load type
    stype = rrec[3]
 
    #$% set flag to zero
    ieflag = 0                                                          #**-2
 
    #$% if type of run is RELINK
    if (typrun == 'RELIN')
       {
        call fchsat (stype,ieflag)
 
        #$% if flag is one
        if (ieflag == 1)
           {
            #$% decrement SST counter
            nssts = nssts - 1
 
            #$% send SURVSAT data
            call echov ("Survsat ")
            call echohn (rrec[2],$$MAXname) # jb E2141 /8-char. names 1/4/00
            call echov (" not entered because of above errors.")
            call echor
            #$% get next
            next
           }
       }
 
   }                                                                    #**-9
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
 
Subroutine FLSOS
 
########################################################################
#$%
#$% Purpose:   FLSOS loads SOSUS data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    SOS
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:
#$%
########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KSOS,
        KSOSA,
        KSOSX2,
        I,
        KSOSX1,
        KSOSX3                                      # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,sos$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count        #**-2
 
#$% set SOS to zero
nsos = 0
 
#$% for each record entry
for (nrec=2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% if entry is region
    if (rrec[2] == 'REG')
       {
        #$% increment counter
        nsos = nsos + 1                                                 #**-4
 
        #$% set SOS pointer
        sos$pointer$to nsos
        sos$map
 
        #$% load SOSUS region data
        sos$regnumber       = rrec[3]
        sos$meanaxislength  = rrec[4]
        sos$sigmalength     = rrec[5]
        sos$boundarydepth   = rrec[6]
        sos$numberofsets    = rrec[7]
        sos$bis$regionarea  = rrec[8]
        sos$bis$nodedensity = rrec[9]
        sos$bis$range       = rrec[10]
        sos$sub$index       = 0
        sos$sub$index       = 0
        i = 11
 
        #$% for each POS entry
        for (sos$pos$index = 1; sos$pos$index <= sos$pos$slots;
             sos$pos$index = sos$pos$index + 1)
           {
            #$% if entry is found
            if (i < irec[$halfquad,1])
               {
                #$% load position latitude and longitude
                sos$pos$lat = rrec[i]
                sos$pos$lon = rrec[i+1]
               }
            #$% else
            else
               {
                sos$pos$lat = 99999
                sos$pos$lon = 99999
               }
 
            i = i + 2
           }
       }
    #$% else if entry is not SUB or region number
    else if (rrec[2] != 'SUB' | nsos == 0 | rrec[3] != sos$regnumber)
       {
        #$% get next
        next                            # bum record
       }
    #$% else
    else # (rrec[2] == 'SUB')
       {
        #$% increment counter
        sos$sub$index = sos$sub$index + 1                               #**-6
        sos$numberofsets = sos$sub$index
 
        #$% load SUB data
        sos$sub$class    = rrec[4]
        sos$sub$depth    = rrec[5]        #given as shallow or deep
        sos$sub$propmode = rrec[6]
                                                                        #**-3
        i = 7
        #$% for each detection entry
        for (sos$det$index = 1; sos$det$index <= sos$det$slots;
             sos$det$index = sos$det$index + 1)
           {
            #$% load SUB detection prob
            sos$sub$det$prob = rrec[i]
            i = i + 1                                                   #**-2
            #$% increment counter
           }
       }
   }
 
8010 continue
 
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine FLSWABS
 
########################################################################
#$%
#$% Purpose:   FLSWABS loads SWABS data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    SWB
#$%
#$% Date:      February 1991
#$%
#$% Author:    Carol Kropp and Susan Miller
#$%
########################################################################
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KSWB,
        KSWBA,
        KSWBX2,
        I,
        KSWBX1,
        KSWBX3                                          # MJC 6/7/2K (E2145)
 
  #$% open scenario file
  call FDopen ($read, scenario$name, $lits, swb$file, 32*4, lfcS, istat)
 
  #$% read scenario file for record count
  read (lfcS,rec=1,err=8010)    krec          # read rec count
 
  nswb = 0
 
  #$% for each record entry
  for (nrec = 2 ; nrec <= krec; )
    {
     #$% get scenario record
     call fgetr (lfcS, nrec, 16, rrec)
 
     #$% if entry is region
     if (rrec[2] == 'REG')
       {
        nswb = nswb + 1
 
        swb$pointer$to  rrec[3]
        swb$map
 
        #$% load SWABS region data
        swb$regnumber     = rrec[3]
        swb$regdefined    = rrec[4]
        swb$locationerror = rrec[5]
        swb$sigma         = rrec[6]
        swb$sub$index     = 0
 
        i = 8
        #$% for each POS entry
        for (swb$pos$index = 1; swb$pos$index <= swb$pos$slots;
                                      swb$pos$index = swb$pos$index + 1)
          {
           #$% if entry is found
           if (i < irec[$halfquad,1])
             {
              #$% load position latitude and longitude
              swb$pos$lat = rrec[i]
              swb$pos$lon = rrec[i+1]
             }
           else
             {
              swb$pos$lat = 99
              swb$pos$lon = 99
             }
 
           i = i + 2
          }
       }
 
     #$% else if entry is not SUB or region number
     else if (rrec[2] != 'SUB' | nswb == 0 | rrec[3] != swb$regnumber)
       next                            # bum record
 
     #$% else
     else      # (rrec[2] == SUB)
       {
        #$% increment counter
        swb$sub$index = swb$sub$index + 1
        swb$numberofsets = swb$sub$index
 
        #$% load SUB data
        swb$sub$class = rrec[4]
 
        i = 5
        #$% for each detection entry
        for (swb$det$index = 1; swb$det$index <= swb$det$slots;
                                    swb$det$index = swb$det$index + 1)
          {
           #$% load SUB detection prob
           swb$sub$det$prob = rrec[i]
           i = i + 1
          }
       }
    }
 
 
  8010 continue
 
  call FDclos (lfcS)                              # close file
 
return
end

 
subroutine FLBPAIR
 
########################################################################
#$%
#$% Purpose:   FLBPAIR loads Bistatic pair data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    BIS
#$%
#$% Date:      June 1991
#$%
#$% Author:    C. Leaf
#$%
########################################################################
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KBIS,
        KBISA                                       # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read, scenario$name, $lits, bis$file, 32*4, lfcS, istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010)    krec          # read rec count
 
nbis = 0
 
#$% for each record entry
for (nrec = 2 ; nrec <= krec; )
  {
   #$% get scenario record
   call fgetr (lfcS, nrec, 16, rrec)
 
   nbis = nbis + 1
 
   bis$pointer$to  nbis
   bis$map
 
   #$% load Bistatic pair data
   BIS$ActiveSource    = rrec[2]
   BIS$PassiveReceiver = rrec[3]
  }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

Subroutine FLSON
 
########################################################################
#$%
#$% Purpose:   FLSON loads Sonar Environment Region data that was
#$%            previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:
#$%
#$% Date:      June 1983
#$%
#$% Author:    J. P. Kvederis
#$%
########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KSON,
        KSONA,
        I,
        KSONX1,
        K                                                   # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,son$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count        #**-2
 
#$% set SOS to zero
nson = 0
 
#$% for each record entry
for (nrec=2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment counter
    nson = nson + 1                                                 #**-4
 
    #$% set SON pointer
    son$pointer$to nson
    son$map
 
    #$% load Sonar Environment Region data
    son$regnumber = rrec[3]
    son$sonarenv  = rrec[4]
 
    i = 5                                                           #**-7
    #$% for each POS entry
    for (son$pos$index = 1; son$pos$index <= son$pos$slots;
         son$pos$index = son$pos$index + 1)
       {
        #$% if entry is found
        if (i < irec[$halfquad,1])
           {
            K = I
            #$% load position latitude and longitude
            son$pos$lat = rrec[i]
            son$pos$lon = rrec[i+1]
           }                                                        #**-4
        #$% else
        else
           {
            son$pos$lat = 99
            son$pos$lon = 99
           }
        i = i + 2
       }
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
Subroutine FLLIDAR
 
########################################################################
#$%
#$% Purpose:   FLLIDAR loads LIDAR Environment Region data that was
#$%            previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KLDR,
        KLDRA,
        I,
        KLDRX1,
        K                                               # MJC 6/7/2K (E2145)
 
  #$% open scenario file
  call FDopen ($read, scenario$name, $lits, ldr$file, 32*4, lfcS, istat)
 
  #$% read scenario file for record count
  read (lfcS,rec=1,err=8010) krec          # read rec count
 
  #$% set LIDAR count to zero
  nldr = 0
 
  #$% for each record entry
  for (nrec=2 ;nrec <= krec; )
    {
     call fgetr (lfcS,nrec,16,rrec)     # get scenario record
     nldr = nldr + 1
 
     ldr$pointer$to rrec[3]
     ldr$map
 
     #$% load LIDAR Region data
     ldr$regnumber = rrec[3]
     ldr$kvalue  = rrec[4]
 
     i = 5
     #$% for each POS entry
     for (ldr$pos$index = 1; ldr$pos$index <= ldr$pos$slots;
                             ldr$pos$index = ldr$pos$index + 1)
       {
        if (i < irec[$halfquad,1])            #$% if entry is found
          {
           K = I
           ldr$pos$lat = rrec [i]
           ldr$pos$lon = rrec [i+1]
          }
        else
          {
           ldr$pos$lat = 99
           ldr$pos$lon = 99
          }
        i = i + 2
       }
    }
 
  8010 continue
  call FDclos (lfcS)                              # close file
 
return
end
 

Subroutine FLAML
 
###########################################################
#$%
#$% Purpose:   FLAML loads air maintenance log data
#$%            that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    AML
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC,
        I,
        KAML,
        KAMLA                                   # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,aml$file,16*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec          # read rec count       #**-2
 
#$% decrement record counter
naml = nrec - 1
nrec = 2
 
#$% for each AML entry
for (i = 1 ;i <= naml; i = i+1)
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,8,rrec)
 
    #$% set AML pointer
    aml$pointer$to i
    aml$map
 
    #$% load AML data
    aml$sidenumber    = rrec[2]
    aml$type          = rrec[3]
    aml$basename      = rrec[4]
    aml$timeflown     = rrec[5]
    aml$timeup        = rrec[6]
    aml$sqdindx       = rrec[7]
    aml$defaultmission = rrec[8]
   }                                                                    #**-5
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
Subroutine FLTON
 
###############################################################
#$%
#$% Purpose:   FLTON loads recognized tonal list data
#$%            that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FCHSAT     ECHOI
#$%            FDCLOS     FGETR      ECHOH
#$%            ECHOR
#$%
#$% Tables:    RTL
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    J. KVEDERIS
#$%
###############################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KTON,
        KTONA                               # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,ton$file,32*4,lfcS,istat)
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count
 
#$% initialize recognized tonal lists
nton = 0
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment counter
    nton = nton + 1
 
    #$% set pointer
    ton$pointer$to nton
    ton$map
 
    #$% load recognized tonal data - JFR 5/10/93 - dumped tonals
    ton$name           = rrec[2]
    ton$classification1 = rrec[3]
    ton$classification2 = rrec[4] # JFR 5/10/93 - 2nd classification name
    ton$classification3 = rrec[5] # JFR 5/10/93 - 3rd classification name
    ton$classification4 = rrec[6] # JFR 5/10/93 - 4th classification name
   }                                                                    #**-9
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
Subroutine FLEPH
 
###############################################################
#$%
#$% Purpose:   FLEPH loads probability of hit data
#$%            that was previously defined.
#$%
#$% Date:      NOVEMBER 1983
#$%
#$% Author:    J. KVEDERIS
#$%
###############################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KEPH,
        KEPHA                                       # MJC 6/7/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,eph$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count
 
#$% set EPH to zero
neph = 0                                                               #**-3
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment EPH counter
    neph = neph + 1
 
    #$% set EPH pointer
    eph$pointer$to neph
    eph$map
 
    #$% load PROB OF HIT data
    eph$target        = rrec[2]
    eph$weapon        = rrec[3]
    eph$percent       = rrec[4]
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
Subroutine FLTBLS
 
###############################################################
#$%
#$% Purpose:   FLTBLS loads the CBI and the Attrition tables
#$%            that were previously defined.
#$%
#$% Date:      May 1991
#$%
#$% Author:    JOHN F. RICHARDSON [MODIFICATIONS]
#$%
#$% Called by: FINIT
#$%
###############################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KCBI,
        KCBIA,
        KATT,
        KATTA                                           # MJC 6/7/2K (E2145)
 
#$% open scenario file - Combat Index
call FDopen ($read,scenario$name,$lits,cbi$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count
 
#$% set CBI to zero
ncbi = 0                                                               #**-3
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment CBI counter
    ncbi = ncbi + 1
 
    #$% set CBI pointer
    cbi$pointer$to ncbi
    cbi$map
 
    #$% load Combat Index data
    cbi$attacker$posture = rrec[2]
    cbi$defender$onroad = rrec[3]
    cbi$defender$column = rrec[4]
    cbi$defender$line = rrec[5]
    cbi$defender$wedge = rrec[6]
    cbi$defender$vee = rrec[7]
    cbi$defender$circle = rrec[8]
    cbi$defender$echelonleft = rrec[9]
    cbi$defender$echelonright = rrec[10]
   }
 
8010 continue
 
#$% close scenario file - Combat Index
call FDclos (lfcS)                              # close file
 
 
#$% open scenario file - Attrition Coeficients
call FDopen ($read,scenario$name,$lits,att$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8020) krec          # read rec count
 
#$% set att to zero
natt = 0                                                               #**-3
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment att counter
    natt = natt + 1
 
    #$% set att pointer
    att$pointer$to natt
    att$map
 
    #$% load att Coefficient data
    att$table = rrec[3]
    att$attacker = rrec[4]
    att$defender = rrec[5]
    att$coefficient = rrec[6]
   }
 
8020 continue
 
#$% close scenario file - Attrition Coef.
call FDclos (lfcS)                              # close file
 
 
return
 
end
 

 
Subroutine FGVFOR
 
##################################################################
#$%
#$% Purpose:   FGVFOR validates and loads ship and shorebase and site
#$%            data for the RELINK mode.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FXBASE     FSUSE    FXSITE (KHC 5/28/92)
#$%            FGTASK     FXSHIP     FCUSE
#$%            ECHOH      ECHOR      FDCLOS
#$%
#$% Tables:    FORCE
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed code which handled ground units and
#$%            organizations, since the ground enhancements
#$%            were never completed.
#$%
##################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC,
        KREC,
        KFORCE,
        M,
        ITASK,
        ILAT,
        ILONG,
        ICOURS,
        ISPEED,
        IRANGE,
        IBEAR,
        IDEPTH,
        DUMMY,
        KORG                                    # MJC 6/7/2K (E2145)
 
literal  name,class,guide,forcdata[12],taskn,indicator   # KHC 5/28/92
# added orgdata,char_name,parent_name --- JFR 6/10/91
literal  orgdata[21]  #JFR 6/10/91
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,force$file,24*4,lfcS,istat)   # KHC 5/28/92
                                                                         #**-3
#$% set force to zero
nforce = 0
 
#$% read scenario file for old record count
read (lfcS,rec=1,err=8010) nrec         #     get old rec count
#$% decrement record counter
krec = nrec - 1
#$% set record
nrec = 2
 
 
 
#$% for each force entry
for (force$index=1; force$index<=krec; force$index=force$index+1)
   {
    #$% open scenario file
 
    #$% read scenario file for force record
    read (lfcS,rec=nrec,err=8010) (forcdata[m],m=1,12)       # KHC 5/28/92
 
    itask    = forcdata[1]
    name    = forcdata[2]
    class   = forcdata[3]
    ilat     = forcdata[4]
    ilong    = forcdata[5]
    icours   = forcdata[6]
    ispeed   = forcdata[7]
    guide   = forcdata[8]
    irange   = forcdata[9]
    ibear = forcdata[10]
    idepth   = forcdata[11]
    indicator = forcdata[12]    # KHC 5/28/92
 
    #$% increment record counter
    nrec = nrec + 1                                                     #**-2
 
    #$% get task number
    call fgtask (itask,taskn)
 
    #$% send message
    call echov ("Loading Force ")
    call echoh (taskn,8)
    call echov (" ")
    call echohn (name,$$MAXname) # jb E2141 /8-char. names 1/4/00
    call echov ("......")                                             #**-1
    call echor
 
    #$% if class is zero
    #if (class == 0)
    if (indicator == 0)                     # KHC 5/28/92    if shore base
       {
        #$% verify shorebase status
        call FXbase (istat,             # returned status
                     itask,             # task number
                     name)              # name to be known by
       }                                                                #**-1
    #$% else
    else if (indicator == 1)               #$% if site khc 5/28/92
       {
        #$% verify site status
          call FXsite (istat,             #returned status
                       itask ,            # task number
                       name ,             # name to be known by
                       class,             # site class
                       ilat  ,            # A initial lat
                       ilong )            # A initial long
       }
    else
       {
          #$% verify ship data
          call FXship (istat,             # returned status
                       itask ,            # task number
                       name ,             # name to be known by
                       class,             # ship class
                       ilat  ,            # A initial lat (or zero)
                       ilong ,            # A initial long (or zero)
                       icours,            # A initial course (or zero)
                       ispeed,            # A initial speed (or zero)
                       idepth,            # initial depth
                       guide,             # B station guide name (or zero)
                       ibear ,            # B station bearing (or zero)
                       irange,            # B station range (or zero)
                        dummy)                    # 1/19/90, reh
       }                                                                #**-10
 
    #$% if status is YES
    if (istat == $yes)
       {
        #$% set in use slot
        call FSuse
        #$% increment force counter
        nforce = nforce + 1
       }
    #$% else
    else
       {
        #$% clear in use slot
        call FCuse
        #$% send message
        call echov ("The Force ")
        call echoh (taskn,8)
        call echov (" ")
        call echohn (name,$$MAXname) # jb E2141 /8-char. names 1/4/00
        call echov (" is not loaded because of the above errors.")
        call echor
       }
 
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
# DO ORGANIZATIONS -- JFR 6/7/91
# first load up vehicle characteristics ---JFR 6/10/91
#call FLVEHC (scenario$name,nvehicle,wrvehicle,$vehicle,
#             vehicle$file,istat,"Vehicle   ")    # JFR 6/10/91
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,org$file,42*4,lfcS,istat)
                                                                        #**-3
#$% set org to zero
norg = 0
 
#$% read scenario file for old record count
read (lfcS,rec=1,err=8010) nrec         #     get old rec count
#$% decrement record counter
krec = nrec - 1
#$% set record
nrec = 2
 
 
 
#$% for each org entry
for (org$index=1; org$index<=krec; org$index=org$index+1)
   {
    #$% open scenario file
    call FDopen ($read,scenario$name,$lits,org$file,42*4,lfcS,istat)
 
    #$% read scenario file for org record -JFR 6/7/91
    read (lfcS,rec=nrec,err=8010) (orgdata[m],m=1,21)
 
    itask = orgdata[1]                    #JFR 6/7/91
    name = orgdata[2]                     #JFR 6/7/91
 
    #$% increment record counter
    nrec = nrec + 1                                                     #**-2
 
    #$% get task number
    call fgtask (itask,taskn)
 
    #$% send message
    call echov ("Loading Organization ")
    call echoh (taskn,8)
    call echov (" ")
    call echohn (name,$$MAXname) # jb E2141 /8-char. names 1/4/00
    call echov ("......")                                             #**-1
    call echor
 
    #$% if status is YES
    if (istat == $yes)
       {
        #$% set in use slot
        call FSuse
        #$% increment force counter
        norg = norg + 1
       }
    #$% else
    else
       {
        #$% clear in use slot
        call FCuse
        #$% send message
        call echov ("The Organization ")
        call echoh (taskn,8)
        call echov (" ")
        call echohn (name,$$MAXname) # jb E2141 /8-char. names 1/4/00
        call echov (" is not loaded because of the above errors.")
        call echor
       }
 
   }
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FGVPAT
 
########################################################################
#$%
#$% Purpose:   FGVPAT validates and loads communication path data.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     ECHOR      FSUSE
#$%            FCUSE      ECHOH      FINSEQ
#$%            FVOTHR     FDCLOS
#$%
#$% Tables:    PATH       NODE       BUILD
#$%
#$% Date:      DECEMBER 81
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        MPATHS,
        NREC,
        KPATH,
        KNODE,
        M,
        I                                           # MJC 6/8/2K (E2145)
 
literal pathdata[6],name
literal cat0 / 0 /
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,path$file,12*4,lfcS,istat)
 
#$% set path to zero
npaths = 0
 
#$% read scenario file for path count
read (lfcS,rec=1,err=8010) mpaths        # read path count
 
#$% set record
nrec = 2
 
#$% for each path entry
for (path$index=1; path$index<=mpaths; path$index=path$index+1)
   {
    #$% send message
    call echov ("Loading Commpath ")
 
    #$% set node index to one
    node$index = 1
 
    #$% read scenario file for new path data
    read(lfcS,rec=nrec,err=8010) (pathdata[m],m=1,6)
 
    path$name  = pathdata[1]
    path$nodes = pathdata[2]
    path$rho   = pathdata[3]
    path$mu    = pathdata[4]
    path$pair  = pathdata[5]
    path$ckt   = pathdata[6]
 
    #$% set name
    name = path$pair
 
    #$% set error count
    i = errcnt
    #$% load equipment data
    call finseq (ncommp,wrcommp,$commpair,name,cat0,"Commpair  ")
 
    #$% if error count
    if (i == errcnt)
        #$% verifies equipment data
        call FVothr (build$name,$litc,commp$file,ncommp,
                             wrcommp,"Commpair  ")
                                                                        #**-9
    #$% if not error count
    if (i != errcnt)
        {
        #$% set path pair blank
        path$pair  = $BLANKLIT
        #$% clear slot in use
        call FCuse                      # Clear table
        }
    #$% else
    else
        {
        #$% set slot in use
        call FSuse                      # set table
        }
 
    #$% increment record counter
    nrec = nrec + 1
 
    #$% for each path node entry
    for (node$index=2; node$index<=path$nodes;
         node$index=node$index+1)
       {
        #$% read scenario file for new path data
        read (lfcS,rec=nrec,err=8010)(pathdata[m],m=1,6)
 
        path$cat   = pathdata[1]
        path$class = pathdata[2]
        path$rho   = pathdata[3]
        path$mu    = pathdata[4]
        path$pair  = pathdata[5]
        path$roger = pathdata[6]
 
        #$% increment record counter
        nrec = nrec + 1                                                 #**-3
 
        #$% if node index is two
        if (node$index == 2)
           {
            #$% send message
            call echohn (path$name,$$MAXname) # jb E2141 /8-char. names 1/4/00
            call echov ("......")
            call echor
           }
 
        #$% set name
        name = path$pair
 
        #$% if name is not end
        if (name != 'END')
           {
            #$% set error count
            i = errcnt
            #$% load equipment data
            call finseq (ncommp,wrcommp,$commpair,name,cat0,"Commpair  ")
 
            #$% if error count
            if (i == errcnt)
                #$% verifies equipment data
                call FVothr (build$name,$litc,commp$file,ncommp,
                             wrcommp,"Commpair  ")
                                                                        #**-9
            #$% if not error count
            if (i != errcnt)
               {
                #$% set path pair blank
                path$pair  = $BLANKLIT
                #$% clear slot in use
                call FCuse                      # Clear table
               }
            #$% else
            else
               {
                #$% set slot in use
                call FSuse                      # set table
               }
           }
 
       }
 
    #$% increment path counter
    npaths = mpaths
   }
 
8010 continue
 
#$% set error count to zero
errcnt = 0
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 
 

 
Subroutine FLbml
 
###########################################################
#$%
#$% Purpose:   FLbml loads boat maintenance log data
#$%            that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    BML
#$%
#$% Date:      5/10/89
#$%
#$% Author:    R.E.Hundt
#$%
###########################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        NREC,
        I,
        KBML,
        KBMLA                               # MJC 6/8/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,bml$file,8*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) nrec          # read rec count       #**-2
 
#$% decrement record counter
nbml = nrec - 1
nrec = 2
 
#$% for each bml entry
for (i = 1 ;i <= nbml; i = i+1)
   {
    #$% get scenario record
    call fgetr (lfcS,nrec,4,rrec)
 
    #$% set bml pointer
    bml$pointer$to i
    bml$map
 
    #$% load bml data
    bml$name          = rrec[2]
    bml$class         = rrec[3]
    bml$basename      = rrec[4]
   }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 
 

subroutine fl_boatclass
########################################################################
#$%
#$% Purpose:   FL_BOATCLASS Loads Boat Class data during the "Relink"
#$%            phase.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     ADD_BOAT_CLASS
#$%
#$%
#$% Tables:    BML      CLASS
#$%
#$% Date:      MAY 15, 1989
#$%
#$% Author:    R.E. HUNDT
#$%
########################################################################
 
ForceCommon
integer K,
        KBML,
        KBMLA,
        KCLASS,
        ISTAT                                   # MJC 6/8/2K (E2145)
 
logical*1   iclass_found
literal     type
 
type = 'BOAT'                    # value used in procedure call, 1/19/90
 
#$% for each boat maintenance log entry
for (k=1; k<=nbml; k=k+1)
   {
    #$% set bml pointer to map
    bml$pointer$to k
    bml$map
 
    #$% if slot not in use, get next
    if (bml$InUse == $no) next
 
    iclass_found = .false.
 
    #$% for each ship characteristics entry
    for (class$index=1; class$index<=nclass; class$index=class$index+1)
       {
        #$% if ship characteristics class is boat name
        if (bml$class == class$name)
           {
            iclass_found = .true.
            break
           }
       }
 
    #$% if boat class not yet loaded in ship class record
    IF( ! iclass_found )
        {
        # need to load the other characteristics for this boat
        call add_boat_class(bml$class, type, istat)  # reh 1/19/90
        }
    }
 
end
 

 
Subroutine fluvp
 
###############################################################
#$%
#$% Purpose:   FLUVP loads UAV Probaility data
#$%            that was previously defined in force.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    UVP
#$%
#$% Date:      2/6/90
#$%
#$% Author:    R. Hundt
#$%
################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KUVP                                    # MJC 6/8/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,uvp$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count        #**-2
 
#$% set uvp to zero
nuvp = 0
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
    {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment uvp counter
    nuvp = nuvp + 1                                                   #**-2
 
    #$% set index to number of uvp
    uvp$Index = nuvp
 
    uvp$targTypeIndex = rrec[2]
    uvp$Type = rrec[3]
 
    #$% for all integer range values
    FOR (UVP$NumRanges = 1; UVP$NumRanges <= $UAV$NumRangesPerType;
         UVP$NumRanges = UVP$NumRanges + 1)
        {
        UVP$Range          = rrec[(UVP$NumRanges*4)]
        UVP$DetectPb       = rrec[(UVP$NumRanges*4)+1]
        UVP$RecognitionPb  = rrec[(UVP$NumRanges*4)+2]
        UVP$IdentPb        = rrec[(UVP$NumRanges*4)+3]
        }
 
    }# end for each record entry
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

Subroutine flmdr
###############################################################
#$%
#$% Purpose:   FLMDR loads Sonobuoy median detection range data
#$%            that was previously defined in force.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    MDR
#$%
#$% Date:      6/90
#$%
#$% Author:    R. Hundt
#$%
################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KMDR                                    # MJC 6/8/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,mdr$file,32*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count        #**-2
 
#$% set mdr to zero
nmdr = 0
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
    {
    #$% get scenario record
    call fgetr (lfcS,nrec,16,rrec)
 
    #$% increment mdr counter
    nmdr = nmdr + 1                                                   #**-2
 
    #$% set index to number of mdr
    mdr$Index = nmdr
 
    mdr$SonobuoyName          = rrec[2]
    mdr$SubClass              = rrec[3]
    MDR$GoodENVDetectRange    = rrec[4]
    MDR$FairENVDetectRange    = rrec[5]
    MDR$PoorENVDetectRange    = rrec[6]
    MDR$DefaultENVDetectRange = rrec[7]
 
    }# end for each record entry
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

Subroutine flIntra
###############################################################
#$%
#$% Purpose:   FLintra loads intra-platform EMI data
#$%            that was previously defined in force.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    IPE
#$%
#$% Date:      8/90
#$%
#$% Author:    hfisher - CSC
#$%
################################################################
 
ForceCommon
integer LFCS,
        ISTAT,
        KREC,
        NREC,
        KINTRA                                          # MJC 6/8/2K (E2145)
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,INTRA$file,12*4,lfcS,istat)
 
#$% read scenario file for record count
read (lfcS,rec=1,err=8010) krec          # read rec count        #**-2
 
#$% set intra to zero
nintra = 0
 
#$% for each record entry
for (nrec = 2 ;nrec <= krec; )
    {
    #$% get scenario record
    call fgetr (lfcS,nrec,6,rrec)
 
    #$% increment intra counter
    nintra = nintra + 1                                                   #**-2
 
    #$% set index to number of intra
    Intra$Index = nintra
 
    INTRA$Class   = rrec[2]
    INTRA$Victim  = rrec[3]
    INTRA$Percent = rrec[4]
    INTRA$Culprit = rrec[5]
 
    }# end for each record entry
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

Subroutine FLFOM
 
########################################################################
#$%
#$% Purpose:   FLFOM loads frequency omission data that was previously defined.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS
#$%
#$% Tables:    frequency omission
#$%
#$% Date:      6/91
#$%
#$% Author:    Hundt
#$%
########################################################################
 
forceCommon
integer LFCS,
        ISTAT,
        MFOM,
        NREC,
        KFREQ_OMISSION,
        M,
        KFREQ_OMISSION_ITEM                             # MJC 6/8/2K (E2145)
 
literal FOMdata[23]
 
#$% open scenario file
call FDopen ($read,scenario$name,$lits,freq_omission$file,46*4,lfcS,istat)
 
#$% set number of frequency omission plans to zero
nFOM = 0                                                              #**-2
 
#$% read scenario file for FOM entries in file
read (lfcS,rec=1,err=8010) mFOM
 
#$% set count to two
nrec = 2
 
#$% for each FOM entry
for (freq_omission$index=1;
     freq_omission$index<= mFOM-1;
     freq_omission$index=freq_omission$index+1)
    {
    #$% read scenario file for new freq_omission count
    read (lfcs,rec=nrec,err=8010) (fomdata[m],m=1,22)
 
    #$% increment counter
    nrec = nrec + 1
 
    #$% load freq_omission data
    freq_omission$Plan_name  = FOMdata[2]
    freq_omission$Path_name  = FOMdata[3]
 
    for (freq_omission$item_index = 1;
         freq_omission$item_index <= $maxFomItems;
         freq_omission$item_index = freq_omission$item_index + 1)
        {
        freq_omission$LowFreq = FOMdata [2+freq_omission$item_index*2 ]
        freq_omission$HiFreq = FOMdata [3 + freq_omission$item_index*2 ]
        }
 
    #$% increment path count
    nfom = nfom + 1
    }
 
8010 continue
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
Subroutine FLSQD
###########################################################
#$%
#$% Purpose:   FLSQD loads the aircraft squadron name info.
#$%
#$% Called By: FINIT
#$%
#$% Calls:     FDOPEN     FDCLOS     FGETR
#$%
#$% Tables:    SQD
#$%
#$% Date:      April 1995
#$%
#$% Author:    Carol L. Kropp
#$%
###########################################################
ForceCommon
integer  LFCS,
         ISTAT,
         KSQD,
         KSQDA                                       # MJC 6/8/2K (E2145)
integer  nrec
integer  i
 
  call FDopen ($read, scenario$name, $lits, sqd$file,
               8*4,    lfcS,          istat)
  read (lfcS,rec=1, err=8010)  nrec
 
  nsquadrons = nrec - 1
  nrec = 2
  for (i = 1 ; i <= nsquadrons; i = i + 1)
   {
    call fgetr (lfcS, nrec, 4, rrec)
    SQD$Pointer$to  i
    SQD$Map
 
    SQD$SquadronName = rrec[2]
   }
 
8010 continue
  call FDclos (lfcS)
 
return
end
