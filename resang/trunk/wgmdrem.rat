####                    File WGMDREM.rat
####
####    Record of Modifications:
####
####        Programmer          Date        Modification
####
####        G. G. Gustafson     4/4/88      Modified INCLUDE statements by
####                                        adding the logical name NEW_BASE
####                                        to all.
####
####        G. G. Gustafson     4/4/88      Added call to
####                                        DELETE_POTENTIAL_JAMMER
####                                        in subprogram REMOVE_UNITS
####
####        R. E. Hundt         3/89        Conversion from UNT,POS,DYN to
####                                        UNT,DEQ tables
####
####        C. M. Leaf          4/90        Added INCLUDE statement for
####                                        BBRTH.INC and subroutine REMRCL.
####
####        C. L. Kropp         7/92        Rename REMOVE to REMOVE_UNITS
####
####        C. L. Farbstein     9/92        remove ir detections upon removal
####
####        Alex Vagus          8/93        Added statements to zap TTI entrees
####                                        of detector or target
####
####        Carol Kropp         9/94        Removed old, unused routine DelRMT,
####                                        which kept the RMT table as a linked
####                                        list...thrown out in July 1984.
####
####        Carol Kropp         9/94        Added routine Zero_RMT_Entry to clear
####                                        other associated table entries and then
####                                        clear the RMT entry.  Code was duplicated
####                                        in many places.
####
####        Jim Allen           2/98        (E1864) - Removed TTI table references
####                                        and added routine clear_STA_ref.
####

#
##  VAX Conversion:
#  1/19/82  Redefined $DebugV as ##, so program would compile.
#           With this token in (supposed to be = $$Debug$Control = YES),
#           RATFOR claims bracket troubles and FORTRAN claims multiple
#           errors: labels missing or doubly-defined, and delimiters present.
#  1/18/82  UNDEFINEd  read, write and err
#  1/15/82
#       The 2-dimensional array iair(2,20) mixed literals in elements [2,n]
#       with integers in elements [1,n].  Chose to split the array into an
#       integer array, iair(20), and a LITERAL array, cair(20), adding
#       CAIR to the COMMON list.
#
#       MSGs to Views:  DATA statements abandoned in favor of using SMOV-
#       type routines to assemble messages that include literal names.
#
# --------------------------------------------------------------------------
 
#####   version 3.1  dated-  7apr81
 
###
### mod to version 3.0          dated 26-feb-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 dew     remove  Changes for Reporting Model
###
 
#####   version 3.0  dated- 22dec80
 
# 
 
#$%      MODULE                       UTILITY                    DATA
#$%    SUBROUTINES                  SUBROUTINES                 TABLES
#$%    ===========                  ===========                 ======
#$%
#$%      REMOVE_UNITS                       ECHO                       UNT
#$%      REMRM                        ECHOH                      POS
#$%      REMOWN                       ECHOHN                     ACD
#$%      REMREP                       ECHOI                      DYN
#$%      REMDAM                                                  VUE
#$%      REMRCN                                                  RMT
#$%      REMSAT                                                  OWN
#$%      REMLCL                                                  REP
#$%      BBLOD1 <WCOMMN>                                         PND
#$%      BBLODM <WCOMMN>                                         LCL
#$%      XDETAC <WGORDP>                                         DAM
#$%      SEND   < SEND >                                         RCN
#$%      FREINV <REPOUT>                                         SPR
#$%      FRECOR <REPOUT>                                         STR
#$%      FREPND <REPOUT>                                         SSR
#$%      REMRCL                                                  SSD
#$%
#$%
#$%
#$%    NOTES
#$%    =====
#$%
#$%    1.  <FILENAME> INDICATES WHERE SUBROUTINE IS LOCATED.
#$%
#$%    2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%    3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%
#$%    FLOWCHART FOR FILE REMOVE_UNITS
#$%    =========================
#$%
#$%    WARREC - REMOVE_UNITS - BBLOD1*
#$%                    - BBLODM*
#$%                    - XDETAC*
#$%                    - SEND  *
#$%                    - REMRMT*
#$%                    - REMRCL*
#$%                    - REMOWN - FREINV*
#$%                             - FRECOR*
#$%                    - REMREP - FREPND*
#$%                    - REMDAM*
#$%                    - REMRCN*
#$%                    - REMLCL*
#$%                    - REMSAT*
 
 

 
INCLUDE "ascii.inc"
INCLUDE "bbaeg.inc"                 # SMM 4/28/95
INCLUDE "bbctl.inc"
INCLUDE "bbcode.inc"
INCLUDE "bbacc.inc"
INCLUDE "bbaml.inc"
INCLUDE "bbasw.inc"                             # jb    6/90
INCLUDE "bbbar.inc"
INCLUDE "bbbml.inc"
INCLUDE "bbboy.inc"
INCLUDE "bbchf.inc"
INCLUDE "bbdam.inc"
INCLUDE "bbdeq.inc"
INCLUDE "bblcl.inc"
INCLUDE "bbird.inc"                       # clf 9/15/92
INCLUDE "bbmfd.inc"                       # clf 9/15/92
INCLUDE "bbmrk.inc"
INCLUDE "bbnam.inc"
INCLUDE "bbown.inc"
INCLUDE "bbpim.inc"
INCLUDE "bbpnd.inc"
INCLUDE "bbpng.inc"
INCLUDE "bbrcn.inc"
INCLUDE "bbrep.inc"
INCLUDE "bbrmt.inc"
INCLUDE "bbrte.inc"
INCLUDE "bbshc.inc"
INCLUDE "bbspr.inc"
INCLUDE "bbssd.inc"
INCLUDE "bbssr.inc"
INCLUDE "bbsta.inc"                   # joa 2/98 (E1864)
INCLUDE "bbstr.inc"
INCLUDE "bbswp.inc"
INCLUDE "bbtat.inc"
INCLUDE "bbtrk.inc"
INCLUDE "bbunt.inc"
INCLUDE "bbvue.inc"
INCLUDE "bbrth.inc"                                  # CML 4/3/90
INCLUDE "orders.inc"
 
define (BBImplicit, Implicit None)  # jb E2145  5/25/00
 
#define($DEBUGV,$$Debug$Control)                        #       1/19/82
define($debugv,ifelse($$DebugControl,YES,,#))
define($DEBUGV,##)                      # Temporary for compile         1/19/82
 
define (RemoveCommon,
        integer iair[20],cgone,igone[unt$slots],
        czap,zap[unt$slots]                             # 1/15/82
        LITERAL cair[20]                                # 1/15/82
        common  /scratch$pad/ iair,cair,cgone,igone,czap,zap # 1/15/82
       )
 

Subroutine REMOVE_UNITS    # 7/7/80                  #Remove all units whose
                                               #status is being-deleted
########################################################
#$%
#$% Purpose:   REMOVE_UNITS removes all units whose
#$%            status is "being deleted"; and
#$%            clears related tracks, satellite
#$%            reporting, reconnaissance and
#$%            surveillance satellite data.
#$%
#$% Called By: WARREC
#$%
#$% Calls:     BBLOD1     BBLODM     ECHO
#$%            ECHOV      ECHOHN     ECHOI
#$%            REMDAM     REMLCL     REMOWN
#$%            REMREP     REMRMT     REMSAT
#$%            SEND       XDETAC
#$%
#$% Tables:    UNT        POS        DYN
#$%            VUE        ACD
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
#$% Modified:  Carol Kropp - 7/95 (E1419)
#$%            When a unit is being deleted, make sure the
#$%            BTT (BE & TIN) entry is cleared.
#$%
#$%            James Allen - 2/96 (E1467)
#$%            If the unit's fuel hoses are allocated
#$%            free up the unit it is attached to.
#$%
#$%            Carol Kropp - 5/96 (E1498)
#$%            If the RTU is connected to the game do
#$%            not delete the unit until a delete msg
#$%            has been sent out.
#$%
########################################################
BBcommon                                       #Utilize blackboard common
RemoveCommon
 
Literal  unt$Name$c, CSTRIP8                            # jb E2145   5/25/00
integer  i,k, Lindx,indx, iout,nlast, iacflg,ipnt, kkstat # jb E2145 5/25/00
integer unt$Pointer,unt$Status$i,unt$Type$i,unt$View$i,unt$PIMindx$i, # jb 5/00
        unt2$Pointer, unt3$Pointer, pim$Pointer, asw$Pointer # jb E2145 5/25/00
integer UNT$ALSPid$I, zlast[100]                            # jb E2145 5/25/00
BBdeclare (unt$GuideIndx$i)
character       msg[ARB]
 
#          ..../....1..../....2..../....3..../....4..../....5..../
#data msg1/"xxxxx is new leader of group  xxxxx"/       # THESE DATA-   1/15/82
#data msg2/"xxxxx is assigned to bingo to xxxxx"/       #  STATEMENTS   1/15/82
#data msg3/"xxxxx will not be able to bingo.   "/       #   ABANDONED   1/15/82
 
data zlast/100*0/
 
$DEBUGV if (trace$remove != $no)
$DEBUGV    {
$DEBUGV     call echov ("  REMOVE:")    # jb  E2145   5/25/00
$DEBUGV    }
 
#$% for each view entry
for (i=1; i<= $last$view; i=i+1)
   {
    iair[i] = 0                                                 # 1/15/82
    cair[i] = 0                                                 # 1/15/82
   }
 
#$% zero zap and index
czap  = 0
cgone = 0
Lindx = 0
 
for (unt$pointer$first; unt$pointer$valid; unt$pointer$next) #for each unit
   {
    if (Xunt$inuse$i == 0) next                # skip if unit is not active
 
    #$% extract and save the slot number
    indx = unt$pointer$index                    ## save pnt
    Lindx = indx
 
    #$% extract needed tables from UNT table entry
    unt$Status$i = Xunt$Status$i
    unt$Type$i   = Xunt$Type$i
    unt$Name$c   = Xunt$Name$c
    unt$View$i   = Xunt$View$i
 
    if (Xunt$AirCapable$i == $YES)              iacflg = $yes
    else                                        iacflg = $no
 
    #$% sinking ?
    if (unt$Status$i == $Sinking$code)
       {
        #$% set flag
        iout = $no
       }
    #$% being deleted ?
    else if (unt$Status$i == $BeingDeleted$code)
       {
        #$% set flag
        i = 0
        nlast = $no
 
        for (ipnt = 1; ipnt <= 100; ipnt = ipnt + 1)
           {
            if (i==0 & zlast[ipnt]==0) i = ipnt
 
            if (zlast[ipnt] != indx) next
            nlast = ipnt
            break
           }
 
        if (nlast == $no)
           {
            iout = $no
            if (i != 0) zlast[i] = indx
           }
        else
           {
            iout = $yes
            zlast[nlast] = 0
           }
       }
    else
       {
        iout = $no
        if (iacflg == $no) next                 # save an index to non-sunk
        if (iair[unt$view$i] != 0) next       # air unit (per view)     1/15/82
 
        #$% save unit pointer and name, get next
        iair[unt$view$i] = unt$pointer$index                    # 1/15/82
        cair[unt$view$i] = unt$name$c                           # 1/15/82
 
        next
       }
 
    if (iacflg == $yes & cgone <= unt$slots)    # collect pointers to aircraft
       {                                        # capable units being-deleted
        cgone = cgone+1                         # or sinking
        igone[cgone] = unt$pointer
       }
 
    ####################################
    # Remove from collective group
    #
 
    if (Xunt$ForceName$c != 0)                  # if in a collective group
       {
        call xdetac (unt$pointer,unt2$pointer)
 
        if (unt2$pointer !=0 & Xunt$marshallStatus$i !=$Recovering$Code &
          Xunt2$Status$i !=$Bingo$Code & Xunt2$Status$i !=$Recovery$Code &
          Xunt2$marshallStatus$i !=$Recovering$Code )           #       2/9/84
 
           {    # if new leader assigned, and NOT RECOVERING, notify:   2/8/84
            k = 0                                               #       1/15/82
            call smovhn (xunt2$name$c,$$MaxLit,msg,k)                  #       1/15/82
            call smovv  (" is new leader of group ",msg,k)   #       1/15/82
            call smovhn (xunt2$ForceName$c,$$MaxLit,msg,k)             #       1/15/82
            call send_ (unt$view$i,0,k,msg)          # send msg to view  1/15/82
           }
       }
    if (iout == $no) next                       # if only sinking....
    if (czap < unt$slots)
        {
        czap = czap + 1
        zap[czap] = indx                        # save unit index
        }
    #$% if tracing of removals is wanted
    $DEBUGV if (trace$remove != $no)
    $DEBUGV    {
    $DEBUGV     call echo ($space)
    $DEBUGV     if (unt$name$c != 0) call echohn (unt$name$c,$$MaxLit)
    $DEBUGV     else                 call echoi (indx)
    $DEBUGV    }
 
 
   }
 
unt$used = Lindx * unt$entry
 
########################################
# re-assign LAUNCH/BINGO platforms
# for each entry - reassign any launched aircraft
for (ipnt = 1; ipnt <= cgone; ipnt = ipnt + 1)
   call Reassign_Aircraft (igone[ipnt])
 
#$% prepare to clear entries from RMT, OWN, REP, DAM, RCN, LCL, and
#$% SAT tables and subtables.
if (czap != 0)
   {
    for (k = 1; k <= czap; k = k + 1)
       {
        CALL delete_potential_jammer ( zap[k] )
 
        call remrmt (zap[k])
        call remrcl (zap[k])
        call remown (zap[k])
        call remrep (zap[k])
        call remnam (zap[k])
        call remdam (zap[k])
        call remrcn (zap[k])
        call remlcl (zap[k])
        call remsat (zap[k])
        call remir  (zap[k])             # remove ir detections - clf 9/15/92
        call remaeg (zap[k])  # set unit destroyed in aeg slot, SMM 4/28/95
		call remaegis (zap[k])
        call remboy (zap[k])
        call rempng (zap[k])
        call remaml (zap[k])
        call rembml (zap[k])
 
        unt$pointer$to zap[k]
        if (Xunt$type$i == $air$code) #clr a/c DYN slot
           {
            if(Xunt$Mission$i == $AntiSub$Code)         # jb    9/3/87
               {
                ASW$Pointer$TO (Xunt$ASWindx$i)             # jb    6/90
                if (ASW$Pointer$VALID)                      # jb    6/90
                    ASW$ZERO                                # jb    6/90
               }
           }
 
        unt$PIMindx$i= Xunt$PIMindx$i                   #       12/8/83
        if (unt$PIMindx$i != $NO)                       #       12/8/83
           {
            PIM$Pointer$TO (unt$PIMindx$i)              #       12/8/83
            pim$ZERO                                    #       12/8/83
            PUTpim$Modified$i ($YES)                    #jb     12/16/83
           }
 
        unt$Guideindx$i= Xunt$Guideindx$i
        if (unt$Guideindx$i != $NO)
           {
            call remove_unit_from_guide_chain (unt$pointer)
           }
 
        if (Xunt$HosesAllocatedFlag$i == $YES)    # joa 2/96 (E1467)
        {
            call free_fuel_transfer_equip (unt$pointer)
        }
 
        UNT$ALSPId$I = xUNT$ALSPId$I     # if the unit is still active on ALSP,
        if (UNT$ALSPId$I != 0)           # send a delete message - clk 12/93
          {
           if (xUNT$GhostedUnit$I == $no)
             {
              call ALSP_Send_Del (0, UNT$AlspID$I)
              call ALSP_Update_DR_Table (UNT$Pointer, UNT$ALSPid$I, 0)
             }
          }

	call mark_sunk_position (unt$pointer)
 
        call clear_STA_ref (unt$pointer)    # joa 9/97 (E1864)
 
        call clear_TAT_ref (unt$pointer)
 
        #call delete_ATO_rte (unt$pointer)
 
        call Clear_BTT_Info (UNT$Pointer)   # clk 7/95 (E1419)
 
        #$% zero UNT and POS table entries
 
        call free_nosicid(Xunt$Nosicid$i)
 
        call FREE_DEQ_CHAIN ( UNT$Pointer )             # DEW 4/12/89
 
        if (JTIDS$Capable$Game == $yes &      # clk 12/95 (E1469)
            JTIDS$Interface$State == $yes &   # don't remove the UNT entry
            xUNT$JTIDSsorn$I != 0      &      # until a delete was sent
            xUNT$JTIDSDeleteSent$I == $no)
          next
 
        if (RTU$Interface$State != $RTU_State_Not_Connected)  # clk 5/96 (E1498)
          {                                                   # Don't allow units
           if (xUNT$GhostedDISUnit$I == $no)                  # sent out over DIS
             {                                                # to be deleted until
              if (xUNT$DISDeleteSent$I == $no)                # DIS is notified
                next
             }   # end of if not a DIS ghost
          }   # end of if the RTU is connected
 
        unt$zero
       }
   }
 
call remove_buoys
 
call remove_minefields
 
call remove_sweepareas
 
return
end
 
 
Subroutine remBOY(indx)
 
########################################################
#$%
#$% Purpose:   remBOY zeroes BOY and BAR slots that
#$%            belong to a MISSION ASW a/c that's being
#$%            deleted (or diverted by another order).
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    BOY      BAR
#$%
#$% Date:      SEPTEMBER 1987
#$%
#$% Author:    Joe Bryant
#$%
########################################################
BBcommon
 
Integer indx, BOY$Pointer, BAR$Pointer  # jb E2145  5/25/00
 
for (boy$pointer$first; boy$pointer$ok; boy$pointer$next)
   {
    if (xBOY$OwnerIndx$i != indx) NEXT
 
    BAR$Pointer$TO (BOY$Pointer$Index)
    BAR$zero
    PUTbar$Modified$i (YES)
 
    BOY$zero
   }
 
return
end
 

 
Subroutine rempng(indx)
 
########################################################
#$%
#$% Purpose:   rempng zeroes PNG slots that
#$%            belong to a unit that
#$%            deleted
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    PNG
#$%
#$% Date:      June 21, 2006
#$%
#$% Author:    James O. Allen
#$%
########################################################
BBcommon
 
Integer indx, PNG$Pointer
 
for (png$pointer$first; png$pointer$ok; png$pointer$next)
   {
    if (xpng$UntIndx$i != indx) NEXT
    PNG$zero
   }
 
return
end
 

 
Subroutine remrmt(indx)                                           #smn002
 
########################################################
#$%
#$% Purpose:   REMRMT removes detected track
#$%            slots in the RMT table.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     Zero_RMT_Entry
#$%
#$% Tables:    RMT
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
#$% Modified:  Susan Miller - 7/97 (E1385)
#$%            Set UNT$TestIntercept$I to $no when the
#$%            assigned target is being cleared.
#$%
########################################################
BBcommon
 
integer indx,
    rmt$Pointer,rmt$Detectee$i,rmt$Detector$i,              # jb E2145 5/25/00
    rmt$AcAssignedTo$i, unt$Pointer,                        # jb E2145 5/25/00
    unt2$Pointer, unt2$AttackIndx$i, unt2$AssignedTarget$i  # jb E2145 5/25/00
 
#$% for each detected track entry
for (rmt$pointer$first; rmt$pointer$valid; rmt$pointer$next)
   {
    rmt$Detectee$i  =  xrmt$Detectee$i
 
    #$% if detectee is index
    if (rmt$Detectee$i == indx)
       {
        rmt$Detector$i = Xrmt$Detector$i          ## <RG> 9/20/85
        unt2$Pointer$To  rmt$Detector$i           ## for bogey tote board.
        rmt$AcAssignedTo$i  =  Xrmt$AcAssignedTo$i
        if (rmt$AcAssignedTo$i != 0)              # someone was covering or
          {                                       # taking him, clear out
           unt$pointer$to   rmt$AcAssignedTo$i    # his fields.
           PUTunt$AttackIndx$i     (0)
           PUTunt$AssignedTarget$i (0)
           PUTunt$CoverFlag$i      (0)
           putUNT$TestIntercept$I ($NO)     # SMM 7/97 (E1385)
          }
 
        unt2$AttackIndx$i = Xunt2$AttackIndx$i
        unt2$AssignedTarget$i = Xunt2$AssignedTarget$i
 
        if (unt2$AttackIndx$i == rmt$detectee$i |    ## The detector was
            unt2$AssignedTarget$i == rmt$detectee$i) ## attacking or covering.
          {
           PUTunt2$AttackIndx$i     (0)
           PUTunt2$AssignedTarget$i (0)
           PUTunt2$CoverFlag$i      (0)
           putUNT$TestIntercept$I ($NO)     # SMM 7/97 (E1385)
          }                                       ## end <RG> for here
 
        # before the track has been removed, check the AEG table
        # for this corresponding detection
        UNT$Pointer$To RMT$Detector$I
        call Clear_AEG_slot(UNT$Pointer,  # send detector UNT pointer
                            0,            # send 0 to indicate not LCL track
                            RMT$Pointer)  # send the RMT pointer
        call Zero_RMT_Entry (RMT$Pointer)
        NEXT
       }
 
    rmt$Detector$i = Xrmt$Detector$i
    unt2$Pointer$To  rmt$Detector$i
 
    #$% if detector is index
    if (rmt$Detector$i == indx)
       {
        PUTrmt$detector$i    (0)                        #       6/11/84
        if (unt2$AttackIndx$i == rmt$detectee$i) ## <RG> 9/17/85  He was
          {                                      ## attacking or covering.
           PUTunt2$AttackIndx$i     (0)
           PUTunt2$AssignedTarget$i (0)
           PUTunt2$CoverFlag$i      (0)
           putUNT$TestIntercept$I ($NO)     # SMM 7/97 (E1385)
          }
       }
    #$% if aircraft assigned to, is index
    if (xrmt$AcAssignedTo$i == indx)
       {
        unt2$pointer$To  Xrmt$AcAssignedTo$i  ## <RG> 9/20/85
        PUTrmt$AcAssignedTo$i (0)                       #       6/11/84
        PUTrmt$coverflag$i    (0)      ## <RG>  Reset the assigned aircraft's
        PUTunt2$CoverFlag$i   (0)      ## cover flag to zero,
        PUTunt2$AttackIndx$i  (0)      ## his attack index to zero, and
        PUTunt2$Assignedtarget$i (0)   ## his assigned target to zero.
        putUNT$TestIntercept$I ($NO)    # SMM 7/97 (E1385)
       }
    #$% else if ship assigned to, is index
    if (xrmt$ShipAssignedTo$i == indx)
       {
        unt2$pointer$To  xrmt$ShipAssignedTo$i  ## <RG> 9/20/85
        PUTunt2$AttackIndx$i  (0)      ## his attack index to zero, and
        PUTunt2$Assignedtarget$i (0)   ## his assigned target to zero.
        PUTrmt$ShipAssignedTo$i (0)                     #       6/11/84
       }
   }
 
return
end
 

 
subroutine remrcl (indx)
 
####################################################################
#$%
#$% Purpose:   REMRCL removes detected track slots in the RCL table.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     DEL_RCLslot
#$%
#$% Tables:    RTH     RTH$RCL
#$%
#$% Date:      AUG 87
#$%
#$% Author:    Richard Schauer
#$%
####################################################################
BBcommon
 
Integer indx, irot, ilast, islot, ifound,   # jb E2145 5/25/00
        RTH$Pointer, RTH$RCL$Index          # jb E2145 5/25/00
 
ifound=$NO
for (RTH$Pointer$First; RTH$Pointer$OK; RTH$Pointer$Next)
  {
   if (Xrth$InUse$i == $NO) NEXT
   if (Xrth$NumberRCL$i == 0) NEXT
   irot = RTH$Pointer$Index
   RTH$RCL$Index = Xrth$FirstRCL$i
   ilast = RTH$RCL$Index
   while (RTH$RCL$Index != 0)
     {
      if (Xrth$RCL$UnitIndx$i != indx)
        {
         ilast = RTH$RCL$Index
         RTH$RCL$Index = Xrth$RCL$Next$i
         NEXT
        }
      islot = RTH$RCL$Index
      call del_RCLslot(irot,islot,ilast)
      BREAK
     }
  }
return
end

 
subroutine remown (indx)                                        #smn002
 
########################################################
#$%
#$% Purpose:   REMOWN is called to "zero" an OWN
#$%            (own-force) table slot.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     FREINV     FRECOR
#$%
#$% Tables:    OWN
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
BBcommon
 
integer indx,                                              # jb E2145 5/25/00
    own$pointer, own$FirstInvIndx$i, own$FirstCorIndx$i,   # jb E2145 5/25/00
    own$Guide$i, own$AssignedTarget$i                      # jb E2145 5/25/00
 
#$% for each OWN entry
for (own$pointer$first; own$pointer$ok; own$pointer$next)
   {
    #$% if unit is index
    if (xown$Unit$i == indx)
       {
        #$% call to restore inventory and corners data
        own$FirstInvIndx$i = xown$FirstInvIndx$i
        own$FirstCorIndx$i = xown$FirstCorIndx$i
 
        call FREINV(own$FirstInvIndx$i)
        call FRECOR(own$FirstCorIndx$i)
 
        #$% zero OWN pointer
        own$zero
        PUTown$Modified$i (YES)
       }
    #$% else if OWN guide is index
    else if (xown$Guide$i == indx)
       {
        #$% zero OWN guide and store
        own$Guide$i = 0
        PUTown$Guide$i
       }
    #$% else if assigned target is index
    else if (xown$AssignedTarget$i == indx)
       {
        #$% zero assigned target and store
        own$AssignedTarget$i = 0
        PUTown$AssignedTarget$i
       }
   }
 
return
end
 

 
 
Subroutine remrep (indx)                                        #smn002
 
#################################################################
#$%
#$% Purpose:   REMREP is called to zero a report-queue entry.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     FREPND
#$%
#$% Tables:    REP        PND        LCL
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
#################################################################
BBcommon
 
integer indx,                                                 # jb E2145 5/25/00
    rep$pointer,                                              # jb E2145 5/25/00
    pnd$pointer, pnd$NextIndx$i, pnd$RecordType$i, pnd$lcl$index,  # jb 5/25/00
    lcl$pointer, lcl$Detectee$i                               # jb E2145 5/25/00
 
#$% for each report-queue entry
for (rep$pointer$first; rep$pointer$ok; rep$pointer$next)
   {
    #$% if sender is index
    if (xrep$SenderIndx$i == indx)
       {
        #$% call to restore pending queue
        call FREPND(xrep$FirstPndIndx$i)
 
        #$% zero REP pointer
        rep$zero
       }
    else
       {
        #$% get first pending index
        pnd$NextIndx$i = xrep$FirstPndIndx$i
 
        #$% while next index exists
        while (pnd$NextIndx$i != 0)
           {
            #$% set pending pointer and get next index
            pnd$pointer$to pnd$NextIndx$i
            pnd$NextIndx$i = xpnd$NextIndx$i
 
            #$% get record type
            pnd$RecordType$i = xpnd$RecordType$i
 
            #$% if record type is not detection, get next
            if (pnd$RecordType$i != $detection$code) next
 
            #$% for each LCL entry
            for (pnd$lcl$index=1;pnd$lcl$index$ok;pnd$lcl$index=pnd$lcl$index+1)
               {
                #$% set LCL pointer
                lcl$pointer = pnd$lcl$pointer
 
                #$% if detectee is not index, get next
                if (Xlcl$Detectee$i != indx) next
 
                #$% zero detectee and store
                lcl$Detectee$i = 0
                PUTlcl$Detectee$i
               }
           }
       }
   }
 
return
end
 

 
 
Subroutine remdam(indx)                                         #smn002
 
########################################################
#$%
#$% Purpose:   REMDAM removes all damage unit report
#$%            data (zeroes a DAM table entry).
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    DAM
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
BBcommon
 
Integer indx,  DAM$Pointer      # jb E2145  5/25/00
 
if (indx == 0) return
 
for (dam$pointer$first; dam$pointer$ok; dam$pointer$next)
   {
    if (xdam$UnitIndx$i != indx) next
 
    if (xdam$ReportStatus$i == $ReportReceived$code)
       {
        #$% zero unit index and store
        PUTdam$UnitIndx$i (0)
       }
    else
       {
        dam$zero
        PUTdam$Modified$i (YES)                         #       2/15/83
       }
   }
 
return
end
 

 
 
Subroutine remrcn(indx)
 
########################################################
#$%
#$% Purpose:   REMRCN removes all reconnaisance
#$%            information (zeroes an RCN table
#$%            entry).
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    RCN
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
BBcommon
 
Integer indx,  RCN$Pointer      # jb E2145  5/25/00
 
#$% for each reconn information entry
for (rcn$pointer$first; rcn$pointer$ok; rcn$pointer$next)
   {
    #$% if reconn unit is not index, get next
    if (xrcn$ReconnUnit$i != indx) next
 
    #$% zero reconnUnit index
 
    PUTrcn$ReconnUnit$i (0)
    PUTrcn$Modified$i (YES)                             #       2/15/83
   }
 
return
end
 

 
 
Subroutine remnam(indx)
 
########################################################
#$%
#$% Purpose:   REMNAM removes reference to UNT
#$%            information (zeroes nam$UNTIndx$i)
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    NAM
#$%
#$% Date:      APR 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon
 
Integer indx,  NAM$Pointer      # jb E2145  5/25/00
 
#$% for each Name information entry
for (nam$pointer$first; nam$pointer$ok; nam$pointer$next)
   {
    if (Xnam$Type$i != $name$unit) next                 # not unit
    if (Xnam$UntIndx$i != indx) next                    # not same index
 
    PUTnam$UntIndx$i (YES)
   }
 
return
end
 

 
 
Subroutine remsat (indx)
 
#############################################################
#$%
#$% Purpose:   REMSAT removes all surveillance satellite
#$%            data (zeroes entries in the SPR, STR, SSR,
#$%            and SSD tables.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    SPR        STR        SSR
#$%            SSD
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
#############################################################
BBcommon
 
Integer indx, SSD$pointer,  SSR$Pointer,     # jb E2145  5/25/00
              SPR$Pointer,  STR$Pointer      # jb E2145  5/25/00
 
#$% for each SAT pending task request entry
for (spr$pointer$first; spr$pointer$ok; spr$pointer$next)
   {
    #$% if reportee is index, zero SPR pointer
    if (xspr$Reportee$i == indx) spr$zero
   }
 
#$% for each SAT task request entry
for (str$pointer$first; str$pointer$ok; str$pointer$next)
   {
    #$% if reportee is index, zero STR pointer
    if (xstr$Reportee$i == indx) str$zero
   }
 
#$% for each surveillance satellite report entry
for (ssr$pointer$first; ssr$pointer$ok; ssr$pointer$next)
   {
    #$% if reportee is index, zero SSR pointer
    if (Xssr$DetecteeIndx$i == indx)
       {
        ssr$zero
        PUTssr$Modified$i (YES)                         #       2/15/83
       }
   }
 
#$% for each SAT detection entry
for (ssd$pointer$first; ssd$pointer$ok; ssd$pointer$next)
   {
    #$% if detectee is index, zero SSD pointer
    if (Xssd$DetecteeIndx$i == indx) ssd$zero
   }
 
return
end
 

 
 
Subroutine remlcl(indx)                                            #smn002
 
#############################################################
#$%
#$% Purpose:   REMLCL removes all local detection data.
#$%            (clears an entry in the UNT$LCL subtable)
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT        LCL
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
#############################################################
BBcommon
 
integer indx,lnext,lcurr,lprev,irmall,ISAVE_LCL_NEXTINDX_I, # jb E2145 5/25/00
    unt$Pointer, unt$FirstLclIndx$i,                        # jb E2145 5/25/00
    lcl$Pointer, lcl$NextIndx$i                             # jb E2145 5/25/00
 
#$% for each unit entry
for (unt$pointer$first;unt$pointer$valid;unt$pointer$next)
   {
    #$% if unit pointer is index, set YES; else set NO
    if (unt$pointer$index == indx) irmall = $yes
    else                           irmall = $no
 
    #$% get first LCL index
    unt$FirstLclIndx$i = xunt$FirstLclIndx$i
 
    #$% initialize flags
    lnext = unt$FirstLclIndx$i
    lcurr = 0
    lprev = 0
 
    #$% while next detection exists
    while (lnext != 0)
       {
        #$% save next local detection
        lcurr = lnext
 
        #$% set LCL pointer current
        lcl$pointer$to lcurr
 
        #$% get next index
        lnext = xlcl$NextIndx$i
 
        #$% if remove all is NO and detectee is not index
        if (irmall          == $no &
            xlcl$Detectee$i != indx )
           {
            #$% save current local detection, get next
            lprev = lcurr
            next
           }
 
        #$% clear LCL pointer
        lcl$zero                                # zero vice CLEAR       1/19/82
 
        #$% set next index and store
        lcl$nextindx$i = local$first$free
        putlcl$nextindx$i
 
        local$first$free = lcurr
 
        #$% if no previous entry
        if (lprev == 0)
           {
            #$% set first LCL entry next and store
            unt$firstlclindx$i = lnext
            putunt$firstlclindx$i
           }
        else
           {
            #$% set LCL pointer
            lcl$pointer$to lprev
 
            #$% set next LCL entry and store
            lcl$nextindx$i = lnext
            putlcl$nextindx$i
           }
       }
   }
 
return
end




Subroutine remaegis(indx)

#############################################################
#$%
#$% Purpose:   REMAEGIS removes aegis detections from aegis ships
#$%    
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT        AEG
#$%
#$% Date:      MAR 15
#$%
#$% Author:    Jim Allen
#$%
#############################################################
BBcommon

integer indx,lnext,lcurr
BBDeclare (unt$Pointer, unt$FirstAEGIndex$i, aeg$Pointer, aeg$NextIndex$i) 
BBDeclare (shc$pointer)                          

	unt$pointer$to indx

	if (Xunt$Type$i != $Surface$code) return

	shc$pointer = Xunt$SHCPntr$i
	if (Xshc$AegisType$i == NO) return


    #$% get first LCL index
    unt$FirstAEGIndex$i = xunt$FirstAEGIndex$i

    #$% initialize flags
    lnext = unt$FirstAEGIndex$i
    lcurr = 0

    #$% while next detection exists
    while (lnext != 0)
       {
        #$% save next local detection
        lcurr = lnext

        #$% set LCL pointer current
        aeg$pointer$to lcurr

        #$% get next index
        lnext = xaeg$NextIndex$i

        #$% clear LCL pointer
        aeg$zero                                

        #$% set next index and store
        aeg$nextindex$i = aegis$first$free
        putaeg$nextindex$i

        aegis$first$free = lcurr

       }


return
end

 

 
Subroutine Find_Match (UNT$Pointer,           # in:  Aircraft UNT Pointer
                       UNT$RecoverIndx$I,     # out: New UNT Indx for Recovering
                       UNT$LaunchIndx$I)      # out: New UNT Indx for Launching Platform
                                              #      (since original unit is being cleared)
##############################################################################
#$%
#$% Purpose:   Find_Match will locate a new launch/recover platform for
#$%            the specified aircraft, since it's launching platform is
#$%            being deleted from the game.  The closest platform (to the ac)
#$%            within the same view which is capable of doing air ops and has
#$%            the  specified aircraft type will be selected.  If there are no
#$%            platforms with the specified aircraft type, the closest base
#$%            within the same view which has aircraft will be used.
#$%            Platform which are flagged as sinking or to be deleted are
#$%            not considered acceptable.
#$%
#$% Called By: Reassign_Aircraft
#$%
#$% Calls:     GETRB_M
#$%
#$% Tables:    UNT     ACC
#$%
#$% Date:      April 1995
#$%
#$% Author:    Carol L. Kropp
#$%            Rewrote the routine by this name, since it was not working.
#$%
##############################################################################
BBcommon                                       # Utilize blackboard common
RemoveCommon
 
integer  UNT$Pointer, UNT$RecoverIndx$I, UNT$LaunchIndx$I
 
literal  cstrip8      # literal function used in name extraction
 
integer  ACC$Pointer, ac_view
integer  closest_shore_base_ptr, new_platform_ptr
real     range
real     bearing
integer  int_range, closest_base_range, closest_range
 
integer  UNT2$Pointer, UNT2$Status$I, UNT2$Type$I
literal  UNT2$Name$C
integer  DEQ2$Pointer, DEQ2$Ident$I, DEQ2$Pntr$I
 
 
  ACC$Pointer = xUNT$AccPntr$I
  ac_view = xUNT$View$I
 
  closest_shore_base_ptr = $no
  new_platform_ptr = $no
  closest_base_range = 99999
  closest_range = 99999
 
  for (UNT2$Pointer$First; UNT2$Pointer$Valid; UNT2$Pointer$Next)
    {
     if (ac_view == xUNT2$View$I)
       {
        UNT2$Type$I = xUNT2$Type$I
        if (UNT2$Type$I == $ShoreBase$Code |   # if unit is capable of
            xUNT2$AirCapable$i == $yes)        # launching/recovering ac
          {
           UNT2$Status$I = xUNT2$Status$I
           if (UNT2$Status$I != $Sinking$Code  &
               UNT2$Status$I != $BeingDeleted$code)
             {
              FOR_DEQ2_CHAIN
               {
                DEQ2$Ident$I = xDEQ2$Ident$I
                if (DEQ2$Ident$I == $Aircraft$Code)
                  {
                   call GETRB_M (UNT$Pointer, UNT2$Pointer,
                                 range, bearing)
                   int_range = INT (range + 0.5)
 
                   if (UNT2$Type$I == $ShoreBase$code &
                       int_range < closest_base_range)
                     {
                      closest_shore_base_ptr = UNT2$Pointer
                      closest_base_range = int_range
                     }
 
                   DEQ2$Pntr$I = xDEQ2$Pntr$I
                   if (DEQ2$Pntr$I == ACC$Pointer &   # ac type matches &
                       int_range < closest_range)     # the platform is the closest
                     {
                      new_platform_ptr = UNT2$Pointer
                      closest_range = int_range
                      break    # since the eq entry for this type of ac has
                               # been located, break out of eq loop
                     }   # end of if ac type match and this platform is closer than others
                  }   # end of if eq type is aircraft
               }   # end of loop through the platforms equipment
             }   # end of if the platform is active (not being deleted or sinking)
          }   # end of if the platform is a base or capable of doing air ops
       }   # end of if the platform is from the same view as the ac
    }   # end of loop through the unt table looking for a new home base
 
 
  if (new_platform_ptr != $no)
    UNT2$Pointer = new_platform_ptr
  else if (closest_shore_base_ptr != $no)
    UNT2$Pointer = closest_shore_base_ptr
  else
    UNT2$Pointer = 0
 
  if (UNT2$Pointer$Ok)
    {
     UNT2$Name$C = xUNT2$Name$C
     cair[ac_view] = UNT2$Name$C
     UNT$RecoverIndx$I = UNT2$Pointer$Index
     UNT$LaunchIndx$I  = UNT$RecoverIndx$I
     iair[ac_view]     = UNT$RecoverIndx$I
    }   # end of if a good match was located
  else
    {
     UNT$RecoverIndx$I = 0
     UNT$LaunchIndx$I  = 0
     iair[ac_view]     = 0
    }
 
return
end
 
Subroutine remir(indx)
 
########################################################
#$%
#$% Purpose:   REMIR removes ir detected track
#$%            slots in the IRD table.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:     Zero_IRD_Entry          <wgmdrem.rat>
#$%
#$% Tables:    IRD
#$%
#$% Date:      Sept 1992
#$%
#$% Author:    C. L. Farbstein
#$%
#$% Modified:  Carol Kropp - Sept. 1994 (E1082)
#$%            Replaced IRD$Zero with a call to
#$%            Zero_IRD_Entry, so that the track
#$%            number may be used again w/out duplication.
#$%
########################################################
BBcommon
 
integer  indx
 
integer  IRD$Pointer, IRD$Detector$I, IRD$Target$I
 
#$% for each detected track entry
for (IRD$pointer$first; IRD$pointer$ok; IRD$pointer$next)
  {
  IRD$Detector$i  =  xIRD$Detector$i
  IRD$Target$i  =  xIRD$Target$i
 
  #$% if detector or target is index
  if (IRD$Detector$i == indx | IRD$Target$i == indx)
    {
    #$% zero IRD slot
    call Zero_IRD_Entry (IRD$Pointer)
    }
  }
 
return
end

 
Subroutine Zero_RMT_Entry (RMT$Pointer)
#############################################################################
#
#    Purpose:  Zero_RMT_Entry will clear the track history (TRK) if there is
#              one, obtain the information required to free the RMT track
#              number, call Free_View_Track_Nbr, zero the RMT entry (resetting
#              the modified flag), and set the global variable RMT$Changed.
#              If the detection type is ESM or Passive Sonar, need to
#              check to see if there were multiple entries with that
#              track number.
#
#    Called By:
#
#    Calls:     Free_View_Track_Nbr
#
#    Tables:    RMT    TRK     UNT     VUE
#
#    Date:      15-Sept-1994
#
#    Author:    Carol Kropp
#
#    Modified:  Susan Miller - 6/16/95 (E1420)
#               Removed code that extracts the VUE based upon the detector
#               and replaced it with the use of stored RMT detector view.
#
#    Modified:  Carol Kropp - 1/96 (E1469)
#               If the detection was sent to the LSE, then a delete report
#               needs to be sent, so flag the entry (the routine will be
#               called again for the entry after the report was sent).
#
#############################################################################
BBcommon
 
integer  RMT$Pointer
 
integer  RMT$TRKindx$I, TRK$Pointer
integer  track_number, detection_type
 
integer  unit_index, UNT$Pointer
integer  VUE$Pointer
integer  VUE$FirstRmtIndx$I, VUE$LastRmtIndx$I
integer  duplicated_track_number
integer  RMT2$Pointer, last_rmt_pointer
integer  RMT2$TrackNumber$I, RMT2$DetectionType$I
integer  unit_class
integer  RMT$DetectorView$I
 
  RMT$TRKindx$I = xRMT$TRKindx$I       # clear the track history
  if (RMT$TRKindx$I > 0)               # if there is one
    {
     TRK$Pointer$To (RMT$TRKindx$I)
     TRK$Zero
     putTRK$Modified$I  ($yes)
    }
 
  if (JTIDS$Capable$Game == $yes &      # clk 1/96 (E1469)
      JTIDS$Interface$State == $yes)    # don't remove the RMT entry
    {                                   # until a delete was sent,
     if (xRMT$JTIDSsorn$I != 0      &   # when RESA was reporting it
         xRMT$JTIDSDeleteSent$I == $no)
       {
        putRMT$JTIDSDeletePending$I  ($yes)
        return
       }
    }
 
  track_number = xRMT$TrackNumber$I
 
  if (track_number != 0)
    {
     detection_type = xRMT$DetectionType$I
     duplicated_track_number = $no
 
     # use the RMT detector view rather than setting the UNT pointer
     # since the detector could be zero at this point   SMM 6/15/95 E1420
     RMT$DetectorView$I = xRMT$DetectorView$I
     VUE$Pointer$To  (RMT$DetectorView$I)
 
     # if the ESM or Passive Sonar track number is attached to
     # multiple track entries, then DO NOT free the track number
     if (detection_type == $ESM$Code |
         detection_type == $PassiveSonar$Code)
       {
        VUE$FirstRmtIndx$I = xVUE$FirstRmtIndx$I
        VUE$LastRmtIndx$I = xVUE$LastRmtIndx$I
 
        RMT2$Pointer$To  (VUE$LastRmtIndx$I)
        last_rmt_pointer = RMT2$Pointer
 
        for (RMT2$Pointer$To (VUE$FirstRmtIndx$I); RMT2$Pointer <= last_rmt_pointer;
                                                   RMT2$Pointer$Next)
          {
           if (RMT$Pointer != RMT2$Pointer)
             {
              RMT2$TrackNumber$I = xRMT2$TrackNumber$I
              if (RMT2$TrackNumber$I == track_number)
                {
                 RMT2$DetectionType$I = xRMT2$DetectionType$I
                 if (RMT2$DetectionType$I == detection_type)
                   {
                    duplicated_track_number = $yes
                    break
                   }
                }
             }
          }
       }   # end of if track is ESM or Passive Sonar
 
     if (duplicated_track_number == $no)
       {
        unit_index = xRMT$Detectee$I    # determine the unit type
        UNT$Pointer$To  (unit_index)    # classification of the detected
        unit_class = xUNT$Type$I        # unit
 
        call Free_View_Track_Nbr (VUE$Pointer, detection_type,
                                   unit_class, track_number)
       }   # end of non-duplicated track number
    }   # end of track number is non-zero
 
  RMT$Zero
  putRMT$Modified$I  ($yes)
  RMT$Changed = $yes
 
return
end

 
Subroutine Zero_IRD_Entry (IRD$Pointer)
#############################################################################
#
#    Purpose:  Zero_IRD_Entry will obtain the information required to free
#              the track number, call Free_View_Track_Nbr, and zero the IRD
#              entry (resetting the modified flag).
#
#    Called By:
#
#    Calls:     Free_View_Track_Nbr
#
#    Tables:    IRD     VUE
#
#    Date:      21-Sept-1994
#
#    Author:    Carol Kropp
#
#############################################################################
BBcommon
 
integer  IRD$Pointer
 
integer  track_number
integer  VUE$Pointer
 
track_number = xIRD$TrackSEQ$I
VUE$Pointer$To  (xIRD$View$I)                           # dew 11/99 (E2172)
call Free_View_Track_Nbr (VUE$Pointer, $EOIR$Code, 0, track_number)
 
IRD$Zero
putIRD$Modified$I ($yes)
 
return
end

 
Subroutine Reassign_Aircraft (UNT$Pointer)    # in:  Platform for which aircraft need
                                              #      reassignment, since it is dead
##############################################################################
#$%
#$% Purpose:   Reassign_Aircraft will loop through the UNT table looking
#$%            for aircraft which are assigned to the specified unit and
#$%            reassign then (whenever possible).
#$%
#$% Called By: Reassign_Aircraft
#$%
#$% Calls:     Find_Match
#$%
#$% Tables:    UNT
#$%
#$% Date:      April 1995
#$%
#$% Author:    Carol L. Kropp
#$%            Code removed from Remove_Units and re-written.
#$%
##############################################################################
BBcommon                                       # Utilize blackboard common
RemoveCommon
 
integer  UNT$Pointer    # dead platform with aircraft
 
literal  cstrip8      # literal function used in name extraction
 
integer  indx           # dead platform UNT index
integer  UNT2$Pointer, UNT2$LaunchIndx$I, UNT2$RecoverIndx$I
integer  UNT2$View$I,  UNT2$AMLIndx$I
integer  AML$Pointer
integer  UNT3$Pointer
integer  msg_len
character  msg [ARB]
 
 
  indx = UNT$Pointer$Index
 
  for (UNT2$Pointer$First; UNT2$Pointer$Valid; UNT2$Pointer$Next)
     {
      if (xUNT2$Type$I == $Air$Code)      # located any ac needing reassignment
        {
         if (xUNT2$Status$I != $AcAwaitingLaunch$code)
           {
            UNT2$LaunchIndx$I  = xUNT2$LaunchIndx$I
            UNT2$RecoverIndx$I = xUNT2$RecoverIndx$I
 
            if (UNT2$LaunchIndx$i  == indx |
                UNT2$RecoverIndx$i == indx )
              {
               call Find_Match (UNT2$Pointer, UNT2$RecoverIndx$I, UNT2$LaunchIndx$I)
               putUNT2$LaunchIndx$I
               putUNT2$RecoverIndx$I
               UNT2$AMLIndx$I = xUNT2$AMLIndx$I
               AML$Pointer$To  (UNT2$AMLIndx$I)
               putAML$OwnerIndx$I  (UNT2$LaunchIndx$I)
 
               UNT2$View$I = xUNT2$View$I
               msg_len = 0
               call smovhn (xUNT2$Name$C, $$MaxLit, msg, msg_len)
               if (UNT2$RecoverIndx$I != 0)
                 {
                  UNT3$Pointer$To  (UNT2$RecoverIndx$I)
                  call smovv  (" is now assigned to ", msg, msg_len)
                  call smovhn (xUNT3$Name$C, $$MaxLit, msg, msg_len)
                 }
               else
                  call smovv  (" has no identified recover platform.", msg, msg_len)
               call send_   (UNT2$View$I, 0, msg_len, msg)
              }   # end of if the ac is lanched from or is to bingo to dead unit
           }   # end of if ac is not awaiting launch
        }   # end of it the unit is an ac
     }   # end of loop through the unit table looking for aircraft
 
return
end

Subroutine REMAEG(index)
 
#############################################################
#$%
#$% Purpose:   REMAEG receives the index in the UNT table of the
#$%            unit being deleted, searches the AEG table for the
#$%            matching unit and sets the destroyed flag to yes.
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Tables:    AEG
#$%
#$% Date:      April 28, 1995
#$%
#$% Author:    Susan Miller
#$%
#############################################################
BBcommon
 
integer index, AEG$Pointer
 
 # loop thru the AEG table and flag any other detections of this
 # unit as being destroyed
 for (AEG$Pointer$First; AEG$Pointer$Ok; AEG$Pointer$Next)
    {
     if (xAEG$TargetUNTIndex$I != index) next
     else # match, mark it as being destroyed
        putAEG$TargetUNTDestroyed$I ($yes)
    }
 
return
end

 
Subroutine delete_ATO_rte (UNT$Pointer)
##############################################################################
#$%
#$% Purpose:   If ATO mission, deletes correspoinding rte
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    RTE
#$%
#$% Date:      July 2009
#$%
#$% Author:    James O. Allen
#$%
##############################################################################
BBcommon
 
BBDeclare (UNT$pointer, UNT$ForceName$c, rte$pointer)
 
#{539,ABQ }  DELETE ROUTE (named) <route-name> (order number)
#                          [ ALL | <number> (thru) [ | <number>] ];
 
 
literal args[4], cstrip8, cstrip
integer nord
integer iview
integer nargs
data args/$lex$DELETE$, $lex$ROUTE$, 0, $lex$ALL$/
 
if (Xunt$GhostedUnit$i == $yes) return
if (Xunt$Type$i != $Air$code) return
 
# Delete route
if (Xunt$ATOID$C != 0)
{
    args[3] = Xunt$ForceName$c          # route is same as mission
    nord = 0
    iview = Xunt$view$i
    nargs = 4
    call delRTE (nord, iview, nargs, args)
}
 
return
end

 
Subroutine clear_STA_ref (UNT$Pointer)
##############################################################################
#$%
#$% Purpose:   Clears references in the STA table to unit being deleted
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    STA
#$%
#$% Date:      February 1998 (E1864)
#$%
#$% Author:    James O. Allen
#$%
##############################################################################
BBcommon
 
integer STA$pointer
integer UNT$pointer
integer UNTIndx
 
  UNTIndx = UNT$Pointer$Index
 
  for (STA$Pointer$First; STA$Pointer$Ok; STA$Pointer$Next)
    {
     if (xSTA$PlotPIMIndx$I == UNTIndx)
        putSTA$PlotPIMIndx$I (0)
    }
 
return
end

 
Subroutine clear_TAT_ref (UNT$Pointer)
##############################################################################
#$%
#$% Purpose:   Clears references in the TAT table to unit being deleted
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    TAT
#$%
#$% Date:      June 29, 2006
#$%
#$% Author:    James O. Allen
#$%
##############################################################################
BBcommon
 
integer TAT$pointer
integer UNT$pointer
integer UNTIndx
 
  UNTIndx = UNT$Pointer$Index
 
  for (TAT$Pointer$First; TAT$Pointer$Ok; TAT$Pointer$Next)
    {
     if (xTAT$SourceIndx$I == UNTIndx)
        putTAT$SourceIndx$I (0)
    }
 
return
end

 
Subroutine guidingList (unt3$pointer, guidelist, nlist)
##############################################################################
#$%
#$% Purpose:   list of units guiding on specified unit
#$%
#$% Called By: ospeed, remove_unit_from_guide_chain
#$%
#$% Calls:
#$%
#$% Tables:    UNT
#$%
#$% Date:      January 2005
#$%
#$% Author:    James O. Allen
#$%             staspd
##############################################################################
BBcommon
 
BBDeclare (unt$pointer, UNT3$pointer, unt3$GuideIndx$i)
integer indxunt3, indexGuide, ix, nlist
integer GuideList[ARB]
literal cstrip8
 
# Make list of units guiding on unit
 
indxunt3 = unt3$pointer$index   # Unit being deleted
ix = 0
 
for (unt$pointer$first; unt$pointer$ok; unt$pointer$next)
{
    if (Xunt$InUse$i == $NO) next
 
    if (Xunt$GuideIndx$i == indxunt3)   # Unit guiding on unit being deleted
    {
        ix = ix + 1
        GuideList[ix] = unt$pointer
    }
}
 
nlist = ix
 
return
end

 
Subroutine remove_unit_from_guide_chain (unt3$pointer)
##############################################################################
#$%
#$% Purpose:   unlink unit being deleted from guide chain
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    UNT
#$%
#$% Date:      August 2003
#$%
#$% Author:    James O. Allen
#$%            E2361
##############################################################################
BBcommon
 
BBDeclare (unt$pointer, unt2$pointer, UNT3$pointer, unt3$GuideIndx$i)
integer indxunt3, indexGuide, ix, i, k
integer GuideList[unt$slots]
character       msg[ARB]
literal cstrip8
 
# Make list of units guiding on unit being deleted
call guidingList (unt3$pointer, guidelist, ix)
 
 
# If unit being deleted has guide, assign guide to guiding units
unt3$GuideIndx$i = Xunt3$GuideIndx$i
if (unt3$GuideIndx$i != $NO)
{
    for (i = 1; i <= ix; i = i + 1)
    {
        unt$pointer = GuideList[i]      # staspd joa 2/05
        PUTunt$GuideIndx$i (unt3$GuideIndx$i)
        PUTunt$GuideBearing$f (Xunt3$GuideBearing$f)
        PUTunt$GuideRange$f (Xunt3$GuideRange$f)
        PUTunt$GuideTrue$i (Xunt3$GuideTrue$i)
    }
    if (ix > 0)
    {
        k = 0
        unt2$pointer$to unt3$GuideIndx$i
        call smovv  ("Units guiding on ",msg,k)
        call smovhn (xunt3$name$c,$$MaxLit,msg,k)
        call smovv  (" are now guiding on its guide  ",msg,k)
        call smovhn (xunt2$Name$c,$$MaxLit,msg,k)
        call send_ (Xunt2$view$i,0,k,msg)          # send msg to view
    }
}
 
# If unit has no guide, make first unit on guiding list the new guide
else
{
    unt$pointer = GuideList[1]              # new guide
    PUTunt$GuideIndx$i (0)
    PUTunt$GuideBearing$f (0.0)
    PUTunt$GuideRange$f (0.0)
    PUTunt$GuideTrue$i (1)
    PUTunt$OrderedLatitude$f (Xunt3$OrderedLatitude$f)
    PUTunt$OrderedLongitude$f (Xunt3$OrderedLongitude$f)
    PUTunt$RangeToNext$f (Xunt3$RangeToNext$f)
 
    indexGuide = unt$pointer$index
    for (i = 2; i <= ix; i = i + 1)
    {
        unt$pointer = GuideList[i]
        PUTunt$GuideIndx$i (indexGuide)
    }
 
    k = 0
    unt$pointer = GuideList[1]              # new guide
    call smovhn (xunt$name$c,$$MaxLit,msg,k)
    call smovv  (" replacing guide ",msg,k)
    call smovhn (xunt3$Name$c,$$MaxLit,msg,k)
    call send_ (Xunt2$view$i,0,k,msg)          # send msg to view
}
 
return
end
 

 
subroutine remove_buoys
##############################################################################
#$%
#$% Purpose:   Remove expired buoys and chaff clouds
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    BOY  BAR
#$%
#$% Date:      July 10, 2006
#$%
#$% Author:    James O. Allen
##############################################################################
BBcommon
BBdeclare (boy$pointer, boy$type$i, boy$KillTime$f, boy$IndxCHF$i)
BBdeclare (bar$pointer)
BBdeclare (chf$pointer)
 
integer ix
real    LIFE, maxmin
 
for (boy$pointer$first;boy$pointer$ok;boy$pointer$next)
{
    boy$Type$i = Xboy$Type$i
    boy$KillTime$f = xboy$KillTime$f
 
    if (boy$type$i == $CHAFF$code)
    {
        #$% get buoy pointer index number
        ix = boy$pointer$index
 
        #$% set barrier pointer to boy pointer index
        bar$pointer$to ix
 
        #$% compute chaff life in terms of game minutes
        boy$IndxCHF$i = Xboy$IndxCHF$i
        LIFE = chaff$life
        if ( boy$IndxCHF$i > 0 & boy$IndxCHF$i <= chf$SLOTS )
        {
            CHF$Pointer$TO (boy$IndxCHF$i)
            if (xCHF$RBOCflag$i == $NO)
                LIFE = xCHF$Life$i
        }
        maxmin = game$time - LIFE
 
        #$% get game minute chaff becomes active and later is inactive
 
        #$% If the barrier is too old, or fell to the ground
        if ( boy$KillTime$f < maxmin |   #if entire barrier too
            Xboy$ChaffAlt$i <= 1 ) # old, or has sunk to ground
        {
            #$% delete buoy and barrier data from blackboard and get next entry
            boy$zero
            bar$zero
            PUTbar$Modified$i ($YES)
            next
        }
    }
    else if (boy$Type$i == $Commbuoy$code)
    {
        if(boy$KillTime$f <= game$time ) # buoys expired
        {
            BOY$ZERO                                    #delete entry
        }
    }
    else if (boy$Type$i == $ActiveBarrier$code |
             boy$Type$i == $PassiveBarrier$code)
    {
        if(boy$KillTime$f <= game$time ) # buoys expired
        {
            BAR$POINTER$TO BOY$POINTER$INDEX            #delete corresponding
            BAR$ZERO                                    #   barrier plot entry
            PUTbar$Modified$i ($YES)
            BOY$ZERO                                    #delete entry
        }
    }
    else if (boy$Type$i == $TowedArray$code |
             boy$Type$i == $VDS$code)
    {
        if(boy$KillTime$f <= game$time ) # buoys expired
        {
            BOY$ZERO                                    #delete entry
        }
    }
}
 
return
end

 
subroutine remove_minefields
##############################################################################
#$%
#$% Purpose:   Remove minefields
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    MFD
#$%
#$% Date:      Oct. 25, 2006
#$%
#$% Author:    James O. Allen
##############################################################################
BBcommon
BBdeclare (mfd$pointer)
integer indx
 
indx = 0
for (mfd$pointer$first;mfd$pointer$ok;mfd$pointer$next)
{
    if (Xmfd$InUse$i != 0)
    {
        if (Xmfd$Status$i == $BeingDeleted$code)  mfd$zero
        else                                      indx = mfd$pointer$index
    }
}
 
mfd$used = indx * mfd$entry
 
return
end

 
subroutine remove_sweepareas
##############################################################################
#$%
#$% Purpose:   Remove sweepareas marked for deletion
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    SWP
#$%
#$% Date:      March 29, 2007
#$%
#$% Author:    James O. Allen
##############################################################################
BBcommon
BBdeclare (swp$pointer, swp$status$i)
integer indx
 
indx = 0
for (swp$pointer$first;swp$pointer$ok;swp$pointer$next)
{
    if (Xswp$InUse$i != 0)
    {
        if (Xswp$Status$i == $BeingDeleted$code)  swp$zero
        else                                      indx = swp$pointer$index
    }
}
 
swp$used = indx * swp$entry
 
 
return
end
 

 
Subroutine remaml(indx)
 
########################################################
#$%
#$% Purpose:   REMAML removes ownership of aircraft owned by unit being deleted
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:
#$%
#$% Tables:    AML
#$%
#$% Date:      Aug 07
#$%
#$% Author:    James O. Allen
#$%
########################################################
BBcommon
 
integer indx
 
BBdeclare (unt$pointer, aml$pointer)
 
for (aml$pointer$first; still_ok(aml) ; aml$pointer$next)
{
    #$% if not owner index, get next entry
    if (Xaml$OwnerIndx$i != indx) next
 
    putaml$OwnerIndx$i (0)
    putaml$Status$i ($Destroyed$Code)
    putaml$NextIndx$i (0)
}
 
return
end
 

 
Subroutine rembml(indx)
 
########################################################
#$%
#$% Purpose:   REMBML removes ownership of boats owned by unit being deleted
#$%
#$% Called By: REMOVE_UNITS
#$%
#$% Calls:
#$%
#$% Tables:    BML
#$%
#$% Date:      Aug 07
#$%
#$% Author:    James O. Allen
#$%
########################################################
BBcommon
 
integer indx
 
BBdeclare (unt$pointer, bml$pointer)
 
for (bml$pointer$first; still_ok(bml) ; bml$pointer$next)
{
    #$% if not owner index, get next entry
    if (Xbml$OwnerIndx$i != indx) next
 
    putbml$OwnerIndx$i (0)
    putbml$Status$i ($Destroyed$Code)
    putbml$NextBML$i (0)
}
 
return
end


 
Subroutine mark_sunk_position (unt$pointer)
##############################################################################
#$%
#$% Purpose:   Plot track at position of sunken unit
#$%            by entering PLOT TRACK order for tech control(station 1)
#$%
#$% Called By: remove_units
#$%
#$% Calls:
#$%
#$% Tables:    UNT
#$%
#$% Date:      November 2015
#$%
#$% Author:    James O. Allen
#$%
##############################################################################
BBcommon
 
BBDeclare (unt$pointer, unt$SuperType$i, unt$Type$i, mrk$pointer, mrk$Type$i)
literal cstrip8
literal label
real    RadToDMS
integer ista, kk, igot, iside
integer game_dtg

#{912,ABQ       }      PLOT TRACK [ENEMY | FRIENDLY | NEUTRAL | UNKNOWN]
#                                [AIR | SUBMARINE | SURFACE]
#                                  (at position) <latitude> <longitude>
#                                  (and name it) <track-name> [|<track-name-b>];

if (Xunt$GhostedUnit$i == $YES) return		# Skip ghosted units

unt$Type$i = Xunt$Type$i
unt$SuperType$i = Xunt$SuperType$i

if (!(unt$SuperType$i == $Surface$SuperCode     |
	  unt$SuperType$i == $SmallBoat$SuperCode   |
	  unt$SuperType$i == $Submarine$SuperCode)) return

#$% get free mrk slot
for (MRK$POINTER$FIRST;MRK$POINTER$VALID;MRK$POINTER$NEXT)
{
	#$% if mark label (track name) not found, next
    if (XMRK$LABEL1$C != 0) next 

    #$% if mark pointer is in last position
    if(MRK$POINTER > MRK$LAST)
    {
    	#$% reset last pointer position
        MRK$LAST$TO MRK$POINTER + MRK$ENTRY -1
    }

    IGOT = $YES                     #indicate found

    break                           
}                                
#$% if label (track name) not found, break
if (IGOT == $NO) return 

call whside (Xunt$View$i, iside)
if      (iside == $Neutral$code) mrk$Type$i = $Neutral$code
else if (iside == $Blue$code)    mrk$Type$i = $Friendly$code
else if (iside == $Orange$code)  mrk$Type$i = $Enemy$code
PUTMRK$TYPE$I

PUTMRK$CAT$I( unt$type$i )                      
putMRK$Station$I( 1 )
PUTMRK$LATITUDE$F( Xunt$TrueLatitude$F ) 
PUTMRK$LONGITUDE$F( Xunt$TrueLongitude$F ) 
PUTMRK$LABEL1$C( Xunt$Name$c )

# 2nd label is SK<dtg>
kk = 0 
call smovv ("SK", label, kk)
call smoviz(game_dtg(game$time), 6, label, kk)
PUTMRK$LABEL2$C( label )    

return
end
