#$%  Modifications:
#$%
#$%     Jim Allen - VTS Modifications
#$%     Switched from engamgent record definition of an array to HSENG.DEF
#$%     to be consistance with other history record definitions.
#$%
#$%     Carol Kropp - 7/95 (E1419)
#$%     Added Basic Encyclopedia, Target Identification, and the Attacker and
#$%     Target Characteristic Names.  (Added to all writelist and typelist lines.)
#$%
#$%     Susan Miller - 11/97 (E1580)
#$%     Changed format statements so that the new time format would be displayed
#$%     properly.  Changed 9008, 9009, 9011, 9012, 9018, 9019, 9020
#$%     Added declaration of engdtgstr in subroutines dphit, dpmiss
#$%
#$%     Susan Miller - 5/98 (E1985)
#$%     Changed the format statements that displayed the ph from f4.1 to f5.1 in
#$%     order to have the room to display 100.0 if needed and some of the tabs.
#$%     format statements - 9012, 9009, 9018
 
include "macros.inc"
include "ascii.inc"
include "hseng.inc"
include "hstim.inc"
include "time.inc"
 
undefine (read)
undefine (write)
undefine (err)
undefine (close)
define   (three00, 300)
define   (five00, 500)
define   (one000, 1000)
define   (two000, 2000)
define   (ten000,10000)
 
define   ($no  ,0)    # clk 8/96 (E1709) - Added for use in determining
define   ($yes ,1)    # if a unit has been reported as sinking.
 
#@1 - Minutes since simulation start time (real)
#@2 - Resultant DTG string
define   (dtgstr_macro,{irc = MIN_TO_DTG(_                # Convert time-step to DTG
                                        xTIM$StartDTG$F,  # dtg of sim time 0; 5 element array
                                                          #  1-year,2-mon,3-day,4-hr,5-min
                                        @1,               # minutes to be added to InitDtg:in:float:min
                                        EngDTG)           # Resultant dtg ddhhmm:real array: out
                       lenengdtgstr = 0
                       call SmovNoyrMoDatetime (_         # DTG array to string
                                        EngDTG,           # DTG:in:array[5]:real
                                        @2,               # DTG(dd-hhmm:ss):out:array:character
                                        lenengdtgstr)     # Current position in str:inout:integer
                      })
 
# For writelist* macros:  @1 is the file unit number
#                         @2 is the format statement label
define   (writelist,    {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1, @2) engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                        xENG$Target$C,
                        Xeng$TAlspId$i, Eng_Result_Code_2_Text(xENG$Result$I),
                        xENG$ResultPh$F,
                        xENG$Range$F, xENG$MbuRange$F,
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
define   (writelisth,   {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1, @2) engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                        xENG$Target$C,
                        Xeng$TAlspId$i, Eng_Result_Code_2_Text(xENG$Result$I), xENG$Range$F,
                        xENG$MbuRange$F,
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
define   (writelistg,   {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1, @2) engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                        xENG$Target$C,
                        Xeng$TAlspId$i, xENG$GunEpu$I, xENG$ResultPh$F,
                        xENG$Range$F, xENG$MbuRange$F,
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
define   (writelistgm,  {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1, @2) engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                        xENG$Target$C,
                        Xeng$TAlspId$i, 'M', xENG$ResultPh$F, xENG$Range$F,
                        xENG$MbuRange$F,
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 4/9/93 - Fired at a ghosted unit (they determine hit/miss)
define   (writelistf,   {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1,@2)   engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                        xENG$Target$C, Xeng$TAlspId$i,
                        'F', '[', xENG$NumberFired$I, ']', xENG$Range$F, xENG$MbuRange$F,
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 5/20/93 - Unsuccessful launch
define   (writelistu,   {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1,@2)   engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                        'U', '(', xENG$ResultPh$F, ')',
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 2/94 (E1124) - Run time termination (torpedo/missile)
define   (writelistt,   {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1, @2) engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C,
                        xENG$Target$C, Xeng$TAlspId$i,
                        Eng_Result_Code_2_Text(xENG$Result$I),
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 6/95 (E1419) - Position engagements with BE/TIN information
# Note:  @3 is the latitude of the target position in dd-mm-ssh format
# Note:  @4 is the longitude of the target position in ddd-mm-ssh format
define   (writelistp,   {
                        dtgstr_macro (xENG$Time$F, engdtgstr)
                        write(@1, @2) engdtgstr, xENG$Platform$C,
                        Xeng$SAlspId$i, xENG$Weapon$C,
                        @3, @4, 'F', '(', xENG$NumberHit$I, '/', xENG$NumberFired$I, ')',
                        xENG$Range$F, xENG$MbuRange$F,
                        xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                        xENG$PlatformType$C, xENG$TargetType$C })
 
# For typelist* macros:  @1 is the format statement label
define   (typelist,   {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                       xENG$Target$C, Xeng$TAlspId$i,
                       Eng_Result_Code_2_Text(xENG$Result$I), xENG$ResultPh$F,
                       xENG$Range$F, xENG$MbuRange$F,
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
define   (typelisth,   {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                       xENG$Target$C, Xeng$TAlspId$i,
                       Eng_Result_Code_2_Text(xENG$Result$I), xENG$Range$F,
                       xENG$MbuRange$F,
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
define   (typelistg,   {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                       xENG$Target$C, Xeng$TAlspId$i,
                       xENG$GunEpu$I, xENG$ResultPh$F, xENG$Range$F, xENG$MbuRange$F,
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
define   (typelistgm,  {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                       xENG$Target$C, Xeng$TAlspId$i,
                       'M', xENG$ResultPh$F, xENG$Range$F, xENG$MbuRange$F,
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 4/9/93 - Fired at a ghosted unit (they determine hit/miss)
define   (typelistf,  {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                       xENG$Target$C, Xeng$TAlspId$i,
                       'F', '[', xENG$NumberFired$I, ']', xENG$Range$F, xENG$MbuRange$F,
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 5/20/93 - Unsuccessful launch
define   (typelistu,  {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C, xENG$Track$C,
                       'U', '(', xENG$ResultPh$F, ')',
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 2/94 (E1124) - Run time termination (torpedo/missile)
define   (typelistt,  {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C,
                       xENG$Target$C, Xeng$TAlspId$i,
                       Eng_Result_Code_2_Text(xENG$Result$I),
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
# clk 6/95 (E1419) - Position engagements with BE/TIN information
# Note:  @2 is the latitude of the target position in dd-mm-ssh format
# Note:  @3 is the longitude of the target position in ddd-mm-ssh format
define   (typelistp,  {
                       dtgstr_macro (xENG$Time$F, engdtgstr)
                       print @1,       engdtgstr, xENG$Platform$C,
                       Xeng$SAlspId$i, xENG$Weapon$C,
                       @2, @3, 'F', '(', xENG$NumberHit$I, '/', xENG$NumberFired$I, ')',
                       xENG$Range$F, xENG$MbuRange$F,
                       xENG$BEPart1$C, xENG$BEPart2$C, xENG$TIN$C,
                       xENG$PlatformType$C, xENG$TargetType$C })
 
define (timewindowCommon,
    real lower_time
    real upper_time
    common/Common_timewindow/ lower_time, upper_time
)
 
define   (engagecommon, {
          literal      inbuf, command
          literal      weaponray[ten000], targetray[ten000],
                       platray[ten000]
          real         firstengage, lastengage
          real         rangeray[two000]
          integer      numberofrecord, numberofplat, numberoftarget,
                       numberofweapon, numberofrange,  maxrange,
                       minrange, inlength
          integer      statiray[9999]    # reh 8/30/89
          logical      printfileopen, printer
          character    line[132], filename[40], printname[20]
          character    cresult[1]
 
          vaxcharacter*40 v_filename
          equivalence (filename, v_filename)
 
          vaxcharacter*20 v_printname
          equivalence (printname, v_printname)
 
	common/e_common/ inbuf, command, weaponray, targetray,
         	platray, firstengage, lastengage, rangeray,
	   	numberofrecord, numberofplat, numberoftarget,
          	numberofweapon, numberofrange,  maxrange,
		minrange, inlength, statiray, printfileopen,
		printer, line, filename, printname, cresult
	})
 
define   (formcommon,   {
9008  format(1x, 'TIME   ', t14, 'PLATFORM', t23, 'ALSPID', t31, 'WEAPON',
             t40, 'TRACK',
             t49, 'TARGET', t58, 'ALSPID', t66, 'RESULT', t73, 'RANGE',
             t81, 'MBURANGE',
             t91, 'BE NUMBER', t108, 'TIN', t117, 'PLAT TYPE',
             t126, 'TG TYPE' /)
 
# DPMISS, ECHO_RECORD
# Gun miss
# E2248 jhm 12/01   moved outcome from t56 to t47 and pH from f5.1 to f4.0
9009  format(1x, 10a1, 'Z', t14, a8, t23, i8, t32, a8, t41, a8, t50, a8, t59,
             i8, t68,  a1, '(', F4.0, ')',
             t75, F7.1, t83, F7.1, t93, a8, a8, t110, a8, t119, a8, t128, a6)
 
# DPHIT, ECHO_RECORD
# Standard hit
9011  format(1x, 10a1,'Z', t14, a8, t23, i8, t32, a8, t41, a8, t50, a8, t59,
             i8, t68, a1,
             t75, F7.1, t83, F7.1, t93, a8, a8, t110, a8, t119, a8, t128, a6)
 
# DPHIT, ECHO_RECORD
# Gun engagement resulting in a hit
9012  format(1x, 10a1, 'Z', t14, a8, t23, i8, t32, a8, t41, a8, t50, a8, t88,
             i8, t68, i4, '(', F5.1, ')',
             t75, F7.1, t83, F7.1, t93, a8, a8, t110, a8, t119, a8, t128, a6)
 
# DPHIT, ECHO_RECORD
# clk 6/95 (E1419) - Position engagements with BE/TIN information
9020  format (1x, 10a1, 'Z', t14, a8, t23, i8, t32, a8, t41, a9,
              t51, a10, t62, # E2141
              a1, a1, i2, a1, i2, a1,
              t73, F7.1, t81, F7.1, t91, a8, a8, t108, a8, t117, a8, t126, a7)
})
 
 
# Note:  The following construct is totally out of bounds.....
# The ENGAGECOMMON and FORCECOMMON macros are not declaring COMMON
# But instead are mearly defining variables.....
# This whole thing requires re-work                 DEW 4-Feb-92
 
define  (allcommon,  {
                      eng$record$definition
                      timcommon
      common /everything/ eng$record })
 
 
 

      program panaen
 
	implicit none
#
#       This program analizes the results of engagement after a war-game
#       by using a disk file created during the game.
#       The user is requested to enter the name of the file to be
#       analyzed, an attempt will be made to open the specified file.
#       Error message will displayed and program terminates if failed
#       to open the file otherwise the user is requested to enter
#       commands one at time.
#       Command (HELP) can be entered at any time for a brief descrip_
#       tion of all other commands.
#       The program will loop until (BYE) is entered.
 
 
 
allcommon
engagecommon
formcommon
timewindowcommon
 
9002  format(1x, '*** Engagement file open error ***')
9005  format(1x, '* Unable to match command, enter again *')
9006  format(1x, '***** Bad input, enter command *****')
9007  format(1x, 'Enter (BYE/PRINT/ALL/PLATFORM/WEAPON/TARGET)',/,
             1x, '      (SUMMARY/RANGE/HIT/MISS/POSITION)         : ',$)
 
define (numberofcommands,11)  # Assign the number of commands to be defined.
define (exitexit, { call echor
                    print 9002
                    call echor
                    call exit    })
 
      LitCharEquiv (commands, numberofcommands)
      data   commandsC/'BYE     ','PRINT   ','ALL     ',
                      'PLATFORM','WEAPON  ','TARGET  ','SUMMARY ',
                      'RANGE   ','HIT     ','MISS    ','POSITION'/
 
literal dummy
integer ierr, i, j, ii, icommand, i_switch_1
integer icount
integer irc, delete_file_version
literal cstrip8
logical foundit
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 

 
      ##### initialization #####
      printer = .true.
      maxrange = 0
      minrange = 10000
      call initr4        # save this line
#      call echoff
      call cinit                       # save this line
 
	  irc = delete_file_version(printname)
      open(unit         =16,
#           organization ='sequential',
           file         =v_printname,
           form         ='formatted',
           status       ='new',
           recl         =134*4,
           err          =0030)
      goto 0031
0030  continue ### we should never be here
0031  printfileopen = .true.
 
      open(unit         =88,
#           organization ='sequential',
#           blocksize    =512,
           file         =v_filename,
#           recordtype   ='fixed',
           form         ='unformatted',
           access       ='sequential',
           status       ='old',
           iostat       = ierr,
           err          =0050)
      goto 0051
 
0050  print 9002
      exitexit
0051
      ##### Get low and high time frame
      icount = 0
      repeat
        { read(88, end=8150, err=8150) eng$record
          icount = icount + 1
          if (icount == 1)
             firstengage    = Xeng$time$f
          next
8150      rewind(88)
          lastengage = Xeng$Time$f
          break
        }
      lower_time = firstengage
      upper_time = lastengage
print 9007
     call timewindow
print 9007

      numberofplat   = 0  # jhm ufl07
      numberofweapon = 0
      numberoftarget = 0
      numberofrange  = 0
      firstengage    = eng$time$f
      foundit        = .false.
      repeat
        { 
		  read(88, end=9150, err=9150) eng$record
          eng$Time$f = Xeng$Time$f
          while (eng$Time$f < lower_time | eng$Time$f > upper_time)
		  {
		  	read(88, end=9150, err=9150) eng$record
          	eng$Time$f = Xeng$Time$f
		  }

          do i=1, numberofplat
            { if (Xeng$Platform$c == platray[i]) {foundit = .true.; break}
            }
          if (foundit != .true.)
            { numberofplat = numberofplat + 1
              if(numberofplat >= 1)platray[numberofplat] = Xeng$Platform$c  #ufl07 jhm
            }
          else {foundit = .false.}
 
          do i=1, numberofweapon
            { if (Xeng$Weapon$c == weaponray[i]) {foundit = .true.; break}
            }
          if (foundit != .true.)
            { numberofweapon = numberofweapon + 1
              weaponray[numberofweapon] = Xeng$Weapon$c
            }
          else {foundit = .false.}
 
          if (Xeng$Result$i != eng$P$code)
            {
             do i=1, numberoftarget
               { if (Xeng$Target$c == targetray[i]) {foundit = .true.; break}
               }
             if (foundit != .true.)
               { numberoftarget = numberoftarget + 1
                 targetray[numberoftarget] = Xeng$target$c
               }
             else {foundit = .false.}
            }
 
 
          do i=1, numberofrange
            { if ( Xeng$Range$f == rangeray[i]) {foundit = .true.; break}
            }
          if (foundit != .true.)
            { if(numberofrange < 2000) #max of rangeray array
               {
                numberofrange = numberofrange + 1
                rangeray[numberofrange] = Xeng$Range$f
               }
             else {foundit = .false.; break}  #end of max rangeray test #jhm ufl07
            }
          else {foundit = .false.}

          next
9150      rewind(88)
          lastengage = Xeng$Time$f
          break
        }
      ##### sort range array
      do i=1, numberofrange - 1
        { for (j=numberofrange; j>i; j=j-1)
             { if (rangeray[i] <= rangeray[j]) {next}
               else { ii = rangeray[i]
                      rangeray[i] = rangeray[j]
                      rangeray[j] = ii
                    }
             }
        }
print 9007
      ##### sort weapon array
      call arraysort(numberofweapon, weaponray)
 
      ##### sort target array
      call arraysort(numberoftarget, targetray)
 
      ##### sort platform array
      call arraysort(numberofplat, platray)
      ##### build statistics array, save engagement time ...etc
      do i=1, 9999
        { read(88, end=9200, err=9200) eng$Record
          eng$Time$f = Xeng$Time$f
          if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
          statiray[i] = Xeng$Range$f
          if (Xeng$Range$f < minrange) {minrange = Xeng$Range$f}
          else if (Xeng$Range$f > maxrange) {maxrange = Xeng$Range$f}
          numberofrecord = i
          next
9200      rewind(88)
          break
        }
 
 
      repeat           #********* MAIN INPUT LOOP ******************
 
        { call echor
          print 9007
          call getinput
          if (line[1] == -1) {call echor; call exit}
          if (line[1] == $SPACE) {next}
 
          # Search Command table for a match with the input
          icommand = -1
          do i=1,numberofcommands
            { command = $BLANKLIT
              dummy = commands[i]         # shame
              j = 0
              call smovh(dummy, inlength, command, j)
              if (inbuf == command)       # Match ?
                { icommand = i
                  break
                }
             }
 
           if (icommand == -1)             # invalid command (no match)
             { call echor
               print 9005
               next                        # loop for more input
             }
 
          switch (icommand)
            { case  1: call byebye      ###### bye
              case  2: call printop     ###### print
              case  3: call allall      ###### all
              case  4: call dpplatform  ###### platform
              case  5: call dweapon     ###### weapon
              case  6: call dtarget     ###### target
              case  7: call stati       ###### kill summary
              case  8: call drange      ###### range
              case  9: call dphit       ###### hit
              case 10: call dpmiss      ###### miss
              case 11: call dposit      ###### position
              default: print 9006
             }
         }
 
      end
 

 
      subroutine arraysort(arraylen, arrayname)
      implicit none
      integer arraylen
      literal arrayname[five00], dummy
      character ii[8], jj[8]
      integer i, j,len
      logical larger
 
      do i=1, arraylen - 1
        { for (j=arraylen; j>i; j=j-1)
             { len = 0
               call smovh(arrayname[j], 8, jj, len)
               len = 0
               call smovh(arrayname[i], 8, ii, len)
               if (larger(ii, jj))
                 { dummy = arrayname[i]
                   arrayname[i] = arrayname[j]
                   arrayname[j] = dummy
                 }
             }
        }
 
      end
 

 
      subroutine getinput
 
      ################################################################
      ##%
      ##% purpose: Get number of Bytes input, convert to upper case
      ##%          move to inbuf or return -1 if anything wrong.
      ##%
      ##% called by: many subroutines
      ##%
      ##% calls:   GETLNH, SMOV
      ##%
      ###############################################################
 
      implicit none
      engagecommon
 
      character cupper
      integer i, j, irc, c_rtty_reset
 
	  call tty_init						# Terminal in raw mode
      call getlnh(line, 80)
	  irc = c_rtty_reset()				# Restore terminal characteristics
      if (line[1] == -1 | line[1] == $SPACE) {return}
      do i = 1, 80
        {if (line[i] >= $lita & line[i] <= $litz)
           line[i] = cupper(line[i])
         if (line[i] == $SPACE) { inlength = i-1; break}
        }
 
      inbuf = $BLANKLIT
      if (inlength <= 8)
        { j = 0
          call smovh(line, inlength, inbuf, j)
        }
      return
 
      end  ######################## getinput #########################
 
 

      subroutine printop
 
      ################################################################
      ##%
      ##% purpose: printop sets/resets print option
      ##%
      ##% Called by: Post_Analysis_Engagement(PAENGA)
      ##%
      ##% Calls:   None
      ##%
      ################################################################
 
      implicit none
      engagecommon
 
0201  format(1x, '***** Enable to open print file *****')
0202  format(1x, '***** Print file option on *****')
0203  format(1x, '***** Print file option off *****')
0204  format(1x, ' Enter (ON /OFF) : ', $)
 
      repeat
        {
         call echor
         print 0204
 
         call getinput
         if (line[1] == -1) {call echor; call exit}
         if (line[1] == $SPACE) {return}
 
         if (inbuf == 'ON')
           {printer = .true.
            if (printfileopen != .true.)
              { open(unit         =16,
                     file         = v_printname,
                     form         ='formatted',
                     status       ='new',
                     recl         =134,
                     err          =0250)
                goto 0251
0250            continue ### we should never be here
0251            printfileopen = .true.
               }
            call echor
            print 0202
            break
           }
        else if (inbuf == 'OFF')
               { printer = .false.
                 call echor
                 print 0203
                 break
               }
             else next
       }
 
      return
 
      end ##### of printer option ###########################
 

      subroutine timewindow  ################# time ###################
 
      #################################################################
      ##%
      ##% purpose: timewindow displays the first and the last
      ##%          engagement time of the game and then allow the
      ##%          user to set a time-intervai in and between.
      ##% called by: PAENGA
      ##%
      ##% calls:   getinput
      ##%
      ################################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowCommon
 
9010  format(1x, 'First engagement time = ', 17a1, 5x, /,
             1x, 'Last  engagement time = ', 17a1)
0401  format('1', 'Low time = ', 17a1, 5x,
                 'high time = ', 17a1)
0402  format(1x, 'Enter Return for entire time or low  time (yyyymmddhhmmss) : ', $)
0403  format(1x, 'Enter high time (yyyymmddhhmmss) : ', $)
0404  format(1x, '***** Lower limit too small, enter again *****')
0405  format(1x, '***** Upper limit too large, enter again *****')
0406  format(1x, a8)
 
integer min_to_dtg, dtg_to_min
real FirstEngageDtg[5]
real LastEngageDtg[5]
real Low_Dtg[5], High_Dtg[5]
real ltime,utime, ttime
character FirstEngageDtgStr[17]
character LastEngageDtgStr[17]
character LowDtgStr[17], HighDtgStr[17]
integer   irc, len
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
 
    irc = MIN_TO_DTG (_                      # Convert time-step to DTG
                      xTIM$StartDtg$F,       # dtg of sim time 0; 5 element array
                                             #  1-year,2-mon,3-day,4-hr,5-min
                      firstengage,           # minutes to be added to InitDtg:in:float:min
                      FirstEngageDtg)        # Resultant dtg ddhhmm:real array: out
 
    len = 0
    call smovdatetime (_                     # DTG array to string
                       FirstEngageDtg,       # DTG:in:array[5]:real
                       FirstEngageDtgStr,    # DTG(02JAN1994 1231:45):out:array:character
                       len)                  # Current position in str:inout:integer
 
    irc = MIN_TO_DTG (_                      # Convert time-step to DTG
                      xTIM$StartDtg$F,       # dtg of sim time 0; 5 element array
                                             #  1-year,2-mon,3-day,4-hr,5-min
                      lastengage,            # minutes to be added to InitDtg:in:float:min
                      LastEngageDtg)         # Resultant dtg ddhhmm:real array: out
 
    len = 0
    call smovdatetime (_                     # DTG array to string
                       LastEngageDtg,        # DTG:in:array[5]:real
                       LastEngageDtgStr,     # DTG(02JAN1994 1231:45):out:array:character
                       len)                  # Current position in str:inout:integer
 
 
         ##### display engagement time
         print 9010, FirstEngageDtgStr, LastEngageDtgStr
 
         ##### get lower time
         print 0402
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1)  {call echor; call exit}
         call parse_dtg (line, low_dtg)     # yyyymmddhhmmss
         irc = DTG_TO_MIN(_                 # Difference in minutes between two dtgs
                      xTIM$StartDtg$F,      # dtg of time 0; 5 element array
                                            #  1-year,2-mon,3-day,4-hr,5-min
                      low_dtg,              # Input dtg:in:int dtg array
                      ltime)                # resultant Inputdtg - InitDtg
 
         if (ltime < firstengage) {ltime = firstengage}
 
         ##### get upper time limit
         print 0403
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1 ) {call echor; call exit}
 
         call parse_dtg (line, High_dtg)     # yyyymmddhhmmss
         irc = DTG_TO_MIN(_                 # Difference in minutes between two dtgs
                      xTIM$StartDtg$F,      # dtg of time 0; 5 element array
                                            #  1-year,2-mon,3-day,4-hr,5-min
                      high_dtg,             # Input dtg:in:int dtg array
                      utime)                # resultant Inputdtg - InitDtg
 
         if (utime > lastengage) {utime = lastengage}
 
         call echor
         len = 0
         call smovdatetime (_             # DTG array to string
                            Low_dtg,      # DTG:in:array[5]:real
                            LowDtgStr,    # DTG(02JAN1994 1231:45):out:array:character
                            len)          # Current position in str:inout:integer
 
         len = 0
         call smovdatetime (_             # DTG array to string
                            High_dtg,     # DTG:in:array[5]:real
                            HighDtgStr,   # DTG(02JAN1994 1231:45):out:array:character
                            len)          # Current position in str:inout:integer
         print 0401, LowDtgStr, HighDtgStr
         if (printer == .true.) {write(16,0401) LowDtgStr, HighDtgStr}
 
         lower_time = ltime
         upper_time = utime
      return
 
      end  #################### timewindow ##########################
 

      subroutine dpplatform
 
      #################################################################
      ##%
      ##% display all platform type in the file.
      ##% one at a time can be selected for display.
      ##%
      ################################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
0501  format(1x, '***** Platform Names *****', /)
0502  format(1x, 8a9)
0503  format(1x, '** unable to find -', a8, '- in the table **')
0504  format(1x, ' Enter platform name : ', $)
0505  format('1', '** All engagements initiated from ', a8, ' **',/)
0506  format(1x, 'Total number of platforms :',i3 /)
      literal cstrip8
      integer i
      logical platfound
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
 
      repeat
        {
         ##### display platform type
         call echor
         print 0501
         print 0506, (numberofplat)
         print 0502, (platray[i], i=1,numberofplat)
 
         ##### get platform name
         call echor
         print 0504
         platfound = .false.
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1)  {call echor; call exit}
 
         ##### verify name
         do i=1, numberofplat
           { if (inbuf == platray[i]) {platfound = .true.}
           }
 
         if (platfound != .true.)
           { call echor
             print 0503, inbuf
             break
           }
 
         ##### display engagements of selected platform
         call echor
         print 0505, inbuf
         if (printer == .true.) {write(16, 0505) inbuf}
         print 9008
         if (printer == .true.) {write(16, 9008)}
 
         repeat
           { read(88, end=0555, err=0555) eng$Record
             eng$Time$f = Xeng$Time$f
             if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
             if (inbuf == Xeng$Platform$c)
               call echo_record
             next
0555         rewind(88)
             break
           }
        }
 
      return
 
      end ################ display platform #######################
 
 

      subroutine dweapon
 
      #################################################################
      ##%
      ##% display all weapon type in the file.
      ##% one at a time can be selected for display.
      ##%
      ################################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
 
0601  format(1x, '***** Weapon type *****', /)
0602  format(1x, 8a9)
0603  format(1x, '** unable to find -', a8, '- in the table **')
0604  format(1x, ' Enter weapon name : ', $)
0605  format('1', '** All engagements that used ', a8, ' **', /)
      integer i
      logical weaponfound
      literal cstrip8
 
      repeat
        {
         ##### display weapon type
         call echor
         print 0601
         print 0602, (weaponray[i], i=1,numberofweapon)
 
         ##### get weapon name
         call echor
         print 0604
         weaponfound = .false.
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1)  {call echor; call exit}
 
         ##### verify name
         do i=1, numberofweapon
           { if (inbuf == weaponray[i]) {weaponfound = .true.; break}
           }
         if (weaponfound != .true.)
           { call echor
             print 0603, inbuf
             next
           }
 
         ##### display engagements of selected weapon
         call echor
         print 0605, inbuf
         if (printer == .true.) {write(16, 0605) inbuf}
         print 9008
         if (printer == .true.) {write(16, 9008)}
 
         repeat
           { read(88, end=0655, err=0655) eng$Record
             eng$Time$f = Xeng$Time$f
             if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
             if (inbuf == Xeng$Weapon$c)
               call echo_record
             next
0655         rewind(88)
             break
           }
        }
 
      return
 
      end ################ display weapon #######################
 
 

      subroutine dtarget
 
      #################################################################
      ##%
      ##% display all target type in the file.
      ##% one at a time can be selected for display.
      ##%
      ################################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
0701  format(1x, '***** Target Names *****', /)
0702  format(1x, 8a9)
0703  format(1x, '** unable to find -', a8, '- in the table **')
0704  format(1x, ' Enter target name : ', $)
0705  format('1', '** All engagements aimed at ', a8, ' **', /)
0706  format(1x, 'Total number of targets :',i3 /)
      integer i
      logical targetfound
      literal cstrip8
 
      repeat
        {
         ##### display target type
         call echor
         print 0701
         print 0706, (numberoftarget)
         print 0702, (targetray[i], i=1,numberoftarget)
 
         ##### get target name
         call echor
         print 0704
         targetfound = .false.
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1)  {call echor; call exit}
 
         ##### verify name
         do i=1, numberoftarget
           { if (inbuf == targetray[i]) {targetfound = .true.; break}
           }
         if (targetfound != .true.)
           { call echor
             print 0703, inbuf
             next
           }
 
         ##### display engagements of selected target
         call echor
         print 0705, inbuf
         if (printer == .true.) {write(16, 0705) inbuf}
         print 9008
         if (printer == .true.) {write(16, 9008)}
 
         repeat
           { read(88, end=0755, err=0755) eng$Record
             eng$Time$f = Xeng$Time$f
             if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
             if (inbuf == Xeng$Target$c)
               call echo_record
             next
0755         rewind(88)
             break
           }
        }
 
      return
 
      end ################ display target #######################
 
 

      subroutine drange
 
      #################################################################
      ##%
      ##% display all range type in the file.
      ##% one at a time can be selected for display.
      ##%
      ################################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
0901  format('1', 'Selected low range = ', i6, 5x,
                 'high range = ',  i6, /)
0902  format(1x, '***** range table *****', /)
0903  format(1x, 10f8.1)
0904  format(1x, 'Enter low  range : ', $)
0905  format(1x, 'Enter high range : ', $)
0906  format(1x, '***** Lower range too small *****')
0907  format(1x, '***** Upper range too large *****')
      integer lrange, hrange, ctoi
      integer i, len
 
      repeat
        {
         ##### display ranges
         call echor
         print 0902
         print 0903, (rangeray[i], i=1, numberofrange)
 
         ##### get lower range
         call echor
         print 0904
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1)  {call echor; call exit}
         len = 1
         lrange = ctoi(inbuf, len)
 
         ##### get high range
         call echor
         print 0905
         call getinput
         if (line[1] == -99) {return}
         if (line[1] == -1)  {call echor; call exit}
         len = 1
         hrange = ctoi(inbuf, len)
 
         ##### display engagements of selected range
         call echor
         print 0901, lrange, hrange
         if (printer == .true.) {write(16, 0901) lrange, hrange}
         print 9008
         if (printer == .true.) {write(16, 9008)}
 
         repeat
           { read(88, end=0955, err=0955) eng$Record
             eng$Time$f = Xeng$Time$f
             if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
             if (Xeng$Range$f >= lrange & Xeng$Range$f <= hrange)
               call echo_record
             next
0955         rewind(88)
             break
           }
        }
 
      return
 
      end ################ display range #######################
 

 
      subroutine dphit
 
      ##########################################################
      ##%
      ##% display all engagements that scored hit
      ##%
      ##########################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
VaxCharacter*9   v_lat                   # vax character representation of lat for write statments
VaxCharacter*10  v_lon                   # vax character representation of lon for write statments
integer          str_len
character        engdtgstr[10]
integer		 irc, min_to_dtg, lenengdtgstr
literal		 cstrip8, eng_result_code_2_text
real 		 engdtg[5]
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
 
1001  format('1', '***** Engagements that scored hit *****', /)
 
      call echor
      print 1001
      print 9008
      if (printer == .true.) {write(16, 1001); write(16,9008)}
 
      repeat
        { read(88, end=1055, err=1055) eng$Record
          eng$Time$f = Xeng$Time$f
          if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
          ENG$Result$I = xENG$Result$I
          if (ENG$Result$I == ENG$P$Code)      # All engagements against positions
            {                                  # hit the ground, so include them
             v_lat = ""
             v_lon = ""
             str_len = 0
             call vmovlls (xENG$RecLat$F, "NS", v_lat, str_len)
             str_len = 0
             call vmovlls (xENG$RecLon$F, "EW", v_lon, str_len)
 
             typelistp (9020, v_lat, v_lon)
             if (printer == .true.)
               { writelistp (16, 9020,v_lat, v_lon) }
            }
          if (ENG$Result$I == ENG$Gun$Code)
            {
             if(xENG$GunEpu$I != 0)
               {
                typelistg (9012)
                if (printer == .true.)
                  { writelistg (16, 9012) }
               }
            }
          else if (ENG$Result$I == ENG$Hit$Code |
                   eng$Result$i == ENG$HitAmplification$code)
            {
             typelisth (9011)
             if (printer == .true.)
               { writelisth (16, 9011) }
            }
          next
1055      rewind(88)
          break
         }
 
      return
      end
 

 
      subroutine dpmiss
 
      ##########################################################
      ##%
      ##% display all engagements that scored miss
      ##%
      ##########################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
      character  engdtgstr[10]
      integer	 irc, min_to_dtg, lenengdtgstr
      literal	 cstrip8, eng_result_code_2_text
      real 	 engdtg[5]
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
 
1003  format('1', '***** Engagements that missed *****', /)
 
      call echor
      print 1003
      print 9008
      if (printer == .true.) {write(16, 1003); write(16, 9008)}
 
      repeat
        { read(88, end=1055, err=1055) eng$Record
          eng$Time$f = Xeng$Time$f
          if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
          ENG$Result$I = xENG$Result$I
          if (ENG$Result$I == ENG$Gun$Code)
            {
             if(xENG$GunEpu$I == 0)
               {
                typelistgm (9009)
                if (printer == .true.)
                  { writelistgm (16, 9009) }
               }
            }
          else if (ENG$Result$I == ENG$Miss$Code)
            {
             typelist (9009)
             if (printer == .true.)
               { writelist(16, 9009) }
            }
          next
1055      rewind(88)
          break
        }
 
      return
      end
 

 
 
      subroutine allall
 
      ############################################################
      ##%
      ##% At this time, this subroutine prints the Enaggement
      ##% file as is. As the name (ALL) implies, a lot more
      ##% should be done.
      ##% Wait until there is more time
      ##%
      ############################################################
      implicit none
      allcommon
      formcommon
      engagecommon
      timewindowcommon
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
0300  format('1', '** A list of all engagements **', //)
 
      if (printfileopen != .true.)
        { open(unit         =16,
               file         =v_printname,
               form         ='formatted',
               recl         =134,
               status       ='unknown')
          printfileopen = .true.
        }
 
      ##### output engagement file, first the header
      write(16, 0300)
      print 0300
      write(16, 9008)
      print 9008
 
      ##### then the whole thing
      repeat
        { read(88, end=0350, err=0350) eng$Record
          eng$Time$f = Xeng$Time$f
          if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
          call echo_record
          next
0350      rewind(88)
          break
        }
      return
      end
 

 
      subroutine byebye
 
      #################################################################
      ##%
      ##% Close disk files, spool print file and exit
      ##%
      #################################################################
 
      implicit none
      engagecommon
 
      character dumdum[20]
      integer   i, j
 
0100  format(1x, 'Print file name is')
0101  format(1x, 20a1)
      close(88)
      j = 0
      do i=1, 20 {call smovv (" ", dumdum, j)}
      j = 0
      i = 0
      repeat { i = i+1;
               if (printname[i] == EOS) break
               call smovh(printname[i], 1, dumdum, j)
             }
      if (printfileopen == .true.)
        { close(16)                 #  do spool print file here later
          print 0100
          print 0101, dumdum
        }
 
      stop "Have a nice day!"
 
      end
 

 
subroutine stati
############################################################
#$%
#$% Purpose:   STATI generates a summary listing of all
#$%            aircraft, boats and ships lost.
#$%
#$% Called By: PANAEN
#$%
#$% Calls:     Sinking_or_Splash_Entry
#$%            Inport_or_Ondeck_Entry
#$%            Aircraft_structured_name
#$%
#$% Date:      March 1992
#$%
#$% Author:    Carol L. Kropp
#$%
#$% Modified:  Carol Kropp - 8/95 (E1449)
#$%            Many non-aircraft platforms are being named with
#$%            the standard callsign format (LLNNN), so no check
#$%            is made to the Aircraft_Structured_Name function
#$%            when populating the hit_record array.  Also the
#$%            hit_record array is only populated once now (not
#$%            both times through the file).
#$%            Also added check to make sure that the array bound
#$%            is not past (would crash otherwise).
#$%
#$% Modified:  John McCormick - 8/99 (E2146)
#$%            Aircraft Summary section of the Engagement Log
#$%            coming out with errors on A/C destroyed and weapons
#$%            used. Defined separate arrays and examined the hit
#$%            records in separate loop from ships.
#$%
#$%
############################################################
implicit none
allcommon
engagecommon
timewindowcommon
integer lp
 
define   (array_size, 99999)
 
integer  launches    # # of cruise missile/torpedo launches recorded
integer  hits        # # of hits recorded in hit_record
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
 
literal  launchray [array_size, 2]  # launching platform/track record array
                                    # [n,1] << platform  [n,2] << target
literal  hit_record [array_size, 4] # record of hit array
                                    # [n,1] << target    [n,2] << platform
                                    # [n,3] << weapon    [n,4] << already_killed
literal  launchray2 [array_size, 2]  # launching platform/track record array
                                     # (E2146) jhm 9/99
                                    # [n,1] << platform  [n,2] << target
literal  hit_record2 [array_size, 4] # record of hit array
                                     # (E2146) jhm 9/99
                                    # [n,1] << target    [n,2] << platform
                                    # [n,3] << weapon    [n,4] << already_killed
 
integer  last_hit_entry    # hit_record index to last hit recorded
integer  last_ac_hit       # hit_record index to last aircraft hit recorded
integer  i                 # loop control variable
integer  Aircraft_structured_name    # integer function
integer min_to_dtg, lenengdtgstr
real    engdtg[5]
character engdtgstr[10]
literal cstrip8, output_platform, output_target, output_weapon, taskid
integer irc
 
#          1         2         3         4         5         6         7
# 1234567890123456789012345678901234567890123456789012345678901234567890
#                                          FIRING       DAMAGED             0802
#  TIME         TARGET       WEAPON       PLATFORM     BASE/SHIP
#  xxxxxxxxxx   xxxxxxxx     xxxxxxxx     xxxxxxxx                          0804
#  xxxxxxxxxx   xxxxxxxx     xxxxxxxx     xxxxxxxx     xxxxxxxx INPORT      0805
#  xxxxxxxxxx   xxxxxxxx     xxxxxxxx     xxxxxxxx     xxxxxxxx ONDECK      0806
 
0800  format ('1', ' ***** SUMMARY OF BOATS, SHIPS AND SUBMARINES LOST *****', /)
0801  format ('1',//, ' ***** SUMMARY OF AIRCRAFT LOST *****', /)
0802  format (30x, 'FIRING', 29x,'TARGET',3X, 'TARGET', 6X, 'DAMAGED', /,
              1x, ' TIME', 5x, 'TARGET', 4x, 'WEAPON', 2x, 'PLATFORM', 4x, 'LAT / LONG',4X, 'TASKID',4X,' TYPE ', 3X,'ALSPID',5X, 'BASE/SHIP', /)
0803  format (1x, 10a1, 5x, a8, 5x, a8, 5x, a16, 5x, a8)
0805  format (1x,130a1)
 
  print 0800
  print 0802
  if (printer == .true.)
    {
     write (16, 0800)
     write (16, 0802)
    }
 
  launches = 0
  hits = 0
 
  #$% Process launch entries for platform/track information.
  #$% Process SINKING and INPORT entries for lost boats & ships.
  #$% Process record of hit entries for target/weapon/platform information.
  repeat
    {
     read(88, end=2000, err=2000) eng$Record   # read the engagement file record
     eng$Time$f = Xeng$Time$f
     if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
 
     ENG$Platform$C = xENG$Platform$C
     ENG$Result$I = xENG$Result$I
 
     if (ENG$Platform$C == 'SPLASH' |              # if a lost aircraft record
         ENG$Platform$C == 'ONDECK')
       next
     else if (ENG$Result$I == ENG$Launch$Code)       # if a record of a launch
       {
        launches = launches + 1
        launchray [launches, 1] = ENG$Platform$C     # unit name of the launching platform
        launchray [launches, 2] = xENG$Track$C       # unit name of the cruise missile or torpedo
       }
     else if (ENG$Platform$C == 'SINKING')          # if a sunk ship record
       call Sinking_or_Splash_Entry (launchray, launches,
                                     hit_record, hits,
                                     printer, last_hit_entry)
     else if (ENG$Platform$C == 'INPORT')          # if a lost boat record
       call Inport_or_Ondeck_Entry (launchray, launches,
                                    hit_record,
                                    printer, last_hit_entry)
     else if (ENG$Result$I == ENG$Hit$Code |         # a hit (including guns) on a target
              eng$Result$i == ENG$HitAmplification$code |
              ENG$Result$I == ENG$Gun$Code)
       {
        #$% Locate the target in the hit_record
        for (i = 1; i <= hits; i = i + 1)
          if (hit_record [i,1] == xENG$Target$C)
            break           # record found
 
        if (i > hits) # if the target wasn't found add to end of list
          {
           if (i <= array_size)    # if there is room in the array
             {
              hits = i
             }
           else                    # there isn't any room
             {
              call echov  ("There is no room to record the")
              call echov  (" hit entry for ")
              call echohn (xENG$Target$C, $$MaxLit)
              call echov  (".")
              call echor
              call echov  ("The attacker was ")
              call echohn (ENG$Platform$C, $$MaxLit)
              call echov  (" using ")
              call echohn (xENG$Weapon$C, $$MaxLit)
              call echov  (".")
              call echor
              next
             }   # end of if there was no room to add it
          }   # end of if target wasn't in list
 
        #$% Store the information into hit_record
        hit_record [i,1] = xENG$Target$C
        hit_record [i,2] =  ENG$Platform$C
        hit_record [i,3] = xENG$Weapon$C
 
        last_hit_entry = i
 
        if (Aircraft_structured_name (hit_record [i,1]) == $YES)
          last_ac_hit = i
 
       }
 
     next
2000 rewind(88)
     break
    }
 
  print 0801
  print 0802
  if (printer == .true.)
    {
     write (16, 0801)
     write (16, 0802)
    }
 
  #$% Read the engagement history file listing all aircraft lost
  #$% (E2146) JHM 8/99  - Start of new code
  hits = 0
  repeat
    {
     read(88, end=2001, err=2001) eng$Record
     eng$Time$f = Xeng$Time$f
     if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
 
     ENG$Platform$C = xENG$Platform$C
     ENG$Result$I = xENG$Result$I
     dtgstr_macro (xENG$Time$F, engdtgstr)
 
     if (ENG$Platform$C == 'INPORT' |
         ENG$Platform$C == 'SINKING')
       next
     if (ENG$Platform$C == 'SPLASH')        # if a crashed airplane record
       {
        if (xENG$Weapon$C == 'ENGAGE')      # if crashed due to an engagement
          call Sinking_or_Splash_Entry (launchray2, launches,
                                        hit_record2, hits,
                                        printer, last_ac_hit)
        else   # system failure, no fuel, take off or landing crash
 
         {
          output_target = xENG$Target$C    # target name form engrec
          output_weapon =   'NOFUEL'
          output_platform = $BLANKLIT
 
          for(i=1; i <= 131; i = i+1)                  #jhm ufl05 clear out line
             line[i] = $SPACE
          #$% Output to the summary listing - no previous information needed
          lp=0
          call smovh(engdtgstr,10,line,lp)
          call smovv(" ",line,lp)
          call smovh(output_target,8,line,lp)
          call smovv(" ",line,lp)
          call smovh(output_weapon,8,line,lp)
          call smovv(" ",line,lp)
          call smovh(output_platform,8,line,lp)
          call smovv(" ",line,lp)
          call smovll(xENG$RecLAT$F,"NS",line,lp)   #JHM UFL02 9/02
          call smovv(" ",line,lp)
          call smovll(xENG$RecLon$F,"EW",line,lp)
          call smovv("  ",line,lp)
          call fgtask(xENG$HierarchyId$I,taskid)            #
          call smovh(taskid,8,line,lp)                #JHM UFL02 9/02
          call smovv("  ",line,lp)
          call smovh(xENG$TargetType$C,8,line,lp)
          call smovv(" ",line,lp)
          call smovi(xENG$TalspId$I,line,lp)
          line[130] = EOS
 
          print 0805, line
          if (printer == .true.)
            write (16,0805) line
         }
       }
     else if (ENG$Platform$C == 'ONDECK')    # if a lost aircraft record
       call Inport_or_Ondeck_Entry (launchray2, launches,
                                    hit_record2,
                                    printer, last_hit_entry)
 
 
     else if (ENG$Result$I == ENG$Launch$Code)       # if a record of a launch
       {
        launches = launches + 1
        launchray2 [launches, 1] = ENG$Platform$C     # unit name of the launching platform
        launchray2 [launches, 2] = xENG$Track$C       # unit name of the cruise missile or torpedo
       }
 
     else if (ENG$Platform$C == 'INPORT')          # if a lost boat record
       call Inport_or_Ondeck_Entry (launchray2, launches,
                                    hit_record2,
                                    printer, last_hit_entry)
 
     else if (ENG$Result$I == ENG$Hit$Code |         # a hit (including guns) on a target
              eng$Result$i == ENG$HitAmplification$code |
              ENG$Result$I == ENG$Gun$Code)
       {
        #$% Locate the target in the hit_record
        for (i = 1; i <= hits; i = i + 1)
          if (hit_record2 [i,1] == xENG$Target$C)
            break           # record found
 
        if (i > hits) # if the target wasn't found add to end of list
          {
           if (i <= array_size)    # if there is room in the array
             {
              hits = i
             }
           else                    # there isn't any room
             {
              call echov  ("There is no room to record the")
              call echov  (" hit entry for ")
              call echohn (xENG$Target$C, $$MaxLit)
              call echov  (".")
              call echor
              call echov  ("The attacker was ")
              call echohn (ENG$Platform$C, $$MaxLit)
              call echov  (" using ")
              call echohn (xENG$Weapon$C, $$MaxLit)
              call echov  (".")
              call echor
              next
             }   # end of if there was no room to add it
          }   # end of if target wasn't in list
 
        #$% Store the information into hit_record
        hit_record2 [i,1] = xENG$Target$C
        hit_record2 [i,2] =  ENG$Platform$C
        hit_record2 [i,3] = xENG$Weapon$C
 
        last_hit_entry = i
 
        if (Aircraft_structured_name (hit_record2 [i,1]) == $YES)
          last_ac_hit = i
       }
 
 
 
     next
2001 rewind(88)
     break
    }
#$% (E2146) JHM 8/99  - End of new code block
 
  return
  end

 
 
subroutine Sinking_or_Splash_Entry (_
              launch_array,   # launch platform/track record
              num_launches,   # number of launches recorded
              hit_record,     # record of hits
              num_hits,       # number of hits recorded
              file_flag,      # flag if to write to file
              last_hit)       # index into hit_record for last hit unit
############################################################
#$%
#$% Purpose:   Sinking_or_Splash_Entry process the current
#$%            engrec when the entry in the engagement
#$%            log is for a sunk ship/boat or a splashed
#$%            aircraft.
#$%
#$% Called By: STATI
#$%
#$% Calls:     Determine_platform
#$%
#$% Date:      March 1992
#$%
#$% Author:    Carol L. Kropp
#$%
#$% Modified:  Carol Kropp - 8/96 (E1709)
#$%            Fix the keeping track of if an entry has been
#$%            reported, was reporting some units multiple times.
#$%
############################################################
implicit none
allcommon
literal  launch_array [array_size, 2], hit_record [array_size, 4]
integer  num_launches, num_hits, last_hit, file_flag
 
literal  output_target
literal  output_weapon, output_platform
integer  i     # loop control variable
integer  previously_reported   # clk 8/96 (E1709)
integer  min_to_dtg, lenengdtgstr
integer  lcomp_v
real engdtg[5], ENG$RecLAT$F, ENG$RecLon$F
character engdtgstr[10], line[132]   #JHM 9/02 UFL02
literal cstrip8, taskid
integer irc, lp, ENG$HierarchyId$I, ENG$TargetType$C, ENG$TalspId$I  #jhm ufl05
 
0804  format (1x, 10a1, 5x, a8, 5x, a8, 5x, a8, 5x, a20)
0805  format (1x,130a1)
 
 
  for(i=1; i <= 131; i = i+1) #jhm ufl05 clear out line
        line[i] = $SPACE
 
 
  output_target = xENG$Target$C    # target name form engrec
 
  #$% Locate the record or hit for the target
  for (i = num_hits; i >= 1; i = i - 1)
    {
     if (hit_record [i,1] == Xeng$Target$c)
       break
    }
 
  previously_reported = $no
  if (i == 0)    # if i = 0 then the record of hit was not found
    {
     if (xENG$Platform$C == 'SPLASH')    # if an aircraft, use last_hit (flight leader)
       i = last_hit
     else
       {
        output_weapon = 'UNKNOWN'
        output_platform = 'UNKNOWN'
       }
    }
  else           # the record of hit was located for the target
    {
     if (lcomp_v(hit_record [i,4], 'TRUE') != 0)    # if the target was not already killed
       {
        output_weapon = hit_record [i,3]
        call Determine_platform (hit_record [i,2],
                                 launch_array, num_launches, output_platform)
       }
     else
       {
        previously_reported = $yes   # clk 8/96 (E1709) keep track that it was previously reported
       }
    }
 
  if (previously_reported == $no)    # clk 8/96 (E1709) only report new ones
    {
 
 
     dtgstr_macro (xENG$Time$F, engdtgstr)
 
        lp=0                                      #JHM UFL02 9/02
        call smovh(engdtgstr,10,line,lp)
        call smovv(" ",line,lp)
        call smovh(output_target,8,line,lp)
        call smovv(" ",line,lp)
        call smovh(hit_record[i,3],8,line,lp)   #JHM 7/03 OUTPUT_WEAPON
        call smovv(" ",line,lp)
        call smovh(hit_record[i,2],8,line,lp)
        call smovv(" ",line,lp)
        call smovll(xENG$RecLAT$F,"NS",line,lp)   #JHM UFL02 9/02
        call smovv(" ",line,lp)
        call smovll(xENG$RecLon$F,"EW",line,lp)
        call smovv("  ",line,lp)
        call fgtask(xENG$HierarchyId$I,taskid)            #
        call smovh(taskid,8,line,lp)                #JHM UFL02 9/02
        call smovv("  ",line,lp)
        call smovh(xENG$TargetType$C,8,line,lp)
        call smovv(" ",line,lp)
        call smovi(xENG$TalspId$I,line,lp)
        line[130] = EOS
 
     #$% Output the information to the summary listing
        print 0805, line
     if (file_flag == .true.)
        write(16,0805) line
     #$% If engrec was a SINKING entry, update the index to the last known
     #$% non-aircraft record of hit and then update the record of hit as killed
    }   # end of if the platform was not previously reported
 
return
end

 
 
subroutine Inport_or_Ondeck_Entry (_
             launch_array,   # input - launch platform/track record
             num_launches,   # input - number of launches recorded
             hit_record,     # input - record of hits
             file_flag,      # input - flag if yo write to file
             last_hit)       # input - hit_record index to last non-aircraft hit
############################################################
#$%
#$% Purpose:   Inport_or_Ondeck_Entry process the current
#$%            engrec when the entry in the engagement
#$%            log is for a boat or aircraft lost due to
#$%            damaged sustained by the owning base or ship.
#$%
#$% Called By: STATI
#$%
#$% Calls:     Determine_platform
#$%
#$% Date:      March 1992
#$%
#$% Author:    Carol L. Kropp
#$%
############################################################
implicit none
allcommon
 
literal  launch_array [array_size, 2], hit_record [array_size, 4]
integer  num_launches, last_hit, file_flag
 
literal  output_target
literal  output_weapon, output_platform, output_base
integer min_to_dtg, lenengdtgstr
real engdtg[5]
character engdtgstr[10], line[132]   # JHM UFL02 9/02
literal cstrip8, taskid
integer irc, lp, i                     #
 
0805  format (1x, 10a1, 5x, a8, 5x, a8, 5x, a8, 5x, a8, ' INPORT')
0806  format (1x, 10a1, 5x, a8, 5x, a8, 5x, a8, 5x, a8, ' ONDECK')
0811  format (1x, 130a1)
 
for(i=1; i <= 131; i = i+1)                  #jhm ufl05 clear out line
        line[i] = $SPACE
 
 
  output_target = xENG$Target$C    # target name form engrec
 
  #$% Use the information for the last non-aircraft record of hit
  output_weapon = hit_record [last_hit,3]
  output_base = hit_record [last_hit,1]
  call Determine_platform (hit_record [last_hit,2],
                           launch_array, num_launches, output_platform)
 
  dtgstr_macro (xENG$Time$F, engdtgstr)
        lp=0                                      #JHM UFL02 9/02
        call smovh(engdtgstr,10,line,lp)
        call smovv(" ",line,lp)
        call smovh(output_target,8,line,lp)
        call smovv(" ",line,lp)
        call smovh(output_weapon,8,line,lp)
        call smovv(" ",line,lp)
        if(output_platform == 0)
            output_platform = 'UNKNOWN'
        call smovh(output_platform,8,line,lp)
        call smovv(" ",line,lp)
        call smovll(xENG$RecLAT$F,"NS",line,lp)   #JHM UFL02 9/02
        call smovv(" ",line,lp)
        call smovll(xENG$RecLon$F,"EW",line,lp)
        call smovv("  ",line,lp)
        call fgtask(xENG$HierarchyId$I,taskid)            #
        call smovh(taskid,8,line,lp)                #JHM UFL02 9/02
        call smovv("  ",line,lp)
        call smovh(xENG$TargetType$C,8,line,lp)
        call smovv(" ",line,lp)
        call smovi(xENG$TalspId$I,line,lp)
        call smovv("  ",line,lp)
        call smovh(output_base,8,line,lp)
        call smovv(" ",line,lp)
 
  #$% Output the information to the summary listing
  if (xENG$Platform$C == 'INPORT')      # if a boat INPORT entry
    {
      call smovv("INPORT",line,lp)
      line[130]= EOS
      print 0811, line
 
     if (file_flag == .true.)
        write(16, 0811)line
    }
  else     # an aircraft ONDECK entry
    {
        call smovv("ONDECK",line,lp)
        line[130] = EOS
        print 0811, line
     if (file_flag == .true.)
        write(16, 0811)line
    }
 
return
end

 
 
subroutine Determine_platform (unit_name,      # name of the platform
                               launch_array,   # launch platform/track record
                               num_launches,   # number of launches recorded
                               output_platform)
############################################################
#$%
#$% Purpose:   Determines if the platform is a cruise
#$%            missile or torpedo and if so determines
#$%            the name of the launching unit.
#$%
#$% Called By: STATI
#$%
#$% Calls:     None
#$%
#$% Date:      January 1992
#$%
#$% Author:    Carol L. Kropp
#$%
############################################################
implicit none
literal    unit_name, launch_array [array_size, 2], output_platform
integer    num_launches
 
literal    name
character  name_array [8]
integer    i
 
equivalence (name_array, name)
 
  name = unit_name
  #$% check to see if the platform is a cruise missile or a torpedo
  if ((name_array[1] == $LETP | name_array[1] == $LETQ | name_array[1] == $LETT) &
      (name_array[2] >= $DIG0 & name_array[2] <= $DIG9) &
      (name_array[3] >= $DIG0 & name_array[3] <= $DIG9) &
      (name_array[4] >= $DIG0 & name_array[4] <= $DIG9) &
      (name_array[5] >= $DIG0 & name_array[5] <= $DIG9))
    {
     #$% locate the launch record
     for (i = num_launches; i > 0; i = i - 1)
       {
        if (launch_array [i, 2] == unit_name)
          output_platform = launch_array [i, 1]
       }
    }
  else output_platform = unit_name
 
  return
  end

 
 
integer function Aircraft_structured_name (unit_name)      # name of the platform
############################################################
#$%
#$% Purpose:   Determines if the unit name is structed
#$%            like the aircraft call signed LLDDD
#$%            (where L = A-Z & D = 0-9).
#$%
#$% Called By: STATI
#$%
#$% Calls:     None
#$%
#$% Date:      March 1992
#$%
#$% Author:    Carol L. Kropp
#$%
############################################################
implicit none
literal    unit_name
 
literal    name
character  name_array [8]
 
equivalence (name_array, name)
 
  name = unit_name
  #$% check to see if the name is structed like an aircrafts
  if ((name_array[1] >= $LETA & name_array[1] <= $LETZ) &
      (name_array[2] >= $LETA & name_array[2] <= $LETZ) &
      (name_array[3] >= $DIG0 & name_array[3] <= $DIG9) &
      (name_array[4] >= $DIG0 & name_array[4] <= $DIG9) &
      (name_array[5] >= $DIG0 & name_array[5] <= $DIG9))
     Aircraft_structured_name = $YES
   else
     Aircraft_structured_name = $NO
 
  return
  end

 
 
subroutine cinit
 
#########################################################
#$%
#$% Purpose:   CINIT gets user input from command line specifying:
#$%            1.  the game number file suffix (to
#$%                identify input files) and
#$%            2.  scenario file prefix (to
#$%                identify input files).
#$%            3.  output is to disk.
#$%
#$% Called By: COMLOG
#$%
#$% Calls:     PUTLIN      PUTC      UPPER      SMOV..
#$%
#$% Tables:    None
#$%
#$% Date:      JAN 83    * Copied & Hacked  8/85 *
#$%
#$% Author:    Timothy P. Adamos
#$%
#########################################################
implicit none
engagecommon
 
integer   CTOI, GETARG3
character buf[ARB]
integer   narg, istat, k, igame, jj, jjj
 
 call help_pgm(1,
              "pgaeng: Engagement history reports by shooter, target, weapon",
              "pgaeng Tags: PGA, Engagement",
              "Usage: pgaeng <scenario>",
              "",
              "",
              "",
              "",
              "Example: pgaeng port")
 
narg = 1
 
istat = getarg3(narg, buf, 20)		# get scenario name from command line
 
jj = 0					# generate system's file name for NODE
call smovhn (buf,$$MaxLit,filename,jj)      # E2225 JOA 6/26/01
 
jjj = 0                                 # generate print file name for NODE
call smovhn (buf,$$MaxLit,printname,jjj)    # E2225 JOA 6/26/01
 
call smov (EOS, filename, jj)
jj = jj - 1
 
call load_start_time (filename)
 
call smovv  ("h.eng",filename,jj)
call smov   (EOS,      filename,jj)
 
call smovv  ("x.eng",printname,jjj)   # print file name
call smov   (EOS,      printname,jjj)
 
call fold (filename)
call fold (printname)
 
#open(unit=.......
#     file= nodf.....
#     ......
#     and so on....
 
narg = narg + 1
call get_command_line_arg ( narg )  # read the Nth argument as a command file
 
return
end
 

Logical Function Larger (S1, S2)
implicit none
character S1[ARB], S2[ARB]
integer   i1, i2, len, j1, j2, length
 
i1 = 0
i2 = 0
len = 0
Larger  = .FALSE.
 
repeat
    {
    len = len + 1
    j1 = 0
    call smovh (S1[len],1,i1,j1)
    j2 = 0
    call smovh (S2[len],1,i2,j2)
    if (i1 < i2) break
    if (i1 > i2)
    	{
    	Larger = .TRUE.
    	break
    	}
    } until (len == length(S1))
 
return
end
 

subroutine echo_record
 
##############################################################################
#$%
#$% Echo_record displays engagement record to the terminal, and if
#$% print option is on, writes record to the file.
#$%
#$% E2248 - moved format 9019 t54 to t57, to allign T with other outcomes on CM jhm
##############################################################################
implicit none
allcommon
formcommon
engagecommon
 
9017  format (1x, 10a1, 'Z', t14, a8, t23, i7, t31, a8, t40, a8, t49, a8,
              t58, i7, t66, a1, a1, i5, a1, t73, f7.1, t81, f7.1,
              t91, a8, a8, t108, a8, t117, a8, t124, a8)
9018  format (1x, 10a1, 'Z', t14, a8, t23, i6, t30, a8, t39, a8,
              t57, a1, 1x, a1, F5.1, a1,
              t89, a8, a8, t106, a8, t115, a8, t124, a8)
9019  format (1x, 10a1, 'Z', t14, a8, t23, i6, t30, a8, t39, a8,
              t57, i6, t64, a1,
              t89, a8, a8, t106, a8, t115, a8, t124, a8)
 
integer min_to_dtg, lenengdtgstr
real    engdtg[5]
character engdtgstr[10]
 
VaxCharacter*9   v_lat                   # vax character representation of lat for write statments
VaxCharacter*10  v_lon                   # vax character representation of lon for write statments
integer          str_len
integer		 ENG$Result$I, irc
literal 	 cstrip8, eng_result_code_2_text
 
  ENG$Result$I = xENG$Result$I
  if (ENG$Result$I == ENG$P$Code)       # Engagements against positions
    {
     v_lat = ""
     v_lon = ""
     str_len = 0
     call vmovlls (xENG$RecLat$F, "NS", v_lat, str_len)
     str_len = 0
     call vmovlls (xENG$RecLon$F, "EW", v_lon, str_len)
 
     typelistp (9020, v_lat, v_lon)
    }
  else if (ENG$Result$I == ENG$Fired$Code)    # Fired at a ghosted unit - clk 4/9/93
    { typelistf (9017) }
  else if (ENG$Result$I == ENG$Gun$Code)
    {
     if (xENG$GunEpu$I == 0)
       { typelistgm (9009) }
     else
       { typelistg (9012) }
    }
  else if (ENG$Result$I == ENG$Miss$Code)
    { typelist (9009) }
  else if (ENG$Result$I == ENG$Unsuccessful$Code)        # clk 5/20/93 (E1118)
    { typelistu (9018) }
  else if (ENG$Result$I == ENG$Termination$Code)         # clk 2/94 (E1124)
    { typelistt (9019) }
  else
    {typelisth(9011)}
 
  if (printer == .true.)
    {
     if (ENG$Result$I == ENG$P$Code)   # note: v_lat and v_lon set above
       { writelistp (16, 9020, v_lat, v_lon) }
     else if (ENG$Result$I == ENG$Fired$Code)       # clk 4/9/93
       { writelistf(16, 9017) }
     else if (ENG$Result$I == ENG$Gun$Code)
       {
        if (xENG$GunEpu$I == 0)
          { writelistgm (16, 9009) }
        else
          { writelistg (16, 9012) }
       }
     else if (ENG$Result$I == ENG$Miss$Code)
       { writelist (16, 9009) }
     else if (ENG$Result$I == ENG$Unsuccessful$Code)       # clk 5/20/93
       { writelistu (16, 9018) }
     else if (ENG$Result$I == ENG$Termination$Code)         # clk 2/94 (E1124)
       { writelistt (16, 9019) }
     else
       { writelisth (16, 9011) }
    }
return
end
 

      subroutine dposit
 
      #################################################################
      ##%
      ##% display all position engagements in the file.
      ##% one at a time can be selected for display.
      ##%
      ################################################################
      implicit none
      allcommon
      engagecommon
      timewindowcommon
 
BBDeclare (ENG$Time$F, ENG$Platform$C, ENG$Weapon$C, ENG$Target$C,
	   ENG$RecLat$F, ENG$RecLon$F, ENG$Track$C, ENG$Result$I,
	   ENG$Range$F, ENG$MBURange$F)
 
      integer i, lcomp_v
      logical platfound
      literal cstrip8
 
9016  format(1x, 'TIME   ', t14, 'PLATFORM', t23, 'ALSPID', t30, 'WEAPON',
             t48, 'LAT', t57, 'LONG',
             t64, 'RESULT', t71, 'RANGE',
             t79, 'MBURANGE',
             t89, 'BE NUMBER', t106, 'TIN', t115, 'PLAT TYPE',
             t124, ' TGT TYPE' /)
 
0701  format(1x, '***** Position Engagements *****', /)
0702  format(1x, 8a9)
0703  format(1x, '** unable to find -', a8, '- in the table **')
0704  format(1x, ' Enter platform name(* = all): ', $)
0705  format('1', '** All engagements with ',a8,'at positions',/)
 
      repeat
        {
         ##### display platforms
         call echor
         print 0701
         print 0702, (platray[i], i=1,numberofplat)
 
         ##### get target name
         call echor
         print 0704
         platfound = .false.
         call getinput
         if (line[1] == $SPACE) {return}
         if (line[1] == -1)  {call echor; call exit}
 
         ##### verify name
         if (lcomp_v(inbuf, "*       ") != 0)
           {
            do i=1, numberofplat
              {
               if (inbuf == platray[i])
                 {
                  platfound = .true.
                  break
                 }
              }
            if (platfound != .true.)
              {
               call echor
               print 0703, inbuf
               next
              }
           }
         ##### display engagements of selected target
         call echor
         print 0705, inbuf
         if (printer == .true.) {write(16, 0705) inbuf}
         print 9016
         if (printer == .true.) {write(16, 9016)}
 
         repeat
           { read(88, end=0755, err=0755) eng$Record
             eng$Time$f = Xeng$Time$f
             if (eng$Time$f < lower_time | eng$Time$f > upper_time) next
             if (Xeng$Result$i != eng$P$code) next
             if (inbuf == Xeng$Platform$c | inbuf == '*')
               call echo_record
             next
0755         rewind(88)
             break
           }
        }
 
      return
 
      end ################ display position#######################
 

 
Literal function Eng_Result_Code_2_Text(         # Engagement result code to text
                                        Code)    # See hseng.def for defintion
implicit none
integer code
integer len
character text[8]
literal Ltext
equivalence (text, Ltext)
integer i_switch_1
 
len = 0
Ltext = $BLANKLIT
 
switch (Code)
{
 
    case ENG$Hit$Code:          call smovv ("H",text,len)
    case ENG$HitAmplification$Code: call smovv ("H",text,len)
    case ENG$Miss$Code:         call smovv ("M",text,len)
    case ENG$Unsuccessful$Code: call smovv ("U",text,len)
    case ENG$Fired$Code:        call smovv ("F",text,len)
    case ENG$Gun$Code:          call smovv ("G",text,len)
    case ENG$Launch$Code:       call smovv ("L",text,len)
    case ENG$P$Code:            call smovv ("P",text,len)
    case ENG$Termination$Code:  call smovv ("T",text,len)
    default:                    call smovv ("?",text,len)
}
 
return( Ltext )
end
