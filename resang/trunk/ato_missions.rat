# done: handle tskcntry us so only us naval missions processed
# done: convert india time to zulu time
# done: 4 letter callsign 
# done: load airspace definitions
# done: map mission type
# done: handle cancel mission section of ATO
# done: process SCL, including BEST
# done: Augment SCL, e.g. sonobuoys
# done: load aircraft mapping file
# done: load weapon mapping file
# done: load platform mapping file
# done: handle strike missions with be, tin, and ripple
# done: handle refuel
# done: closest, posture shooter fire tlam method 
# done: handle missing fields. Null for missing optional fields in ATO msg  
# done: Airspace may have undefined ref. Skip refuel

include "ascii.inc"
include "macros.inc"
#include "asctl.def"
#include "asshp.inc"
include "bbctl.inc"
include "bbcode.inc"
include "bbcmc.inc"
include "bbdeq.inc"
include "bbord.inc"
include "bbrte.inc"
include "bbrto.inc"
include "bbunt.inc"
include "orders.inc"

define (err, -3)   # alsp.inc undefines it - who_am_i uses it

define (number_args, 6)
define ($maxtgt, 30)

define (missionCommon,
    character my_misn[80]      # Mission Number
    character my_mtype[80]     # Mission Type, i.e. CAS
    character my_deploc[80]    # Departure location
    character my_arrloc[80]    # Arrival location
    character my_nacft[80]
    character my_actype[80]
    character my_callsign[80]
    character my_scl[80]
    character my_iff1[80]
    character my_iff2[80]
    character my_iff3[80]
    character my_arrtime[80]
    character my_leadtime[80]
    character my_deptime[80]
    character my_airspace[80]
    character my_ordalt[80]
    character my_base[80]
    integer   my_tgt_count
    integer   is_cm
    character my_tgt_tot[20,$maxtgt]
    character my_tgt_lat[20,$maxtgt]
    character my_tgt_lon[20,$maxtgt]
    character my_tgt_tin[20,$maxtgt]
    character my_cnt[80]
    character my_cmtype[80]
    character my_ttype[80]
    character ar_callsign[80]
    character ar_misn[80]
    character ar_iff[80]
    character ar_arrtime[80]
    character ar_airspace[80]
    character ar_alt[80]
    character ar_fuelamt[80]
    character UniqueATOIDChar

    common/misnCommon/my_misn, my_mtype, my_deploc, my_arrloc,
      my_nacft, my_actype, my_callsign, my_scl, my_iff1, my_iff2, my_iff3,
      my_arrtime, my_leadtime, my_deptime, my_airspace, my_ordalt, my_base,
      my_tgt_count, is_cm, my_tgt_tot, my_tgt_lat, my_tgt_lon, my_tgt_tin,
      my_cnt, my_cmtype, my_ttype,
      ar_callsign, ar_misn, ar_iff, ar_arrtime, ar_airspace, ar_alt, ar_fuelamt,
      UniqueATOIDChar
)


#-------------------------------------------------------------------------
# Country code table definition (CC)

define (CC$Slots, 20)
define (CC$Pointer, cc_indx)
define (CC$Pointer$First, cc_indx = 1)
define (CC$Pointer$OK, cc_indx <= Xcc$Used$i)
define (CC$Pointer$Valid, cc_indx <= CC$Slots)
define (CC$Pointer$Next, cc_indx = cc_indx + 1)

define (XCC$Used$I, cc_used)
define (CC$Used$I, i_cc_used)
define (PUTCC$Used$I,
    cc_used = ifelse(@1,,cc$used$i,@1)
)

define (XCC$ATOName$C, cc_ATOname[1,cc_indx])
define (CC$ATOName$C, c_cc_ATOname)
define (PUTCC$ATOName$C,
    kk_cc = 0
    call smovh(ifelse(@1,,cc$ATOname$c,@1), 400, cc_ATOname[1,cc_indx], kk_cc)
    call smov (EOS, cc_ATOname[1,cc_indx], kk_cc)
)

define (countrycodeCommon,
    character cc_ATOname[80,CC$Slots], c_cc_ATOname[80]
    integer cc_used, kk_cc
    common/CCCommon/cc_used, kk_cc, cc_ATOName, c_cc_ATOname
)

#-------------------------------------------------------------------------
# Airbase mapping table definition (AB)

define (AB$Slots, 200)
define (AB$Pointer, ab_indx)
define (AB$Pointer$First, ab_indx = 1)
define (AB$Pointer$OK, ab_indx <= Xab$Used$i)
define (AB$Pointer$Valid, ab_indx <= AB$Slots)
define (AB$Pointer$Next, ab_indx = ab_indx + 1)

define (XAB$Used$I, ab_used)
define (AB$Used$I, i_ab_used)
define (PUTAB$Used$I,
    ab_used = ifelse(@1,,ab$used$i,@1)
)

define (XAB$ATOName$C, ab_ATOname[1,ab_indx])
define (AB$ATOName$C, c_ab_ATOname)
define (PUTAB$ATOName$C,
    kk_ab = 0
    call smovh(ifelse(@1,,ab$ATOname$c,@1), 400, ab_ATOname[1,ab_indx], kk_ab)
    call smov (EOS, ab_ATOname[1,ab_indx], kk_ab)
)

define (XAB$ModelName$C, ab_modelName[1,ab_indx])
define (AB$modelName$C, c_ab_modelName)
define (PUTAB$modelName$C,
    kk_ab = 0
    call smovh(ifelse(@1,,ab$modelname$c,@1), 400, ab_modelname[1,ab_indx],
               kk_ab)
    call smov (EOS, ab_modelName[1,ab_indx], kk_ab)
)

define (airbaseCommon,
    character ab_ATOname[80,AB$Slots], c_ab_ATOname[80]
    character ab_modelName[80,AB$Slots], c_ab_ModelName[80]
    integer ab_used, kk_ab
    common/ABCommon/ab_used, kk_ab, ab_ATOName, c_ab_ATOname, 
                    ab_ModelName, c_ab_ModelName
)
#-------------------------------------------------------------------------
# Mission and Base mapping table definition (MB)

define (MB$Slots, 1000)
define (MB$Pointer, mb_indx)
define (MB$Pointer$First, mb_indx = 1)
define (MB$Pointer$OK, mb_indx <= XMB$Used$i)
define (MB$Pointer$Valid, mb_indx <= MB$Slots)
define (MB$Pointer$Next, mb_indx = mb_indx + 1)

define (XMB$Used$I, mb_used)
define (MB$Used$I, i_mb_used)
define (PUTMB$Used$I,
    mb_used = ifelse(@1,,MB$used$i,@1)
)

define (XMB$MissionNumber$C, mb_MissionNumber[1,mb_indx])
define (MB$MissionNumber$C, c_mb_MissionNumber)
define (PUTMB$MissionNumber$C,
   { kk_mb = 0
    call smovhn(ifelse(@1,,MB$MissionNumber$c,@1), ARB, mb_MissionNumber[1,mb_indx], kk_mb)
    call smov (EOS, mb_MissionNumber[1,mb_indx], kk_mb)}
)

define (XMB$MissionBase$C, mb_MissionBase[1,mb_indx])
define (MB$MissionBase$C, c_mb_MissionBase)
define (PUTMB$MissionBase$C,
    {kk_mb = 0
    call smovhn(ifelse(@1,,MB$MissionBase$c,@1), ARB, mb_MissionBase[1,mb_indx],
               kk_mb)
    call smov (EOS, mb_MissionBase[1,mb_indx], kk_mb)}
)

define (XMB$MissionType$I, mb_MissionType[mb_indx])
define (MB$MissionType$I, i_mb_MissionType)
define (PUTMB$MissionType$I,
    {
    mb_MissionType[mb_indx] = ifelse(@1,,MB$MissionType$I,@1)
    }
)
# mb$MissionType$I values
define ($AircraftMissionType,1)
define ($CruiseMissileMissionType,2)

define (MissionBaseCommon,
    character mb_MissionNumber[80,MB$Slots], c_mb_MissionNumber[80]
    character mb_MissionBase[80,MB$Slots],   c_mb_MissionBase[80]
	integer   mb_MissionType[MB$Slots],      i_mb_MissionType
    integer mb_used, kk_mb
    common/MBCommon/mb_used, kk_mb,
					mb_MissionNumber, c_mb_MissionNumber, 
                    mb_MissionBase, c_mb_MissionBase,
					mb_MissionType, i_mb_MissionType
)

#-------------------------------------------------------------------------
# Airtype mapping table definition (AT)

define (AT$Slots, 500)
define (AT$Pointer, at_indx)
define (AT$Pointer$First, at_indx = 1)
define (AT$Pointer$OK, at_indx <= Xat$Used$i)
define (AT$Pointer$Valid, at_indx <= AT$Slots)
define (AT$Pointer$Next, at_indx = at_indx + 1)

define (XAT$Used$I, at_used)
define (AT$Used$I, i_at_used)
define (PUTAT$Used$I,
    at_used = ifelse(@1,,at$used$i,@1)
)

define (XAT$ATOName$C, at_ATOname[1,at_indx])
define (AT$ATOName$C, c_at_ATOname)
define (PUTAT$ATOName$C,
    kk_at = 0
    call smovh(ifelse(@1,,at$ATOname$c,@1), 400, at_ATOname[1,at_indx], kk_at)
    call smov (EOS, at_ATOname[1,at_indx], kk_at)
)

define (XAT$ModelName$C, at_modelName[1,at_indx])
define (AT$modelName$C, c_at_modelName)
define (PUTAT$modelName$C,
    kk_at = 0
    call smovh(ifelse(@1,,at$modelname$c,@1), 400, at_modelname[1,at_indx],
               kk_at)
    call smov (EOS, at_modelName[1,at_indx], kk_at)
)

define (airtypeCommon,
    character at_ATOname[80,AT$Slots], c_at_ATOname[80]
    character at_modelName[80,AT$Slots], c_at_ModelName[80]
    integer at_used, kk_at
    common/ATCommon/at_used, kk_at, at_ATOName, c_at_ATOname, 
                    at_ModelName, c_at_ModelName
)
#-------------------------------------------------------------------------
# Air Weapon mapping table definition (AW)

define (AW$Slots, 500)
define (AW$Pointer, aw_indx)
define (AW$Pointer$First, aw_indx = 1)
define (AW$Pointer$OK, aw_indx <= Xaw$Used$i)
define (AW$Pointer$Valid, aw_indx <= AW$Slots)
define (AW$Pointer$Next, aw_indx = aw_indx + 1)

define (XAW$Used$I, aw_used)
define (AW$Used$I, i_aw_used)
define (PUTAW$Used$I,
    aw_used = ifelse(@1,,aw$used$i,@1)
)

define (XAW$ATOName$C, aw_ATOname[1,aw_indx])
define (AW$ATOName$C, c_aw_ATOname)
define (PUTAW$ATOName$C,
    kk_aw = 0
    call smovh(ifelse(@1,,aw$ATOname$c,@1), 400, aw_ATOname[1,aw_indx], kk_aw)
    call smov (EOS, aw_ATOname[1,aw_indx], kk_aw)
)

define (XAW$ModelName$C, aw_modelName[1,aw_indx])
define (AW$modelName$C, c_aw_modelName)
define (PUTAW$modelName$C,
    kk_aw = 0
    call smovh(ifelse(@1,,aw$modelname$c,@1), 400, aw_modelname[1,aw_indx],
               kk_aw)
    call smov (EOS, aw_modelName[1,aw_indx], kk_aw)
)

define (weaponCommon,
    character aw_ATOname[80,AW$Slots], c_aw_ATOname[80]
    character aw_modelName[80,AW$Slots], c_aw_ModelName[80]
    integer aw_used, kk_aw
    common/AWCommon/aw_used, kk_aw, aw_ATOName, c_aw_ATOname, 
                    aw_ModelName, c_aw_ModelName
)
#-------------------------------------------------------------------------
# Air Load Augmentation table definition (AL)

define (AL$Slots, 500)
define (AL$Pointer, AL_indx)
define (AL$Pointer$First, AL_indx = 1)
define (AL$Pointer$OK, AL_indx <= XAL$Used$i)
define (AL$Pointer$Valid, AL_indx <= AL$Slots)
define (AL$Pointer$Next, AL_indx = AL_indx + 1)

define (XAL$Used$I, AL_used)
define (AL$Used$I, i_AL_used)
define (PUTAL$Used$I,
    AL_used = ifelse(@1,,AL$used$i,@1)
)

define (XAL$AirType$C, AL_AirType[1,AL_indx])
define (AL$AirType$C, c_AL_AirType)
define (PUTAL$AirType$C,
    kk_AL = 0
    call smovh(ifelse(@1,,AL$AirType$c,@1), 400, AL_AirType[1,AL_indx], kk_AL)
    call smov (EOS, AL_AirType[1,AL_indx], kk_AL)
)

define (XAL$Mission$C, AL_Mission[1,AL_indx])
define (AL$Mission$C, c_AL_Mission)
define (PUTAL$Mission$C,
    kk_AL = 0
    call smovh(ifelse(@1,,AL$Mission$c,@1), 400, AL_Mission[1,AL_indx],
               kk_AL)
    call smov (EOS, AL_Mission[1,AL_indx], kk_AL)
)

define (XAL$Load$C, AL_Load[1,AL_indx])
define (AL$Load$C, c_AL_Load)
define (PUTAL$Load$C,
    kk_AL = 0
    call smovh(ifelse(@1,,AL$Load$c,@1), 400, AL_Load[1,AL_indx],
               kk_AL)
    call smov (EOS, AL_Load[1,AL_indx], kk_AL)
)

define (loadCommon,
    character AL_AirType[80,AL$Slots], c_AL_AirType[80]
    character AL_Mission[80,AL$Slots], c_AL_Mission[80]
    character AL_Load[80,AL$Slots], c_AL_Load[80]
    integer AL_used, kk_AL
    common/ALCommon/AL_used, kk_AL, AL_AirType, c_AL_AirType, 
                    AL_Mission, c_AL_Mission,
                    AL_Load, c_AL_Load
)
#-------------------------------------------------------------------------
# Time Shift Common (TS)

define (TimeShiftCommon,
    integer ts_days, ts_hours, ts_minutes
    common/TSCommon/ts_days, ts_hours, ts_minutes
)

#---------------------------------------------------------------------
define (BBImplicit, Implicit None)

undefine write   # use the standard fortran write statement
undefine read

program ATO_Naval_Missions
#########################################################################
#$%
#$% Purpose:    This program converts raw naval ato missions into RESA flights
#$%
#$% Calls:      initr4         <rlib.olb>
#$%             read_arguments
#$%             ctoi
#$%             remark
#$%             exit
#$%             delay
#$%             smov..
#$%             echo..
#$%             write
#$%             close
#$%
#$% Tables:     global variables
#$%
#$% Date:       Jan 2011
#$%
#$% Author:     James O. Allen
#$%
#########################################################################
implicit none
MissionCommon
MissionBaseCommon

integer   atoid_update  
integer   ctoi        # integer function

integer          arg_len[number_args], k
vaxcharacter*80  args[number_args], params

character  msg[ARB]
integer   error

integer   msg1_len
character msg1[80]
vaxcharacter*80  v_msg1
Equivalence  (msg1, v_msg1)

vaxcharacter*80  nmfile
vaxcharacter*80  mlfile

literal   atoid
vaxcharacter*8  atoidv
character atoidC[8]
Equivalence  (atoid, atoidv, atoidC)

literal   auto_tlam
vaxcharacter*8  auto_tlamv
character auto_tlamC[8]
Equivalence  (auto_tlam, auto_tlamv, auto_tlamC)

character atoid_suffix[2]

integer   game_number
VMSchar*30  bbname
character   bbmsg[ARB]
character ato_root[80]

call initR4

BBMap

call Read_Arguments (number_args, args, arg_len, params)

# get working atoid directory
call fs2rs(args[1], ato_root)

atoid = $BLANKLIT
atoidV = args[2][1:arg_len[2]]
atoidC[arg_len[2]+1] = EOS
k = 1
atoid_update = ctoi (%%ref(args[3]),k)

nmfile = args[4][1:arg_len[4]]
mlfile = args[5][1:arg_len[5]]

auto_tlam = $BLANKLIT
auto_tlamV = args[6][1:arg_len[6]]
auto_tlamC[arg_len[6]+1] = EOS
call upper (auto_tlamC)

#call get_airspace (ato_root, atoid, atoid_update)

# Get unique atoid char from atoid history file 
call atoid_load 
call atoid_find (atoidC, atoid_suffix)
if (atoid_suffix[1] == EOS)
{
    call atoid_add (atoidC)
    call atoid_find (atoidC, atoid_suffix)
}
UniqueAtoidChar = atoid_suffix[1]

call countrycode_load
call airtype_load
call airbase_load
call weapon_load
call load_load
call timeshift_load

PUTmb$used$I( 0 )			# Empty mission base table
call add_pending_mission_bases (atoid, atoid_update)

call Open_Mission_Output (ato_root, atoid, atoid_update, nmfile)

call Open_Mission_List (ato_root, atoid, atoid_update, mlfile)

call get_ato_missions(ato_root, atoid, atoid_update, auto_tlamC)

close(11)
close(12)

End

Subroutine get_ato_missions (ato_root,
                             atoid,
                             atoid_update_number,
                             auto_tlamC)            # Extract fields from ATO
# Position in ATO to US Naval tasking
# Assume aircraft mission begins with amsndat and next mission triggers write
# MTGTLOC CM fire mission written independently
# See atoairmap.dat, atobasemap.dat, atoloadaugment.map, atoweaponmap.dat

BBcommon
MissionCommon
AirbaseCommon
LoadCommon
MissionBasecommon
TimeShiftCommon
CountryCodeCommon

BBdeclare (unt$pointer)
integer ab$pointer
integer al$pointer
integer mb$pointer
integer cc$pointer
literal cstrip8, cstrip
character ato_root[80]
literal atoid
integer atoid_update_number
character auto_tlamC[8]
vmschar vstrip*ARB
integer k, kk, i, ic
integer msg_len
integer nl
integer getatowrd, equal, load_find, index, equal_hv
integer MissionBase_find, CountryCode_find
integer name_len
integer return_val
integer ipos
integer isize, nsign
integer lenline
integer ctoi, length
integer ialt
integer niff1, niff2, niff3
integer airbase_find
logical inMission
logical NavyTasking
logical USTasking
character atoid_char
character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)
character msg[80]

character ato_rcd[120]
vmschar*120 ato_rcd_v
equivalence(ato_rcd, ato_rcd_v)

character aline[140]
character keyword[80000]
vaxcharacter*80  v_msg
Equivalence  (msg, v_msg)

character atoidc[8]
literal   atoidL
equivalence (atoidL, atoidc)

character token[80009]
character fmt_lat[80]
character fmt_lon[80]

vaxcharacter legal_name*24
character misn[80]
character cnx_misn[80]
character skip_mission[80]
character mtype[80]
character cmtype[80]
character country[80]
character service[80]
character deploc[80]
character arrloc[80]

character nacft[80]
character actype[80]
character callsign[80]
character scl[80]
character iff1[80]
character iff2[80]
character iff3[80]

character arrtime[80]
character deptime[80]
character airspace[80]
character ordalt[80]

character tot[80]
character net[80]
character nlt[80]
character ttype[80]
character dmpipos[80]
character tin[80]
character xxxx[80]
character cupper

define ($nawsim,7)
# XINT,XCAS,XATK,XAEW,XSCP,XAR,AEW,EW,WW,GAEW,GINT,GCAS,GATK,GAEW
Literal awsim_mission[$nawsim]
vmschar*8 awsim_mission_v[$nawsim]
equivalence(awsim_mission, awsim_mission_v)
data awsim_mission_v/"XINT","XCAS","XATK","XAEW","AEW","EW","WW"/
                    
nl = 0
NavyTasking = .false.
inMission = .false.

atoidL = atoid                          # Local copy
for (kk=1; kk<=$$MaxLit; kk=kk+1) atoidc[kk] = cupper(atoidc[kk])	# Upper case atoid (local copy)

# Flag not to write empty missions
kk = 0
call smov(EOS, my_misn, kk)

name_len = 0
call smovhn  (ato_root, ARB, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovhn (atoid, $$MaxLit, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovi  (atoid_update_number, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovhn (atoid, $$MaxLit, file_name, name_len)
call smovv  (".", file_name, name_len)
call smovi  (atoid_update_number, file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open raw ato"
    return
}

if (auto_tlamC[1] != $LETY)
{
    name_len = 0
    call smovhn  (ato_root, ARB, file_name, name_len)
    call smovv  ("/", file_name, name_len)
    call smovhn (atoid, $$MaxLit, file_name, name_len)
    call smovv  ("/", file_name, name_len)
    call smovi  (atoid_update_number, file_name, name_len)
    call smovv  ("/", file_name, name_len)
    call smovv  ("tlam.pre", file_name, name_len)
    call smov   (EOS, file_name, name_len)
    open(unit    =  14,                            #open tlam file
        file    =   file_name_v,
        status  =  'unknown',
        access  =  'sequential',
        recl    =   140,
        iostat  =   return_val)
    
    if (return_val != 0)
    {
        print *, "unable to open tlam.pre"
        return
    }
    kk = 0
    call smovv (" #From RESA I/O terminal type: CNTL-F ato/", msg, kk)
    call smovhn (atoid, $$MaxLit, msg, kk)
    call smovv  ("/", msg, kk)
    call smovi  (atoid_update_number, msg, kk)
    call smovv  ("/", msg, kk)
    call smovv  ("tlam.pre",msg, kk)
    call smov   (EOS, msg, kk)
    write (14, 9002) (msg[i],i=1,length(msg))

    kk = 0
    call smovv (" #Type CNTL-G after editing fire order.", msg, kk)
    call smov   (EOS, msg, kk)
    write (14, 9002) (msg[i],i=1,length(msg))
}

repeat
{
    #$% get line of input from raw ato
    read (10,9001,END=8000) ato_rcd_v
    lenline = len_trim(ato_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, ato_rcd, k)    
    call upper (ato_rcd)
    ipos = 0        
    isize = getatowrd (ato_rcd, ipos, keyword)

    #!------------------------------------------
    #! cancel missions
    #! CNXMSN/<cntry>/<task unit>/<mission #>/...// 
    #! FOR <platform> CANCEL SCRAMBLE <misn> ATOID <atoid>
    if (equal_hv (keyword,"CNXMSN") == YES)
    {
        isize = getatowrd (ato_rcd, ipos, country) # country
        # Only process US country
        if (equal_HV (country, "US") == NO) next
        isize = getatowrd (ato_rcd, ipos, keyword) # task unit
        while (getatowrd (ato_rcd, ipos, misn) !=0)
        {
            kk = 0
            call smovhn (misn, $$Maxlit, cnx_misn, kk)
            call smov   (UniqueATOIDChar, cnx_misn, kk)
            call smov   (EOS, cnx_misn, kk)
            # Find base for mission 
            mb$pointer = MissionBase_find(cnx_misn)
            if (mb$pointer > 0)
            {
				if (Xmb$MissionType$I == $AircraftMissionType)
				{
                	kk = 0
                	call smovv ("FOR ", aline, kk)
                	call smovhn (Xmb$MissionBase$C, $$MaxLit, aline, kk)
                	call smovv (" CANCEL SCRAMBLE ", aline, kk)
                	call smovhn (cnx_misn, $$MaxLit, aline, kk)
                	call smovv (" ATOID ", aline, kk)
                	call smovhn (atoidL, $$MaxLit, aline, kk)                   
                	write (11, 9002) (aline[i],i=1,kk)
				}
				if (Xmb$MissionType$I == $CruiseMissileMissionType)
				{
                	kk = 0
               		call smovv ("FOR ", aline, kk)
                	call smovhn (Xmb$MissionBase$C, $$MaxLit, aline, kk)
                	call smovv (" CANCEL FIRE CRUISE ", aline, kk)
                	call smovhn (cnx_misn, $$MaxLit, aline, kk)                   
               	    write (11, 9002) (aline[i],i=1,kk)
				}

9002            format(120a1)
            }
			else
			{
				print 9003, (cnx_misn[kk],kk=1,length(cnx_misn))
9003			format("Mission not pending so not canceled: ",80a1)
			}            
        }
        next
    }
    #!------------------------------------------
    # Check for end of mission
    if ((equal_hv(keyword, "AMSNDAT") == YES |
         equal_hv(keyword, "MTGTLOC") == YES |
         equal_hv(keyword, "TSKCNTRY") == YES) & inMission == .true. & length(my_misn) != 0)
    {
        call write_naval_mission(atoidL, auto_tlamC)
        call write_naval_mission_number(atoid)
        call  clear_mission_fields()
		inMission = .false.
    }
    #!------------------------------------------
    #! Set country taskingf
    if (equal_hv (keyword,"TSKCNTRY") == YES)
    {
        isize = getatowrd (ato_rcd, ipos, country)
		cc$pointer = CountryCode_find (country)
        if (cc$pointer == 0)						# Country code not on do not process list
		{
            USTasking = .true.
            NavyTasking = .false.
		}
        else
        {
            USTasking = .false.
            NavyTasking = .false.
        }
    }
    #!------------------------------------------
    #! Set Navy tasking

    if (equal_hv (keyword,"SVCTASK") == YES)
    {
        isize = getatowrd (ato_rcd, ipos, service)
        if (equal_hv(service, "N") == YES | equal_hv(service, "F") == YES)
            NavyTasking = .true.
        else
            NavyTasking = .false.
    }

    # Only process us navy missions
    if (USTasking == .false.) next
    if (NavyTasking == .false.) next

    if (inMission == .false.)
    {
        if (equal_hv(keyword, "AMSNDAT") == YES | equal_hv(keyword, "MTGTLOC") == YES)
        {
            inMission = .true.
        }
        else
        {
            next
        }
    }
 
# sample raw ato 2000
#AMSNDAT/1021/-/-/-/CAS/-/-/DEPLOC:NABE/ARRLOC:NABE//
#MSNACFT/4/OTHAC:FA18E/ALMOND11/2G32X2A2WX1/-/151/23211/33211//
#AMSNLOC/132130ZFEB/132200ZFEB/BREWERS CP/230//
#REQNO/01YBF040//

# sample raw ato 2004
#AMSNDAT/F/0250/-/-/-/REC/-/-/DEPLOC:RODN/032120IJUN/ARRLOC:RODN/040825IJUN//
#MSNACFT/1/ACTYP:P3C/RINGLING50/2M46X2M50X4M20X1A65X4M64X58S53X24S62/-
#/RG50/-/-/A:100/-/B:20250/-/B:30250//
#AMSNLOC/040000IJUN/040600IJUN/SALMON/10//
#REQNO/WC3G00009//

    if (equal_hv(keyword, "AMSNDAT")  == YES)
    {
        #AMSNDAT/1021/-/-/-/CAS/-/-/DEPLOC:NABE/ARRLOC:NABE//
        isize = getatowrd (ato_rcd, ipos, token)  # 2 not used
        isize = getatowrd (ato_rcd, ipos, misn)   # 3
        isize = getatowrd (ato_rcd, ipos, token)  # 4 not used
        isize = getatowrd (ato_rcd, ipos, token)  # 5 not used
        isize = getatowrd (ato_rcd, ipos, token)  # 6 not used
        isize = getatowrd (ato_rcd, ipos, mtype)  # 7 mission type
        isize = getatowrd (ato_rcd, ipos, token)  # 8 not used
        isize = getatowrd (ato_rcd, ipos, token)  # 9 not used
        isize = getatowrd (ato_rcd, ipos, deploc) # 10 launch platform
        isize = getatowrd (ato_rcd, ipos, arrtime)# 11 arrival time
        isize = getatowrd (ato_rcd, ipos, arrloc) # 12 bingo platform
        isize = getatowrd (ato_rcd, ipos, deptime)# 13 departure time

        #!------------------------------------------
        #! Get Mission Type
        #!------------------------------------------
        call convert_mission_type (mtype, my_mtype)

        #!------------------------------------------
        #! Skip Ground alert mission types
        #!------------------------------------------
        if (mtype[1] == $LETG)
        {
            inMission = .false.
            next
        }
        #!------------------------------------------
        #! Skip Air Force missions that are not ASW
        #!------------------------------------------
        if (equal_hv(service, "F") == YES)
        {
			if (equal_hv(mtype, "ASW") == NO & equal_hv(mtype, "XASW") == NO)
			{
            	inMission = .false.
            	next
			}
        }
        #!------------------------------------------
        #! skip if awsim flying mission
        for (i=1; i <= $nawsim; i = i + 1)
        {
            kk = 0; call smovhn (awsim_mission[i], $$maxlit, skip_mission, kk)
            call smov (EOS, skip_mission, kk)
            if (equal(mtype, skip_mission) == YES)
            {
                inMission = .false.
                next
            }
        }
        #!------------------------------------------
        #! Get Mission Number
        kk = 0
        call smovhn (misn, $$Maxlit, my_misn, kk)
        call smov   (UniqueATOIDChar, my_misn, kk)
        call smov   (EOS, my_misn, kk)
        #!------------------------------------------
        #! Get Departure Location
        kk = 0
        call smovhn (deploc[8], $$Maxlit, my_deploc, kk)
        call smov   (EOS, my_deploc, kk)
        ab$pointer = airbase_find(my_deploc)
        if (ab$pointer != 0)
        {
            kk = 0
            call smovhn (Xab$ModelName$c, $$Maxlit, my_deploc, kk)
            call smov  (EOS, my_deploc, kk)
        }
        else
        {
            inMission = .false.
            kk = 0
            call smovv ("Departure Base ", msg, kk)
            call smovhn (my_deploc, $$Maxlit, msg, kk)
            call smovv (" not on list. Mission ", msg, kk)
            call smovhn (my_misn, $$Maxlit, msg, kk)
            call smovv (" skipped.", msg, kk)
            call smov  (EOS, msg, kk)
            print 9007, (msg[i], i=1,kk)
9007        format (1x,80a1) 
            next
        }

        #!------------------------------------------
        #! Get Arrival Time
        if (arrtime[7] != $LETZ)
        {
            call timeshift(arrtime,ts_days, ts_hours, ts_minutes,
                           my_arrtime)
            kk = length(my_arrtime)
        }
        else
        {
            call timeshift(arrtime,ts_days, 0, ts_minutes,
                           my_arrtime)
            kk = length(my_arrtime)
        }
        call smov   (EOS, my_arrtime, kk)
        #!------------------------------------------
        #! Get Arrival Location
        kk = 0
        call smovhn (arrloc[8], $$Maxlit, my_arrloc, kk)
        call smov   (EOS, my_arrloc, kk)
        ab$pointer = airbase_find(my_arrloc)
        if (ab$pointer != 0)
        {
            kk = 0
            call smovhn (Xab$ModelName$c, $$Maxlit, my_arrloc, kk)
            call smov  (EOS, my_arrloc, kk)
        }
        else
        {
            kk = 0

            call smovv ("Arrival Base ", msg, kk)
            call smovhn (my_arrloc, $$Maxlit, msg, kk)
            call smovv (" not mapped for Mission ", msg, kk)
            call smovhn (my_misn, $$Maxlit, msg, kk)
            call smov  (EOS, msg, kk)
            print 9007, (msg[i], i=1,kk)
        }

        #!------------------------------------------
        #! Get Departure Time
        if (deptime[7] != $LETZ)
        {
            call timeshift(deptime,ts_days, ts_hours, ts_minutes,
                           my_deptime)
            kk = length(my_deptime)
        }
        else
        {
            call timeshift(deptime,ts_days, 0, ts_minutes,
                           my_deptime)
            kk = length(my_deptime)
        }
        call smov   (EOS, my_deptime, kk)
    }

    if (equal_hv(keyword, "MTGTLOC") == YES)
    {
        # sample raw ato 2000
        #  1     2  3    4             5 6  7                  8  9 a  b
        #MTGTLOC/P/8300/TOT:161335IAUG/-/-/ID:0380-07643DD002/UNK/O/1/0025
        #  c      d                        e
        #KJF01U/DMPID:390334.2N1254412.3E/WGS 1984//

        #  1        2             3         4   5   6    7      8
        #MTGTLOC/designator/mission number/TOT/NET/NLT/tgt id/tgt type/
        #              9          a         b       c       d
        #         missile type/#missiles/tgt pri/tgt obs/comtst id/
        #                   e            f
        #        position of impact/geodetic datum//

        # sample raw ato 2004
        #  1     2  3   4  5           6           7                  8  9 a
        #MTGTLOC/P/0445/-/NET:032221I/NLT:032236I/ID:0380-06193PA001/UNK/C/2
        #   b   c   d     e                           f
        #/00042/-/M00R6B/DMPIT:3954.0980N12747.7145E/WE//

        is_cm = $yes
        isize = getatowrd (ato_rcd, ipos, keyword)   # 2 Ignore 
        isize = getatowrd (ato_rcd, ipos, misn)      # 3 Mission Number
        isize = getatowrd (ato_rcd, ipos, tot)       # 4 Time on Target
        isize = getatowrd (ato_rcd, ipos, net)       # 5 Not earlier than
        isize = getatowrd (ato_rcd, ipos, nlt)       # 6 Not later than
        isize = getatowrd (ato_rcd, ipos, keyword)   # 7 Ignore target identifier
        isize = getatowrd (ato_rcd, ipos, ttype)     # 8 target type
        isize = getatowrd (ato_rcd, ipos, cmtype)    # 9 CM Type
        isize = getatowrd (ato_rcd, ipos, my_cnt)    #10 missile count
        isize = getatowrd (ato_rcd, ipos, keyword)   #11 Ignore tgt pri 
        isize = getatowrd (ato_rcd, ipos, keyword)   #12 Ignore tgt obj
        isize = getatowrd (ato_rcd, ipos, tin)       #13 component target id
        isize = getatowrd (ato_rcd, ipos, dmpipos)   #14 Target position
        #!------------------------------------------
        #! Get mission number
        kk = 0
        call smovhn (misn, $$Maxlit, my_misn, kk)
        call smov   (UniqueATOIDChar, my_misn, kk)
        call smov   (EOS, my_misn, kk)
        #!------------------------------------------
        #! Get not earlier than time on target
        kk = 0
        if      (tot[1] != $minus) call smovh(tot, ARB, arrtime, kk)
        else if (net[1] != $minus) call smovh(net, ARB, arrtime, kk)
        else if (nlt[1] != $minus) call smovh(nlt, ARB, arrtime, kk)
        call smov (EOS, arrtime, kk)
        
        if (arrtime[11] != $LETZ)
        {
            call timeshift(arrtime[5],ts_days, ts_hours, ts_minutes,
                           my_tgt_tot[1,1])
            kk = length(my_tgt_tot[1, 1])
        }
        else
        {
            call timeshift(arrtime[5],ts_days, 0, ts_minutes,
                           my_tgt_tot[1,1])
            kk = length(my_tgt_tot[1, 1])
        }
        call smov   (EOS, my_tgt_tot[1,1], kk)
        #!------------------------------------------
        #! Get target position
        call format_tgt_pos (dmpipos, fmt_lat, fmt_lon) 
        kk = 0
        call smovhn (fmt_lat, ARB, my_tgt_lat[1,1], kk)
        call smov   (EOS, my_tgt_lat[1,1], kk)
        kk = 0
        call smovhn (fmt_lon, ARB, my_tgt_lon[1,1], kk)
        call smov   (EOS, my_tgt_lon[1,1], kk)

        #!------------------------------------------
        #! Get tin
        kk = 0
        call smovh (tin, ARB, my_tgt_tin[1,1], kk)
        call smov  (EOS, my_tgt_tin[1,1], kk)
        #!------------------------------------------
        #! Get missile type
        kk = 0
        if      (cmtype[1] == $LETT) call smovv ("TLAMC", my_cmtype, kk)
        else if (cmtype[1] == $LETC) call smovv ("AGM86", my_cmtype, kk)
        else if (cmtype[1] == $LETO) call smovv ("TLAMC", my_cmtype, kk)
        else if (cmtype[1] == $LETA) call smovv ("TLAMC", my_cmtype, kk)
        else                      call smovv ("TLAMC", my_cmtype, kk)
        call smov (EOS, my_cmtype, kk)
        #!------------------------------------------
        #! Get target type
        kk = 0
        if     (equal_hv(ttype,"ADA") == YES)    call smovv("AIRDEFENSE",my_ttype,kk)
        else if(equal_hv(ttype,"ASSYTV") == YES) call smovv("TRUCKS",my_ttype,kk)
        else if(equal_hv(ttype,"ARMOR") == YES)  call smovv("ARMOR",my_ttype,kk)
        else if(equal_hv(ttype,"ARTY") == YES)   call smovv("ARTILLERY",my_ttype,kk)
        else if(equal_hv(ttype,"BRFXD") == YES)  call smovv("BRIDGE FIXED",my_ttype,kk)
        else if(equal_hv(ttype,"FTCR") == YES)   call smovv("BRIDGE ENGINEERED",my_ttype, kk)
        else if(equal_hv(ttype,"FTST") == YES)   call smovv("BRIDGE ENGINEERED",my_ttype, kk)
        else if(equal_hv(ttype,"CONVOY") == YES) call smovv("TRUCKS",my_ttype,kk)
        else if(equal_hv(ttype,"HELO") == YES)   call smovv("HELICOPTERS", my_ttype,kk)
        else if(equal_hv(ttype,"INF") == YES)    call smovv("INFANTRY",my_ttype,kk)
        else if(equal_hv(ttype,"RADAR") == YES)  call smovv("RADAR",my_ttype,kk)
        else if(equal_hv(ttype,"ROAD") == YES)   call smovv("ROAD",my_ttype,kk)
        else if(equal_hv(ttype,"VHOTH") == YES)  call smovv("TRUCKS",my_ttype,kk)
        call smov(EOS,my_ttype,kk)
        #!------------------------------------------
        #! Select CM shooter closest to impact position
        # Loop through UNT table
        # Keep CM shooter closest to target and within CM range
        # Location of own and enemy forces not considered
        call CMshooter_select(unt$pointer)
        if (unt$pointer == 0)
        {
            kk = 0
            call smovv ("No CM shooter selected for mission ", msg, kk)
            call smovh (my_misn, ARB, msg, kk)
            call smov (EOS, msg, kk)
            print 9007, (msg[i], i=1,kk)

            kk = 0
			call smovv("NOCMBASE", my_base, kk)
            call smov (EOS, my_base, kk)
        }
        else
        {
            kk = 0
            call smovh(Xunt$name$c,$$Maxlit,my_base,kk)
            call smov(EOS,my_base,kk)
        }
        # MTGTLOC mission appears on single line. Write now
        call write_naval_mission(atoidL, auto_tlamC)
        call write_naval_mission_number(atoid)
        call  clear_mission_fields()
        inmission = .false.
    }    

    if (equal_hv(keyword, "AMPN") == YES)
    {
        #AMPN/DEPLOC:NABE/ARRLOC:NABE//
        isize = getatowrd (ato_rcd, ipos, deploc) # 2 launch platform
        isize = getatowrd (ato_rcd, ipos, arrloc) # 3 bingo platform

        #!------------------------------------------
        #! Get Departure Location
        kk = 0
        deploc[7] = EOS
        if (equal_hv(deploc, "DEPLOC") == YES)
        {
            call smovhn (deploc[8], $$Maxlit, my_deploc, kk)
            call smov   (EOS, my_deploc, kk)
            ab$pointer = airbase_find(my_deploc)
            if (ab$pointer != 0)
            {
                kk = 0
                call smovhn (Xab$ModelName$c, $$Maxlit, my_deploc, kk)
                call smov  (EOS, my_deploc, kk)
            }
            else
            {
                inMission = .false.
                kk = 0
                call smovv ("Base ", msg, kk)
                call smovhn (my_deploc, $$Maxlit, msg, kk)
                call smovv (" not on list. Mission ", msg, kk)
                call smovhn (my_misn, $$Maxlit, msg, kk)
                call smovv (" skipped.", msg, kk)
                call smov  (EOS, msg, kk)
                print 9007, (msg[i], i=1,kk)
                next
            }
        }
        #!------------------------------------------
        #! Get Arrival Location
        kk = 0
        arrloc[7] = EOS
        if (equal_hv(arrloc, "ARRLOC") == YES)
        {
            call smovhn (arrloc[8], $$Maxlit, my_arrloc, kk)
            call smov   (EOS, my_arrloc, kk)
            ab$pointer = airbase_find(my_arrloc)
            if (ab$pointer != 0)
            {
                kk = 0
                call smovhn (Xab$ModelName$c, $$Maxlit, my_arrloc, kk)
                call smov  (EOS, my_arrloc, kk)
            }
            else
            {
                inMission = .false.
                kk = 0
                call smovv ("Base ", msg, kk)
                call smovhn (my_arrloc, $$Maxlit, msg, kk)
                call smovv (" not on list. Mission ", msg, kk)
                call smovhn (my_misn, $$Maxlit, msg, kk)
                call smovv (" skipped.", msg, kk)
                call smov  (EOS, msg, kk)
                print 9007, (msg[i], i=1,kk)
                next
            }
        }
    }

    if (equal_hv(keyword, "MSNACFT") == YES)
    {
        # Sample USMTF 2000
        #MSNACFT/4/OTHAC:FA18E/ALMOND11/2G32X2A2WX1/-/151/23211/33211//

        # USMTF 2004 Format
        #   1     2     3      4             5
        #MSNACFT/#AC/AC type/call sign/Primary config code/
        #             6                   7             8        9
        #      secondary config code/L16 call sign/TACAN Channel/-/
        #         10      11  12       13   14
        #      IFF Mode 1/?/IFF Mode 2/?/IFF Mode 3//

        # Sample USMTF 2004
        #   1    2     3        4                  5                         6
        #MSNACFT/1/ACTYP:P3C/RINGLING50/2M46X2M50X4M20X1A65X4M64X58S53X24S62/-/
        #  7   8 9   10  11  12    13   14
        #/RG50/-/-/A:100/-/B:20250/-/B:30250//

        isize = getatowrd (ato_rcd, ipos, nacft)     # 2 Number of aircraft
        isize = getatowrd (ato_rcd, ipos, actype)    # 3 Aircraft type
        nsign = getatowrd (ato_rcd, ipos, callsign)  # 4 callsign
        isize = getatowrd (ato_rcd, ipos, scl)       # 5 Standard Conventional Loadout
        isize = getatowrd (ato_rcd, ipos, token)     # 6 not used
        isize = getatowrd (ato_rcd, ipos, token)     # 7 not used
        isize = getatowrd (ato_rcd, ipos, token)     # 8 not used
        isize = getatowrd (ato_rcd, ipos, token)     # 9 not used
        niff1 = getatowrd (ato_rcd, ipos, iff1)      #10 IFF mode 1
        isize = getatowrd (ato_rcd, ipos, token)     #11 not used
        niff2 = getatowrd (ato_rcd, ipos, iff2)      #12 IFF mode 2
        isize = getatowrd (ato_rcd, ipos, token)     #13 not used
        niff3 = getatowrd (ato_rcd, ipos, iff3)      #14 IFF mode 3

        #!------------------------------------------
        #! Get Number of Aircraft
        kk = 0
        call smovhn (nacft, $$Maxlit, my_nacft, kk)
        call smov   (EOS, my_nacft, kk)

        #!------------------------------------------
        #! Get Aircraft type
        kk = 0
        call smovhn (actype[7], $$Maxlit, my_actype, kk)
        call smov   (EOS, my_actype, kk)
        call airtype_map (my_actype)
        #!------------------------------------------
        #! Get callign (shorten by keeping first 2 and last 2 characters)
        kk = 0
        call smovhn (callsign, 2, my_callsign, kk)
        call smovhn (callsign[nsign-1], 2, my_callsign, kk)
        call smov   (EOS, my_callsign, kk)

        #!------------------------------------------
        #! Get SCL
        # 4G31X3A2W1 = [ 4 G31, 3 A, 2 1, 1 external tank ]

        call scl_translate (scl, my_scl)
        # Augment load if specified in load augmentation file
        al$pointer = load_find (my_actype, my_mtype)
        if (al$pointer != 0)
        {
            kk = length(my_scl)
            call smovv (" ", my_scl, kk)
            call smovh (Xal$Load$c, ARB, my_scl, kk)
            call smov (EOS, my_scl, kk)
        }
        #!------------------------------------------
        #! Get IFFx
        if (niff1 > 0)
        {
            if (Iff1[3] == $DIG1)
            {
                kk = 0
                call smovhn (Iff1[4], ARB, my_iff1, kk)
                call smov   (EOS, my_iff1, kk)
            }
            else if (Iff1[3] == $DIG2)
            {
                kk = 0
                call smovhn (Iff1[4], ARB, my_iff2, kk)
                call smov   (EOS, my_iff2, kk)
            }
            else if (Iff1[3] == $DIG3)
            {
                kk = 0
                call smovhn (Iff1[4], ARB, my_iff3, kk)
                call smov   (EOS, my_iff3, kk)
            }
        }
        if (niff2 > 0)
        {
            if (Iff2[3] == $DIG1)
            {
                kk = 0
                call smovhn (Iff2[4], ARB, my_iff1, kk)
                call smov   (EOS, my_iff1, kk)
            }
            else if (Iff2[3] == $DIG2)
            {
                kk = 0
                call smovhn (Iff2[4], ARB, my_iff2, kk)
                call smov   (EOS, my_iff2, kk)
            }
            else if (Iff2[3] == $DIG3)
            {
                kk = 0
                call smovhn (Iff2[4], ARB, my_iff3, kk)
                call smov   (EOS, my_iff3, kk)
            }
        }
        if (niff3 > 0)
        {
            if (Iff3[3] == $DIG1)
            {
                kk = 0
                call smovhn (Iff3[4], ARB, my_iff1, kk)
                call smov   (EOS, my_iff1, kk)
            }
            else if (Iff3[3] == $DIG2)
            {
                kk = 0
                call smovhn (Iff3[4], ARB, my_iff2, kk)
                call smov   (EOS, my_iff2, kk)
            }
            else if (Iff3[3] == $DIG3)
            {
                kk = 0
                call smovhn (Iff3[4], ARB, my_iff3, kk)
                call smov   (EOS, my_iff3, kk)
            }
        }
    }
    if (equal_hv(keyword, "AMSNLOC") == YES)
    {
        #2000 AMSNLOC/132130ZFEB/132200ZFEB/BREWERS CP/230//
        #2004 AMSNLOC/040000IJUN/040600IJUN/SALMON EGG/10//
        isize = getatowrd (ato_rcd, ipos, arrtime)   # 2 Arrival time
        isize = getatowrd (ato_rcd, ipos, deptime)   # 3 Departure time
        isize = getatowrd (ato_rcd, ipos, airspace)  # 4 Airspace name
        isize = getatowrd (ato_rcd, ipos, ordalt)    # 5 Ordered Altitude 

        #!------------------------------------------
        #! Get arrival time
        kk = 0
        if (arrtime[7] != $LETZ)
        {
            call timeshift(arrtime,ts_days,ts_hours,ts_minutes, my_arrtime)
            kk = length (my_arrtime)
        }
        else
        {
            call timeshift(arrtime,ts_days,0,ts_minutes, my_arrtime)
            kk = length (my_arrtime)
        }
        call smov   (EOS, my_arrtime, kk)

        #!------------------------------------------
        #! Get departure time
        kk = 0
        if (deptime[7] != $LETZ) 
        {
            call timeshift(deptime, ts_days, ts_hours, ts_minutes, my_deptime)
            kk = length (my_deptime)
        }
        else
        {
            call timeshift(deptime, ts_days, 0, ts_minutes, my_deptime)
            kk = length (my_deptime)
        }
        call smov   (EOS, my_deptime, kk)

        #!------------------------------------------
        #! Get airspace reference
        kk = 0
        call smovh (airspace, ARB, my_airspace, kk)
        call smov   (EOS, my_airspace, kk)
        call legit_name (my_airspace, legal_name)
        kk = 0
        call smovvn (legal_name, my_airspace, kk)
        call smov   (EOS, my_airspace, kk)

        #!------------------------------------------
        #! Get ordered altitude
        kk = 0
        call smovh (ordalt, ARB, my_ordalt, kk)
        call smov  (EOS, my_ordalt, kk)
        # Multiple ordered altitude by 100
        kk = 1
        ialt =  ctoi (my_ordalt, kk) * 100
        kk = 0
        call smovi (ialt, my_ordalt, kk)
        call smov  (EOS, my_ordalt, kk)

    }    
    if (equal_hv(keyword, "ARINFO") == YES)
    {
        # USMTF 2000 Sample
        #ARINFO/SUMO10/6013/36010/NAME:YELLOW/190/ARCT:161230I/NDAR:161241IAUG
        #/KLBS:11.0/-/-/ACTYP:KC130/WTD//

        # USMTF 2004 Sample
        #ARINFO/LEGACY01/0301E/B:30301/NAME:GREEN1-HI/250/ARCT:031223I
        #/NDAR:031235IJUN/KLBS:11.8/-/-/LY01/ACTYP:KC135R/CLD//

        isize = getatowrd (ato_rcd, ipos, ar_callsign)# 2 Tanker callsign
        isize = getatowrd (ato_rcd, ipos, ar_misn)    # 3 Tanker mission no.
        isize = getatowrd (ato_rcd, ipos, ar_iff)     # 4 IFF code
        isize = getatowrd (ato_rcd, ipos, airspace)   # 5 Control point
        isize = getatowrd (ato_rcd, ipos, ar_alt)     # 6  Altitude 
        isize = getatowrd (ato_rcd, ipos, arrtime)    # 7 Refuel time
        isize = getatowrd (ato_rcd, ipos, keyword)    # 7 End refuel time
        isize = getatowrd (ato_rcd, ipos, ar_fuelamt) # 8 Decimal fuel (thousands)

        #!------------------------------------------
        #! Get arrival time
        ic = index(arrtime, $COLON)
        kk = 0
        if (arrtime[ic+7] != $LETZ)
        {
            call timeshift(arrtime[ic+1],ts_days,ts_hours,ts_minutes,
                           ar_arrtime)
            kk = length (ar_arrtime)
        }
        else
        {
            call timeshift(arrtime[ic+1],ts_days,0,ts_minutes,
                           ar_arrtime)
            kk = length (ar_arrtime)
        }
        call smov   (EOS, ar_arrtime, kk)

        #!------------------------------------------
        #! Get departure time
        kk = 0
        if (deptime[7] != $LETZ) 
        {
            call timeshift(deptime,ts_days,ts_hours,ts_minutes, my_deptime)
            kk = length (my_deptime)
        }
        else
        {
            call timeshift(deptime,ts_days,ts_hours,0, my_deptime)
            kk = length (my_deptime)
        }
        call smov   (EOS, my_deptime, kk)

        #!------------------------------------------
        #! Get airspace reference
        kk = 0
        call smovh (airspace[5], ARB, ar_airspace, kk)  # Skip NAME:
        call smov   (EOS, ar_airspace, kk)
        call legit_name (ar_airspace, legal_name)
        kk = 0
        call smovvn (legal_name, ar_airspace, kk)
        call smov   (EOS, ar_airspace, kk)

        #!------------------------------------------
        #! Get ordered altitude
        kk = 0
        call smovh (ordalt, ARB, my_ordalt, kk)
        call smov  (EOS, my_ordalt, kk)
        # Multiple ordered altitude by 100
        kk = 1
        ialt =  ctoi (my_ordalt, kk) * 100
        kk = 0
        call smovi (ialt, my_ordalt, kk)
        call smov  (EOS, my_ordalt, kk)

    }    
    if (equal_hv(keyword, "GTGTLOC") == YES)
    {
        # USMTF 2000 Sample
        #GTGTLOC/P/-/NET:161335IAUG/NLT:161355I/PYONGYANG MPAF HQ MAIN HQ BLDG
        #/ID:0380-07643DD002/HQ/CTR W CNR E SHAPED MPAF BLDG
        #/DMPID:390334.2N1254412.3E/WGS 1984/-/K103AW/0006X//

        # USMTF 2004 Format
        #   1        2       3   4   5     6       7       8      9
        #GTGTLOC/designator/TOT/NET/NLT/Tgt name/Tgt ID/Tgt Type/DMPI desc/
        #            10            11              12           13
        #     point of impact/geodetic datum/impact elevation/component Tgt id/
        #       14        15           16        17
        #     tgt pri/tgt objective/L16 trkno/comments//

        # USMTF 2004 Sample
        #   1    2 3  4               5          6
        #GTGTLOC/P/-/NET:031040IJUN/NLT:031055I/PUKCHANG AFLD DISPERSED AMMO S
        #     7                 8       9
        #/ID:0380-08457PA006/AMMODP/F501KM AMMO STOR BLDG 5
        #    10                       11   12    13     14
        #/DMPIT:3930.9803N12558.4033E/WE/201FT/F501KM/00023//

        isize = getatowrd (ato_rcd, ipos, keyword)   # 2 Ignore p/a desig
        isize = getatowrd (ato_rcd, ipos, tot)       # 3 Time on Target
        isize = getatowrd (ato_rcd, ipos, net)       # 4 Not earlier than
        isize = getatowrd (ato_rcd, ipos, nlt)       # 5 Not Later Than
        isize = getatowrd (ato_rcd, ipos, keyword)   # 6 Ignore target name
        isize = getatowrd (ato_rcd, ipos, keyword)   # 7 Ignore target identifier
        isize = getatowrd (ato_rcd, ipos, keyword)   # 8 Ignore target type
        isize = getatowrd (ato_rcd, ipos, keyword)   # 9 Ignore DMPI desc
        isize = getatowrd (ato_rcd, ipos, dmpipos)   #10 DMPID position
        isize = getatowrd (ato_rcd, ipos, keyword)   #11 Ignore geodetic datum
        isize = getatowrd (ato_rcd, ipos, keyword)   #12 Ignore impact elevation
        isize = getatowrd (ato_rcd, ipos, tin)       #13 component target id
        my_tgt_count = my_tgt_count + 1
        #!------------------------------------------
        #! Get non-blank arrival time
        kk = 0
        if      (tot[1] != $minus) call smovh(tot, ARB, arrtime, kk)
        else if (net[1] != $minus) call smovh(net, ARB, arrtime, kk)
        else if (nlt[1] != $minus) call smovh(nlt, ARB, arrtime, kk)
        call smov (EOS, arrtime, kk)
        if (arrtime[11] != $LETZ)
        {
            call timeshift(arrtime[5],ts_days,ts_hours,ts_minutes,
                           my_tgt_tot[1,my_tgt_count])
            kk = length(my_tgt_tot[1, my_tgt_count])
        }
        else
        {
            call timeshift(arrtime[5],ts_days,0,ts_minutes,
                           my_tgt_tot[1,my_tgt_count])
            kk = length(my_tgt_tot[1, my_tgt_count])
        }
        call smov   (EOS, my_tgt_tot[1,my_tgt_count], kk)
        #!------------------------------------------
        #! Get target position
        call format_tgt_pos (dmpipos, fmt_lat, fmt_lon) 
        kk = 0
        call smovhn (fmt_lat, ARB, my_tgt_lat[1,my_tgt_count], kk)
        call smov   (EOS, my_tgt_lat[1,my_tgt_count], kk)
        kk = 0
        call smovhn (fmt_lon, ARB, my_tgt_lon[1,my_tgt_count], kk)
        call smov   (EOS, my_tgt_lon[1,my_tgt_count], kk)

        #!------------------------------------------
        #! Get tin
        kk = 0
        call smovh (tin, ARB, my_tgt_tin[1,my_tgt_count], kk)
        call smov  (EOS, my_tgt_tin[1,my_tgt_count], kk)
    }    
} # end repeat for file
8000
if (inMission == .true. & length(my_misn) != 0)
{
    call write_naval_mission(atoidL, auto_tlamC)
    call write_naval_mission_number(atoid)
    call  clear_mission_fields()
}

close(10)
if (auto_tlamC[1] != $LETY)
{
    close(14)
}


return
end

Subroutine write_naval_mission( atoidL, auto_tlamC )
BBcommon
MissionCommon

literal atoidL
literal cstrip8
character auto_tlamC[8]

BBDeclare(rte$pointer,rto$pointer,rto$wrd$index)
integer rteindx
real DMS2rad
character atoid[80]
character token[80]
character msg[80]
character aline[140]
character mission_type[80]
character sname[9]
literal   snameL
equivalence (sname,snameL)
integer shp$pointer, shp$pos$index
integer kk, k
integer i
integer length, ctoi
integer isize, ipos
integer getwrd, equal, fndrte
integer pct_ripple
integer getatowrd
integer fuel_lbs
integer iseq, icnt, nord

character as_radius[80]
character as_lat[80]
character as_lon[80]

character keyword[80]
vmschar*1 hemi

if (is_cm == 1)                 # Cruise missile mission
{
    kk = 0
    if (length(my_base) == 0) call smov ($POUND, aline, kk) # no selected base
    call smovv ("FOR ", aline, kk)
    call smovhn (my_base, ARB, aline, kk)
    call smovv (" CANCEL FIRE CRUISE ", aline, kk)
    call smovh (my_misn, ARB, aline, kk)
    call smov  (EOS, aline, kk)

    if (auto_tlamC[1] != $LETY)
        write (14, 9001) (aline[i],i=1,length(aline))
    else
        write (11, 9001) (aline[i],i=1,length(aline))

    kk = 0
    if (length(my_base) == 0) call smov ($POUND, aline, kk) # no selected base
    call smovv ("FOR ", aline, kk)
    call smovhn (my_base, ARB, aline, kk)
    if (auto_tlamC[1] != $LETY) call smov ($CNTLB, aline, kk) # Break into to kb
    call smovv (" FIRE ", aline, kk)
    call smovh (my_cnt, ARB, aline, kk)
    call smovv (" ", aline, kk)
    call smovh (my_cmtype, ARB, aline, kk)
    call smovv (" CRUISE AT POSITION ", aline, kk)
    call smovh (my_tgt_lat[1,1], ARB, aline, kk)
    call smovv (" ", aline, kk)
    call smovh (my_tgt_lon[1,1], ARB, aline, kk)
    call smovv (" MISSION ", aline, kk)
    call smovh (my_misn, ARB, aline, kk)

    if (length(my_ttype) != 0)
    {
        call smovv (" TARGET ", aline, kk)
        call smovh (my_ttype, ARB, aline, kk)
    }
    if (length(my_tgt_tin[1,1]) != 0)
    {
        call smovv (" BE NULL TIN ", aline, kk)
        call smovh (my_tgt_tin[1,1], ARB, aline, kk)
    }
    if (length(my_tgt_tot[1,1]) != 0)
    {
        call smovv (" TOT ", aline, kk)
        call smovh (my_tgt_tot[1,1], ARB, aline, kk)
    }
    call smov  (EOS, aline, kk)

    if (auto_tlamC[1] != $LETY)
        write (14, 9001) (aline[i],i=1,length(aline))
    else
        write (11, 9001) (aline[i],i=1,length(aline))

9001    format (140a1)

    return
}

#--------------------------------------------------------------------
#Creating route for flight plan allows gamers to modify mission using RESA orders
#Gamers are not trained to modify missions in routes so return to flight plan
#Code can be uncommented and re-organized to revert from flight plan to route

#Route Approach
# DELETE ROUTE
# DEFINE ROUTE
# SET IFF
# <flight plan>
# BINGO
# CANCEL SCRAMBLE
# SCRAMBLE
# LOAD
# EXECUTE ROUTE
# STOP

#Flight plan approach
# CANCEL SCRAMBLE
# SCRAMBLE
# LOAD
# SET IFF
# <flight plan>
# BINGO

kk = 0
call smovhn (atoidl, $$MaxLit, atoid, kk)
call smov  (EOS, atoid, kk)

#kk = 0
#call smovv ("DELETE ROUTE ", aline, kk)
#call smovh (my_misn, length(my_misn), aline, kk)
#call smovv (" ALL", aline, kk)
#call smov  (EOS, aline, kk)
#write (11, 9001) (aline[i],i=1,length(aline))

#kk = 0
#call smovv ("DEFINE ROUTE ", aline, kk)
#call smovh (my_misn, length(my_misn), aline, kk)
#call smovv (" BLUE 4", aline, kk)
#call smov  (EOS, aline, kk)
#write (11, 9001) (aline[i],i=1,length(aline))

kk = 0
call smovv ("FOR ", aline, kk)
call smovh (my_deploc, length(my_deploc), aline, kk)
call smovv (" CANCEL SCRAMBLE ", aline, kk)
call smovh (my_misn, length(my_misn), aline, kk)
call smovv (" ATOID ", aline, kk)
call smovh (atoid, length(atoid), aline, kk)
call smov  (EOS, aline, kk)
write (11, 9001) (aline[i],i=1,length(aline))

kk = 0
call smovv ("FOR ", aline, kk)
call smovh (my_deploc, length(my_deploc), aline, kk)
call smovv (" SCRAMBLE ", aline, kk)
call smovh (my_nacft, length(my_nacft), aline, kk)
call smovv (" ", aline, kk)
call smovh (my_actype, length(my_actype), aline, kk)
call smovv (" MISSION ", aline, kk)
call smovh (my_misn, length(my_misn), aline, kk)
call smovv (" ATOID ", aline, kk)
call smovh (atoid, length(atoid), aline, kk)
call smovv (" CALLSIGN ", aline, kk)
call smovh (my_callsign, length(my_callsign), aline, kk)
call smovv (" 90 300 ", aline, kk)
if (length(my_ordalt) != 0)
    call smovh (my_ordalt, length(my_ordalt), aline, kk)
else
    call smovv ("20000", aline, kk)
call smovv (" END ", aline, kk)
call smovh (my_arrtime, length(my_arrtime), aline, kk)
call smovv (" AT ", aline, kk)
# Subtract 4 hours from TOT to get lead time for launch time calc
call dtg_arith (my_arrtime, -4*60., my_leadtime)
call smovh (my_leadtime, length(my_leadtime), aline, kk)
call smov  (EOS, aline, kk)
write (11, 9001) (aline[i],i=1,length(aline))

if (length(my_scl) > 0)
{
    kk = 0
    call smovv ("LOAD ", aline, kk)
    call smovh (my_scl, length(my_scl), aline, kk)
    call smov  (EOS, aline, kk)
    write (11, 9001) (aline[i],i=1,length(aline))
}

# Used when flight plan in route
#kk = 0
#call smovv ("EXECUTE ROUTE ", aline, kk)
#call smovh (my_misn, length(my_misn), aline, kk)
#call smov  (EOS, aline, kk)
#write (11, 9001) (aline[i],i=1,length(aline))

#kk = 0
#call smovv ("STOP", aline, kk)
#call smov  (EOS, aline, kk)
#write (11, 9001) (aline[i],i=1,length(aline))

if (length(my_mtype) > 0)
{
	kk = 0
	call smovv ("MISSION ", aline, kk)
	call smovh (my_mtype, length(my_mtype), aline, kk)
	call smov  (EOS, aline, kk)
	write (11, 9001) (aline[i],i=1,length(aline))
}

if (length(my_iff1) > 0 | length(my_iff2) > 0 | length(my_iff3) > 0)
{
    kk = 0
    call smovv ("SET IFF ", aline, kk)
    if (length(my_iff1) > 0)
    {
        call smovv ("1 ", aline, kk)
        call smovh (my_iff1, length(my_iff1), aline, kk)
    }
    if (length(my_iff2) > 0)
    {
        call smovv (" 2 ", aline, kk)
        call smovh (my_iff2, length(my_iff2), aline, kk)
    }
    if (length(my_iff3) > 0)
    {
        call smovv (" 3 ", aline, kk)
        call smovh (my_iff3, length(my_iff3), aline, kk)
    }
    call smov  (EOS, aline, kk)
    write (11, 9001) (aline[i],i=1,length(aline))
}

if (length(my_ordalt) > 0)
{
    kk = 0
    call smovv ("ALTITUDE ", aline, kk)
    call smovh (my_ordalt, length(my_ordalt), aline, kk)
    call smov  (EOS, aline, kk)
    write (11, 9001) (aline[i],i=1,length(aline))
}

#-----------------------------------------------------------------
# Aircraft always activates radar
kk = 0
call smovv ("ACTIVATE RADAR", aline, kk)
call smov  (EOS, aline, kk)
write (11, 9001) (aline[i],i=1,length(aline))

#-----------------------------------------------------------------
# Refuel
# USMTF message
#ARINFO/SUMO10/6013/36010/NAME:YELLOW/190/ARCT:161230I/NDAR:161241IAUG
#/KLBS:11.0/-/-/ACTYP:KC130/WTD//

# RESA orders
#PROCEED POSITION N36-30-00 E124-45-00 AT 170630
#REFUEL CALLSIGN 6013 ONLOAD 11000

if (length(ar_fuelamt) > 0)
{
	snameL = $BLANKLIT
	call shorten_name(ar_airspace, sname)
	sname[length(sname)+1] = BLANK				# Convert string to literal(padded with spaces)

    rteindx = fndrte(snameL)
    if (rteindx == 0)
    {
        kk = 0
        call smovv ("Refueling Airspace ", msg, kk)
        call smovhn (ar_airspace, ARB, msg, kk)
        call smovv ("(", msg, kk)
        call smovh (snameL, $$MAXLIT, msg, kk)
        call smovv (")", msg, kk)
        call smovv (" not found for Mission ", msg, kk)
        call smovhn (my_misn, $$Maxlit, msg, kk)
        call smov  (EOS, msg, kk)
        print 9007, (msg[i], i=1,kk)
9007        format (1x,80a1) 
    }

    
    if (rteindx != 0)
    {
        kk = 0
        call smovv ("PROCEED POSITION ", aline, kk)

        # Convert control point name, my_airspace, to lat, lon
		rte$pointer$to rteindx

   		for (rto$pointer = Xrte$RTOPntr$i; rto$pointer$ok; rto$pointer$next)
		{
    		rto$wrd$index = 3           # Order Number
    		nord = Xrto$wrd$$c
			if (nord == ORBIT$order | nord == PROCEED$order)
				break
		}
 
        rto$wrd$index = 10
        if (Xrto$wrd$$c >= 0) hemi = "N"
        else                  hemi = "S"
        call smovlls (DMS2rad(Xrto$wrd$$c), hemi, aline, kk)
        call smovv (" ", aline, kk)

        rto$wrd$index = 11
        if (Xrto$wrd$$c >= 0) hemi = "E"
        else                  hemi = "W"
        call smovlls (DMS2rad(Xrto$wrd$$c), hemi, aline, kk)
        call smovv (" ", aline, kk)

        call smovv (" AT ", aline, kk)
        call smovh (ar_arrtime, ARB, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))
    
        kk = 0
        call smovv ("ALTITUDE ", aline, kk)
        call smovh (my_ordalt, ARB, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))
    
        kk = 0
        call smovv ("REFUEL CALLSIGN ", aline, kk)
        call smovh (ar_misn, ARB, aline, kk)
        call smovv (" ONLOAD ", aline, kk)
        k = 1
        fuel_lbs = ctoi (ar_fuelamt[6], k) * 1000
        call smovi (fuel_lbs, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))
    }
}
#-----------------------------------------------------------------
# execute route
# USMTF message
#AMSNLOC/250300IAUG/250530IAUG/F6/170//

# RESA orders
#PROCEED POSITION N36-30-00 E124-45-00 AT 170630
#EXECUTE ROUTE F6
#
if (length(my_airspace) > 0)
{
	snameL = $BLANKLIT
	call shorten_name(my_airspace, sname)
	sname[length(sname)+1] = BLANK				# Convert string to literal(padded with spaces)
    rteindx = fndrte(snameL)

    if (rteindx == 0)
    {
        kk = 0
        call smovv ("!Airspace ", msg, kk)
        call smovhn (my_airspace, ARB, msg, kk)
        call smovv ("(", msg, kk)
        call smovh (snameL, $$MAXLIT, msg, kk)
        call smovv (")", msg, kk)
        call smovv (" not found for Mission ", msg, kk)
        call smovhn (my_misn, $$Maxlit, msg, kk)
        call smov  (EOS, msg, kk)
        print 9007, (msg[i], i=1,length(msg))
        write (11, 9001) (msg[i],i=1,length(msg))    # Send msg to terminal

        kk = 0
        call smovv ("#PROCEED POSITION ", aline, kk)
        # Convert control point name, my_airspace, to lat, lon
 		call smovv ("<first airspace pos> ", aline, kk)
        call smovv (" PAT ", aline, kk)
        call smovh (my_arrtime, ARB, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))
    
        kk = 0
        call smovv ("#EXECUTE ROUTE ", aline, kk)
        call shorten_name (my_airspace, sname)
        call smovhn (sname, ARB, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))

        # If no airspace, hover over launching platform
        kk = 0
        call smovv ("STATION 0 ", aline, kk)
        call smovhn (my_base, ARB, aline, kk)
        call smovv (" 0", aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))

    }
    
    if (rteindx != 0)
    {
        kk = 0
        call smovv ("PROCEED POSITION ", aline, kk)
        # Convert control point name, my_airspace, to lat, lon
		rte$pointer$to rteindx
		rto$pointer = Xrte$rtoPntr$i

   		for (rto$pointer = Xrte$RTOPntr$i; rto$pointer$ok; rto$pointer$next)
		{
    		rto$wrd$index = 3           # Order Number
    		nord = Xrto$wrd$$c
			if (nord == ORBIT$order | nord == PROCEED$order)
				break
		}
 
        rto$wrd$index = 10			# Latitude
        if (Xrto$wrd$$c >= 0) hemi = "N"
        else                  hemi = "S"
        call smovlls (DMS2rad(Xrto$wrd$$c), hemi, aline, kk)
        call smovv (" ", aline, kk)

        rto$wrd$index = 11			# Longitude
        if (Xrto$wrd$$c >= 0) hemi = "E"
        else                  hemi = "W"
        call smovlls (DMS2rad(Xrto$wrd$$c), hemi, aline, kk)
        call smovv (" ", aline, kk)

        #shp$pos$index = 1
        #if (Xshp$POS$Latitude$f >= 0) hemi = "N"
        #else                          hemi = "S"
        #call smovlls (Xshp$POS$Latitude$f, hemi, aline, kk)
        #call smovv (" ", aline, kk)
        #if (Xshp$POS$Longitude$f >= 0) hemi = "E"
        #else                           hemi = "W"
        #call smovlls (Xshp$POS$Longitude$f, hemi, aline, kk)

        call smovv (" PAT ", aline, kk)
        call smovh (my_arrtime, ARB, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))
    
        kk = 0
        call smovv ("EXECUTE ROUTE ", aline, kk)
        call shorten_name (my_airspace, sname)
        call smovhn (sname, ARB, aline, kk)
        call smov  (EOS, aline, kk)
        write (11, 9001) (aline[i],i=1,length(aline))
    }
}    
#-----------------------------------------------------------------
# Ripple order based on number of strike positions
if (my_tgt_count > 1)
{
    pct_ripple = 100 / my_tgt_count
    kk = 0
    call smovv ("RIPPLE ", aline, kk)
    call smovi (pct_ripple, aline, kk)
    call smovv (" PERCENT", aline, kk)
    call smov  (EOS, aline, kk)
    write (11, 9001) (aline[i],i=1,length(aline))
}
#-----------------------------------------------------------------
# Strike position orders

for (k = 1; k <= my_tgt_count; k = k + 1)
{
    if (k == my_tgt_count)
    {
    kk = 0
    call smovv ("RIPPLE 100 PERCENT", aline, kk)
    call smov  (EOS, aline, kk)
    write (11, 9001) (aline[i],i=1,length(aline))
    }
    
    kk = 0
    call smovv ("STRIKE POSITION ", aline, kk)
    call smovh (my_tgt_lat[1,k], ARB, aline, kk)
    call smovv (" ", aline, kk)
    call smovh (my_tgt_lon[1,k], ARB, aline, kk)

    if (my_tgt_tin[1,k] != EOS)
    {
        call smovv (" BE NULL TIN ", aline, kk)
        call smovh (my_tgt_tin[1,k], ARB, aline, kk)
    }
    call smovv (" TOT ", aline, kk)
    call smovh (my_tgt_tot[1,k], length(my_tgt_tot[1,k]), aline, kk)
    call smov  (EOS, aline, kk)
    write (11, 9001) (aline[i],i=1,length(aline))
}

kk = 0
call smovv ("BINGO", aline, kk)
if (length(my_arrloc) > 0)
{
    call smovv (" TO ", aline, kk)
    call smovh (my_arrloc, length(my_arrloc), aline, kk)
}
if (length(my_deptime) > 0)
{
    call smovv (" AT ", aline, kk)
    call smovh (my_deptime, length(my_deptime), aline, kk)
}
call smov  (EOS, aline, kk)
write (11, 9001) (aline[i],i=1,length(aline))

return
end

Subroutine write_naval_mission_number( atoidL )
# Write ATO mission number+ for comparison with missions internal to RESA  
implicit none
MissionCommon

literal atoidL

character aline[120]
integer kk, i
integer length

kk = 0
call smovh (my_misn, length(my_misn), aline, kk)
call smov  (EOS, aline, kk)
write (12, 9001) (aline[i],i=1,length(aline))
9001    format (120a1)

return
end


Subroutine Open_Mission_List (ato_root, atoid, atoid_update, mlfile)
implicit none

vaxcharacter*(*) mlfile

character ato_root[80]
literal atoid
integer atoid_update
integer return_val, name_len
character  file_name[ARB]
vmschar*ARB file_name_v
equivalence(file_name, file_name_v)

file_name_v = ""
name_len = 0
call smovhn  (ato_root, ARB, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovhn (atoid, $$MaxLit, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovi  (atoid_update, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovv  (mlfile, file_name, name_len)


open(unit    =   12,                  #open output file
     file    =   file_name_v,
     status  =  'unknown',
     access  =  'sequential',
     recl    =   120,
     iostat  =   return_val)

if (return_val != 0)
{
    print *, "Unable to open mission list file ", file_name_v
    return
}

return
end


Subroutine Open_Mission_Output (ato_root, atoid, atoid_update, nmfile)
implicit none

vaxcharacter*(*) nmfile
character ato_root[80]
literal atoid
integer atoid_update
integer return_val, name_len
character  file_name[ARB]
vmschar*ARB file_name_v
equivalence(file_name, file_name_v)

file_name_v = ""
name_len = 0
call smovhn  (ato_root, ARB, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovhn (atoid, $$MaxLit, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovi  (atoid_update, file_name, name_len)
call smovv  ("/", file_name, name_len)
call smovv  (nmfile, file_name, name_len)

open(unit    =   11,                  #open output file
     file    =   file_name_v,
     status  =  'unknown',
     access  =  'sequential',
     recl    =   140,
     iostat  =   return_val)

if (return_val != 0)
{
    print *, "Unable to open naval missions file", file_name_v
    return
}


return
end


Subroutine clear_mission_fields()
implicit none
MissionCommon
integer kk
integer i

kk = 0; call smov(EOS, my_misn, kk)
kk = 0; call smov(EOS, my_mtype, kk)
kk = 0; call smov(EOS, my_deploc, kk)
kk = 0; call smov(EOS, my_arrloc, kk)
kk = 0; call smov(EOS, my_nacft, kk)
kk = 0; call smov(EOS, my_actype, kk)
kk = 0; call smov(EOS, my_callsign, kk)
kk = 0; call smov(EOS, my_scl, kk)
kk = 0; call smov(EOS, my_iff1, kk)
kk = 0; call smov(EOS, my_iff2, kk)
kk = 0; call smov(EOS, my_iff3, kk)
kk = 0; call smov(EOS, my_arrtime, kk)
kk = 0; call smov(EOS, my_deptime, kk)
kk = 0; call smov(EOS, my_airspace, kk)
kk = 0; call smov(EOS, my_ordalt, kk)
kk = 0; call smov(EOS, my_base, kk)
for(i=1;i<=my_tgt_count;i=i+1)
{
    kk = 0; call smov(EOS, my_tgt_tot[1,i], kk)
    kk = 0; call smov(EOS, my_tgt_lat[1,i], kk)
    kk = 0; call smov(EOS, my_tgt_lon[1,i], kk)
    kk = 0; call smov(EOS, my_tgt_tin[1,i], kk)
}
kk = 0; call smov(EOS, my_cnt, kk)
kk = 0; call smov(EOS, my_cmtype, kk)
kk = 0; call smov(EOS, my_ttype, kk)
kk = 0; call smov(EOS, ar_callsign, kk)
kk = 0; call smov(EOS, ar_misn, kk)
kk = 0; call smov(EOS, ar_iff, kk)
kk = 0; call smov(EOS, ar_arrtime, kk)
kk = 0; call smov(EOS, ar_airspace, kk)
kk = 0; call smov(EOS, ar_alt, kk)
kk = 0; call smov(EOS, ar_fuelamt, kk)
my_tgt_count = 0            # for GTGTLOC message count
is_cm = 0                   # for MTGTLOC

return
end


Subroutine convert_mission_type (ato_mtype, my_mtype)

implicit none
character ato_mtype[80], my_mtype[80]
integer kk, equal_hv

# my        ato

# AD                        # Air Defense(R)
# AEW       AEW             # Airborne Early Warning
# AI        AI              # Air Interdiction
# ALFT      SAAM            # Special Assignment Airlift Mission
# ALFT      TAL             # Theater Airlift
# ASW       ASW             # AntiSubmarine Warfare
# BAI       BAI             # Battlefield Air Interdiction
# CAP       CAP             # Combat Air Patrol
# CAP       FCAP            # Force Protection Combat Air Patrol
# CAP       ICAP            # Ingress Combat Air Patrol
# CAP       PCAP            # Point Combat Air Patrol
# CAP       XCAP            # Air Alert Combat Air Patrol
# CAS       RCAS            # Rear Area CAS
# CAS       XCAS            # Airborne Alert Close Air Support
# DCA       DCA             # Airborne Alert Defensive CounterAir
# DCA       XDCA            # Airborne Alert Defensive CounterAir
# DECOY                     # Decoy
# ESCORT    ESC             # Escort
# ESCORT    XESC            # Airborne Alert Escort
# EW        EW              # Electronic Warfare
# EW        EWS             # Electronic Warfare Support
# EW        XEW             # Airborne Alert Electronic Warfare
# FY        VIPLF           # Very Important Person Lift
# JAMMER    SEAD            # Suppression Enemy Air Defenses
# MP                        # Maritime Patrol(R)
# OCA       OCA             # Offensive Counter Air
# RECONN    REC             # Reconnaissance
# RECONN    SCP             # Airborne Alert Reconnaissance
# RECONN    XREC            # Airborne Alert Reconnaissance
# RELAY     COMM            # Comms Relay(R)
# RESCUE    RSC             # Rescue
# SEARCH    CSAR            # Combat Search and Rescue
# SEARCH    SAR             # Search and Rescue
# SEARCH    XSAR            # Airborne Alert Search and Rescue
# SM        SOF             # Special Operations Forces
# SM        SOP             # Special Operations
# SM        SPECL           # Special Mission(R)
# SM        XSOF            # Airborne Alert Special Operations Forces
# STRCAP    BRCAP           # Barrier Combat Air Patrol
# STTANKER  XAR             # Airborne Alert Aerial Refueling
# STRIKE    ATK             # Attack
# STRIKE    TALD            # Tactical Air Land Assault
# STRIKE    XATK            # Airborne Alert Attack
# STRIKE    OAS             # Offensive Air Support
# SURCAP    SUCAP           # Surface Combat Air Patrol
# SURVEILLANCE JSTARS       # Joint Surveillance Target Attack Radar System
# SW        SWEP            # Air to Air Sweep
# TANKER    AR              # Aerial Refueling
# TASMO                     # TASMO(R)
# TEW       TAC             # Tactical Electronic Warfare(R)
# WW        WW              # Wild Weasel
# WW        XWW             # Airborne Alert Wild Weasel

define ($convert_mission,if (equal_hv(ato_mtype,@1) == YES)call smovv(@2,my_mtype, kk))

kk = 0
$convert_mission("AEW",   "AEW")
$convert_mission("XAEW",  "AEW")
$convert_mission("XINT",  "AI")
$convert_mission("AI",    "AI")
$convert_mission("SAAM",  "ALFT")
$convert_mission("TAL",   "ALFT")
$convert_mission("ASW",   "ASW")
$convert_mission("XASW",  "ASW")
$convert_mission("BAI",   "BAI")
$convert_mission("CAP",   "CAP")
$convert_mission("FCAP",  "CAP")
$convert_mission("ICAP",  "CAP")
$convert_mission("PCAP",  "CAP")

$convert_mission("XCAP",  "CAP")
$convert_mission("RCAS",  "CAS")
$convert_mission("XCAS",  "CAS")
$convert_mission("DCA",   "DCA")
$convert_mission("XDCA",  "DCA")
$convert_mission("ESC",   "ESCORT")
$convert_mission("EA",    "EW")
$convert_mission("EW",    "EW")
$convert_mission("EWS",   "EW")
$convert_mission("XEW",   "EW")

$convert_mission("VIPLF", "FY")
$convert_mission("SEAD",  "JAMMER")
$convert_mission("OCA",   "OCA")
$convert_mission("REC",   "RECONN")
$convert_mission("SCP",   "RECONN")
$convert_mission("XSCP",  "RECONN")
$convert_mission("XREC",  "RECONN")
$convert_mission("COMM",  "RELAY")
$convert_mission("RSC",   "RESCUE")
$convert_mission("CSAR",  "SEARCH")

$convert_mission("SAR",   "SEARCH")
$convert_mission("XSAR",  "SEARCH")
$convert_mission("SOF",   "SM")
$convert_mission("SOP",   "SM")
$convert_mission("SPECL", "SM")
$convert_mission("XSOF",  "SM")
$convert_mission("BRCAP", "STRCAP")
$convert_mission("ATK",   "STRIKE")
$convert_mission("TALD",  "STRIKE")
$convert_mission("XATK",  "STRIKE")
$convert_mission("OAS",   "STRIKE")
$convert_mission("SUCAP", "SURCAP")
$convert_mission("JSTARS","SURVEILLANCE")
$convert_mission("SWEP",  "SW")
$convert_mission("AR",    "TANKER")
$convert_mission("XAR",   "STTANKER")
$convert_mission("TAC",   "TEW")
$convert_mission("WW",    "WW")
$convert_mission("XWW",   "WW")

#if (kk == 0)                        # Default mission type is none
#    call smovv ("NONE", my_mtype, kk)

call smov (EOS, my_mtype, kk)


return
end

subroutine scl_translate (scl, my_scl)
Implicit None
WeaponCommon
integer aw$pointer
# 4G31X3A2W1 = [ 4 G31, 3 A, 2 1, 1 external tank ]

character scl[16]
character my_scl[120]
character weapon_name[10]
character msg[80]
character file_name[80]
character keyword[80]
integer kk, mm
integer j, jj
integer i
integer length, ctoi, equal, equal_hv
integer getatowrd, lenline
integer at_count, nbrwep, return_val, isize, amt
integer weapon_find
integer lscl, ntank


# Basic format is nA where
#      n is a single digit number of weapon load count
#      A is a single letter designating type of weapon
# Exceptions
#      If weapon designation is more the one letter, it is terminated by X
#      If string terminates with number and prior char is a letter,
#            indicates number of external tanks

call upper (scl)
mm = 0
if (equal_hv (scl,"BEST") == YES)
{
    call smov  (EOS, my_scl, mm)
    return
}

# First character must be numeric.  Eliminates boom, drogue, - found
if (scl[1] < $DIG0 | scl[1] > $DIG9)
{
    call smov  (EOS, my_scl, mm)
    return
}

at_count = 1
i = 1
lscl = length(scl)
ntank = 0

# Numeric last char is number of fuel tanks if prior char is a letter
if (scl[lscl] >= $DIG1 & scl[lscl] <= $DIG9 &
    scl[lscl-1] >= $LETA & scl[lscl-1] <= $LETZ)
{
    ntank = ctoi(scl,lscl)
    lscl = lscl - 1 
}

while (i<=lscl)
{
    if (at_count == 1)
    {
        # Check for prior X with implied number 1
        if (i > 1)
        {
            if (scl[i-1] == $LETX)
            {
                if (scl[i] >= $LETA & scl[i] <= $LETZ)
                {
                    nbrwep = 1
                    at_count = 0 
                    next
                }
            }
        }
        # Skip to first numberic character
        while ((scl[i] < $DIG0 | scl[i] > $DIG9) & i <= lscl) i=i+1
        if (i > lscl) break
        nbrwep = ctoi (scl, i)    
        at_count = 0
    }
    else
    {    
        if ((scl[i+2] >= $DIG0 & scl[i+2] <= $DIG9) | scl[i+2] == $LETX) # long weapon name
        {
            jj = i + 1
            while (scl[jj] != $LETX & jj <= lscl) jj = jj + 1
            kk = 0
            call smovh (scl[i], jj - i, weapon_name, kk)
            call smov  (EOS, weapon_name, kk)
            i = jj + 1
        }        
        else if ((scl[i+1] >= $LETA & scl[i+1] <= $LETZ) &
                 (scl[i+2] >= $LETA & scl[i+2] <= $LETZ))
        {
            jj = i + 1
            while (scl[jj] != $LETX & jj <= lscl) jj = jj + 1
            kk = 0
            call smovh (scl[i], jj - i, weapon_name, kk)
            call smov  (EOS, weapon_name, kk)
            i = jj + 1
        }        
        else
        {
            kk = 0
            call smov (scl[i], weapon_name, kk)
            call smov (EOS, weapon_name,kk)            
            i = i + 1
        }
        aw$pointer = weapon_find(weapon_name)
        if (aw$pointer != 0)
        {
            if (length(Xaw$ModelName$c) != 0)
            {
                call smovi (nbrwep, my_scl, mm)
                call smovv (" ", my_scl, mm)
                call smovh (Xaw$ModelName$c, ARB, my_scl, mm)
            }
        }
        else
        {
            #call smovh (weapon_name, ARB, my_scl, mm)
            print 9007, "ATO Weapon not mapped: ",
                        (weapon_name[j],j=1,length(weapon_name))
            print 9007, " in SCL: ",
                        (scl[j],j=1,length(scl))
9007        format(1x, A, 40A1)
        }
        if (i < lscl) call smovv (" ", my_scl, mm)

        at_count = 1
        nbrwep = 0
    }
} #end SCL loop

if (ntank > 0)     # SCL has trailing number
{
    amt = ntank * 2300
    call smovv (" ", my_scl, mm)
    call smovi (amt, my_scl, mm)        
    call smovv (" JP", my_scl, mm)
}

call smov  (EOS, my_scl, mm)

return
end


Subroutine countrycode_load
implicit none
countrycodeCommon

integer name_len
integer return_val
integer k, kk
integer lenline
character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)
character cc_rcd[400]
vmschar*400  cc_rcd_v
equivalence(cc_rcd, cc_rcd_v)
integer ipos, isize
integer getwrd
character keyword[80]
integer cc$pointer
integer i

name_len = 0
call smovv  ("atocountrycode.dat", file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open atoairmap.dat"
    return
}

cc$pointer = 0
repeat
{
    #$% get line of input from resa formatted country code definitions
    read (10,9001,END=8000) cc_rcd_v
    lenline = len_trim(cc_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, cc_rcd, k)
    call upper (cc_rcd)
    ipos = 1        
    call skipbl (cc_rcd, ipos)
    if (cc_rcd[ipos] == $EXCLAIM | cc_rcd[ipos] == $POUND) next

    isize = getwrd (cc_rcd, ipos, cc$ATOName$c)
    cc$pointer$next
    PUTcc$ATOName$c
}
8000

PUTcc$used$i (cc$pointer)

close(10)
return
end


integer function countrycode_find(countrycode)
implicit none
CountryCodeCommon
character  countrycode[80]
integer cc$Pointer
integer length
integer equal
integer kk

for (cc$Pointer$First; cc$Pointer$OK; cc$Pointer$Next)
{
    if (equal(countrycode, Xcc$ATOName$C) == YES) break
}

if (!cc$Pointer$OK) cc$pointer = 0

countrycode_find = cc$pointer

return
end

Subroutine airtype_load
implicit none
AirtypeCommon

integer name_len
integer return_val
integer k, kk
integer lenline
character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)
character at_rcd[400]
vmschar*400  at_rcd_v
equivalence(at_rcd, at_rcd_v)
integer ipos, isize
integer getwrd
character keyword[80]
integer at$pointer
integer i

name_len = 0
call smovv  ("atoairmap.dat", file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open atoairmap.dat"
    return
}

at$pointer = 0
repeat
{
    #$% get line of input from resa formatted airspace definitions
    read (10,9001,END=8000) at_rcd_v
    lenline = len_trim(at_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, at_rcd, k)
    call upper (at_rcd)
    ipos = 1        
    call skipbl (at_rcd, ipos)
    if (at_rcd[ipos] == $EXCLAIM | at_rcd[ipos] == $POUND) next

    isize = getwrd (at_rcd, ipos, at$ATOName$c)
    isize = getwrd (at_rcd, ipos, at$ModelName$c)
    at$pointer$next
    PUTat$ATOName$c
    PUTat$ModelName$c
}
8000

PUTat$used$i (at$pointer)

close(10)
return
end

Subroutine airtype_map(airtype)
implicit none
AirtypeCommon
character  airtype[80]
integer at$Pointer
integer length
integer equal
integer kk

for (at$Pointer$First; at$Pointer$OK; at$Pointer$Next)
{
    if (equal(airtype, Xat$ATOName$C) == YES) break
}

if (at$Pointer$OK)
{
    kk = 0
    call smovhn(Xat$ModelName$c, $$maxlit, airtype, kk)
    call smov(EOS, airtype, kk)
}

return
end


Subroutine airbase_load
implicit none
AirbaseCommon

integer name_len
integer return_val
integer k, kk
integer lenline
character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)

character ab_rcd[400]
vmschar*400 ab_rcd_v
equivalence(ab_rcd, ab_rcd_v)

integer ipos, isize
integer getwrd
character keyword[80]
integer ab$pointer
integer i

name_len = 0
call smovv  ("atobasemap.dat", file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open atobasemap.dat"
    return
}

ab$pointer = 0

repeat
{
    #$% get line of input from resa formatted airspace definitions
    read (10,9001,END=8000) ab_rcd_v
    lenline = len_trim(ab_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, ab_rcd, k)
    call upper (ab_rcd)

    ipos = 1        
    call skipbl (ab_rcd, ipos)
    if (ab_rcd[ipos] == $EXCLAIM | ab_rcd[ipos] == $POUND) next

    isize = getwrd (ab_rcd, ipos, ab$ATOName$c)
    isize = getwrd (ab_rcd, ipos, ab$ModelName$c)
    ab$pointer$next
    PUTab$ATOName$c
    PUTab$ModelName$c
}
8000

PUTab$used$i (ab$pointer)

close(10)
return
end

integer function airbase_find(airbase)
implicit none
AirbaseCommon
character  airbase[80]
integer ab$Pointer
integer length
integer equal
integer kk

for (ab$Pointer$First; ab$Pointer$OK; ab$Pointer$Next)
{
    if (equal(airbase, Xab$ATOName$C) == YES) break
}

if (!ab$Pointer$OK) ab$pointer = 0

airbase_find = ab$pointer

return
end

Subroutine weapon_load
implicit none
WeaponCommon

integer name_len
integer return_val
integer k, kk
integer lenline
character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)

character aw_rcd[400]
vmschar*400  aw_rcd_v
equivalence(aw_rcd, aw_rcd_v)

integer ipos, isize
integer getwrd
character keyword[80]
integer aw$pointer
integer i

name_len = 0
call smovv  ("atoweaponmap.dat", file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open atoweaponmap.dat"
    return
}

aw$pointer = 0

repeat
{
    #$% get line of input from resa formatted airspace definitions
    read (10,9001,END=8000) aw_rcd_v
    lenline = len_trim(aw_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, aw_rcd, k)
    call upper (aw_rcd)

    ipos = 1        
    call skipbl (aw_rcd, ipos)
    if (aw_rcd[ipos] == $EXCLAIM | aw_rcd[ipos] == $POUND) next

    isize = getwrd (aw_rcd, ipos, aw$ATOName$c)
    isize = getwrd (aw_rcd, ipos, aw$ModelName$c)
    aw$pointer$next
    PUTaw$ATOName$c
    PUTaw$ModelName$c
}
8000

PUTaw$used$i (aw$pointer)

close(10)
return
end


Subroutine cmShooter_select (shortest_unt)
BBcommon
MissionCommon

literal cstrip8
integer k, kk
integer needcm
integer ctoi, litcmp, equal
integer nfound, eqlist[5,ARB]
integer shortest_unt, error
integer ifind, n
integer ntlam_allocated[unt$slots]

real    range, brng, shortest_range
real    tgtlat, tgtlon

bbdeclare (unt$pointer, unt$view$i)
bbdeclare (cmc$pointer)
bbdeclare (deq$pointer)

character cmctype[10]

data ntlam_allocated/unt$slots*0/

shortest_range = 999999.0
shortest_unt   = 0

# Find units with TLAMS
for (unt$pointer$first; unt$pointer$ok; unt$pointer$next)
{
    if (Xunt$Status$I == $BeingDeleted$Code) next

    unt$view$i = Xunt$view$i
    if (unt$view$i < $FirstBlue$View | unt$view$i > $LastBlue$View) next

    nfound = 0       
    call DEQGET(UNT$Pointer,
                $CruiseMissile$Code,           # send ident code
                nfound,                       # send/receive nbr items fnd
                eqlist)                       # send/receive list of EQ

    if (nfound == 0) next                     #if equipment NOT found

    iFind = $NO
    k = 1; needcm = ctoi(my_cnt, k)

    For (N=1; N <= nfound; N =N +1)
    {
        CMC$Pointer = eqlist[2,N]
        k = 0; call smovhn (Xcmc$Type$c, $$MaxLit, cmctype, k)
        call smov (EOS, cmctype, k)
        if (equal( my_cmtype, cmctype ) == YES)
        {
            DEQ$Pointer$To  (eqlist[1,N])
            if ((xDEQ$Remaining$I - ntlam_allocated[unt$pointer$index]) < 
                 needcm) next
            iFind = $YES
            break
        }
    }
    if (ifind == $NO) next          # No cmtype or not enough

#    if (xUNT$Type$I == $Sub$Code &                  # if shooter is a sub and
#    xUNT$TrueAltDepth$I > xCMC$LaunchDepth$I) next  # below launch depth

    # Convert position from string to radians(N,E are flags for lat lon)
    call cvt_DMS_Rad (my_tgt_lat[1,1], tgtlat, Error) 
    call cvt_DMS_Rad (my_tgt_lon[1,1], tgtlon, Error) 

    # Get range to impact position
    call RLL2RB( _        #Rhumb line Lat/Lon to Range/Bearing
                   Xunt$TrueLatitude$f,
                   Xunt$TrueLongitude$f,
                   cos(Xunt$TrueLatitude$f),
                   tgtlat,
                   tgtlon,
                   cos(tgtlat),
                   RANGE,
                   BRNG   )

    # Skip if beyond missile range
    if (range > (xCMC$MaxFlightDur$I*Xcmc$avgSpeed$i*$Hours$Per$Minute)) next
 
    # Keep unit with shortest range to impact position
    if (range < shortest_range)
    {
        shortest_range = range
        shortest_unt = unt$pointer
    }
}


# Keep track of tlams allocated for this ato update
if (shortest_unt > 0)
{
    unt$pointer = shortest_unt
    ntlam_allocated[unt$pointer$index] = ntlam_allocated[unt$pointer$index] + 
                                         needcm
}

return
end


integer function weapon_find(weapon)
implicit none
WeaponCommon
character  weapon[80]
integer aw$Pointer
integer length
integer equal
integer kk

for (aw$Pointer$First; aw$Pointer$OK; aw$Pointer$Next)
{
    if (equal(weapon, Xaw$ATOName$C) == YES) break
}

if (!aw$Pointer$OK) aw$pointer = 0

weapon_find = aw$pointer

return
end

Subroutine load_load        # Aircraft load augmentation by actype and mission
implicit none
LoadCommon

integer name_len
integer return_val
integer k, kk
integer lenline

character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)

character al_rcd[400]
vmschar*400 al_rcd_v
equivalence(al_rcd, al_rcd_v)

integer ipos, isize
integer getwrd
character keyword[80]
integer al$pointer
integer i

name_len = 0
call smovv  ("atoloadaugment.dat", file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open atoloadaugment.dat"
    return
}

al$pointer = 0

repeat
{
    #$% get line of input from resa formatted airspace definitions
    read (10,9001,END=8000) al_rcd_v
    lenline = len_trim(al_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, al_rcd, k)
    call upper (al_rcd)

    ipos = 1        
    call skipbl (al_rcd, ipos)
    if (al_rcd[ipos] == $EXCLAIM | al_rcd[ipos] == $POUND) next

    isize = getwrd (al_rcd, ipos, al$AirType$c)
    isize = getwrd (al_rcd, ipos, al$Mission$c)
    # Copy rest of line containing load info
    call skipbl (al_rcd, ipos)
    kk = 0
    call smovh(al_rcd[ipos],ARB, al$Load$c, kk)
    call smov (EOS, al$Load$c, kk)

    al$pointer$next
    PUTal$AirType$c
    PUTal$Mission$c
    PUTal$Load$c
}
8000

PUTal$used$i (al$pointer)

close(10)
return
end

integer function load_find(AirType, Mission)
implicit none
LoadCommon
character  AirType[80]
character  Mission[80]
character  Match_AirType[80]
character  Match_Mission[80]
integer al$Pointer
integer length
integer equal, equal_hv
integer kk
integer match_level
integer hold_pointer

kk = 0
call smov( EOS, match_AirType, kk)
kk = 0
call smov( EOS, match_Mission, kk)

match_level = 5
hold_pointer = 0

# Find most specific match
for (al$Pointer$First; al$Pointer$OK; al$Pointer$Next)
{
    #  5   4          3              2                1   (match level)
    # () (* *) or (* Mission) or (AirType *) or (Airtype Mission)
    if (equal(AirType, Xal$Airtype$C) == YES & equal(Mission, Xal$Mission$c) == YES)
    {
        match_level = 1
        hold_pointer = al$pointer
        break
    }
    else if (equal(Airtype, Xal$Airtype$C) == YES & equal_hv(Xal$Mission$c, "*") == YES &
             match_level > 2)
    {
        match_level = 2
        hold_pointer = al$pointer
    }
    else if (equal_hv(Xal$Airtype$C, "*") == YES & equal(Mission, Xal$Mission$c) == YES &
             match_level > 3)
    {
        match_level = 3
        hold_pointer = al$pointer
    }
    else if (equal_hv(Xal$Airtype$C, "*") == YES & equal_hv(Xal$Mission$c, "*") == YES &
             match_level > 4)
    {
        match_level = 4
        hold_pointer = al$pointer
    }
}

load_find = hold_pointer

return
end

Subroutine timeshift_load
implicit none
TimeShiftCommon

integer name_len
integer return_val
integer k, kk
integer lenline
character file_name[50]
vmschar*50 file_name_v
equivalence(file_name, file_name_v)

character ts_rcd[400]
vmschar*400 ts_rcd_v
equivalence(ts_rcd, ts_rcd_v)

integer ipos, isize
integer ctoim
character keyword[80]
integer i

# Default is no time shift
ts_days = 0
ts_hours = -9           # India to Zulu
ts_minutes = 0

name_len = 0
call smovv  ("atotimeshift.dat", file_name, name_len)
call smov   (EOS, file_name, name_len)
open(unit    =   10,                            #open input file
    file    =   file_name_v,
    status  =  'old',
    access  =  'sequential',
    recl    =   120,
    iostat  =   return_val)

if (return_val != 0)
{
    print *, "unable to open atotimeshift.dat"
    return
}

repeat
{
    #$% get line of input from resa formatted airspace definitions
    read (10,9001,END=8000) ts_rcd_v
    lenline = len_trim(ts_rcd_v)
9001    format(a)
    k = lenline
    call smov (EOS, ts_rcd, k)
    call upper (ts_rcd)

    ipos = 1        
    call skipbl (ts_rcd, ipos)
    if (ts_rcd[ipos] == $EXCLAIM | ts_rcd[ipos] == $POUND) next

    ts_days = ctoim (ts_rcd, ipos)
    ts_hours = ctoim (ts_rcd, ipos)
    ts_minutes = ctoim (ts_rcd, ipos)
    break                               # Only one record processed
}
8000

close(10)
return
end

Subroutine format_tgt_pos (tgt_pos, fmt_lat, fmt_lon)
implicit none
character tgt_pos[ARB]
character fmt_lat[ARB]
character fmt_lon[ARB]
character deg_fract[20]
integer kk, k
integer index, ctoi
integer lon_pos, hemi_pos
integer  i_switch_1  # SMM 3/00
real*4  deg_f, sec_f
integer isec, isec_f

switch (tgt_pos[5])
{
    case $LETS:             # ddmmssNdddmmss
    {
        kk = 0
        call smovh (tgt_pos[7], 2,  fmt_lat, kk)  # deg
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[9], 2,  fmt_lat, kk)  # min
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[11], 2, fmt_lat, kk)  # sec
        call smov  (tgt_pos[13],    fmt_lat, kk)  # hemi
        call smov  (EOS,            fmt_lat, kk) 
        kk = 0
        call smovh (tgt_pos[14], 3, fmt_lon, kk)  # deg
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[17], 2, fmt_lon, kk)  # min
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[19], 2, fmt_lon, kk)  # sec
        call smov  (tgt_pos[21],    fmt_lon, kk)  # hemi
        call smov  (EOS,            fmt_lon, kk) 
    }    

    case $LETM:             # ddmmNdddmmE
    {
        kk = 0
        call smovh (tgt_pos[7], 2,  fmt_lat, kk)  # deg
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[9], 2,  fmt_lat, kk)  # min
        call smov  (tgt_pos[11],    fmt_lat, kk)  # hemi
        call smov  (EOS,            fmt_lat, kk) 
        kk = 0
        call smovh (tgt_pos[12], 3, fmt_lon, kk)  # deg
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[15], 2, fmt_lon, kk)  # min
        call smov  (tgt_pos[17],    fmt_lon, kk)  # hemi
        call smov  (EOS,            fmt_lon, kk) 
    }    

    case $LETD:             # ddmmss.tNdddmmss.tE
    {
        kk = 0
        call smovh (tgt_pos[7], 2,  fmt_lat, kk)  # deg
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[9], 2,  fmt_lat, kk)  # min
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[11], 2, fmt_lat, kk) # sec
        call smovh (tgt_pos[13], 2, fmt_lat, kk) # .t
        call smov  (tgt_pos[15],    fmt_lat, kk)    # hemi
        call smov  (EOS,            fmt_lat, kk) 
        kk = 0
        call smovh (tgt_pos[16], 3, fmt_lon, kk)  # deg
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[19], 2, fmt_lon, kk)  # min
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[21], 2, fmt_lon, kk)  # sec
        call smovh (tgt_pos[23], 2, fmt_lon, kk) # .t
        call smov  (tgt_pos[25],    fmt_lon, kk)     # hemi
        call smov  (EOS,            fmt_lon, kk) 
    }    

    case $LETC:             # ddmmsshhNdddmmsshhE
    {
        kk = 0
        call smovh (tgt_pos[7], 2,  fmt_lat, kk)  # deg
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[9], 2,  fmt_lat, kk)  # min
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[11], 2, fmt_lat, kk) # sec
        call smovv (".",            fmt_lat, kk) 
        call smovh (tgt_pos[13], 2, fmt_lat, kk) # hh
        call smov  (tgt_pos[15],    fmt_lat, kk) # hemi
        call smov  (EOS,            fmt_lat, kk) 
        kk = 0
        call smovh (tgt_pos[16], 3, fmt_lon, kk)  # deg
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[19], 2, fmt_lon, kk)  # min
        call smovv ("-",            fmt_lon, kk) 
        call smovh (tgt_pos[21], 2, fmt_lon, kk)  # sec
        call smovv (".",            fmt_lat, kk) 
        call smovh (tgt_pos[23], 1, fmt_lon, kk)  # hh, first digit
        call smov  (tgt_pos[25],    fmt_lon, kk)  # hemi
        call smov  (EOS,            fmt_lon, kk) 
    }    

    case $LETK:             # ddmm.tttNdddmm.tttE
    {
        kk = 0
        call smovh (tgt_pos[7], 2, fmt_lat, kk)  # deg
        call smovv ("-",           fmt_lat, kk) 
        call smovh (tgt_pos[9], 2, fmt_lat, kk)  # min
        k = 0
        call smovh (tgt_pos[12], 3, deg_fract, k)
        call smov  (EOS, deg_fract, k)
        k = 1
        deg_f = ctoi (deg_fract, k) / 1000.0
        sec_f = deg_f * 60.
        isec  = sec_f
        sec_f = sec_f - isec
        isec_f = sec_f * 1000
        call smovv ("-",            fmt_lat, kk) 
        call smovi (isec,           fmt_lat, kk)
        call smovv (".",            fmt_lat, kk) 
        call smovi (isec_f,         fmt_lat, kk)
        call smov  (tgt_pos[15],    fmt_lat, kk)    # hemi
        call smov  (EOS,            fmt_lat, kk) 
        kk = 0
        call smovh (tgt_pos[16], 3, fmt_lon, kk)  # deg
        call smovv ("-", fmt_lon, kk) 
        call smovh (tgt_pos[19], 2, fmt_lon, kk)  # min
        k = 0
        call smovh (tgt_pos[22], 3, deg_fract, k)
        call smov  (EOS, deg_fract, k)
        k = 1
        deg_f = ctoi (deg_fract, k) / 1000.0
        sec_f = deg_f * 60.
        isec  = sec_f
        sec_f = sec_f - isec
        isec_f = sec_f * 1000
        call smovv ("-",            fmt_lon, kk) 
        call smovi (isec,           fmt_lon, kk)
        call smovv (".",            fmt_lon, kk) 
        call smovi (isec_f,         fmt_lon, kk)
        call smov  (tgt_pos[25],    fmt_lon, kk)     # hemi
        call smov  (EOS,            fmt_lon, kk) 
    }    

    case $LETT:             # ddmm.ttttNdddmm.ttttE
    {
        kk = 0
        call smovh (tgt_pos[7], 2,  fmt_lat, kk)  # deg
        call smovv ("-",            fmt_lat, kk) 
        call smovh (tgt_pos[9], 2,  fmt_lat, kk)  # min
        k = 0
        call smovh (tgt_pos[12], 4, deg_fract, k)
        call smov  (EOS, deg_fract, k)
        k = 1
        deg_f = ctoi (deg_fract, k) / 10000.0
        sec_f = deg_f * 60.
        isec  = sec_f
        sec_f = sec_f - isec
        isec_f = sec_f * 1000
        call smovv  ("-",           fmt_lat, kk) 
        call smovi (isec,           fmt_lat, kk)
        call smovv  (".",           fmt_lat, kk) 
        call smovi (isec_f,         fmt_lat, kk)
        call smov  (tgt_pos[16],    fmt_lat, kk)    # hemi
        call smov  (EOS,            fmt_lat, kk) 
        kk = 0
        call smovh (tgt_pos[17], 3, fmt_lon, kk)  # deg
        call smovv ("-", fmt_lon, kk) 
        call smovh (tgt_pos[20], 2, fmt_lon, kk)  # min
        k = 0
        call smovh (tgt_pos[23], 4, deg_fract, k)
        call smov  (EOS, deg_fract, k)
        k = 1
        deg_f = ctoi (deg_fract, k) / 10000.0
        sec_f = deg_f * 60.
        isec  = sec_f
        sec_f = sec_f - isec
        isec_f = sec_f * 1000
        call smovv ("-",            fmt_lon, kk) 
        call smovi (isec,           fmt_lon, kk)
        call smovv (".",            fmt_lon, kk) 
        call smovi (isec_f,         fmt_lon, kk)
        call smov  (tgt_pos[27],    fmt_lon, kk)     # hemi
        call smov  (EOS,            fmt_lon, kk) 
    }    

    default:
    {
    }
}

return
end


subroutine who_am_i (igame, bbname)
###########################################################
#$%
#$% Purpose:   WHO_AM_I allows user to start a game using
#$%            a command line input
#$%
###########################################################
implicit none
VMSchar*(*) BBname
character  buf[30]
integer    igame, ctoi
integer    ic, getarg, k

#call read_pNAME_INDEX(igame)    # get game index from process name
igame = 0

#if (igame < 1 | igame > gam$slots)
#    {
#    igame = ERR
#
#    ic = getarg(1, buf, 20)
#    if (ic != EOF & buf[1] != EOS)
#    {
#    k=1                    
#    igame = ctoi (buf,k)    # get game index number from command line 
#
#    if (igame > gam$slots) igame = ERR
#    }
#    }

if (igame == ERR)
    {
    call REMARK_v ("Missing Game Index")
    call exit                # exit program
    }

call make_CSF_bb_name (igame,$$BBNAME,bbname)

end


Integer function MissionBase_find (this_misn)   # Input
# Returns index into mb table

implicit none
missionCommon
MissionBasecommon

integer mb$pointer
integer equal, length
integer kk

character this_misn[80]

# Find base for mission 
for (mb$pointer$first; mb$pointer$ok; mb$pointer$next)
{
    if (equal (this_misn, Xmb$MissionNumber$c) == YES)
    {
        break
    }
}            

if (mb$pointer$ok)
    MissionBase_find = mb$pointer
else
    MissionBase_find = 0

return
end


Subroutine add_pending_mission_bases (atoid, atoid_pos)
BBcommon
missionCommon
MissionBasecommon
 
BBDeclare (ord$pointer)
literal cstrip8, cstrip
literal atoid
integer atoid_pos
integer MissionBase_find, almostequal
integer mb$pointer
vmschar vstrip*ARB
integer k
integer msg_len
character msg[80]
vaxcharacter*80  v_msg
Equivalence  (msg, v_msg)
 
character atoidc[8]
literal   atoidL
vmschar*8 atoid_v
equivalence (atoidL, atoidc, atoid_v)
 
literal misn
character misnc[8]
equivalence (misn, misnc)
 
literal unt$atoid$c
character untatoidc[8]
equivalence (unt$atoid$c, untatoidc)
 
character atoid_suffix[2]

atoidL = atoid                          # Local copy
call upper_v(atoid_v)
 
#$% search ORD table for launch orders
for_all_ok (ord)
{
    if (Xord$Code$i == LAUNCH$order |
        Xord$Code$i == LAUNCHC$order)
	{
    	if (Xord$Sequence$i != 1) next      # Scramble always first order
 
    	if (Xord$NbrArgs$i < 9 ) next      # ATO Scramble has 9 arguments
 
    	if (Xord$W06$c != $lex$ATOID$) next     # Ship non ato launch orders
 
    	if (!almostequal(atoidL,Xord$W07$c)) next       # Skip different ATOID

    	mb$pointer = MissionBase_find(Xord$W05$c )  #Replace or add
    	if (mb$pointer == 0)
    	{
    		# Add to missionbase table
        	mb$pointer = Xmb$Used$i
        	mb$pointer = mb$pointer + 1
        	PUTmb$used$i( mb$pointer )
    	}
    	PUTmb$MissionNumber$c( Xord$W05$c  )
    	PUTmb$MissionType$I( $AircraftMissionType  )
    	PUTmb$MissionBase$c( Xord$Addressee$c )
	}

    else if (Xord$Code$i == FIRECRUISE$order)
	{
 
    	if (Xord$NbrArgs$i < 10 ) next		# ATO Fire has 10 arguments
 
    	if (Xord$W09$c != $lex$MISSION$) next    	# Ship non ato fire orders

    	misn = $BLANKLIT
    	call smovhn (Xord$W10$c, $$Maxlit, misn, k)
 
    	if (misnc[k] != UniqueAtoidChar) next	# Skip different ATOID

    	mb$pointer = MissionBase_find(Xord$W10$c )  #Replace or add
    	if (mb$pointer == 0)
    	{
    		# Add to missionbase table
        	mb$pointer = Xmb$Used$i
        	mb$pointer = mb$pointer + 1
        	PUTmb$used$i( mb$pointer )
    	}
    	PUTmb$MissionNumber$c( Xord$W10$c  )
    	PUTmb$MissionType$I( $CruiseMissileMissionType  )
    	PUTmb$MissionBase$c( Xord$Addressee$c )
	}
}
 
return
end


