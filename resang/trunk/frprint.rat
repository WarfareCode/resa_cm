###
### Modification of WES Version 3.1 to the VAX 11/780
###
###
###
### number prog    module      comments
### =====  ====    ======      =========================================
###                            VAX Conversion started 1 December 81 --
###                            completed 28 February 82
###
###
###
###
###
###
 
#####   version 3.1  dated-  7apr81
 
 
###
### mod to version 3.0          dated 08-jan-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 dew     fputil  Moved code to force.rat
###
 
#####   version 3.0  dated- 22dec80
 
#$%     MODULE                       UTILITY                    DATA
#$%   SUBROUTINES                  SUBROUTINES                 TABLES
#$%   ===========                  ===========                 ======
#$%
#$%     FPCOMM                       IPBYTE                    PATH
#$%     FPCOMA                       SMOV1                     NODE
#$%     FPCOM1                       SMOVH                     FORCE
#$%     FPESM                        SMOV                      MV
#$%     FPFORC                       SYNBLD                    EMCON
#$%     FPORDR                                                 SOS
#$%     FPORDS                                                 AML
#$%     FPPLNA                                                 WET
#$%     FPPLAN                                                 HFD
#$%     FPPLN1                                                 SST
#$%     FPSERA                                                 BML
#$%     FPSEAR                                                 LER
#$%     FPSRC1                                                 SWB
#$%     FPCHAR                                                 BIS
#$%     FPCHR1
#$%     FGLEN
#$%     FPWET
#$%     FPHFA
#$%     FPHFD
#$%     FPSST
#$%     FPSOA
#$%     FPSOS
#$%     FPSWABS
#$%     FPLIDAR
#$%     FPAML
#$%     FPEMCO
#$%     FPEMC1
#$%     FFMEM <FORCE>
#$%     FSRITE<FORCE>
#$%     FGLEX <FORCE>
#$%     FGETR <FORCE>
#$%     FDOPEN<FORCE>
#$%     FPSOS <FORCE>
#$%     FPBML
#$%     FPBISTATIC
#$%
#$%
#$%   NOTES
#$%   =====
#$%
#$%   1.  <FILENAME> INDICATES WHERE SUBROUTINE IS LOCATED.
#$%
#$%   2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%   3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%   FLOWCHART FOR FILE FPRINT
#$%   =========================
#$%
#$%      FRPRINT    - FPCOMM - FPCOMA - FPCOM1 - FFMEM *
#$%      <FORCE>    - FPESM *
#$%                 - FPFORC - FSRITE*
#$%                 - FPORDR - FPORDS - FGLEX *
#$%                 - FPPLAN - FPPLN1 - FPORDS - FGLEX *
#$%                 - FPSEAR - FPSRC1 - FPORDS - FGLEX *
#$%                 - FPWET *
#$%                 - FPHFA  - FPHFD *
#$%                 - FPSST  - FGLONG*
#$%                 - FPSOA  - FPSOS  - FGLAT *
#$%                                   - FGLONG*
#$%                 - FPSWABS- FPSWB  - FGLAT *
#$%                                   - FGLONG*
#$%                 - FPLIDAR- FPLDR  - FGLAT *
#$%                                   - FGLONG*
#$%                 - FPAML *
#$%                 - FPEMCO - FPEMC1*
#$%                 - FPBML *
 
 
 
define ($highest$ascii,'zzzzzzzz')
define (TENEX$MONITOR,%"30000%)
define (TOPS20$MONITOR,%"40000%)
include "bbcode.inc"
include "plplay.inc"
include "frmain.inc"
include "ascii.inc"

subroutine fpcomm (nargs,args)
 
########################################################
#$%
#$% Purpose:   FPCOMM controls all the printing of
#$%            communication pathways data.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPCOMA     FPCOM1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],name
 
9000 format (/)
 
#$% set name
name = args[3]
 
#$% if name is "ALL", print all communication pathways data
if (name == 'ALL') call fpcoma
#$% else print an individual communication pathway
else                  call fpcom1 (name)
skip$lines (1)
#$% skip line
 
 
return
end

subroutine fpcoma                       # print all commpaths
 
IMPLICIT NONE
ForceCommon
 
#####################################################################
#$%
#$% Purpose:   FPCOMA prints data for all communication pathways.
#$%
#$% Called By: FPCOMM
#$%
#$% Calls:     FPCOM1
#$%
#$% Tables:    PATH
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#####################################################################
 
literal name
integer m, path$index
 
##02 format (30("  ",6(i4,")",a6)/))
9002 format (30("  ",6(i4,")",a8)/))    # jb E2141 (a8 vs a6) 12/14/99
 
#$% skip lines and start heading
skip$lines (2)start$head
mv$v(" Commpaths ------") write$line   # jb $v vice $s    12/14/99
skip$lines (1)
 
#$% if paths are less than one return
if (npaths < 1) return
 
write (35,9002) (m,wrpaths[1,1,m],m=1,npaths)
#$% skip line
skip$lines (1)
 
#$% for each path entry
for (path$index=1; path$index <= npaths; path$index=path$index+1)
   {
    #$% set path name
    name = path$name
 
    #$% print the selected communication pathway
    call fpcom1 (name)
   }
 
#$% skip line
skip$lines (1)
 
return
end

 
subroutine fpcom1 (name)
 
########################################################
#$%
#$% Purpose:   FPCOML prints data for an individual
#$%            communication pathway.
#$%
#$% Called By: FPCOMM     FPCOMA
#$%
#$% Calls:     FPMEM
#$%
#$% Tables:    PATH       NODE
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
IMPLICIT NONE
ForceCommon
 
literal  name, xrog
integer  PATH$index,NODE$index,ISTAT,M1,M2,M
 
9000 format (1x)
#                ..../....1..../....2..../....3..../....4..../....5
9001 format (/,"   ---- Commpath",1x,a8," ----     Circuit #",i2,//,
             "   Node   Cat   Class    Mu  Rho  Pair   Roger?",/,1x)
9002 format (1x,i6,7x,7x,  2x,2i5, 4x,a8)            #jb E2141 12/14/99
 
9003 format (1x,i6,1x,a6,1x,a8,2i5, 4x,a8, 1x,a7) #jb E2141 12/14/99
 
9004 format (1x,i6,7x,7x,  2x,2i5, 4x,a8, 1x,a7)     #jb E2141 12/14/99
 
9005 format ("  Un-defined Commpath ",a8,/)     #jb E2141 (a8) 12/15/99
 
9006 format (/," Members are:",7a9,/,           #jb E2141 12/14/99
            10("    ",8a9/))                    #jb E2141 12/14/99
 
9007 format (/,"  Members include:","  None entered at this time")
 
#$% for path entry
for (path$index=1; path$index <= npaths; path$index=path$index+1)
   {
    #$% if not path name, get next entry
    if (path$name != name) next
    #$% otherwise write path name and circuit
    write (35,9001) name,int(path$ckt)
 
    #$% for each node entry
    for (node$index =1; node$index <= path$nodes; node$index= node$index+1)
       {
        #$% if path is yes, roger "YES"
        if (path$roger == $yes) xrog = 'YES'
        #$% else roger "NO"
        else                    xrog = 'NO'
 
        #$% if first node
        if (node$index == 1)
            #$% write first node path data
            write (35,9002) node$index,int(path$mu),int(path$rho),
                            path$pair
 
        #$% else if not last node then it is middle node
        else if (node$index != path$nodes)
            #$% write middle node path data
            write (35,9003) node$index,path$cat,path$class,
                            int(path$mu),int(path$rho),path$pair,
                            xrog
 
        #$% else can only be last node
        else                                            # last node
            #$% write last node path data
            write (35,9004) node$index,int(path$mu),int(path$rho),
                            path$pair,xrog
       }
 
 
    #$% get membership matrix slot
    call ffmem (name,istat)
    #$% if there are path members
    if (istat != 0)
       {
        m1 = istat + 2
        m2 = istat + wrmembr[istat] - 1
        #$% write path members
        write (35,9006) (wrmembr[m],m=m1,m2)
        #$% write a space after each member
        write (35,9000)
       }
    #$% else
    else
       {
        #$% else write none entered at this time
        write (35,9007)
       }
 
    write (35,9000)
    return
   }
 
#$% write undefined commpath name
write (35,9005) name
return
end

 
subroutine fpesm  (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FPESM prints fingerprinted emitter list.
#$%
#$% Called By: FPRINT     FPALL
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer emitter$index
 
9000 format (//)
9001 format (//"    ------ ",a5,x,a17," --- Fingerprinted Emitters ------",/) #
 
9002 format ("     None entered at this time"/)
9003 format (i9," entered.  They are:",/,40(6x,4(a9,a9),/) ) #jb E2141 12/15/99
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
#$% if emitters found
if (nemit >=1)
   {
    #$% write fingerprint emitter list
    #$% write number of emitters loaded, and each entry
    write (35,9003) nemit,(emitter$name,emitter$plat,
                    emitter$index=1,nemit)
   }
else
   {
    write (35,9002)
   }
 
write (35,9000)
 
 
return
end

 
subroutine fpforc (nargs,args)
 
#############################################################
#$%
#$% Purpose:   FPFORC prints ship and shorebase data for
#$%            all entries by ascending task numbers.
#$%            Also will print groundunits by ascending
#$%            task numbers
#$%
#$% Called By: FPRINT     FPALL
#$%
#$% Calls:     FSRITE     FGTASK     FGLAT
#$%            FGLONG
#$%
#$% Tables:    FORCE
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],taskn,latn,longn,clatn,clongn,formation
integer icnt,force$index,j,org$index
 
9001 format (//"    ------ ",a5,x,a17," --- Forces ------",//,
 "                                ","Guide/           Brg/ Range/",/,
 " Task #    Name      Class      ","Lat     Long     Cse  Speed   Depth  ",/,
 " -------   --------  --------   ","------  -------  ---  -----   -----  ")
 
# "                          Guide/          Bearing/  Range/",/, # jb E2141
# " Task #    Name   Class   Lat     Long    Course    Speed     Depth  ",/,
# " --------  -----  -----   ------  ------- ------    -----     -----  ")
 
#   xxxxxxxxXXXXXXXxxxxxxXXXXXXX...........XXXXXXxxxxxxxXXXXXXXXXX
#   xxxxxxxxXXXXXXXxxxxxxXXXXXXXXXXxxxxxxxxXXXXXXxxxxxxxXXXXXXXXXX
#   ..../....1..../....2..../....3..../....4..../....5..../....6
 
9002 format (1x,a8,2x,a8)   # jb E2141 (a8 for force name)      12/16/99
 
9003 format (1x,a8,2x,a8,2x,a8,3x,a8,a8,i4,i7,i8.0) # jb E2141 12/16/99
 
9004 format (1x,a8,2x,a8,2x,a8,3x,a8,8x,i4,i7,i8.0) # jb E2141 12/16/99
        #    task   name  clas guide  brg  rng  depth
9005 format (1x)
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
#$% set count to zero
icnt = 0
#$% for each force entry
for (force$index=1; force$index <= nforce; force$index=force$index+1)
   {
    #$% for each save array slot
    for (j = 1; j<= icnt; j=j+1)
       {
        #$% if force entry is not in save array slot, get next
        if (wiforce[$halfquad,1,irec[$halfquad,j]] <= force$task) next
 
        #$% shift save array entries to the right
        call fsrite (rrec,j,j+1,nforce)
        #$% break loop
        break
       }
 
    #$% save force index
    irec[$halfquad,j] = force$index
    #$% increment counter
    icnt = icnt + 1
   }
 
#$% for each force save array entry
for (j=1; j <= nforce; j=j+1)
   {
    force$index = irec[$halfquad,j]
 
    #$% get task number
    call fgtask (force$task,taskn)
 
    #$% get latitude
    call fglat  (force$lat,latn)
 
    #$% get longitude
    call fglong (force$long,longn)
 
    #$% if not classification
    if (force$class == 0)                              #JFR 5/10/91
        #$% write classification ship data
        write (35,9002) taskn,force$name
 
    #$% else if not guide
    else if (force$guide == 0)                         #JFR 5/10/91
        #$% write guide ship data
        write (35,9003) taskn,force$name,force$class,latn,longn,
                        force$course,force$speed,force$depth
 
    #$% else
    else
        #$% write ship data
        write (35,9004) taskn,force$name,force$class,force$guide,
                        force$bearing,force$range,force$depth
   }
 
#######################################################################
#$%
#$% Now do all the top level organizations   JFR 5/10/91
#$% Start with the ground unit header record
#$%
#######################################################################
 
9006 format (//,       #  \/ <--jb "," Inserted 12/16/99 --> \/
 "  Task #  Name   Class  ","     Zone Easting Northing  Lat    Long    Speed"," Postr",/,
 "  ------- -----  -----       ---- ------- --------  ------"," ------- ----- -----")
# "  Task #  Name   Class       Zone Easting Northing  Lat    Long    Speed Postr",/,
# "  ------- -----  -----       ---- ------- --------  ------ ------- ----- -----")
#   ..../....1..../....2..../....3..../....4..../....5..../....6..../....7
 
9007 format (2x,a8,a7,a7,"Src: ",i2,x,a,2x,i6,2x,i7,2x,a7,a8,i5,1x,a7)
9008 format (24x,        "Des: ",i2,x,a,2x,i6,2x,i7,2x,a7,a8)
 
write (35,9006)
 
#$% set count to zero
icnt = 0
#$% for each org entry
for (org$index=1; org$index <= norg; org$index=org$index+1)
   {
    #$% for each save array slot
    for (j = 1; j<= icnt; j=j+1)
       {
        #$% if org entry is not in save array slot, get next
        if (wiorg[$halfquad,1,irec[$halfquad,j]] <= org$task) next
 
        #$% shift save array entries to the right
        call fsrite (rrec,j,j+1,norg)
        #$% break loop
        break
       }
 
    #$% save org index
    irec[$halfquad,j] = org$index
    #$% increment counter
    icnt = icnt + 1
   }
 
for (j=1; j <= norg; j=j+1)
   {
    org$index = irec[$halfquad,j]
 
    if (org$source$zone$number != 0)
      {
        #$% get task number
        call fgtask (org$task,taskn)
 
        #$% get formation #JFR 5/10/91
        if (org$formation == $CIRCLE$formation) formation = 'CIRCL'
        else if (org$formation == $VEE$formation) formation = 'VEE'
        else if (org$formation == $WEDGE$formation) formation = 'WEDGE'
        else if (org$formation == $LINE$formation) formation = 'LINE'
        else if (org$formation == $COLUMN$formation) formation = 'COLUM'
        else if (org$formation == $ONROAD$formation) formation = 'OROAD'
        else if (org$formation == $ECHELONRIGHT$formation) formation = 'ECHRT'
        else if (org$formation == $ECHELONLEFT$formation) formation = 'ECHLT'
        else formation = $BLANKLIT
 
        #$% get source latitude
        call fglat  (org$source$latitude,latn)
 
        #$% get current latitude
        call fglat  (org$destination$latitude,clatn)
 
        #$% get source longitude
        call fglong (org$source$longitude,longn)
 
        #$% get current longitude
        call fglong (org$destination$longitude,clongn)
 
        write (35,9007) taskn,org$name,org$groundunit$name,
                        org$source$zone$number,
                        char(int(org$source$zone$letter)),
                        org$source$easting,
                        org$source$northing,
                        latn,longn,org$speed,formation
 
        write (35,9008) org$destination$zone$number,
                        char(int(org$destination$zone$letter)),
                        org$destination$easting,
                        org$destination$northing,
                        clatn,clongn
      }
   }
 
#######################################################################
#$%
#$% Now do all the child level ground units  #JFR 5/10/91
#$% Start with the ground unit header record
#$%
#######################################################################
 
9009 format (//,  # jb E2141 next 2 lines (8-char. names)  12/16/99:
 "  Task #    Name     Class   Parent   X-Offset  Y_Offset ",/,
 " -------- -------- -------- --------  --------  -------- ")
#  ..../....1..../....2..../....3..../....4..../....5..../....6..../....7
 
9010 format (1x,a8,a9,a9,1x,a9,2x,i8,2x,i8) # jb E2141 /8-char.names 12/16/99
 
write (35,9009)
 
for (j=1; j <= norg; j=j+1)
   {
    org$index = irec[$halfquad,j]
 
    if (org$parent$name != 0)
      {
        #$% get task number
        call fgtask (org$task,taskn)
 
        write (35,9010) taskn,org$name,org$groundunit$name,
                        org$parent$name,
                        org$xoffset,org$yoffset
      }
   }
 
#$% write one blank space
write (35,9005)
 
return
end

 
subroutine fpordr (nargs,args)                  # print all prestored orders
 
#################################################################
#$%
#$% Purpose:   FPORDR controls the print of prestored orders.
#$%
#$% Called By: FPRINT     FPALL
#$%
#$% Calls:     FPORDS
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
 
9000 format (//)
9001 format (//"    ------ ",a5,x,a17," --- Orders - Prestored ------",/) #12/99
9002 format ("     None entered at this time"/)
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
#$% if any orders entered
if (norder >=1)
   {
    #$% print prestored orders
    call fpords (norder,wrorder)
   }
#$% else
else
   {
    #$% write none entered message
    write (35,9002)
   }
#$% write two blank lines
write (35,9000)
 
return
end

 
subroutine fpords (nordr,wrordr)     # print all prestored orders
 
#########################################################
#$%
#$% Purpose:   FPORDS prints prestored plans, orders,
#$%            and search plans.
#$%
#$% Called By: FPORDR     FPPLN1     FPSRC1
#$%
#$% Calls:     FGLEX      SMOVH      SYNBLD
#$%            SMOV1      SMOV
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#########################################################
 
IMPLICIT NONE
ForceCommon
 
literal taskn,cof
integer  len,nordr
literal  xlex[$max$args],addr,wrordr[$ParserRecLen,arb],iaddr
character  dest[arith($max$args,*,8)]      # Avg of 8 char per arg
integer K,ITIME,ISEQ,KARGS,NORD,NCNT,IND,J,ISNUMBER,ITASK,M2,M
 
9003 format ("     ",130a1)
 
#$% for each order entry
for (k=1; k <= nordr; k=k+1)
   {
    call fglex (wrordr,k,addr,itime,iseq,kargs,xlex)
    iaddr = addr
    #$% set order
    nord  = wrordr[$stk$nord,k]
    #$% set count
    ncnt  = wrordr[$stk$cnt,k]
 
    #$% if sequence is not one, set to YES
    if (iseq != 1) ind = $yes
    #$% else set to NO
    else           ind = $no
 
    #$% set line length
    len = 0
    #$% move data
    call smovi (k,dest,len)
    call smovv (")  ",dest,len)
 
    j = 0
    cof = $BLANKLIT
    #$% if not one
    if (ncnt != 1)
       {
        #$% move sequence data
        call smovi (iseq,cof,j)
        call smovv (" of ",cof,j)
        call smovi (ncnt,cof,j)
       }
 
    #$% move data
    call smovh (cof,8,dest,len)
 
    #$% if address is negative one
    if (iaddr == -1)
       {
        #$% move address data
        call smovv (" FOR ",dest,len)
        call smovv ("(prior addressee)",dest,len)
       }
    #$% else if address is zero
    else if (iaddr == 0)
       {
        continue
       }
    else if ($isnumeric(iaddr))      #if iaddr is a task number
       {
        itask = iaddr
        #$% get task number
        call fgtask (itask,taskn)
        #$% move data
        call smovv (" FOR ",dest,len)
        call smovhn (taskn,8,dest,len)
       }
    #$% else
    else
       {
        #$% move address data
        call smovv (" FOR ",dest,len)
        call smovhn (addr,$$MAXname,dest,len) # jb E2141    12/16/99
       }
 
    #$% move space
    call smov ($space,dest,len)
 
    #$% load data
    call synbld (_                  # Build text from lex data
               itime,               # game minute when to be executed
               ind,                 # $yes/$no if time is phase dependent
               nord,                # ordr number (code)
               kargs,               # number of words in the lex array
               xlex,                # lex code(s) array
               dest,                # array to receive text (130 words)
               len)                 # value for number of bytes in dest
                                    # and incremented by those added
 
 
    m2 = len
    if (m2 > 130) m2 = 130
    #$% write orders
    write (35,9003) (dest[m],m=1,m2)
   }
 
return
end

 
subroutine fpplna (nargs,args)                  # print all
 
#################################################################
#$%
#$% Purpose:   FPPLNA prints header record and initializes
#$%            data to print all contingency plans.
#$%
#$% Called By: FPALL
#$%
#$% Calls:     FPPLN1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],name,side
 
9000 format (//)    # jb For mdate \/ (now 17 char's)   12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Plans - Contingency ------",/)#12/99
9002 format ("     None entered at this time"/)
9003 format ("     Print is not available yet"/)
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
#$% if any plans
if (nplans >=1)
   {
 
 
    #$% set name
    name = 'ALL'
    #$% set side to blue
    side = 'BLUE'
    #$% print specified side and name
    call fppln1 (side,name)
    #$% set side to orange
    side = 'ORANG'
 
    #$% print specified side and name
    call fppln1 (side,name)
   }
#$% else
else
   {
    #$% write that none are entered at this time
    write (35,9002)
   }
 
write (35,9000)
 
return
end

 
subroutine fpplan (nargs,args)                  # print selected Plan
 
########################################################
#$%
#$% Purpose:   FPPLAN initializes data to print
#$%            selected contingency plan.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPPLN1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],side,name
 
9000 format (1x,/,1x)
 
#$% if entry is blue, set side to blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side to orange
else                       side = 'ORANG'
 
#$% set name
name = args[4]
 
#$% print specified side and name
call fppln1 (side,name)
 
#$% write one blank space, one blank line and another blank space
write (35,9000)
 
return
end

 
subroutine fppln1 (side,name)                 # print selected
 
#############################################################
#$%
#$% Purpose:   FPPLN1 prints specified contingency plans.
#$%
#$% Called By: FPLNA      FPPLAN
#$%
#$% Calls:     FPORDS
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
literal title,side,name
integer iflag, isize, plans$index
 
9000 format (1x,/,1x)
9001 format (//"    ------ ",a5,x,a17," --- ",a10," Plan ",a5,/) #jb 12/15/99
9002 format ("     None entered at this time"/)
9003 format ("     Print is not available yet"/)
 
#$% if side is blue, set title to blue
if (side == 'BLUE') title = 'Blue'
#$% else set title to orange
else                  title = 'Orange'
 
#$% set flag to NO
iflag = $no
 
#$% for each plan entry
for (plans$index = 1; plans$index <= nplans; plans$index=plans$index+1)
   {
    #$% if side is not plan, get next entry
    if (side != plans$side) next
 
    #$% if name is not plan and name is not all, get next entry
    if (name != plans$name & name != 'ALL') next
 
    #$% set flag to YES
    iflag = $yes
    #$% write header record
    write (35,9001) scenario$name,mdate,title,plans$name # jb 12/15/99
 
    #$% set size
    isize = plans$size - 1
 
    #$% print prestored orders
    call fpords (isize,wrplan[1,2,plans$index])
 
    #$% write one blank space, one blank line and another blank space
    write (35,9000)
   }
 
#$% if flag is no, write none entered at this time
if (iflag == $no) write (35,9002)
 
#$% write one blank space, one blank line and another blank space
write (35,9000)
 
return
end
 

 
subroutine fpsera (nargs,args)                  # print all search plans
 
##########################################################
#$%
#$% Purpose:   FPSERA initializes parameters to print
#$%            all search plan data.
#$%
#$% Called By: FPALL
#$%
#$% Calls:     FPSRC1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##########################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],name,side
 
9000 format (//)                # \/  mdate now 17 char's  jb  12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Search (plan) Sequences ------",/)
9002 format ("     None entered at this time"/)
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
#$% if plans exist
if (nsearc>=1)                                          #       3/11/83
   {
    #$% set name
    name = 'ALL'
    #$% set side to blue
    side = 'BLUE'
 
    #$% print selected search plan side and name
    call fpsrc1 (side,name)
 
    #$% set side to ornage
    side = 'ORANG'
 
    #$% print selected search plan for orange
    call fpsrc1 (side,name)
   }
#$% else
else
   {
    #$% write none entered at this time
    write (35,9002)
   }
 
#$% write two blank lines
write (35,9000)
 
return
end
 

 
subroutine fpsear (nargs,args)                  # print selected
 
#############################################################
#$%
#$% Purpose:   FPSEAR initializes data to print selected
#$%            search plan data.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPSRC1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],side,name
 
9000 format (1x,/,1x)
 
#$% if entry is blue, set side to blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side to orange
else                       side = 'ORANG'
 
#$% set name
name = args[4]
 
#$% print selected search plan
call fpsrc1 (side,name)
 
#$% write one blank space, one blank line and another blank space
write (35,9000)
 
return
end
 

 
subroutine fpsrc1 (side,name)             # print selected search plan
 
########################################################
#$%
#$% Purpose:   FPSRC1 prints selected search plans.
#$%
#$% Called By: FPSERA     FPSEAR
#$%
#$% Calls:     FPORDS
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
IMPLICIT NONE
ForceCommon
 
literal side,name
literal title
integer iflag, isize, search$index
 
9000 format (1x,/,1x)           #  \/ (mdate now 17 char's  jb  12/15/99
9001 format (//"     ------ ",a5,x,a17," --- ",a10," Search Plan ",a5,/)
9002 format ("     None entered at this time"/)
 
#$% if side is blue, set title to blue
if (side == 'BLUE') title = 'Blue'
#$% else set title to orange
else                  title = 'Orange'
 
#$% set flag to NO
iflag = $no
 
#$% for each search plan entry
for (search$index = 1; search$index <= nsearc; search$index=search$index+1)
   {
    #$% if side is not search plan, get next entry
    if (side != search$side) next
 
    #$% if name is not search plan and is not all, get next
    if (name != search$name & name != 'ALL') next
 
    #$% set flag to YES
    iflag = $yes
    #$% write header record # jb mtime \/ deleted (mdate only)  12/16/99
    write (35,9001) scenario$name,mdate,title,search$name # jb (no mtime) 12/99
 
    #$% set size
    isize = search$size - 1
 
    #$% print prestored orders
    call fpords (isize,wrsearc[1,2,search$index])
 
    write (35,9000)
   }
 
#$% if flag is NO, write none entered at this time
if (iflag == $no) write (35,9002)
 
write (35,9000)
 
return
end
 

 
subroutine fpacta (nargs,args)                  # print all action plans
 
##########################################################
#$%
#$% Purpose:   FPACTA initializes parameters to print
#$%            all action plan data.
#$%
#$% Called By: FPALL
#$%
#$% Calls:     FPACT1
#$%
#$% Tables:    None
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
##########################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],name,side
 
9000 format (//)               #  \/ (mdate now 17 char's  jb  12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Action (plan) Sequences -----",/)
9002 format ("     None entered at this time"/)
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
#$% if plans exist
if (nact >= 1)                                          #       3/11/83
   {
    #$% set name
    name = 'ALL'
    #$% set side to blue
    side = 'BLUE'
 
    #$% print selected action plan side and name
    call fpact1 (side,name)
 
    #$% set side to orange
    side = 'ORANG'
 
    #$% print selected action plan for orange
    call fpact1 (side,name)
   }
 
else
   {
    #$% write none entered at this time
    write (35,9002)
   }
 
#$% write two blank lines
write (35,9000)
 
return
end
 

 
subroutine fpact (nargs,args)                  # print selected action plan
 
#############################################################
#$%
#$% Purpose:   FPACT initializes data to print selected
#$%            action plan data.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPACT1
#$%
#$% Tables:    None
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],side,name
 
9000 format (1x,/,1x)
 
#$% if entry is blue, set side to blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side to orange
else                       side = 'ORANG'
 
#$% set name
name = args[4]
 
#$% print selected action plan
call fpact1 (side,name)
 
#$% write one blank space, one blank line and another blank space
write (35,9000)
 
return
end

 
subroutine fpact1 (side,name)             # print selected action plan
 
########################################################
#$%
#$% Purpose:   FPACT1 prints selected action plans.
#$%
#$% Called By: FPACTA     FPACT
#$%
#$% Calls:     FPORDS
#$%
#$% Tables:    None
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
########################################################
 
IMPLICIT NONE
ForceCommon
 
literal side,name
literal title
integer iflag, isize, act$index
 
9000 format (1x,/,1x)
9001 format (//"    ------ ",a5,x,a17," --- ",a10," Action Plan ",a5,/)
9002 format ("     None entered at this time"/)
 
#$% if side is blue, set title to blue
if (side == 'BLUE') title = 'Blue'
#$% else set title to orange
else                  title = 'Orange'
 
#$% set flag to NO
iflag = $no
 
#$% for each action plan entry
for (act$index = 1; act$index <= nact; act$index = act$index + 1)
   {
    #$% if side is not action plan, get next entry
    if (side != act$side) next
 
    #$% if name is not action plan and is not all, get next
    if (name != act$name & name != 'ALL') next
 
    #$% set flag to YES
    iflag = $yes
    #$% write header record
    write (35,9001) scenario$name,mdate,title,act$name # jb (no mtime) 12/15/99
 
    #$% set size
    isize = act$size - 1
 
    #$% print action orders
    call fpords (isize,wract[1,2,act$index])
 
    write (35,9000)
   }
 
#$% if flag is NO, write none entered at this time
if (iflag == $no) write (35,9002)
 
write (35,9000)
 
return
end

 
subroutine fpchar (nargs,args)                  # print all characteristics
 
##############################################################
#$%
#$% Purpose:   FPCHAR controls the printing of all system
#$%            characteristics data.
#$%
#$% Called By: FPALL
#$%
#$% Calls:     FPCHR1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal xnul[2,1],xair[2,2],xshr[2,2],xshp[2,2],xcmp[2,1],xsit[2,2] #KHC 6/4/92
literal xsen[2,2]
literal args[$max$args]
 
 DATA xnul/$BLANKLIT , 0/  # Spaces
 
 DATA xair/'BUOY' , 4,
           'WEAPO', 4/
 
 DATA xshr/'BUOY' , 4,
           'WEAP' , 4/
 
 DATA xshp/'BUOY' , 4,
           'WEAP' , 4/
 
 DATA xsit/'BUOY' , 4,      # KHC 6/4/92
           'WEAP' , 4/
 
 DATA xsen/'MFUNC', 11,
           'MODEA', 11/
 
 DATA xcmp/'WBUOY', 3/
 
 
 
#$% print system characteristics data
call fpchr1 (shore$file,xshr,2,nshore,wrshore,"Shore Base")
 
call fpchr1 (class$file,xshp,2,nclass,wrclass,"Ship Class")
 
call fpchr1 (site$file,xsit,2,nsite,wrsite,"Site      ")      # KHC 6/4/92
 
call fpchr1 (air$file,xair,2,nair,wrair,"Aircraft  ")
 
call fpchr1 (cruise$file,xnul,0,ncruis,wrcruis,"Cruz Miss ")
 
call fpchr1 (commb$file,xnul,0,ncommb,wrcommb,"Commbuoy  ")
 
call fpchr1 (comms$file,xnul,0,ncomms,wrcomms,"Commsuite ")
 
call fpchr1 (commp$file,xcmp,1,ncommp,wrcommp,"Commpair  ")
 
call fpchr1 (ctrme$file,xnul,0,nctrme,wrctrme,"Countermea")
 
call fpchr1 (iff$file,xnul,0,niff,wriff,"IFF       ")
 
call fpchr1 (jammer$file,xnul,0,njamme,wrjamme,"Jammer    ")
 
call fpchr1 (navaid$file,xnul,0,nnavad,wrnavad,"Navaid    ")
 
call fpchr1 (sensor$file,xsen,2,nsenso,wrsenso,"Radar/ESM ")
 
call fpchr1 (sat$file,xnul,0,nsat,wrsat,"Survsat   ")
 
call fpchr1 (sonar$file,xnul,0,nsonar,wrsonar,"Sonar     ")
 
call fpchr1 (sonob$file,xnul,0,nsonob,wrsonob,"Sonobuoy  ")
 
call fpchr1 (trpdo$file,xnul,0,ntrpdo,wrtrpdo,"Torpedo   ")
 
call fpchr1 (weapon$file,xnul,0,nweap,wrweap ,"Weapon    ")
 
return
end

subroutine fpchr1 (opt,xfld,nfld,nchar,wchar,title)
 
#################################################################
#$%
#$% Purpose:   FPCHR1 prints all system characteristics data.
#$%
#$% Called By: FPCHAR
#$%
#$% Calls:     FGETR      FGLAT      IPBYTE
#$%            FGLEN      FGLONG     FDOPEN
#$%
#$% Tables:    MV
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#################################################################
 
IMPLICIT NONE
ForceCommon
 
integer kwords,nfld,nchar,wichar[$intrealmatch,5,$weapons],line[30] #2/8/89
literal xfld[2,3]
VMSchar*(*) opt,title
literal wrchar[5,$weapons],wchar[5,$weapons],rfld  #jb 180 vice 140  2/8/89
equivalence (wichar,wrchar)
 
character   temp_buf[40]
integer*4   temp_len
real*4      fval, dms2rad
 
integer ix[$weapons]
literal xname[$weapons]
 
integer K, K5, ICNT, KNT, M, K9, LFCB, ISTAT, LFCS, IPNT, ILEN,
        IS_ALPHA_NUMERIC, IFLD, N2, iwid, klen
 
for (k = 1; k <= nchar; k=k+1)                  # move to local array with
   {                                            # integer and real overlay
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wrchar[k5,k] = wchar[k5,k]
       }
   }
 
#$% top page
top$page
 
#$% skip lines
skip$lines (2)start$head
#$% start heading
mv$v(title)mv$v(" Characteristics ------ ") write$line
skip$lines (1)
 
#$% if characteristic is less than one, return
if (nchar < 1) return
 
#$% start line
start$line; space$over 2
#$% set counter to zero
icnt = 0
 
# sort characteristics names....
 
knt = 0
 
for (m=1; m<=nchar; m=m+1)
    {
    knt = knt + 1
 
    xname[knt] = wrchar[1,m]
    }
 
call order1 (xname,ix,knt)
 
#$% for each characteristic entry
for (k9=1; k9<=knt; k9=k9+1)
   {
    m = ix[k9]
 
    #$% increment counter
    icnt = icnt + 1
 
    #$% if count greater than six
    if (icnt > 5)
       {
        #$% write line
        write$line
        start$line; space$over 2
        #$% set counter to one
        icnt = 1
       }
 
    mv$n(k9,4) mv$v(") ") mv$s(wrchar[1,m],$$MaxName)
   }
 
#$% write line
write$line
skip$lines (1)
 
 
#$% for each entry
for (k9=1; k9<=knt; k9=k9+1)
   {
    m = ix[k9]
 
    if (wichar[$halfquad,2,m] != 0)             # if entry is in BUILD File
       {
        #$% open build file
        call FDopen ($read,build$name,$litc,opt,32*4,lfcB,istat)
        #$% set record
        kwords = wichar[$halfquad,2,m]
        #$% get build record
        call fgetr (lfcB,kwords,16,rrec)
       }
    else if (wichar[$halfquad,4,m] != 0)        # else if entry in FORCE File
       {
        #$% open sceanario file
        call FDopen ($read,scenario$name,$lits,opt,32*4,lfcS,istat)
        #$% set record
        kwords = wichar[$halfquad,4,m]
        #$% get scenario record
        call fgetr (lfcS,kwords,16,rrec)
       }
    #$% else get next
    else next
 
    #$% format record
    skip$lines (2)
    start$line
    space$over 3; mv$v("---")
    space$over 1; mv$v(title)
    space$over 4; mv$v("#")
    space$over 0; mv$n(k9,3)
    space$over 2; mv$s(rrec[3],$$MaxName)
    write$line
    skip$lines (1)
 
    #$% for each entry
    for (ipnt = 2; ipnt <= rrec[1]; ipnt = ipnt + ilen)
       {
        #$% start line
        start$line space$over 1
 
        #$% get length
        call fglen (ipnt,xfld,nfld,ilen)
 
        $debugp call echor
        $debugp call echov(" ipnt=")
        $debugp call echoi(ipnt)
        $debugp call echov(" ilen=")
        $debugp call echoi(ilen)
 
        #$% for each length entry
        for (k=0; k<ilen ; k=k+1)
           {
            #$% set field
            rfld = rrec[ipnt+k]
 
            if (rfld == 'NOMEN' | rfld == 'FNAME') # NOMEN or FNAME
                {
                space$over 2; mv$s(rfld,$$MaxName)
                space$over 2; mv$s(rrec[ipnt+k+1],$$MaxVName)
                break
                }
            else if (is_alpha_numeric (rfld) == YES)
                {
                space$over 2; mv$s(rfld,$$MaxLit)
                }
            else
                {
                ifld = rfld
                if      (rrec[ipnt+k-1] == 'LAT')
                   {
                    call fmovLLS (dms2rad(rfld),"NS")       # DEW (E2141)
                   }
                else if (rrec[ipnt+k-1] == 'LONG')
                   {
                    call fmovLLS (dms2rad(rfld),"EW")       # DEW (E2141)
                   }
                else
                   {
                    if ($iswhole (rfld) )       # integer check only
                        {
                        iwid = 8
 
                        if (rfld > 0)
                            {
                            iwid = max(iwid,int(1 + log10(rfld)))
                            }
 
                        mv$n(ifld,iwid)
                        }
                    else
                        {
                        fval = rfld             # convert to 32-bit real
 
                        temp_len = 0            # display in floating point
                        call smovv (" ",temp_buf,temp_len)
                        call smovf (fval,903,temp_buf,temp_len)
 
                        mv$s(temp_buf,temp_len)
                        }
                    }
                }
           }
 
        n2 = ipnt + ilen - 1
 
        #$% write line
        write$line
       }
   }
 
return
end

subroutine fglen (ipnt,xfld,nfld,ilen)
 
###########################################################
#$%
#$% Purpose:   FGLEN determines the length of an input
#$%            statement record.
#$%
#$% Called By: FPCHR1
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################
 
IMPLICIT NONE
ForceCommon
 
integer ipnt,nfld,ilen
literal xfld[2,3]
integer isnumber, k
literal r_lit
 
logical nutest
#$% set numeric field test
nutest(r_lit) = $isnumeric(r_lit)       # numeric field test (statement funct)
 
#$% for each entry
for (k=1; k<=nfld; k=k+1)
   {
    #$% if field is not entry, get next
    if (xfld[1,k] != rrec[ipnt]) next
    #$% set line length
    ilen = xfld[2,k]
    return
   }
 
if (rrec[ipnt] == 'NOMEN'|
    rrec[ipnt] == 'FNAME')
    {
    ilen = 4
    return
    }
 
#$% for each length entry
for (ilen = 2; ilen+ipnt <= rrec[1]; ilen = ilen + 1)
   {
    #$% if numeric test field entry, break loop
    if ( ! nutest(rrec[ipnt+ilen])) break
   }
 
return
end

 
subroutine fpwet (nargs,args)                   # print weather regions
 
#############################################################
#$%
#$% Purpose:   FPWET prints data for each weather region
#$%            in the scenario file.
#$%
#$% Called By: FPRINT     FPALL
#$%
#$% Calls:     None
#$%
#$% Tables:    WET
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer wet$pointer, wet$address, ireg
 
9000 format (//)                 # \/ jb; mdate now 17 char's  12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Weather Regions ------",/)
 
#               jb E2141 (next twolines):                      12/16/99
9005 format (/"             ---Wave---  --Wind---","  -------Cloud-------  -Visibility-")
9006 format ( "     Region  Height Dir  Speed Dir","    % Ceiling   Depth  Range    Cat"/)
#             0..../....1..../....2..../....3..../....4..../....5..../....6
 
#              12345nn123456nn12345nnn12nnn123nnn12nnn12nnnnnn12nnnnnn1234nnn12aaaaa
9007 format (       i7,     i8,     i8,  i5,   i6,  i5,     i8,     i8,    i7,2x, a5)
 
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9005)
write (35,9006)
 
#$% set weather pointer to zero
nweath = 0
 
#$% for each weather entry
for (wet$pointer$first; wet$pointer$valid; wet$pointer$next)
   {
    wet$map
    #$% if WET slot not in use, get next
    if (wet$InUse == $no) next
 
    #$% increment weather counter
    nweath = nweath + 1
 
    #$% set region number
    ireg    = wet$pointer$index - 1               # region number (index)
 
    #$% write weather region data
    write (35,9007) ireg,wet$waveheight,wet$wavedirection,
                    wet$windspeed,wet$winddirection,wet$cloudcover,
                    wet$ceiling,wet$clouddepth,wet$visibility,wet$category
   }
 
write (35,9000)
 
return
end

 
subroutine fphfa (nargs,args)                   # print all hfdf bases
 
#############################################################
#$%
#$% Purpose:   FPHFA prints all High Frequency Detection
#$%            Finder bases.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPHFD
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
 
#$% print all HFDF bases
args[3] = 'ALL'
call fphfd (nargs,args)
 
return
end

 
subroutine fphfd (nargs,args)                   # print hfdf base
 
#############################################################
#$%
#$% Purpose:   FPHFD prints an individual High Frequency
#$%            Detection Finder base.
#$%
#$% Called By: FPHFA
#$%
#$% Calls:     None
#$%
#$% Tables:    HFD
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer hfd$pointer, hfd$address, i, k
 
9000 format (//)                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," ------- Hfdf Base --------",/)
#             0         1         2         3         4         5         6         7
#             0123456789012345678901234567890123456789012345678901234567890123456789012
9002 format (" Base ",a8)   # jb E2141 (a8 vice a5 for Base name  12/16/99
#9003 format (10(1x,i3))
9003 format (10(10(1x,i3)/))
9004 format (1x,a8, " does not exist.") # jb E2141 (a8 vice a5)    12/16/99
 
#$% set HFD pointer
hfd$pointer$first
hfd$map
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
#$% for each HFDF entry
for (i=1; i<=nhfdf; i=i+1)
   {
    #$% if entry is all or basename
    if ('ALL' == args[3] | hfd$basename == args[3])
       {
        #$% write basename
        write (35,9002) hfd$basename
 
        #$% write HFD address
        write (35,9003) (work$file$i[$halfquad,k],k=hfd$address+1,hfd$address+100)
        write (35,9000)
 
        #$% if entry is not all, break loop
        if ('ALL' != args[3]) break
       }
    #$% set HFD pointer to next
    hfd$pointer$next
    hfd$map
   }
 
#$% if not found, write does not exist
if (i > nhfdf & 'ALL' != args[3]) write(35,9004) args[3]
 
return
end

 
subroutine fpsst (nargs,args)                   # print survsat data
 
#############################################################
#$%
#$% Purpose:   FPSST prints all data for Surveillance
#$%            Satellites.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FGLONG
#$%
#$% Tables:    SST
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],longn,longx,slat,slong
integer sst$pointer, sst$address, ipass, i, ilen
 
9000 format (//)                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," ------ SURVSAT DATA ------",/)
#             0         1         2         3         4         5         6         7
#             0123456789012345678901234567890123456789012345678901234567890123456789012
#       jb E2141  (Next two lines)  12/16/99
9002 format ("                     *** ORBITING SATELLITES ***",/)
9003 format (" ----Satellite----"," -------Orbital--------- Equator Crossing  Duty ","Ground",/,
             " Name      Type    Period  Altitude Inclin","   Time Longitude Cycle Station")
9004 format   (1x,a8,1x,a8,i7,i9,2x,a6,i7,3x,a7,i5,2x,a8) # jb E2141  12/16/99
9005 format ("                     *** STATIONARY SATELLITES ***",/)
 
#       jb E2141  (Next two lines)  12/16/99
9006 format ("  Name     Type     Latitude   Longitude","   Altitude  DCycle Station")
9007 format (1x,a8,1x,a8,4x,a6,4x,a7,4x,i6,4x,i3,4x,a8)
9008 format (1x, a8, " does not exist.") # jb E2141 (a8 vice a5)  12/16/99
9009 format (/"----------------------------------------","-------------------------------"/)
                                  # jb 2141 (Inserted  "," )      12/16/99
9010 format ("...There Are No Obiting Sattelites Entered...")
9011 format ("...There Are No Stationary Sattelites Entered...")
 
sst$pointer$first
sst$map
#$% write header record
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9002)
write (35,9003)
ipass = $no
for (i=1; i<=nssts; i=i+1)
   {
    if (sst$orbit == $yes)
       {
        ipass = $yes
        call fglong (sst$xlongitude,longx)
        ilen = 0
        call smoviz (sst$inclination/100,3,longn,ilen)
        call smov ($minus,longn,ilen)
        call smoviz (sst$inclination,2,longn,ilen)
 
        write (35,9004) sst$name, sst$type, sst$period, sst$altitude, longn,
                        sst$xtime, longx, sst$dutycycle, sst$groundstation
       }
    sst$pointer$next
    sst$map
   }
if (ipass == $no) write (35,9010)
write (35,9009)
write (35,9005)
write (35,9006)
 
sst$pointer$first
sst$map
ipass = $no
for (i=1; i<=nssts; i=i+1)
   {
    if (sst$orbit == $no)
       {
        ipass = $yes
        call fglat (sst$latitude, slat)
        call fglong(sst$longitude, slong)
 
        write (35,9007) sst$name, sst$type, slat, slong, sst$altitude,
                        sst$dutycycle, sst$groundstation
       }
    sst$pointer$next
    sst$map
   }
if (ipass == $no) write (35,9011)
write (35,9000)
 
return
end
 

 
subroutine fptone (nargs,args)                   # Print Tonal Values
 
#############################################################
#$%
#$% Purpose:   FPTONE prints Sonar Tonal values for units given
#$%            these inputs during FORCE.
#$%
#$% Called By: FRMAIN
#$%
#$% Calls:     NONE
#$%
#$% Tables:
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
#$% Modified:  J. Richardson 5/93 (E1142)
#$%            Tonal classification is based on four optional
#$%            classification names, no longer tonal values.
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args], name, class, class1, class2, class3 # JFR 5/10/93
                                         # added class1/class2/class3
integer ton$pointer, ton$address
 
9000 format (//)                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," -- Sonar Tonal Classes ---",/)
#              0         1         2         3         4         5         6
#              0123456789012345678901234567890123456789012345678901234567890
9002 format (  "    ---Unit------Class------Class-----Class-----Class-----",/)
#              "       aaaaa     aaaaaaaa   aaaaaaaa  aaaaaaaa  aaaaaaaa   "
9003 format (7x, a5, 5x, a8, 3x, a8, 2x, a8, 2x, a8) # JFR 5/10/93
9004 format (/)
9005 format (  "    There are no sonar tonal CLASSES entered at this time.")
 
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9002)
 
for (ton$pointer$first; ton$pointer$valid; ton$pointer$next)
    {
    ton$map
 
    if (ton$inuse == $no) break
 
    if (nton <=0)
        {
        write (35,9005)
        return
        }
 
    name   = ton$name
    class  = TON$Classification1      # JFR 5/10/93 (E1142)
    class1 = TON$Classification2      # changed to four string
    class2 = TON$Classification3      # classification names
    class3 = TON$Classification4
 
    write(35,9003) TON$Name, TON$Classification1, TON$Classification2,
                   TON$Classification3, TON$Classification4
 
#    write (35,9003) name,class,it1,it2,it3
    }
 
write (35,9000)
 
return
end

 
subroutine fpsosr (nargs,args)                   # print sosus region(s)
 
##################################################################
#$%
#$% Purpose:   FPSOSR checks arguments to see if one or all of the SOSUS
#$%            regions are to be printed and calls the appropriate routine.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     FPSOS FPSOA
#$%
#$% Tables:    SOS
#$%
#$% Date:      FEBRUARY 91
#$%
#$% Author:    Tom Smith
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
 
if (args[4] == $lex$all$)
    {
    #$% print ALL SOSUS regional data
    call fpsoa (nargs,args)
    }
else
    {
    #$% print specified SOSUS regional data
    call fpsos (nargs,args)
    }
 
return
end

 
subroutine fpsoa (nargs,args)                   # print all sosus regions
 
##################################################################
#$%
#$% Purpose:   FPSOA prints all data for Sonar Surveillance
#$%            System regions.
#$%
#$% Called By: FPSOSR                   # 2/20/91 trs
#$%
#$% Calls:     FPSOS
#$%
#$% Tables:    SOS
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer sos$pointer, sos$address, i
 
#$% set SOS pointer
sos$pointer$first
sos$map
#$% for each SOSUS entry
for (i=1; i<=nsos; i=i+1)
   {
    #$% load SOSUS region number
    args[4] = sos$regnumber
    #$% print specified SOSUS regional data
    call fpsos (nargs,args)
    #$% set SOS pointer to next
    sos$pointer$next
    sos$map
   }
 
return
end

 
subroutine fpsos (nargs,args)                   # print single sosus region
 
#############################################################
#$%
#$% Purpose:   FPSOS prints data for an individual Sonar
#$%            Surveillance System region.
#$%
#$% Called By: FPSOSR                   # 2/20/91 trs
#$%
#$% Calls:     FGLAT      FGLONG
#$%
#$% Tables:    SOS
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],omode,odeep,latn,longn
 
dimension nprob(sos$det$slots)
integer jf, j, i, k, nprob
integer sos$pointer, sos$address, sos$pos$index, sos$sub$index, sos$det$index
 
9000 format (//)                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," ----- Sosus Region ------",/)
 
#              0         1         2         3         4         5         6         7
#              0123456789012345678901234567890123456789012345678901234567890123456789012
9002 format ( " Submarine ","Classes",/,
              " --------Probabilities of"," Detection (%s)--------  Sub           ","    Prop",/,
              " -------Unalerted-------"," --------Alerted--------  Class    Depth    Mode ",/,
              "   5  10","  15  20  25  30   5  10  15  20  25  30 knots",/)
#9002 format ( " Submarine Classes",/,
#              " --------Probabilities of Detection (%s)--------  Sub               Prop",/,
#              " -------Unalerted------- --------Alerted--------  Class    Depth    Mode",/,
#              "   5  10  15  20  25  30   5  10  15  20  25  30 knots",/)
 
9003 format ( sos$det$slots(i4), 1x, a8, a8, a8)    # jb E2141  12/16/99
#9003 format ( sos$det$slots(i4), 2x, a5, a9, a8)
 
9004 format ( " Region #", i3, " does not exist.") #jb"," added 12/16/99
9005 format (/"          ---Axis  Length---  Boundary ","    ----Vertices---  # of")
9006 format ( " Region     Mean     Sigma       Depth ","        Lat     Lon  Sets")
 
9007 format (       i7,      i9,      i10,       i12, 6x,     a6, 1x, a7,  i6)
9008 format (       i7, " not defined")
9009 format (  44x, a6, 1x, a7)
 
#$% write header record
 
write (35,9001) scenario$name,mdate ## ,mtime jb (mdate now 17 char.) 12/15/99
 
jf = 0
#$% for each SOSUS entry
for (j=1; j<=nsos; j=j+1)
   {                                    #printing region data
    #$% set SOS pointer
    sos$pointer$to j
    sos$map
    #$% if entry is not SOSUS region number, get next entry
    if (sos$regnumber != args[4]) next
 
    jf = 1
    #$% if SOSUS region defined
    if (sos$regdefined != $no)
       {
        #$% set POS index to one
        sos$pos$index = 1
        #$% get latitude
        call fglat (sos$pos$lat,latn)
        #$% get longitude
        call fglong (sos$pos$lon,longn)
        write (35,9005)
        write (35,9006)
        #$% write SOSUS region data
        write (35,9007) sos$regnumber,sos$meanaxislength,sos$sigmalength,
                        sos$boundarydepth,latn,longn,sos$numberofsets
        #$% for each entry
        for (sos$pos$index = 2; sos$pos$index <= sos$pos$slots;
             sos$pos$index = sos$pos$index +1)
           {
            #$% if SOS position latitude is maximum, break loop
            if (sos$pos$lat == 99999) break
            #$% get latitude
            call fglat (sos$pos$lat,latn)
            #$% get longitude
            call fglong (sos$pos$lon,longn)
            #$% write latitude and longitude
            write (35,9009) latn,longn
           }
       }
    #$% else write region number not defined
    else write (35,9008) sos$regnumber
 
    #$% if number of set defined write submarine classes
    if (sos$numberofsets != $no) write(35,9002)
    #$% for each sub class entry
    for (i=1; i<=sos$numberofsets; i=i+1)
       {                                #printing sub classes
        #$% set sub index
        sos$sub$index = i
        #$% for each detection entry
        for (k=1; k<=sos$det$slots; k=k+1)
           {
            #$% set detection index
            sos$det$index = k
            #$% set detection prob
            nprob(k) = sos$sub$det$prob
           }
        #$% if sub prop mode is NO, set mode blank
        if (sos$sub$propmode == $no) omode = $BLANKLIT
        #$% else set mode to diesel
        else                         omode = 'diesel'
        #$% if sub depth is NO, set depth to shallow
        if (sos$sub$depth == $no) odeep = 'shallow'
        #$% else set depth to deep
        else                      odeep = 'deep'
        #$% write sub class data
        write (35,9003) nprob, sos$sub$class, odeep, omode
       }
    #$% break loop
    break
   }
 
#$% if region is zero, write that it does not exist
if (jf == 0) write (35,9004) int(args[4])
 
write (35,9000)
 
return
end
 

subroutine fpbistatic (nargs,args)                   # print bistatic data
 
##################################################################
#$%
#$% Purpose:   FPBISTATIC prints the appropriate bistatic data.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     None.
#$%
#$% Tables:    SOS     BIS
#$%
#$% Date:      June 91
#$%
#$% Author:    C. Leaf
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer   pair_ptr
integer   nargs
literal   args[$max$args]
integer   sos$pointer, sos$address, bis$pointer, bis$address
 
9000 format (//)              # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Bistatic Sosus Regions ---",/)
9005 format (/" Region # --- Region Area --- Node Density --- Node Range ---")
9007 format (       i7,     8x,    f10.2,     8x,f5.3,        12x, f6.2)
 
#              0         1         2         3         4         5         6         7
#              0123456789012345678901234567890123456789012345678901234567890123456789012
9002 format (//"    ------ ",a5,x,a17," ----- Bistatic Pairs ------",/) # 12/27/99
9003 format (" --- Active Source --- Passive Receiver ---",/)
9009 format (6x, a8, 11x, a8)   # jb E2141 (8-char.nmes)    12/27/99
 
9004 format (" Region #", i3, " does not exist.")
9006 format (" There are no Bistatic Pairs.")
9008 format (" Sosus region #", i3, "is not bistatic.")
 
if (args[2] == $lex$ALL$ | args[3] == $lex$REGION$)      # print region data
  {
   write (35,9001) scenario$name,mdate ## ,mtime (mdate now 17 char.) 12/15/99
   write (35,9005)
   if (args[2] == $lex$ALL$ | args[4] == $lex$ALL$)
     {
      #$% print ALL BISTATIC region data
      for (sos$pointer$first; sos$pointer$valid; sos$pointer$next)
        {
         sos$map
         if (sos$BIS$RegionArea == 0) next
         write (35,9007) SOS$RegNumber, SOS$BIS$RegionArea,
                         SOS$BIS$NodeDensity,SOS$BIS$Range
        }
     }
   else # print specified BISTATIC region data
     {
      if (args[4] < 1 | args[4] > $sosus)
        {
         write (35,9004) args[4]
         return
        }
 
      #$% get region data
      sos$pointer$to args[4]
      sos$map
      if (SOS$BIS$RegionArea == 0)
        write (35, 9008) args[4]
      else
        write (35,9007) SOS$RegNumber, SOS$BIS$RegionArea,
                        SOS$BIS$NodeDensity, SOS$BIS$Range
     }
  }
 
if (args[2] == $lex$ALL$ | args[3] == $lex$PAIRS$)
  {
   write (35,9002) scenario$name,mdate ## jb (mdate now 17 char.) 12/15/99
   write (35,9003)
 
   if (nbis == 0)
     {
      write (35, 9006)
     }
   else
     {
      for (pair_ptr = 1; pair_ptr <= nbis ; pair_ptr = pair_ptr + 1)
        {
         BIS$Pointer$To pair_ptr
         BIS$map
         write (35, 9009) BIS$ActiveSource, BIS$PassiveReceiver
        }
     }
  }
 
return
end

 
subroutine fpswabs (nargs,args)                  # print all SWABS regions
 
#####################################################################
#$%
#$% Purpose:   FPSWABS is called to print SWABS Environment Regions.
#$%            An initial test is made to determine if the order
#$%            is to print just one region or to print all.
#$%
#$% Called By: FPRINT   FPALL
#$%
#$% Calls:     FPSWB
#$%
#$% Tables:    None
#$%
#$% Date:      February 1991
#$%
#$% Author:    Carol Kropp and Susan Miller
#$%
#####################################################################
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer swb$pointer, swb$address
 
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," -- SWABS Environment Regions --",/)
9005 format (/" View - Region -------- Location"//" -------- Sigma ------------ Position Points-----")
9006 format ( "        Number           error  "//"                               Lat       Lon",/)
 
#$% write header record
write (35,9001) scenario$name,mdate ## jb (mdate now 17 char.) 12/15/99
write (35, 9005)                         # Write SWABS header
write (35, 9006)
 
if (args[2] != $lex$ALL$ & args[4] != $lex$ALL$)# Test to see if forth arg is
    {                                           # ALL.  If not ALL, call fpswb
    call fpswb (nargs,args)                     # to print only one swabs
    return                                      # region; otherwise, if ALL,
    }                                           # loop thru all the entries
                                                # and call fpswb to print
                                                # each one until end of loop.
                                                #############################
for (swb$pointer$first; swb$pointer$valid; swb$pointer$next)
   {
    swb$map
    #$% if SWB region slot not in use, get next
    if ((SWB$InUse == $no) | (SWB$regdefined == $no))
      next
 
    #$% write SWABS region data
    args[4] = SWB$regnumber      # load SWABS region number
    if (swb$regnumber > $SWABS$Orange$offset)
      args[5] = $lex$orange$
    else   # Blue region
      args[5] = $lex$blue$
    nargs = 5
    call fpswb (nargs,args)      # print SWABS region data
   }
 
return
end

 
subroutine fpswb (nargs,args)                   # print a SAWBS region
 
#############################################################
#$%
#$% Purpose:   FPSWB prints data for an individual SWABS
#$%            Environment Region.
#$%
#$% Called By: FPSWABS
#$%
#$% Calls:     FGLAT      FGLONG
#$%
#$% Tables:    None
#$%
#$% Date:      February 1991
#$%
#$% Author:    Carol Kropp and Susan Miller
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args], latn, longn
integer region_number
integer swb$pointer, swb$address, swb$pos$index
 
9000 format (/)
9004 format ( " Region #", i3, " does not exist.")
9007 format (" BLUE  ", i4, 13x, i5, 12x, i5,15x, a6, 2x, a7)
9008 format (" ORANG ", i4, 13x, i5, 12x, i5,15x, a6, 2x, a7)
9009 format (61x, a6, 2x, a7)
 
   SWB$pointer$to  args[4]
   SWB$map
   if (SWB$InUse != $no)
     {
      #$% set POS index to one
      SWB$pos$index = 1
 
      call fglat (SWB$pos$lat, latn)       # Get the lat & lon of
      call fglong (SWB$pos$lon, longn)     # first point
 
      #$% write SWABS region data
      if (args[5] == $lex$blue$)
        write (35, 9007) SWB$regnumber, SWB$locationerror, SWB$sigma, latn, longn
      else
        {
         region_number = args[4] - $SWABS$Orange$offset
         write (35, 9008) region_number, SWB$locationerror, SWB$sigma, latn, longn
        }
 
      #$% for each entry                        # Get the remaining points
      for (SWB$pos$index = 2; SWB$pos$index <= SWB$pos$slots;
                                      SWB$pos$index = SWB$pos$index + 1)
        {
         #$% if SWABS position latitude is maximum, break loop
         if (SWB$pos$lat == 99)
           break
         call fglat (SWB$pos$lat, latn)
         call fglong (SWB$pos$lon, longn)
         #$% write latitude and longitude
         write (35, 9009) latn, longn
        }
     }                 # end if position in use
   else
     write (35, 9004) int(args[4])
 
write (35, 9000)                         # Single space; prepare for next
 
return
end
 

 
subroutine fpsona (nargs,args)                   # print all Sonar regions
 
##################################################################
#$%
#$% Purpose:   FPSONA is called to print Sonar Environment Regions.
#$%            An initial test is made to determine if the order
#$%            is to print just one region or to print all.
#$%
#$% Called By: FPRINT   FPALL
#$%
#$% Calls:     FPSON
#$%
#$% Tables:
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer son$pointer, son$address, i
 
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," -- Sonar Environment Regions --",/)
9005 format (/" Region ---------- Environment"//" ------------ Position Points-----")
9006 format ( " Number               Plan    "//"                 Lat     Lon")
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9005)                                 # Write Sonar headers
write (35,9006)
 
#$% set SON pointer
son$pointer$first
son$map
                                                ###############################
                                                #
if (args[2] != $lex$ALL$ & args[3] != $lex$ALL$)# Test to see if third arg is
    {                                           # ALL.  If not ALL, call fpson
    call fpson (nargs,args)                     # to print only one sonar
    return                                      # region; otherwise, if ALL,
    }                                           # loop thru all the entries
                                                # and call fpson to print
                                                # each one until end of loop.
#$% for each sonar environment region entry     #
for (i=1; i<=nson; i=i+1)                       ##############################
   {
    #$% load sonar region number
    args[3] = son$regnumber
    #$% print specified sonar regional data
    call fpson (nargs,args)
    #$% set SON pointer to next
    son$pointer$next
    son$map
   }
 
return
end

 
subroutine fpson (nargs,args)                   # print a Sonar region
 
#############################################################
#$%
#$% Purpose:   FPSON prints data for an individual Sonar
#$%            Environment Region.
#$%
#$% Called By: FPSONA
#$%
#$% Calls:     FGLAT      FGLONG
#$%
#$% Tables:
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],latn,longn
integer jf,j, son$pointer, son$address, son$pos$index
 
9000 format (/)
9004 format ( " Region #", i3, " does not exist.")
9007 format (       i7,            17x,i2,              18x,   a6, 1x, a7)
9009 format (  44x, a6, 1x, a7)
 
jf = 0
#$% for each Sonar entry
for (j=1; j<=nson; j=j+1)
   {                                            #printing region data
    #$% set SON pointer
    son$pointer$to j
    son$map
 
    #$% if entry is not Sonar Environment Region number, get next entry
    if (son$regnumber != args[3]) next
 
    jf = 1
 
    #$% set POS index to one                    # Get the lat & lon of
    son$pos$index = 1                           # first point
    #$% get latitude
    call fglat (son$pos$lat,latn)
    #$% get longitude
    call fglong (son$pos$lon,longn)
    #$% write SONAR region data
    write (35,9007) son$regnumber,son$sonarenv,latn,longn
 
    #$% for each entry                          # Get the remaining points
    for (son$pos$index = 2; son$pos$index <= son$pos$slots;
         son$pos$index = son$pos$index +1                  )
        {
        #$% if SON position latitude is maximum, break loop
        if (son$pos$lat == 99) break
        #$% get latitude
        call fglat (son$pos$lat,latn)
        #$% get longitude
        call fglong (son$pos$lon,longn)
        #$% write latitude and longitude
        write (35,9009) latn,longn
        }
   }
#$% if region is zero, write that it does not exist
if (jf == 0) write (35,9004) int(args[3])
 
write (35,9000)                         # Single space; prepare for next
 
return
end
 

subroutine fplidar (nargs,args)                  # print all LIDAR regions
 
##################################################################
#$%
#$% Purpose:   FPLIDAR is called to print LIDAR Diffuse Regions.
#$%            An initial test is made to determine if the order
#$%            is to print just one region or to print all.
#$%
#$% Called By: FPRINT   FPALL
#$%
#$% Calls:     FPLDR
#$%
#$% Tables:    None
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer ldr$pointer, ldr$address
 
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," -- LIDAR Regions --",/)
9005 format (/" Region ---------- Diffuse ------------ Position Points-----")
9006 format ( " Number          coefficient             Lat       Lon",/)
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35, 9005)                         # Write LIDAR header
write (35, 9006)
 
if (args[2] != $lex$ALL$ & args[3] != $lex$ALL$)# Test to see if third arg is
    {                                           # ALL.  If not ALL, call fpldr
    call fpldr (nargs,args)                     # to print only one lidar
    return                                      # region; otherwise, if ALL,
    }                                           # loop thru all the entries
                                                # and call fpldr to print
                                                # each one until end of loop.
                                                #############################
for (ldr$pointer$first; ldr$pointer$valid; ldr$pointer$next)
   {
    ldr$map
    #$% if LDR slot not in use, get next
    if (LDR$InUse == $no) next
 
    #$% write LIDAR region data
    args[3] = LDR$regnumber      # load LIDAR region number
    call fpldr (nargs,args)      # print LIDAR region data
   }
 
return
end

 
subroutine fpldr (nargs,args)                   # print a LIDAR region
 
#############################################################
#$%
#$% Purpose:   FPLDR prints data for an individual LIDAR
#$%            Environment Region.
#$%
#$% Called By: FPLIDAR
#$%
#$% Calls:     FGLAT      FGLONG
#$%
#$% Tables:    None
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args], latn, longn
integer ldr$pointer, ldr$address, ldr$pos$index
 
9000 format (/)
9004 format ( " Region #", i3, " does not exist.")
9007 format (i5, 15x, f6.3, 14x, a6, 3x, a7)
9009 format (40x, a6, 3x, a7)
 
  ldr$pointer$to args[3]
  ldr$map
  if (ldr$InUse != $no)
    {
     #$% set POS index to one
     ldr$pos$index = 1
 
     call fglat (ldr$pos$lat, latn)       # Get the lat & lon of
     call fglong (ldr$pos$lon, longn)     # first point
 
     #$% write LIDAR region data
     write (35, 9007) ldr$regnumber, ldr$kvalue, latn, longn
 
     #$% for each entry                        # Get the remaining points
     for (ldr$pos$index = 2; ldr$pos$index <= ldr$pos$slots;
                             ldr$pos$index = ldr$pos$index + 1)
       {
        #$% if LIDAR position latitude is maximum, break loop
        if (ldr$pos$lat == 99)
          break
        call fglat (ldr$pos$lat, latn)
        call fglong (ldr$pos$lon, longn)
        #$% write latitude and longitude
        write (35, 9009) latn, longn
       }
    }                 # end if position in use
  else
    write (35, 9004) int(args[3])
 
  write (35, 9000)                         # Single space; prepare for next
 
return
end
 

 
subroutine fpaml (nargs,args)                   # print Air Maint Log
 
##################################################################
#$%
#$% Purpose:   FPAML prints the Aircraft Maintenance Log data.
#$%
#$% Called By: FPRINT
#$%
#$% Calls:     None
#$%
#$% Tables:    AML
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  Carol Kropp - 4/95  (E1393)
#$%            Added display of squadron name and default
#$%            mission information.
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
 
integer  squadron_index
literal  squadron_name
literal  mission_name, astab_mission
integer  aml$pointer, aml$address, litcmp, sqd$pointer, sqd$address
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Aircraft Maintenance Log ------",/)
 
#             0..../....1..../....2..../....3..../....4..../....5..../....6
#              12345aaaaa123aaaaa12345aaaaa1nnnnnnnnnnnnnnnn1234aaaaaaaa12345aaaaaaaa
 
#005 format (/"     Side    Aircraft  Base  ------Time------    Squadron     Default")
#006 format ( "     Number  Type      Name  Flown         Up    Name         Mission"/)
#007 format (    5x,a5,3x,  a5,5x,    a5,1x,i8,       i8,4x,    a8,5x,      a8)
#              12345aaaaa123aaaaa12345aaaaa1nnnnnnnnnnnnnnnn1234aaaaaaaa12345aaaaaaaa
9005 format (/"  Side    Aircraft   Base    "//" ------Time------    Squadron    Default")
9006 format ( "  Number  Type       Name    "//" Flown         Up    Name        Mission"/)
9007 format (    2x,a5,   3x,a8,  3x,a8,     i6,        3x,i8,4x,a8,4x,      a8)
#              12aaaaa123aaaaaaaa123aaaaaaaa1nnnnnnnnnnnnnnnn1234aaaaaaaa12345aaaaaaaa
 
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9005)
write (35,9006)
 
if (args[2] == $lex$all$)
   {
    args[3] = 'AA000'
    args[4] = 'ZZ999'
   }
 
#$% for each AML entry
for (aml$pointer$first; aml$pointer$valid; aml$pointer$next)
   {
    aml$map
    #$% if AML slot not in use, break loop
    if (aml$InUse == $no) break
    #$% if side number is less than entry, get next
    if (litcmp(aml$sidenumber, args[3]) < 0) next
    #$% if side number is greater than entry, break loop
    if (litcmp(aml$sidenumber, args[4]) > 0) break
 
    squadron_index = AML$SQDIndx
    SQD$Pointer$To  squadron_index
    SQD$Map
    squadron_name = SQD$SquadronName
    mission_name  = Astab_Mission (aml$defaultmission)
 
    #$% write AML data
    write (35,9007) aml$sidenumber,aml$type,aml$basename,aml$timeflown,
                    aml$timeup, squadron_name, mission_name
   }
 
write (35,9000)
 
return
end

 
subroutine fpemco (nargs,args)                  # print all emcon plans
 
####################################################
#$%
#$% Purpose:   FPEMCO prints all EMCON plans.
#$%
#$% Called By: FPRINT     FPALL
#$%
#$% Calls:     FPEMC1
#$%
#$% Tables:    None
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
####################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args],side
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- BLUE Emcon Plans ------",/)
9002 format (//"   ------ ",a5,x,a8,a1,x,a5," --- ORANGE Emcon Plans ------",/)
 
#             12345aaaaa12aaa123456aaa12aaa1234567aaa1234567aaa1234aaa12aaa1234aaa
#             0..../....1..../....2..../....3..../....4..../....5..../....6
9005 format (/"     Name   Surface  Air  Approach"//"  Airborne  Sonar  HF   HFLRI  UHF",/)
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9005)
side = 'BLUE'
#$% print blue EMCON plan
call fpemc1 (side)
 
 
#$% write header record
write (35,9001) scenario$name,mdate ## jb (mdate now 17 char.) 12/15/99
write (35,9005)
side = 'ORANG'
#$% print orange EMCON plan
call fpemc1 (side)
 
write (35,9000)
 
return
end

 
subroutine fpemc1 (side)           # print selected emcon plans
 
########################################################
#$%
#$% Purpose:   FPEMC1 prints selected EMCON plans.
#$%
#$% Called By: FPEMCO
#$%
#$% Calls:     None
#$%
#$% Tables:    EMCON
#$%
#$% Date:      JANUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
########################################################
 
IMPLICIT NONE
ForceCommon
 
Literal side,pemcon[8]
integer icnt, emcon$index, emcon$option$index, i
 
9003 format (5x,a5,2x,a3,6x,a3,2x,a3,7x,a3,7x,a3,4x,a3,2x,a3,4x,a3)
9004 format ("     None entered at this time"/)
 
#$% set counter to zero
icnt = 0
 
#$% for each EMCON entry
for (emcon$index = 1 ;emcon$index <= nemcon; emcon$index = emcon$index + 1)
   {
    #$% if not same side, get next
    if (emcon$side != side) next
 
    #$% increment counter
    icnt = icnt + 1
 
    #$% for each EMCON option entry
    for (emcon$option$index = 1 ;emcon$option$index <= 8;
         emcon$option$index = emcon$option$index + 1)
       {
        #$% if option is on, set EMCON to YES
        if (emcon$option == $on) pemcon[emcon$option$index] = 'YES'
        #$% else set EMCON to NO
        else                     pemcon[emcon$option$index] = 'NO'
       }
 
    #$% write EMCON data
    write (35,9003) emcon$name,(pemcon[i],i=1,8)
 
   }
#$% if counter is zero, write none entered at this time
if (icnt == 0) write (35,9004)
 
return
end
 

 
subroutine fpeph (nargs,args)               # print all prob of hit data
 
####################################################################
#$%
#$% Purpose:   FPEPH prints all data for Probabilities of Hit.
#$%
#$% Date:      NOVEMBER 1983
#$%
#$% Author:    Jim Kvederis
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs, nxtpercent
literal args[$max$args], nxttarget, nxtweapon
integer iflag, i
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," ------ Prob of Hit ------",/)
#             0         1         2         3         4         5         6         7
#             0123456789012345678901234567890123456789012345678901234567890123456789012
9002 format (" Target      Weapon     Percent ")
9003 format (1x,a8,4x,a8,4x,i3)
9004 format ("     None entered at this time"/)
 
#$% set EPH pointer
#eph$pointer$first
#eph$map
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9002)       # print header
 
## requested target only
if (args[3] != 'ALL' & nargs > 3)  ## tpa 2/15/84
    {
    call fpeph1 (nargs,args)
    return
    }
 
#$% for each PROB OF HIT entry
iflag = 0             # set to no entries to print
for (i=1; i<=neph; i=i+1)
   {
    call fephsort (nxttarget, nxtweapon, nxtpercent, iflag)
    #$% write PROB OF HIT data
    write (35,9003) nxttarget, nxtweapon, nxtpercent
    iflag = 1         # indicates that at least one entry to print
    #$% set EPH pointer to next
   }
if (iflag == 0) write (35,9004)      # no entries to print
 
write (35,9000)
 
return
end
 

subroutine fpeph1 (nargs,args)            # print requested prob of hit data
 
####################################################################
#$%
#$% Purpose:   FPEPH prints all data for Probabilities of Hit for a
#$%            selected target.
#$%
#$% Date:      NOVEMBER 1983
#$%
#$% Author:    Jim Kvederis
#$%
#######################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs, newpercent[ARB]
literal args[$max$args], nxttarget, nxtweapon, newtarget[ARB], newweapon[ARB]
literal cmpwep, lowwep
integer iflag, iset, eph$pointer, eph$address, icnt, i, j, k,
        MCMP,LITCMP,INDX,NXTPERCENT
 
 
9000 format (//)
9003 format (1x,a8,4x,a8,4x,i3)
9004 format ("     None Entered At This Time"/)
 
iflag = 0             # set to no entries to print
iset  = 1
                                         # generate eph array
eph$pointer$first
eph$map
 
icnt = 0
for (i=1 ; i<=neph ; i=i+1)
   {
    if (args[3] == eph$target)
       {
        icnt = icnt + 1
        newtarget[icnt] = eph$target
        newweapon[icnt] = eph$weapon
        newpercent[icnt] = eph$percent
       }
    eph$pointer$next
    eph$map
   }
 
#$% for each PROB OF HIT entry
for (j=1; j<=icnt; j=j+1)
   {
    #$% set max name
    lowwep = $highest$ascii
 
    for (k=1; k<=icnt; k=k+1)
       {
        if (newweapon [k] == 0) next
        cmpwep = newweapon[k]
 
        mcmp = litcmp(cmpwep, lowwep)
        if (mcmp >= 0) next
 
        #$% if best so far
        lowwep = cmpwep
 
        #$% save pointer
        indx = k
       }
    #$% save next entry in numerical order
    nxttarget  = newtarget[indx]
    nxtweapon  = newweapon[indx]
    nxtpercent = newpercent[indx]
 
    #$% clear array to prevent repeats
    newtarget[indx]  = 0
    newweapon[indx]  = 0
    newpercent[indx] = 0
 
    write (35,9003) nxttarget, nxtweapon, nxtpercent
    iflag = 1         # indicates that at least one entry to print
 
   }
 
if (iflag == 0) write (35,9004)
 
write (35,9000)
 
return
end
 

 
Subroutine fephsort (nxttarget, nxtweapon, nxtpercent, iflag)
 
###########################################################################
#$%
#$% Purpose:   FEPHSORT arranges targets and associated weapons in
#$%            alphabetical order when ALL PROBHITS are to be displayed.
#$%
#$% Date:      December 1983
#$%
#$% Author:    Jim Kvederis
#$%
###########################################################################
 
IMPLICIT NONE
ForceCommon
 
literal newtarget[$eph], newweapon[$eph], nxttarget, nxtweapon
literal lowtarget, cmpname, lowwep, cmpwep
integer newpercent[$eph], nxtpercent
integer IFLAG, ISET, eph$pointer, eph$address, I, NCMP,
        LITCMP, MCMP, INDX
 
if (iflag == 0)                      # if first pass
   {
    iset = 1
                                         # generate eph array
    eph$pointer$first
    eph$map
 
    for (i=1 ; i<=neph ; i=i+1)
       {
        newtarget[i] = eph$target
        newweapon[i] = eph$weapon
        newpercent[i] = eph$percent
 
        eph$pointer$next
        eph$map
       }
   }
 
#$% set max name
lowtarget = $highest$ascii
 
for (i=1 ; i<=neph ; i=i+1)
   {
    if (newtarget[i] == 0) next
 
    cmpname = newtarget[i]
    cmpwep = newweapon[i]
 
    #$% if cmpname not lower than lowtarget, get next entry
    ncmp = litcmp(cmpname,lowtarget)
    if (ncmp > 0) next
    else if (ncmp == 0)
      {
        mcmp = litcmp(cmpwep, lowwep)
        if (mcmp >= 0) next
       }
 
    #$% if best so far
    lowtarget = cmpname                     # at this point, have
    lowwep = cmpwep                         # best candidate so far
 
    #$% save pointer
    indx = i
   }
#$% save next entry in numerical order
nxttarget = newtarget[indx]
nxtweapon = newweapon[indx]
nxtpercent = newpercent[indx]
 
#$% clear array to prevent repeats
newtarget[indx] = 0
newweapon[indx] = 0
newpercent[indx] = 0
 
return
end
 

 
subroutine fpbml (nargs,args)                   # print Boat Maint Log
 
##################################################################
#$%
#$% Purpose:   FPbml prints the Boat Maintenance Log data.
#$%
#$% Called By: FPRINT     FPALL
#$%
#$% Calls:     None
#$%
#$% Tables:    BML
#$%
#$% Date:      MAY 1989
#$%
#$% Author:    Arturo Ma
#$%
##################################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer bml$pointer, bml$address, litcmp
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Boat Maintenance Log ------",/)
 
#             0..../....1..../....2..../....3..../....4..../....5..../....6
#              12345aaaaa123aaaaa12345aaaaa1
 
9005 format (/"  Boat       Boat       Base ")   # jb E2141 12/27/99
9006 format ( "  Name       Class      Name "/)  # jb E2141 12/27/99
9007 format (    2x,a8,3x,     a8,3x,    a8,1x )   # jb E2141 12/27/99
#              12aaaaaaaa123aaaaaaaa123aaaaaaaa1
 
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9005)
write (35,9006)
 
if (args[2] == $lex$all$)
   {
    args[3] = 'A'
    args[4] = 'ZZZZZ'
   }
 
#$% for each BML entry
for (BML$Pointer$First; BML$Pointer$Valid; BML$Pointer$Next)
    {
    BML$map
    #$% if BML slot not in use, break loop
    if (BML$InUse == $no) break
 
    #$% if boat name is less than entry, get next
    if (litcmp(BML$name, args[3]) < 0) next
    #$% if boat name is greater than entry, break loop
    if (litcmp(BML$name, args[4]) > 0) break
 
    #$% write BML data
    write (35,9007) BML$name,BML$class,BML$basename
   }
 
write (35,9000)
 
return
end
 

subroutine fpuvp (nargs,args)     # print all UAV probability data
 
####################################################################
#$%
#$% Purpose:   FPUVP prints all data for UAV Probabilities with
#$% respect to range.
#$%
#$% Date:      2/5/90
#$%
#$% Author:    R. Hundt
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs, save_numranges
literal args[$max$args]
 
literal Type
integer uvp$index, iflag
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," ---- UAV Probabilities ----",/)
#             0         1         2         3         4         5         6         7
#             0123456789012345678901234567890123456789012345678901234567890123456789012
9002 format ("      Target Type Index           Type")
9006 format (14x,i3,17x,a8)
9005 format ("      Range (nm)   Detect Pb     Recognize Pb  Identify Pb")
9003 format (9x,i3,10x,i3,12x,i3,12x,i3)
9004 format ("      None entered at this time"/)
 
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9002)       # print header
 
#$% for each PROB OF HIT entry
iflag = 0             # set to no entries to print
for (UVP$Index=1; UVP$Index<=nuvp; UVP$Index=UVP$Index+1)
    {
    IF ( args [ 3 ] == UVP$TargTypeIndex | args [ 3 ] == $LEX$ALL$ )
        {
        IF (UVP$Type == $UAV$Fixed)
            {
            Type = 'Fixed'
            }
        ELSE IF (UVP$Type == $UAV$Mobile)
            {
            Type = 'Mobile'
            }
 
        write(35,9006) UVP$TargTypeIndex,Type
 
        write(35,9005)
 
        save_numranges = UVP$NumRanges
 
        FOR (UVP$NumRanges = 1; UVP$NumRanges <= $UAV$NumRangesPerType;
             UVP$NumRanges = UVP$NumRanges + 1)
            {
            #$% write UAV PROBABILITIES data
            write (35,9003) UVP$Range,UVP$DetectPb,UVP$RecognitionPb,
                            UVP$IdentPb
 
            iflag = 1         # indicates that at least one entry to print
            }
 
        UVP$NumRanges = save_numranges
        }
    }
 
if (iflag == 0) write (35,9004)      # no entries to print
 
write (35,9000)
 
return
end
 

subroutine fpmdr (nargs,args)
####################################################################
#$%
#$% Purpose:   FPMDR prints all sonobuoy median detection ranges
#$%
#$% Date:      JUNE 90
#$%
#$% Author:    R. Hundt
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
integer mdr$index, iflag
 
9000 format (//)
 
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Sonobuoy Mean Detections ---",/)
#             0         1         2         3         4         5         6         7
#             0123456789012345678901234567890123456789012345678901234567890123456789012
9002 format ("                                    Range(nm) for Evironment")
9003 format (" Sonobuoy   Submarine Class       Good   Fair   Poor   Default")
9004 format (1x,a8,4x,a8,12x,f5.1,2x,f5.1,2x,f5.1,2x,f5.1)
9005 format ("     None entered at this time"/)
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9002)       # print header
write (35,9003)       # print header
 
##$% for each mean detection range entry
iflag = 0             # set to no entries to print
for (MDR$Index=1; MDR$Index<=nmdr; MDR$Index=MDR$Index+1)
    {
    if (args[3] == 'ALL' | args[3] == MDR$SonobuoyName)
        {
        #$% write sonobuoy mean detection range data
        write (35,9004) MDR$SonobuoyName, MDR$SubClass,
            MDR$GoodENVDetectRange, MDR$FairENVDetectRange,
            MDR$PoorENVDetectRange,MDR$DefaultENVDetectRange
        iflag = 1         # indicates that at least one entry to print
        }
    }
 
if (iflag == 0) write (35,9005)      # no entries to print
 
write (35,9000)
 
return
end

subroutine fpintra (nargs,args)
####################################################################
#$%
#$% Purpose:   FPINTRA prints all intra platform EMI data
#$%
#$% Date:      8/90
#$%
#$% Author:    hfisher - CSC
#$%
#############################################################
 
IMPLICIT NONE
ForceCommon
 
integer nargs
VaxCharacter*3 Work_Integer
literal args[$max$args]
integer intra$index, iflag, len
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- IntraPlatform EMI Relationships---",/)
#             0         1         2         3         4         5         6         7
#             012345678901234567890123456789012345678901234567890123456789012345678901234
9003 format (" Class  Victim  Impairment %  Culprit")
#9003 format (" CONNY  SPS40      15         SRN12")
9004 format (1x,a5,2x,a5,6x,a3,9x,a5)
9005 format ("     None entered at this time"/)
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9003)       # print header
 
#$% for each Intra EMI entry
iflag = 0             # set to no entries to print
for (INTRA$Index=1; INTRA$Index<=nintra; INTRA$Index=INTRA$Index+1)
    {
    if (args[3] == 'ALL' | args[3] == INTRA$Class)
        {
        #$% write EMI data
        Len = 0
        Call VMOVIZ (INT(INTRA$Percent),3,Work_Integer,Len)
        write (35,9004) INTRA$Class,INTRA$Victim,Work_Integer,INTRA$Culprit
        iflag = 1         # indicates that at least one entry to print
        }
    }
 
if (iflag == 0) write (35,9005)      # no entries to print
 
write (35,9000)
 
return
end
 

 
subroutine fp_freq_omission (nargs,args)
####################################################################
#$%
#$% Purpose:   FP_freq_omission prints freq_omission data EMI data
#$%
#$% Date:      6/91
#$%
#$% Author:    Hundt
#$%
#############################################################
IMPLICIT NONE
ForceCommon
 
integer nargs
literal args[$max$args]
 
logical*1   name_printed
integer     iflag, freq_omission$Index, freq_omission$item_index
 
9000 format (//)
                                 # \/ jb (mdate now 17 char's) 12/15/99
9001 format (//"    ------ ",a5,x,a17," --- Frequency Omission Plan ---",/)
#               0         1         2         3         4         5         6         7
#               12345678901234567890123456789012345678901234567890123456789012345678901234
9003 format (" Plan    Commpath   Item   Low-Freq(KHz)   High-Freq(KHz)")
9004 format (1x,a5,4x,a5, 6x,I2,7x,I7,10x,I7)
9005 format ("     None entered at this time"/)
9006 format (1x,a5,4x,a5)
 
#$% write header record
write (35,9001) scenario$name,mdate # ,mtime jb (mdate now 17 char.) 12/15/99
write (35,9003)       # print header
 
#$% for each Freq_omission EMI entry
iflag = 0             # set to no entries to print
for (freq_omission$Index=1;
     freq_omission$Index<=nfom;
     freq_omission$Index=freq_omission$Index+1)
    {
    if (args[3] == 'ALL' | args[3] == freq_omission$plan_name)
        {
        name_printed = $no
 
        for (freq_omission$item_index = 1;
             freq_omission$item_index <= $maxFomItems;
             freq_omission$item_index = freq_omission$item_index + 1)
            {
            #$% if no frequency boundary
            if ((freq_omission$LowFreq == 0 |
                 freq_omission$HiFreq == 0 ))
                {
                next
                }
 
            if (name_printed == $no)
                {
                write (35,9004) freq_omission$Plan_Name,
                                freq_omission$Path_Name,
                                freq_Omission$item_index,
                                freq_Omission$LowFreq,
                                freq_Omission$HiFreq
                name_printed = $yes
                }
            else
                {
                write (35,9004) " "," ",
                                freq_Omission$item_index,
                                freq_Omission$LowFreq,
                                freq_Omission$HiFreq
                }
 
            iflag = 1         # indicates that at least one entry to print
            } # end for all items (boundaries)
 
        #$% if no boundary conditions yet entered but commpath has been entered
        if (freq_omission$Path_Name != 0 &
            name_Printed == $no )
            {
            write (35,9006) freq_omission$Plan_Name,
                            freq_omission$Path_Name
            iflag = 1
 
            }
 
        } # end if print information for this entry
    }
 
if (iflag == 0) write (35,9005)      # no entries to print
 
write (35,9000)
 
return
end

subroutine fmovlls (rval,hems)
 
############################################################
#$%
#$% Purpose:   FMOVLLS moves formatted DDD-MMM-SSh to buffer.
#$%            rval is expected to be radians
#$%
#$% Called By:
#$%
#$% Calls:     SMOVLLS
#$%
#$% Tables:    None
#$%
#$% Date:      March 2000
#$%
#$% Author:    Dane Wills
#$%
############################################################
 
IMPLICIT NONE
ForceCommon
 
real    rval
VMSchar hems*(*)
 
call smovLLS (rval,hems,linebf,lenbf)
 
return
end
 
 
