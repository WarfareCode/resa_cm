#       LBCOMMN.RAT
#$%     Look in DOC.WHO for Flowchart and Subroutine Lists.
 
###   James Allen - 12/97 (E1833)
###   Add function match_wildcard which tests to see if given name
###   matches given pattern using vms style * and %.  Allows match
###   for unt$name and unt$event.
###
###   KHC - 5/93 (E1075)
###   The subroutine EXPORD was moved to this file from WGOP.RAT.
###   The processing of the FOR <addressee> [ ORDERS | SENSORS ]
###   commands was moved from the wargame process to the workstation.
 
###   DEW 7/19/89
###   Subroutines moved to LBMATH_PROXIM: GETRB, GETRB_LCL, GETRB_SL,
###                                       PSLANT, & SLRANG
 
###   DEW 3/16/89
###   Mods to all routines for version 5.1  i.e. change of UNT to
###   include all fields from POS and DYN, removal of DUP, ACD, SB,
###   and SHD.  Also, inclusion of DEQ table for equipment.
###
###   Subroutines Removed:  DYNGET, AIRGET, SBGET, SURGET, GEN_DUP, JAMTST
###   Subroutines Added:    DEQGET, DEQ_JAMTST, GET_DEQ_ENTRY, FREE_DEQ_CHAIN
###   Subroutines Modified: GETRB, GETRB_LCL, GETRB_SL, NAVERR, FNDWET
 
 
 
#####   version 3.1  dated-  7apr81
 
 
###
### mod to version 3.0          dated 15-mar-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 rjw     gttrk   now uses rmt$pointer as input to flag whether to
###                     start search at beginning or not
###
 
 
###
### mod to version 3.0          dated 26-feb-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 011 dew     bbsmap  Fixed bug to allow TENEX to open BlackBoard
###
 
 
###
### mod to version 3.0          dated 04-feb-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 rae     seturp  set unit initial value from rpm table
###             getrpm  finds rpm pointer appropriate to given unit
###             belong  determines if rpm task in unit hierarchy
###
 
 
###
### mod to version 3.0          dated 13-jan-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 dew     wgcat   moved code from wargam.rat
###             naverr  moved code from wglsh.rat
###             chkrel  moved code from satmod.rat
###             daytst  moved code from vismod.rat
###             whside  moved code from commod.rat
###
 
###
### mod to version 3.0          dated 06-jan-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 dew     getdet  Disabled.....
###             getact  Disabled.....
###             gettrk  Disabled.....
###             gtact   New- find active track in RMT table (replaces getact)
###             gttrk   New- find active track in RMT table (replaces gettrk)
###
 
 
#####   version 3.0  dated- 22dec80
 

 
define ($DEBUGSEG,#)            # generate allocation messages
define ($DEBUGSEG2,#)           # generate LOD1 messages
define ($DEBUGOPT,#)            # disable optimization (bbtrim)
 
include "ascii.inc"
include "bbacc.inc"
include "bbamh.inc"
include "bbaml.inc"             # clk 3/92 - Air Maintenance Log table
include "bbagd.inc"
include "bbbom.inc"
include "bbboy.inc"
include "bbcmc.inc"             # clk 3/92 - Cruise Missile Characteristics
include "bbcode.inc"
include "bbctl.inc"
include "bbctm.inc"             # clk 3/96 (E1561) - Counter Measure Characteristics
include "bbdac.inc"             # clk 3/92 - Destroyed AirCraft table
include "bbdss.inc"             # JFR 6/16/93 - Aircraft Battle Damage Assessment
include "bbdeq.inc"
include "bbiff.inc"
include "bbird.inc"
include "bbjam.inc"
include "bbjew.inc"
include "bblrt.inc"                                                   #smn002
include "bbmc.inc"              # clk 3/92 - Missile Characteristics
include "bbnam.inc"
include "bbnav.inc"                                                   #smn002
include "bbown.inc"                                                   #smn002
include "bbpai.inc"
include "bbpat.inc"                                                   #smn002
include "bbrad.inc"
include "bbrel.inc"                                                   #smn002
include "bbrmt.inc"                                                   #smn002
include "bbrpm.inc"                                                   #smn002
include "bbrvu.inc"
include "bbshc.inc"
include "bbson.inc"
include "bbsui.inc"
include "bbtor.inc"             # clk 3/92 - Torpedo & Gun Characteristics
include "bbtrp.inc"             # clk 3/96 (E1561) - Smart Torpedo Characteristics
include "bbunt.inc"
include "bbvue.inc"
include "bbwet.inc"
include "macros.inc"
include "orders.inc"
include "plplay.inc"
include "stmain.inc"
include "parallel.inc"
include "wimain_eq.inc"
define (BBimplicit,Implicit None)

Subroutine check_version (ierr,msg)
bbcommon
character msg[ARB]
integer   ierr, kk
 
ierr = NO
msg[1] = EOS
 
if (data$base$version == $$BBVersion) return    # correct version of database?
 
kk = 0
 
call smovv ("Database Version ",msg,kk)
 
if (int(data$base$version*100) != int($$BBVersion*100))
    {
    call smovv ("ERROR",msg,kk)
    ierr = YES
    }
else
    {
    call smovv ("WARNING",msg,kk)
    }
 
call smovv (" (",msg,kk)
call smovf (data$base$version,3,msg,kk)
call smovv (" DB Vs ",msg,kk)
call smovf ($$BBversion,3,msg,kk)
call smovv (" System) ",msg,kk)
 
call smov (EOS,msg,kk)
 
return
end
 
 
 
 
subroutine check_password(iside)
 
#################################################################
#$%  Check_version compares password for the side in question
#$% with user input.  Passwords are for blue, orange, and
#$% control.
#$%
#$% Modified:  James Allen - 12/97 (E1825)
#$%            Added for password checking of new tech control
#$%            station.
#$%
#################################################################
 
BBcommon
integer iside,lcomp,length
character line[8]
integer   len, ii, istat
 
  if ((iside == $blue$code & blue$password == 0) |
      (iside == $orange$code & orange$password == 0) |
      (iside == $TechControl$code & TechControl$password == 0) |
      (iside == $neutral$code & control$password == 0))
    RETURN
 
  call echor
  call echov("Enter Password: ")                            # E2144 dew 10/99
 
  call echop("HOLD")
  call getlnh(line,8)
  call echop("RELS")
  call UPPER(line)
  call echor
 
  len = length(line)
  for (ii = len+1; ii <= 8; ii = ii + 1)
    line(ii) = $SPACE
 
  if (iside == $blue$code)
    istat = lcomp(line,blue$password)
  else if (iside == $neutral$code)
    istat = lcomp(line,control$password)
  else if (iside == $TechControl$code)
    istat = lcomp(line,TechControl$password)
  else # must be orange
    istat = lcomp(line,orange$password)
 
  if (istat != 0)
    {
     call echov("Better luck next time!")                   # E2144 dew 10/99
     call echo($BELL)
     call echor
     call hltslf
    }
 
return
end

Subroutine DEQGET(unt$pointer,                  # receive UNT pointer
                  ident,                        # receive equipment ident code
                  nfound,                       # receive/return nbr items fnd
                  eqlist)                       # receive/return list of EQ
#######################################################
#$%
#$% Purpose:   DEQGET generates an equipment list for any unit.
#$%
#$%     eqlist[1,i] = DEQ$Pointer$Index
#$%     eqlist[2,i] = DEQ$Pntr$I
#$%     eqlist[3,i] = DEQ$Remaining$I
#$%     eqlist[4,i] = maximum range (integer)
#$%     eqlist[5,i] = number of simultaneous engagements
#$%
#$% Called By:
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT  DEQ  MC  CMC
#$%
#$% Date:      March 98
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 11/96 (E1695)
#$%            Added filling of data for max range and
#$%            number of simultaneous engagements for
#$%            both types of SAMs.
#$%
#######################################################
BBcommon
 
integer nfound, eqlist[5,ARB]
integer     ident
BBdeclare  (unt$pointer, deq$pointer, deq$remaining$i,
            mc$pointer, mc$MaxRange$i, bom$DropRange$i, bom$pointer,
            cmc$pointer, cmc$SamMaxRange$i, tor$pointer, tor$Maxef$i)
 
if ( ! unt$pointer$ok) return
 
DEQ$Pointer$to UNT$Pointer$index
 
For_DEQ_Chain (UNT$Pointer$index)            # if NOT iterative....
    {
    if (nfound >= ARB) break
 
    if(Xdeq$ident$i    != ident) next   # if wrong equipment type
 
    deq$remaining$i = Xdeq$remaining$i  # get equipment count
 
    if (deq$remaining$i == 0) next              # out of stock equipment
 
    if (Xdeq$TimeWhenUse$f > game$time) next  # damaged/disabled
 
    nfound = nfound + 1                         # increment number found
 
    eqlist[1,nfound] = DEQ$Pointer$index        # save index of equipment
    eqlist[2,nfound] = Xdeq$pntr$i              #   equipment pointer
    eqlist[3,nfound] = deq$remaining$i          #   equipment count
 
    if (ident == $SAM$Code)   # clk 11/96 (E1695)
      {
       MC$Pointer = eqlist[2,nfound]
       MC$MaxRange$I = xMC$MaxRange$I
       eqlist[4,nfound] = MAX (1, MC$MaxRange$I)
       eqlist[5,nfound] = xMC$NbrSimEngages$I
      }   # end of if this is an implicit SAM
    else if (ident == $AdvancedSAM$Code)
      {
       CMC$Pointer = eqlist[2,nfound]
       CMC$SamMaxRange$I = xCMC$SamMaxRange$I
       eqlist[4,nfound] = MAX (1, CMC$SamMaxRange$I)
       eqlist[5,nfound] = xCMC$SAMSimul$I
      }   # end of if this is an explicit SAM
    else if (ident == $ASM$Code)
      {
       MC$Pointer = eqlist[2,nfound]
       MC$MaxRange$I = xMC$MaxRange$I
       eqlist[4,nfound] = MAX (1, MC$MaxRange$I)
       eqlist[5,nfound] = 1
      }   # end of if this is an ASM
    else if (ident == $AAM$Code)
      {
       MC$Pointer = eqlist[2,nfound]
       MC$MaxRange$I = xMC$MaxRange$I
       eqlist[4,nfound] = MAX (1, MC$MaxRange$I)
       eqlist[5,nfound] = 1
      }   # end of if this is an AAM
    else if (ident == $BOMB$Code)
      {
       BOM$Pointer = eqlist[2,nfound]
       BOM$DropRange$I = xBOM$DropRange$I
       eqlist[4,nfound] = MAX (1, BOM$DropRange$I)
       eqlist[5,nfound] = 1
      }   # end of if this is a bomb
    else if (ident == $Gun$Code)
      {
       TOR$Pointer = eqlist[2,nfound]
       tor$maxef$i =0.5 +xtor$maxef$i / $Yds$Per$Mile
       eqlist[4,nfound] = tor$maxef$i
       eqlist[5,nfound] = 1
      }   # end of if this is a gun
    else  # as before initialize to zero
      {
       eqlist[4,nfound] = 0                        #
       eqlist[5,nfound] = 0                        #
      }
    }
 
return
end
 
 
subroutine sort_eqlist (eqlist,items,icol)      # sort equip list
 
########################################################
#$%
#$% Purpose:   sort_eqlist sorts the ITEMS rows in EQLIST
#$%            in ascending order based on the values in
#$%            column ICOL.
#$%
#$% Called By: AIRRAD
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$%
#$% Date:      APR 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
implicit none
integer         eqlist[5,ARB], items
integer		n, m, icol, isave
 
for (n = 1; n < items; n = n+1)
    {
    for (m = n+1; m <= items; m = m+1)
        {
        if (eqlist[icol,n] <= eqlist[icol,m]) next
 
        isave=eqlist[1,n]; eqlist[1,n]=eqlist[1,m]; eqlist[1,m]=isave
        isave=eqlist[2,n]; eqlist[2,n]=eqlist[2,m]; eqlist[2,m]=isave
        isave=eqlist[3,n]; eqlist[3,n]=eqlist[3,m]; eqlist[3,m]=isave
        isave=eqlist[4,n]; eqlist[4,n]=eqlist[4,m]; eqlist[4,m]=isave
        isave=eqlist[5,n]; eqlist[5,n]=eqlist[5,m]; eqlist[5,m]=isave
        }
    }
 
return
end                     # end of sort_eqlist
 
 
 Subroutine DEQ_JAMTST (DEQ$POINTER,            # receive equipment pointer
                                         # 5/4/89 REH, was RAD$OPERATINGFREQ$I,
                        RAD$CH$FREQUENCY$F, # op.frequency jb $F    1/18/91
                        NJAM,                   # receive ship/air flag and
                        NJPF)                   # return jammed/not jammed
                                                # return jammed perf factor
 
#######################################################
 #$%
 #$% Purpose:   JAMTST generates a test to determine
 #$%            jammer capabilities for ship and
 #$%            aircraft.
 #$%
 #$% Called By: CMHIT
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    SHD        JAM        ACD
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
BBcommon
integer     nJAM, JAMx, nJPF
BBdeclare  (jam$pointer, jam$fq$index,
            deq$pointer, deq$em$index,
            rad$ch$Frequency$f)
 
if(NJAM == $NO)                                 # if jammer on a ship
    {
    JAM$POINTER = XDEQ$PNTR$I                   # get jammer pointer
 
    do JAMX = 1, 10                             # check all bands
        {
        DEQ$EM$Index = JAMX                     # get jammer index
 
        if(XDEQ$EM$BAND$I == $YES)              # if jammer band active
            {
            JAM$FQ$INDEX = DEQ$EM$INDEX         # index band characteristics
 
            if(xjam$fq$centerfreq$i==NINT(RAD$CH$FREQUENCY$F)) #jb $F 1/18/91
                {
                NJAM = $YES                     # flag jammer capable
                NJPF = XJAM$FQ$PERFORMFACTOR$I
                break                           # exit the loop
                }                               # end if radar within band
            }                                   # end if band active
        }                                       # end do all bands
    }                                           # end if jammer on a ship
 
 return
 
 end
 
 
 Subroutine UNTFND(UNT$VIEW$I,                         #receive view
                   NAME,                               #receive name
                   UNT$POINTER)                        #return pointer
 
#######################################################
 #$%
 #$% Purpose:   UNTFND searches the unit table for
 #$%            a particular unit.
 #$%
 #$% Called By: OLOB       OPLOTC      OSTATI
 #$%            OXCIR      WGLSHP
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #$% Modified:  James Allen 3/05
 #$%            Add test for EventName and ForceName
 #######################################################
 
 BBcommon
integer     igot, litcmp
literal     cstrip8, name
BBdeclare  (unt$pointer, unt$name$c, unt$view$i, unt$Type$i)
 
 IGOT = $NO                                     #indicate not found
 
 for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT) #search unit array
    {
     if (Xunt$Status$i == $BeingDeleted$code) next      #joa 10/01 (E2242)
 
     unt$Type$i = Xunt$Type$i
     if(XUNT$VIEW$I == UNT$VIEW$I |             #if view matches or
        UNT$VIEW$I == $NEUTRAL$VIEW |           #view is CONTROL
        UNT$TYPE$I == $SHOREBASE$CODE)         #or unit is a base
       {
        if(litcmp(XUNT$NAME$C, NAME) == 0)    #if name match
          {
           IGOT = $YES                          #indicate found
 
           break                                #exit the loop
          }                                     #end if name match
        else if (Analytical$Run == $YES       &   # If not Training exercise...
                 unt$type$i     == $Air$Code  &   # for Aircraft.....
                 litcmp(xunt$Event$c, name) == 0 )   # check EVENT name
          {
           IGOT = $YES                          #indicate found
 
           break                                #exit the loop
          }
        else if (Analytical$Run == $YES       &   # If not Training exercise...
                 Xunt$SuperType$i == $SmallBoat$SuperCode  &   # for Boats...
                 litcmp(xunt$Event$c, name) == 0 )   # check EVENT name
          {
           IGOT = $YES                          #indicate found
 
           break                                #exit the loop
          }
        else if (litcmp(xunt$forcename$c,name) == 0)  # check Collective names
           {
           IGOT = $YES                          #indicate found
 
           break                                #exit the loop
           }
 
       }                                        #end if view match or CONTROL
 
    }                                           #end search of unit array
 
 if(IGOT == $NO)                                #if not found
   {
    UNT$POINTER = 0                             #return not found
   }                                            #end if not found
 return
 end
 
 
 Subroutine UNTGET(NTOFND,                             #receive number to find
                   NFIND)                              #return results
 
 
#######################################################
 #$%
 #$% Purpose:   UNTGET searches the UNT table for
 #$%            available slots
 #$%
 #$% Called By: OFCRU1
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
 BBcommon
integer     nfound, nfind, ntofnd
BBdeclare  (unt$pointer)
 
 dimension NFIND[11]
 
 NFOUND = 0                                     #indicate none found
 
 for(UNT$POINTER$FIRST;UNT$POINTER$VALID;UNT$POINTER$NEXT) #search unit array
 
    {
     if(XUNT$INUSE$I == $NO)                    #if slot not in use
 
       {
        NFOUND = NFOUND + 1                     #increment number found
 
        NFIND[NFOUND+1] = UNT$POINTER           #save unit pointer
 
        if(UNT$POINTER > UNT$LAST)              #if pointer beyond search
          {
           UNT$LAST$TO UNT$POINTER + UNT$ENTRY -1 #set new search limits
          }
        if(NFOUND == NTOFND | NFOUND == 10)     #if all found of array full
 
          {
           break                                #exit the search
          }                                     #end if all found
 
       }                                        #end if slot not in use
 
    }                                           #end for search unit file
 
 NFIND[1] = NFOUND                              #save number found
 
 return
 end

Subroutine EXPTST(ident,isexp)
 
#######################################################
#$%
#$% Purpose:   EXPTST returns YES/NO for a given
#$%            equipment type.  Return YES if it
#$%            is a deployable (expendable) item.
#$%
#$% Called By: RPINV1
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      DEC 80
#$%
#$% Author:    Ron Williams
#$%
#######################################################
implicit none
integer isexp, ident
byte    expend[0:64]
 
data expend[ $cruisemissile$code] /$yes/
data expend[           $aam$code] /$yes/
data expend[           $asm$code] /$yes/
data expend[           $sam$code] /$yes/
data expend[      $commbuoy$code] /$yes/
data expend[      $sonobuoy$code] /$yes/
data expend[          $mine$code] /$yes/
data expend[          $bomb$code] /$yes/
data expend[       $torpedo$code] /$yes/
data expend[          $wire$code] /$yes/
data expend[         $wbuoy$code] /$yes/
data expend[          $rboc$code] /$yes/
data expend[          $ciws$code] /$yes/
data expend[           $gun$code] /$yes/
data expend[           $GND$code] /$yes/     # added for amphib 11-dec-89
data expend[  $SmartTorpedo$code] /$yes/     # new Torpedo Units  Apr-90
data expend[$CounterMeasure$code] /$yes/   # new Unit type  Apr-90
data expend[         $chaff$code] /$yes/     # jb                8/2/90
data expend[   $AdvancedSAM$Code] /$yes/ # SMM 12/93 added for Advanced air defense
 
isexp = expend[ident]
 
return
end
 

 
subroutine fgtask (itask,taskn)     # generate 0.0.0.0 from number
 
########################################################
#$%
#$% Purpose:   FGTASK generates the force unit task
#$%            number from an integer value.
#$%
#$% Called By: FPFORC     FSAVEP     FSAVFC
#$%            FGVFOR
#$%
#$% Calls:     IPBYTE
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
implicit none
literal taskn
integer itask
integer kk
 
kk = 0; call smovv ("0.0.0.0", taskn, kk)
 
if (itask > 9999)
    {
    call ipbyte (taskn,1,mod(itask/10000,10)+$dig0)
    call ipbyte (taskn,3,mod(itask/1000,10)+$dig0)
    call ipbyte (taskn,5,mod(itask/100,10)+$dig0)
    call ipbyte (taskn,7,mod(itask/10,10)+$dig0)
    call ipbyte (taskn,8,mod(itask,10)+$dig0)
    }
else
    {
    call ipbyte (taskn,1,mod(itask/1000,10)+$dig0)
    call ipbyte (taskn,3,mod(itask/100,10)+$dig0)
    call ipbyte (taskn,5,mod(itask/10,10)+$dig0)
    call ipbyte (taskn,7,mod(itask,10)+$dig0)
    }
 
return
end
 
 
subroutine fglat (lat,latn)         # generate 99-00N form from number
 
####################################################
#$%
#$% Purpose:   FGLAT converts an integer number
#$%            to a latitude geocoordinate.
#$%
#$% Called By: FPFORC     FPCHR1
#$%
#$% Calls:     IPBYTE
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 81
#$%
#$% Author:    Dana Wills
#$%
####################################################
implicit none
literal latn
integer lat, k, kk
 
kk = 0; call smovv ("00-00N", latn, kk)
k = iabs(lat)
call ipbyte (latn,1,mod(k/1000,10)+$dig0)
call ipbyte (latn,2,mod(k/100,10)+$dig0)
call ipbyte (latn,4,mod(k/10,10)+$dig0)
call ipbyte (latn,5,mod(k,10)+$dig0)
 
if (lat < 0) call ipbyte (latn,6,$letS)
return
end
 
 
subroutine fglong (long,longn)     # generate 999-00E form from number
 
####################################################
#$%
#$% Purpose:   FGLONG converts an integer number
#$%            to a longitude geocoordinate.
#$%
#$% Called By: FPFORC     FPCHR1
#$%
#$% Calls:     IPBYTE
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 81
#$%
#$% Author:    Dana Wills
#$%
####################################################
implicit none
literal longn
integer k, long, kk
 
kk = 0; call smovv ("000-00E", longn, kk)
k = iabs(long)
call ipbyte (longn,1,mod(k/10000,10)+$dig0)
call ipbyte (longn,2,mod(k/1000,10)+$dig0)
call ipbyte (longn,3,mod(k/100,10)+$dig0)
call ipbyte (longn,5,mod(k/10,10)+$dig0)
call ipbyte (longn,6,mod(k,10)+$dig0)
 
if (long < 0) call ipbyte (longn,7,$letW)
return
end
 
 
Subroutine getact (i1,i2,i3,i4,i5,i6,i7)
implicit none
integer i1, i2, i3, i4, i5, i6, i7
repeat {call trace; call hltslf}
return
end
 
 
Subroutine gettrk (i1,i2,i3,i4)
implicit none
integer i1, i2, i3, i4
repeat {call trace; call hltslf}
return
end
 
 
Subroutine getnam (nam$pointer)                 # get an empty NAM entry
bbcommon
BBdeclare  (nam$pointer)
 
for (nam$pointer$first; nam$pointer$valid; nam$pointer$next)
    {
    if (Xnam$type$i == $null) return
    }
 
nam$pointer = 0
 
return
end

Subroutine addnam_unit (unt$pointer,nam$pointer)        # add UNT Name to NAM
bbcommon
literal     cstrip8
integer     indx, ifree, inuse
BBdeclare  (unt$pointer, unt$name$c,
            nam$pointer, nam$type$i, nam$name$c)
 
indx       = unt$pointer$index
# Damage astab needs boat serial number, not user specified name #UFL05 joa
nam$name$c = Xunt$name$c
 
ifree      = 0
 
for (nam$pointer$first; nam$pointer$valid; nam$pointer$next)
    {
    nam$type$i = Xnam$type$i
 
    if (nam$type$i == $null & ifree == 0) ifree = nam$pointer
 
    if (nam$type$i != $name$Unit) next          # lets see if it's here already
 
    if (Xnam$UntIndx$i != indx) next            # not this one
 
    if (Xnam$Name$C != nam$name$c) next         # not this one
 
    return                                      # This is it !
    }
 
nam$pointer = ifree
 
if (nam$pointer != 0)
    {
    PUTnam$name$c
    PUTnam$UntIndx$i (indx)
    PUTnam$Type$i    ($name$Unit)
 
    inuse = nam$pointer$index * nam$entry
 
    if (inuse > nam$used) nam$used = inuse
    }
 
return
end
 
Subroutine gtact (unt$view$i,                   # Get Active Track from RMT
                  ctrack,                       #receive track designator
                  rmt$pointer,                  #return detection pointer
                  ibonly)
 
########################################################
#$%
#$% Purpose:   GTACT retrieves an active track
#$%            from the RMT table.
#$%
#$% Called By: OCLIFY     OCOVER     ODESIG
#$%            ODROP      OFTOR0     OFTOR1
#$%            OPLOTC     ORBTO      ORECON
#$%            OTAKE      OXCIR
#$%
#$% Calls:     GTTRK
#$%
#$% Tables:    RMT        UNT        RVU
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
literal     ctrack
integer     ibonly, indx
BBdeclare  (rmt$pointer, unt$view$i, rvu$pointer,
            rmt$detectiontype$i)
 
#$% call to get an active track from RMT table
call gttrk(ctrack,rmt$pointer)
 
#$% if RMT pointer is zero, return
if (rmt$pointer == 0)  return
 
if (unt$view$i > $neutral$view)                   #if request not from control
   {
    indx = rmt$pointer$index
 
    #$% set RVU pointer to unit pointer
    RVU$pointer$to unt$view$i
 
    #$% if index is not within
    if (indx < XRVU$FirstRmtIndx$i |
        indx > XRVU$LastRmtIndx$i   )
       {
        #$% zero RMT pointer, return
        rmt$pointer = 0                         #flag track as invalid
        return
       }
   }
 
#$% get detection type
rmt$DetectionType$i = Xrmt$DetectionType$i
 
 
#$% if detection is active visual or non-visual, set bearing only NO
if (rmt$DetectionType$i == $ActiveVisual$code   |
    rmt$DetectionType$i == $ActiveNonVisual$code) ibonly = $no
#$% else assume passive detection type, set bearing only
else                                              ibonly = $yes
 
return
end
 
 
Subroutine gttrk (ctrack,rmt$pointer)           # Get a track (from RMT)
 
########################################################
#$%
#$% Purpose:   GTTRK finds an active track in the
#$%            RMT table.
#$%
#$% Called By: GTACT
#$%
#$% Calls:     IPBYTE
#$%
#$% Tables:    RVU        RMT
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
literal     CTRACK, CLASS, CSTRIP
integer     NUMBER, IGBYTE, IDTYP1, IDTYP2, ICLASS, I, kk, ctoi
BBdeclare  (RMT$Pointer, RMT$Detectiontype$I,
            RVU$Pointer, RVU$Trackcode$C, RVU$Lastrmtindx$I)
 
RVU$TrackCode$c = $BLANKLIT
call ipbyte (RVU$TrackCode$c,1,igbyte(ctrack,1))
 
#$% set class
class =  igbyte(ctrack,2)
 
#$% if letter A
if (class == $letA)
   {
    #$% set active ID type and air code
    idtyp1 = $ActiveVisual$code
    idtyp2 = $ActiveNonVisual$code
    iclass = $Air$code
   }
#$% else if letter S
else if (class == $letS)
   {
    #$% set active ID type and surface code
    idtyp1 = $ActiveVisual$code
    idtyp2 = $ActiveNonVisual$code
    iclass = $Surface$code
   }
#$% else if letter U
else if (class == $letU)
   {
    #$% set active ID type and sub code
    idtyp1 = $ActiveVisual$code
    idtyp2 = $ActiveNonVisual$code
    iclass = $Sub$code
   }
#$% else if letter E
else if (class == $letE)
   {
    #$% set ESM type and null code
    idtyp1 = $Esm$code
    idtyp2 = $Esm$code
    iclass = $Null$code
   }
#$% else if letter P
else if (class == $letP)
   {
    #$% set passive ID type and null code
    idtyp1 = $PassiveSonar$code
    idtyp2 = $PassiveSonar$code
    iclass = $Null$code
   }
#$% else if letter O
else if (class == $letO)
   {
    idtyp1 = $ActiveNONVisual$code
    idtyp2 = $ActiveNONVisual$code
    iclass = $Null$code
   }
#$% else
else
   {
    #$% zero RMT pointer, return
    rmt$pointer = 0
    return
   }
 
kk = 3
number = ctoi(%%ref(ctrack),kk)                         # DEW 11/99 (E2172)
 
#$% for each RVU entry
for (RVU$pointer$first; RVU$pointer$ok; RVU$pointer$next)
   {
    #$% if not the same track code, get next
    if (xRVU$trackcode$c != RVU$trackcode$c) next
 
    #$% get last RMT index
    RVU$LastRmtIndx$i = XRVU$LastRmtIndx$i
 
    #$% if RMT pointer is zero, get first RMT entry
    if (rmt$pointer == 0) i = XRVU$FirstRmtIndx$i      # allows multiple calls
    #$% else increment RMT pointer
    else                  i = rmt$pointer$index + 1    # to find same trk no.
 
    #$% for each entry
    for ( ; i <= RVU$LastRmtIndx$i; i = i + 1)
      {
       #$% set RMT pointer
       rmt$pointer$to i
 
       #$% if not same track, get next
       if (Xrmt$TrackNumber$i  != number) next
 
       #$% get detection type
       rmt$DetectionType$i = Xrmt$DetectionType$i
 
       #$% if detection type is not 1 or 2, get next entry
       if (rmt$DetectionType$i != idtyp1 &
           rmt$DetectionType$i != idtyp2  ) next
 
       #$% if class is not null and not the same class, get next
       if (iclass != $Null$code & Xrmt$Class$i != iclass) next
 
       return
      }
 
    #$% zero RMT pointer, break loop
    rmt$pointer = 0
    break
   }
 
return
end
 

Subroutine gttrk_tma (ctrack,RMT$Pointer,is_old)   # Get a TMA'd track, in RMT
 
########################################################
#$%
#$% Purpose:   GTTRK_tma finds a TMA'd track in the
#$%            RMT table.
#$%
#$% Called By: ???
#$%
#$% Calls:     IPBYTE
#$%
#$% Tables:    RVU        RMT
#$%
#$% Date:      AUG 83
#$%
#$% Author:    Dane Wills
#$%
########################################################
 
BBcommon
literal     CTRACK, CLASS, CSTRIP
integer     IS_OLD, IGBYTE, NUMBER, I, kk, ctoi
BBdeclare  (RVU$Pointer, RVU$Trackcode$C, RVU$Lastrmtindx$I,
            RMT$Pointer)
 
is_old = NO
 
RVU$TrackCode$c = $BLANKLIT
call ipbyte (RVU$TrackCode$c,1,igbyte(ctrack,1))
 
#$% set class
class =  igbyte(ctrack,2)
 
kk = 3
number = ctoi(%%ref(ctrack),kk)                         # DEW 11/99 (E2172)
 
#$% for each RVU entry
for (RVU$pointer$first; RVU$pointer$ok; RVU$pointer$next)
    {
    #$% if not the same track code, get next
    if (xRVU$trackcode$c != RVU$trackcode$c) next
 
    #$% get last RMT index
    RVU$LastRmtIndx$i = XRVU$LastRmtIndx$i
 
    i = rmt$pointer$index        # start at same trk no.
 
    #$% for each entry
    for ( ; i <= RVU$LastRmtIndx$i; i = i + 1)
        {
        #$% set RMT pointer
        rmt$pointer$to i
 
        #$% if not same track, get next
        if (Xrmt$TrackNumber$i  != number) next
 
        if (xRMT$TMAFlag$I != YES) next                 ## ret flag(0)
 
        if (xRMT$DetectionAge$I == $Old$Code)           ## if old
            {
            is_old = YES
            next
            }
 
        is_old = NO
        return
        }
 
    #$% zero RMT pointer, break loop
    RMT$Pointer = 0
    break
   }
 
return
end
 

Subroutine make_track_num (rmt$pointer,gtrack)
 
########################################################
#$%
#$% Purpose:   MAKE_TRACK_NUM will create a track number for the
#$%            specified entry in the RMT table
#$%
#$% Date:      MAR 91
#$%
#$% Author:    Dane Wills
#$%
########################################################
 
BBcommon
 
Integer*4   Rmt$Pointer
Literal     gtrack, a_track
Character   Class
literal     cstrip
integer     IVIEW
BBdeclare  (RVU$Pointer, UNT3$Pointer,
            RMT$Class$I, RMT$Detectiontype$I, RMT$Tracknumber$I)
 
rmt$TrackNumber$I = Xrmt$TrackNumber$I
 
if (rmt$TrackNumber$I == 0)
    {
    gtrack = '?????'
    return
    }
 
gtrack = $BLANKLIT
 
unt3$pointer$to Xrmt$Detector$i
iview = Xunt3$view$i
RVU$pointer$to iview
 
rmt$DetectionType$i = Xrmt$DetectionType$i
 
if (rmt$DetectionType$i == $PassiveSonar$code)
    {
    Class = 'P'
    }
else if (rmt$DetectionType$i == $ESM$code)
    {
    Class = 'E'
    }
else # if (rmt$DetectionType$i == $ActiveVisual$code   |
     #     rmt$DetectionType$i == $ActiveNonVisual$code )
    {
    rmt$Class$i = Xrmt$Class$i
 
    if      (rmt$Class$i == $Air$code    )  Class = 'A'
    else if (rmt$Class$i == $Sub$code    )  Class = 'U'
    else if (rmt$Class$i == $Surface$code)  Class = 'S'
    else                                    Class = '?'
    }
 
gtrack = A_Track (xRVU$trackcode$C, class, RMT$TrackNumber$i) # dew 11/99 E2172
 
return
end
 

 Real Function DEGMRA(IDM)
 
#######################################################
 #$%
 #$% Purpose:   DEGMRA converts degrees and minutes
 #$%            to radians.
 #$%
 #$% Called By: OMARKU     OPLOTC     OPROCE
 #$%            ORBTO      ORELOC     OXCIR
 #$%            WGLSHP     WGLSOS     WGLSST
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
 BBimplicit
integer     JDEG, IDM, JMIN
 
 JDEG = IABS(IDM/100)                           #get degree portion
 
 JMIN = MOD(IABS(IDM),100)                      #get minutes portion
 
 if(JMIN >= 60)                                 #if more than 59 degrees
    {
     JMIN = JMIN - 60                           #subtract 60 minutes and
 
     JDEG = JDEG + 1                            #add a degree
    }                                           #endif more than 59 minutes
 
 DEGMRA = (JDEG/180. + JMIN/10800.) * $PI       #convert to radians
 
 if(IDM < 0)                                    #if negative input
    {
     DEGMRA = - DEGMRA                          #negate output
    }                                           #endif negative input
 
 return
 end
 
  Real Function DMS2ll (DMS)

#######################################################
 #$%
 #$% Purpose:   DMS2LL converts degrees, minutes, and seconds
 #$%            to float degrees. DMS is a real*8 value with the data
 #$%            formatted as DDDMM.SST.  This function used to be
 #$%            DMS2rad but that norw invokes this function
 #$%
 #######################################################
 implicit none
 real*8      DMS
 real*8      SEC
 INTEGER*4   IDMS, JDEG, JMIN

 IDMS = ABS(INT(DMS))                           # integer DDDMM
 JDEG = IDMS / 100                              #get degree portion (DDD)
 JMIN = IDMS - JDEG * 100                       #get minutes portion (MM)
 SEC  = (abs( DMS ) - iDMS ) * 100.0            #get seconds portion (.SST)

 DMS2LL = SIGN( JDEG + (JMIN + (SEC/60.0)) / 60.0, DMS)        # floating point degrees

 return
 end


 
 Real Function DMS2rad (DMS)
 implicit none
 real*8      DMS
 real        DMS2ll
 DMS2RAD = DMS2ll(DMS) * $deg2rad
 
 return
 end
 
 
      FUNCTION NEWTIM(X)
 
##################################################
      #$%
      #$% Purpose:   NEWTIM finds the current number
      #$%            of seconds of time.
      #$%
      #$% Called By: OCUDB      PLOT       RESYNC
      #$%            SAVEBB     WARCYC
      #$%
      #$% Calls:     None
      #$%
      #$% Tables:    None
      #$%
      #$% Author:    E. A. Decker, SEI
      #$%
      ##################################################
 
#     FINDS THE CURRENT NO OF SECONDS OF TIME************************
#     NOTE THAT "X" IS A DUMMY PARAMETER AND IS NOT USED EXCEPT TO COMPLY
#     WITH THE FORTRAN RULE THAT ALL FUNCTION PROGRAMS MUST HAVE A DUMMY
#     VARIABLE.
#
#     "NOW" RETURNS THE WALL CLOCK TIME IN MILLISECONDS
#     FROM THE BEGINNING OF THE DAY
      implicit none
      integer x, newtim, now
      NEWTIM=NOW(0)/1000
      RETURN
      END
 
 
 
 
        Subroutine ttline(istrng,len)
 
#####################################################
        #$%
        #$% Purpose:   TTLINE types string (istring) with
        #$%            (len) characters to terminal.
        #$%
        #$% Called By: None
        #$%
        #$% Calls:     ECHO       ECHOH
        #$%
        #$% Tables:    None
        #$%
        #$% Date:      OCT 80
        #$%
        #$% Author:    Ron Williams
        #$%
        #####################################################
 
#
#       TTLINE types string (istring) with (len) characters to terminal
#
        implicit none
	integer len
        integer istrng(2)
        call echo ($linefeed)
        call echo ($return)
        call echoh (istrng,len)
        return
        end

subroutine fndwet (UNT$truelatitude$f,
                   UNT$truelongitude$f,
                   wet$pointer)
 
#############################################################
#$%
#$% Purpose:   FNDWET computes the weather region index
#$%            of the region containing the point deter-
#$%            mined by the input latitude and longitude.
#$%
#$% Called By: FLPBLC     FLPBRV     VISMOD
#$%
#$% Calls:     None
#$%
#$% Tables:    WET        POS
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
#############################################################
 
BBcommon
real        f50deg /0.8726646/
 
integer     iv, ih, nDEX
real        dlat, dlon
BBdeclare  (UNT$Truelatitude$F, UNT$Truelongitude$F, WET$Pointer)
 
dlat = UNT$truelatitude$f - weather$baselatitude
dlon = UNT$truelongitude$f - weather$baselongitude
if (weather$baselongitude >= 0.  &
    UNT$truelongitude$f <= 0.)
   dlon = dlon + $twopi
if (dlat >= 0. & dlat < f50deg  &           #if lat in range &
    dlon >= 0. & dlon < f50deg)             #if lon in range
   {                                        #find index of weather region
    iv = dlat*Deg$Per$Rad/10.
    ih = dlon*Deg$Per$Rad/10.
    ndex = 2 + 5 * iv + ih
    wet$pointer$to ndex
   }
else wet$pointer$first
return
end

 
Subroutine suntim
 
########################################################
#$%
#$% Purpose:   SUNTIM calculates the sunrise/sunset
#$%            time initialization.
#$%
#$% Called By: WGLWET
#$%
#$% Calls:     EARLST     QTRIG
#$%
#$% Tables:    WET
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
 
real        fudge /-.0151/
real        SCOS, SSIN, FLAT, FLON, FCOS, FSIN, TERM, DELLON
integer     I
BBdeclare  (WET$Pointer, WET$Sunrise$F, WET$Sunset$F)
 
#call qktrig(sun$latitude,scos,ssin)    # calculate sin/cos of sun latitude
scos = cos(sun$latitude)
ssin = sin(sun$latitude)
 
for(wet$pointer$to 2 ; wet$pointer$valid ; wet$pointer$next) # for each WET
   {
    i = wet$pointer$index - 2
 
    #$% get base latitude and base longitude
    flat = weather$baselatitude + (i / 5) * ($pi/18)
 
    flon = weather$baselongitude + mod(i,5) * ($pi/18)
 
    #call qktrig(flat,fcos,fsin)                # calculate sin/cos base lat
    fcos = cos(flat)
    fsin = sin(flat)
 
    term = (fudge-ssin*fsin)/(scos*fcos)
 
    if (term <= -1.0)                   #if always daylight
       {
        wet$SunRise$f = 2001            #flag for STATUS
        wet$SunSet$f = 2001
       }
    else if (term >= 1.0)               #if always dark
       {
        wet$SunRise$f = 1999            #flag for STATUS
        wet$SunSet$f = 1999
       }
    else
       {
        dellon = acos(term)
 
#       wet$SunRise$f = 4.*(180.- (180./$pi)*(flon+dellon)) - # compute sunrise
#                       (zulu$starttime + game$minute)
 
        wet$SunRise$f = 4.*(180.- (180./$pi)*(flon+dellon)) - (zulu$starttime)
 
        call earlst(wet$SunRise$f)                      # adjust sunrise time
 
#       wet$SunSet$f = 4.*(180.-(180./$pi)*(flon-dellon)) -   # compute sunset
#                       (zulu$starttime + game$minute)
 
        wet$SunSet$f = 4.*(180.-(180./$pi)*(flon-dellon)) - (zulu$starttime)
 
        call earlst(wet$SunSet$f)                       # adjust sunset time
       }
 
    putwet$SunRise$f                                    # save sunrise/sunset
    putwet$SunSet$f
   }
 
return
end
 

 
Subroutine earlst(itime)
 
########################################################
#$%
#$% Purpose:   EARLST is used to adjust calculated time
#$%            (itime) when it is negative or exceeds a day
#$%
#$% Called By: SUNTIM
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
implicit none
real itime
 
# for negative time value add 1440 minutes (24 hrs - 1 day)
 
for( ;itime < 0;itime = itime + $Minutes$Per$Day)
 
# for time value greater than 1440 minutes (24 hrs - 1 day)
# subtract a day
 
for( ;itime >= $Minutes$Per$Day ;itime = itime - $Minutes$Per$Day)
 
return
end
 
 
 
 
Subroutine SATTRK(time,                 #time since initial Nbound eq xing
                  flon0,                #longitude of initial Nbound eq xing
                  fincl,                #inclination of initial Nbound eq xing
                  per,                  #period of satellite
                  flat,                 #current latitude (out)
                  flon)                 #current longitude (out)
 
 
#############################################################
#$%
#$% Purpose:   SATTRK calculates the current latitude
#$%            and longitude by a given satellite.
#$%
#$% Called By: GNDTRK     WGLSST
#$%
#$% Calls:     ANGPI
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
#############################################################
implicit none
real*4 time, flon0, fincl, per, flat, flon
real*4 travel, hinit, ct, st, ci, si, dellon
real*4 ab, x, y, colat, earth
 
travel = time * (2.*$pi) / per
hinit = $pi/2. - fincl
 
ct = cos(travel)
st = sin(travel)
ci = cos(hinit)
si = sin(hinit)
 
dellon = atan2(st*si,ct)
$angpi(dellon)
ab = abs(dellon)
 
if      (ab < .001)       {x = st * ci     ; y =  ct}   #if dellon near 0
else if (ab > $pi - .001) {x = st * ci     ; y = -ct}   #if dellon near pi
else                      {x = sin(dellon) * ci ; y = si }   #general case
if (y < 0.0)  {x = -x ; y = -y}
colat = atan2(y,x)
flat = $pi/2. - colat
earth = amod((.25*$pi/180.)*time,2.*$pi)       #earth rotation
flon = flon0 + dellon - earth
$angpi(flon)
return
end

 
 
 Subroutine NAVERR(NAV$POINTER,                                       #smn002
                   UNT$POINTER)
 
#######################################################
 #$%
 #$% Purpose:   NAVERR sets the errors associated with
 #$%            a particular navigational device.
 #$%
 #$% Called By: BLDCM      WGLSHP     XBLDYN
 #$%
 #$% Calls:     RANDN
 #$%
 #$% Tables:    NAV        POS
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
 BBcommon
real        RANDN
BBdeclare  (NAV$Pointer, NAV$Device$I,
            UNT$Pointer, UNT$Headingerror$F, UNT$Speederror$F,
            UNT$Drindx$I, UNT$Drlatitudeerror$F, UNT$Drlongitudeerror$F,
            UNT$Omegaindx$I, UNT$Omegalatitudeerror$F,
            UNT$Omegalongitudeerror$F,
            UNT$Transitindx$I, UNT$Translatitudeerror$F,
            UNT$Translongitudeerror$F)
 
 #$% get navigational device
 NAV$DEVICE$I = XNAV$DEVICE$I
 
 #$% if device is heading sensor
 if(NAV$DEVICE$I == $HEADINGSENSOR$CODE)
   {
    #$% set heading error and store
    UNT$HEADINGERROR$F = RANDN(0.,XNAV$HEADINGERROR$F)
    PUTUNT$HEADINGERROR$F
   }
 #$% else if device is speed sensor
 else if(NAV$DEVICE$I == $SPEEDSENSOR$CODE)
   {
    #$% set speed error and store
    UNT$SPEEDERROR$F = RANDN(0.,XNAV$SPEEDERROR$F)
    PUTUNT$SPEEDERROR$F
   }
 #$% else if device is DR code
 else if(NAV$DEVICE$I == $DR$CODE)
   {
    #$% set DR index and store
    UNT$DRINDX$I = NAV$POINTER$INDEX
    PUTUNT$DRINDX$I
 
    #$% set DR latitude error and store
    UNT$DRLATITUDEERROR$F = RANDN(0.,XNAV$LATITUDERATE$F)
    PUTUNT$DRLATITUDEERROR$F
 
    #$% set DR longitude error and store
    UNT$DRLONGITUDEERROR$F = RANDN(0.,XNAV$LONGITUDERATE$F)
    PUTUNT$DRLONGITUDEERROR$F
   }
 #$% else if device is OMEGA
 else if(NAV$DEVICE$I == $OMEGA$CODE)
   {
    #$% set OMEGA index and store
    UNT$OMEGAINDX$I = NAV$POINTER$INDEX
    PUTUNT$OMEGAINDX$I
 
    #$% set OMEGA latitude error and store
    UNT$OMEGALATITUDEERROR$F = RANDN(0.,XNAV$LATITUDEERROR$F) + _
                   RANDN(XNAV$LATHUMANFIXED$F,XNAV$LATHUMANRANDOM$F)
    PUTUNT$OMEGALATITUDEERROR$F
 
    #$% set OMEGA longitude error and store
    UNT$OMEGALONGITUDEERROR$F = RANDN(0.,XNAV$LONGITUDEERROR$F) + _
                   RANDN(XNAV$LONHUMANFIXED$F,XNAV$LONHUMANRANDOM$F)
    PUTUNT$OMEGALONGITUDEERROR$F
   }
 #$% else if device is transit or OMEGA transit
 else if(NAV$DEVICE$I == $TRANS$CODE |
         XNAV$DEVICE$I == $OMEGATRAN$CODE)
   {
    #$% set transit index and store
    UNT$TRANSITINDX$I = NAV$POINTER$INDEX
    PUTUNT$TRANSITINDX$I
 
    #$% set transit latitude error and store
    UNT$TRANSLATITUDEERROR$F = RANDN(0.,XNAV$LATITUDEERROR$F) + _
                   RANDN(XNAV$LATHUMANFIXED$F,XNAV$LATHUMANRANDOM$F)
    PUTUNT$TRANSLATITUDEERROR$F
 
    #$% set transit longitude error and store
    UNT$TRANSLONGITUDEERROR$F = RANDN(0.,XNAV$LONGITUDEERROR$F) + _
                   RANDN(XNAV$LONHUMANFIXED$F,XNAV$LONHUMANRANDOM$F)
    PUTUNT$TRANSLONGITUDEERROR$F
   }
 
 return
 end
 
 
 Subroutine CHKREL(rad$pointer,unt$pointer,ifprnt)
 
#######################################################
 #$%
 #$% Purpose:   CHKREL checks the recognized emitter
 #$%            list for the emitter name and unit
 #$%            class.
 #$%
 #$% Called By: BLDSAT     LCLESM
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    REL
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
 BBcommon
 
 literal namemt, namunt
literal     CSTRIP8
integer     IFPRNT, litcmp
BBdeclare  (RAD$Pointer, UNT$Pointer, REL$Pointer)
 
 #$% get radar type and unit name
 namemt = xrad$type$c
 namunt = xunt$name$c
 
 ifprnt = $no
 
 #$% for each REL entry
 for (rel$pointer$first;rel$pointer$ok;rel$pointer$next)
    {
     #$% if emitter name is same and class is same
     if (litcmp(xrel$EmitterName$c, namemt) == 0 &
         litcmp(xrel$Class$c      , namunt) == 0  )
        {
         ifprnt = $yes
         break
        }
    }
 
 return
 end
 
 
Subroutine Unit_Aspect_Index(_        # Subroutine  2/15/91
                     UNT$Pointer,   # Bearing-Source unit
                     UNT2$Pointer,  # Bearing-TO unit
                     indx)    #  OUT:  Aspect INDEX
                          # (Returns integer from 1 to 7)
########################################################
#$%
#$% Purpose:   This routine calculates the RELATIVE bearing
#$%            from the Bearing_Source unit to the Bearing-TO
#$%            unit; returning an INDX value from 1 thru 7
#$%            based on 30-degree sectors (initial sector
#$%            centered at 0 degrees relative).  Indices are
#$%            reflected across the longitudinal centerline.
#$%    PROGRAMMER NOTE:  IF TRUE BEARING AND HEADING ARE ALREADY
#$%        KNOWN, USE entry BRG_aspect_INDEX(TRUBRG, TRUCSE, INDX), where
#$%           TRUCSE is the course of the Bearing-Source unit
#$%           and TRUBRG is the bearing to the Bearing-TO unit.
#$%
#$% Called By:
#$%
#$% Calls:     RLL2RB
#$%
#$% Tables:    UNT
#$%
#$% Date:      OCT 1990
#$%
#$% Author:    Joe Bryant
#$%
########################################################
 
BBcommon
 
integer INDX               # value to be returned
real    BEAR, HDG          # True Brg;  True Crs of Bearing-Source
real    RELbrg 		   # Rel. Brg. in Radians
real        FLAT1, FLON1, CSLAT1, FLAT2, FLON2, CSLAT2,
            RANGE, TRUBRG, TRUCSE
BBdeclare   (UNT$Pointer, UNT2$Pointer)
 
FLAT1 = xUNT$TrueLatitude$F
FLON1 = xUNT$TrueLongitude$F
CSLAT1 = cos(FLAT1)
FLAT2 = xUNT2$TrueLatitude$F
FLON2 = xUNT2$TrueLongitude$F
CSLAT2 = cos(FLAT2)
 
call RLL2RB( _                #Rhumb line Lat/Lon to Range/Bearing
                   FLAT1,            #latitude of 1st pt (input)
                   FLON1,            #longitude of 1st pt (input)
                   CSLAT1,           #cos of lat of 1st pt (input)
                   FLAT2,            #latitude of 2nd pt (input
                   FLON2,            #longitude of 2nd pt (input)
                   CSLAT2,           #cos of lat of 2nd pt (input)
                   RANGE,                #range (output)
                   BEAR    )             #True bearing (output)
 
HDG  = xUNT$TrueCOURSE$F    # Bearing-Source unit's heading (radians)
 
repeat                                                      # E2143 dew 10/99
   {       # Bypass of RLL2RB if true bearing and course are known...
    break
    entry BRG_aspect_INDEX(TRUBRG, # True Brg FROM Bearing-Source unit
                           TRUCSE, # Course   of     "      "     "
                           INDX)
    BEAR = TRUBRG
    HDG  = TRUCSE
   }
 
RELBRG = BEAR - HDG  # Rel. Brg. to Bearing-TO unit (radians)
$angpi (RELBRG)        # Adjust, Between -PI and +PI
if(RELBRG < 0.0) RELBRG = -1.0 * RELBRG    # 0 to +PI
 
# INDX = 1 + (RELBRG + $pi/12.0) / ($pi/6.0) # Pls. don't delete.
INDX = 1.5 + (6.* RELBRG/$PI)    # (Equivalent to line above)
INDX = min(INDX,7)               # Over-cautious!
return
end  # End Subroutine Unit_Aspect_Index / ENTRY BRG_aspect_INDEX
 
 
Subroutine daytst                       #computes the longitude of the sun
                                        #and determines whether affected
                                        #platforms are in daylight or darkness
 
########################################################
#$%
#$% Purpose:   DAYTST computes the longitude of the
#$%            sun and determines whether affected
#$%            platforms are in daylight or dark-
#$%            ness.
#$%
#$% Called By: MOTMAN
#$%
#$% Calls:     ANGPI
#$%
#$% Tables:    UNT        POS
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
real        fudge /-.0151/
real        SUNLON, SCOS, SSIN, PLAT, PLON, DIFF, PCOS, PSIN, TERM
BBdeclare  (UNT$Pointer, UNT$Type$I, UNT$Supertype$I,
            UNT$Truealtdepth$I, UNT$Indaylight$I,
            SHC$Pointer, SHC$Scopedepth$I)
 
#$% compute sun longitude
sunlon = $pi/180. * (180.-(game$time+zulu$starttime)/4.) # JFR 1/13/94 for VTS
sunlon = amod(sunlon,$twopi)
if (sunlon > $pi) sunlon = sunlon - $twopi
 
#$% determine sun latitude
#call qktrig (sun$latitude,scos,ssin)
scos = cos(sun$latitude)
ssin = sin(sun$latitude)
 
#$% for each unit entry
for (unt$pointer$first; unt$pointer$ok; unt$pointer$next)
   {                                            #loop thru all platforms
 
    unt$type$i = xunt$type$i                    # get unit type
    if (unt$type$i == $null$code) next          # if null type, get next
 
    if (unt$type$i == $cruisemissile$code)  next        # if cruise missile...
 
    if (Xunt$status$i == $beingdeleted$code)  next      # if deleted, get next
 
    if (unt$type$i == $sub$code)      # 10/93 clk - corrected the check for a
      {                               # submurged sub, previous check always failed
        UNT$SuperType$I = xUNT$SuperType$I
        if ( UNT$SuperType$I == $Submarine$SuperCode )
          {
           UNT$TrueAltDepth$I = xUNT$TrueAltDepth$I
           SHC$Pointer = xUNT$SHCpntr$I
           SHC$ScopeDepth$I = xSHC$ScopeDepth$I
 
           if (UNT$TrueAltDepth$I > SHC$ScopeDepth$I &  # if the sub is not
               UNT$TrueAltDepth$I > Mast$Depth$Max   )  # exposed, skip it
             next
          }
        else  # a torpedo, counter measure or false contact
          next
      }
 
    plat = xUNT$truelatitude$f
    plon = xUNT$truelongitude$f
 
    diff = plon - sunlon                        # compute difference
    $angpi(diff)
 
    #call qktrig(plat,pcos,psin)                # determine position latitude
    pcos = cos(plat)
    psin = sin(plat)
 
    term = (fudge-ssin*psin)/(scos*pcos)
 
    # determine if platform is in daylight or darkness
    if      (term <= -1.0)             unt$indaylight$i = $yes
    else if (term >=  1.0)             unt$indaylight$i = $no
    else if (abs(diff) <= acos(term))  unt$indaylight$i = $yes
    else                               unt$indaylight$i = $no
 
    PUTunt$indaylight$i                         # store in-daylight flag
   }
 
return
end
 

 
Subroutine SETURP(UNT$POINTER,
                  RPM$POINTER)
 
########################################################
#$%
#$% Purpose:   SETURP sets up the reporting policy
#$%            matrix and store the data in the
#$%            blackboard.
#$%
#$% Called By: OMISSN     OREPUS     WGLURP
#$%            XBLAUN
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT        RPM
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
BBdeclare  (RPM$Pointer, UNT$Pointer, UNT$Makereports$I, UNT$Commbypass$I,
            UNT$Violateemcon$I, UNT$Owninterval$I, UNT$Shiptrackinterval$I,
            UNT$Airtrackinterval$I, UNT$Esmtrackinterval$I,
            UNT$Path1pntr$I, UNT$Path2pntr$I)
 
#$% if RPM pointer is zero, return
if (rpm$pointer == 0)  return
 
#$% initialize make reports flag and store
unt$MakeReports$I = $yes
PUTunt$MakeReports$I
 
#$% get COMM bypass and store
unt$CommBypass$I = xrpm$CommBypass$I
PUTunt$CommBypass$I
 
#$% get violate EMCON and store
unt$ViolateEMCON$I = xrpm$ViolateEMCON$I
PUTunt$ViolateEMCON$I
 
#$% get OWN interval and store
unt$OwnInterval$I = xrpm$OwnInterval$I
PUTunt$OwnInterval$I
 
#$% get ship track interval and store
unt$ShipTrackInterval$I = xrpm$ShipTrackInterval$I
PUTunt$ShipTrackInterval$I
 
#$% get air track interval and store
unt$AirTrackInterval$I = xrpm$AirTrackInterval$I
PUTunt$AirTrackInterval$I
 
#$% get ESM track interval and store
unt$EsmTrackInterval$I = xrpm$EsmTrackInterval$I
PUTunt$EsmTrackInterval$I
 
#$% get first path pointer and store
unt$Path1Pntr$I = xrpm$Path1Pntr$I
PUTunt$Path1Pntr$I
 
#$% get second path pointer and store
unt$Path2Pntr$I = xrpm$Path2Pntr$I
PUTunt$Path2Pntr$I
 
return
end
 

 
Subroutine GETRPM(unt$pointer,rpm$pointer)              #get rpm pntr for unt
 
########################################################
#$%
#$% Purpose:   GETRPM retrieves the reporting policy
#$%            matrix for each force unit.
#$%
#$% Called By: WGLURP     XBLAUN
#$%
#$% Calls:     WHSIDE     BELONG
#$%
#$% Tables:    UNT        RPM
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
 
literal namunt
literal     CSTRIP8
integer     ISIDE, MISS, ITASK, ITADDR, IDO, litcmp
BBdeclare  (UNT$Pointer, RPM$Pointer, RPM$Addressee$C)
 
call whside(xunt$view$i,iside)                          #determine side
 
namunt = xunt$name$c                                    #save unt name
 
for (rpm$pointer$first;rpm$pointer$ok;rpm$pointer$next) #search rpm table
   {
    if (xrpm$Side$i != iside)  next                     #verify side match
 
    if (xrpm$AddresseeType$i != $force$code)  next      #see if rpm is force
 
    rpm$Addressee$c = xrpm$Addressee$c                  #check rpm with unt
 
    if (litcmp(rpm$Addressee$c, namunt) == 0) return    #yes, return pntr
   }
 
miss = xunt$mission$i                                   #save unt mission
 
for (rpm$pointer$first;rpm$pointer$ok;rpm$pointer$next) #search rpm table
   {
    if (xrpm$Side$i != iside)  next                     #verify side match
 
    if (xrpm$AddresseeType$i != $mission$code)  next    #see if rpm is mission
 
    if (xrpm$Addressee$i == miss)  return               #check with unt, rtrn
   }
 
itask = xUNT$HierarchyId$i                              #save unt task
 
for (rpm$pointer$first;rpm$pointer$ok;rpm$pointer$next) #search rpm table
   {
    if (xrpm$Side$i != iside)  next                     #verify side match
 
    if (xrpm$AddresseeType$i != $task$code)  next       #check rpm task w/ unt
 
    itaddr = xrpm$Addressee$i                           #save rpm task pntr
 
    call BELONG(itask,itaddr,ido)                       #check heirarchy
 
    if (ido != $no)  return                             #if same rtrn pntr
   }
 
rpm$pointer = 0                                 #couldn't find matching entry
 
return
end
 
Subroutine BELONG(itask,igroup,ido)
 
########################################################
#$%
#$% Purpose:   BELONG determines if task is in unit
#$%            hierarchy.
#$%
#$% Called By: GETRPM
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
implicit none
integer itsk, itask, igrp, igroup, ido
 
itsk = itask
igrp = igroup
 
while (mod(igrp,10) == 0)
  {
   igrp = igrp/10
   itsk = itsk/10
  }
 
if (itsk == igrp)  ido = $yes
else               ido = $no
 
return
end
 
 
 
Subroutine whside(unt$view$i,iside)
 
 
########################################################
#$%
#$% Purpose:   WHSIDE determines which side is in
#$%            view, whether CONTROL, Blue or Orange.
#$%
#$% Called By: GETRPM     HFDDET     LCLID
#$%            LFXHFD     LMOHFD     NXTSAT
#$%            OEMCON     OFCRU0     OMISSN
#$%            OREPUS     OTAKE      UNTRCV
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams
#$%
########################################################
 
BBcommon
integer        UNT$View$I, ISIDE
 
#$% if view is CONTROL, or Blue or Orange, set side accordingly
if      (unt$view$i == $neutral$view   ) iside = $neutral$code
else if (unt$view$i <= $lastblue$view  ) iside = $blue$code
else                                     iside = $orange$code
 
return
end
 
 
 
 
 
Subroutine gen_RVU
 
########################################################
#$%
#$% Purpose:   GEN_RVU builds the RVU table from information
#$%            in the VUE table.
#$%
#$% Called By: GEN_UPDATES
#$%
#$% Calls:     None
#$%
#$% Tables:    VUE, RVU
#$%
#$% Date:      AUG 82
#$%
#$% Author:    Dana Wills
#$%
########################################################
 
BBcommon
literal     CSTRIP
integer     IVIEW
BBdeclare  (VUE$Pointer, RVU$Pointer)
 
rvu$used = 0
 
for (iview = $first$view; iview <= $last$view; iview=iview+1)
    {
    vue$pointer$to iview
    rvu$pointer$to iview
 
    putRVU$EmbarkIndx$I   (Xvue$EmbarkIndx$I)
    putRVU$Circuit$I      (Xvue$Circuit$I)
    putRVU$TrackCode$C    (Xvue$TrackCode$C)
    putRVU$FirstRmtIndx$I (Xvue$FirstRmtIndx$I)
    putRVU$LastRmtIndx$I  (Xvue$LastRmtIndx$I)
##------------------------------------------------------------
## Activate when RVU fields inserted for linked-list processing..
#   putRVU$FirstRmtPntr$I  (Xvue$FirstRmtPntr$I)        #       7/5/84
#   putRVU$FirstRmtFree$I  (Xvue$FirstRmtFree$I)        #       7/5/84
##-----------------------------------------------------------
    rvu$used = rvu$used + rvu$entry
    }
 
return
end

 
define (MAX$Combos, arith(UNT$Slots,*,4))
 
Subroutine UPD_LRT
 
########################################################
#$%
#$% Purpose:   UPD_LRT looks for new airborne aircraft
#$%            and modifies or creates the LRT table
#$%
#$% Called By: GEN_UPDATES
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT, DYN, OWN
#$%
#$% Date:      JAN 83
#$%
#$% Author:    Timothy P. Adamos
#$%
########################################################
 
bbcommon
 
integer*2       unit_indx[MAX$Combos],                  ## unit Index
                airborne[MAX$Combos],                   ## qty of a/c in flight
                view_indx[MAX$Combos]                   ## index to vue
 
integer         ifree[LRT$Slots],                       ## points to empty slot
                airc_pntr[MAX$Combos],                  ## acc pointer
                count,                                  ## number of total a/c
                n                                       ## number of free slots
 
common /scratch$pad/ unit_indx,airc_pntr,airborne,view_indx,count,ifree,n
 
Integer     K, IUNIT, ILAST, J, NUSED, M
BBdeclare  (OWN$Pointer, OWN$Unit$I, OWN$Accpntr$I,
            OWN$Nbrac$I, OWN$View$I,
            UNT$Pointer, UNT$Recoverindx$I,
            DEQ$Pointer, DEQ$Pntr$I)
BBdeclare  (LRT$Pointer, LRT$Untindx$I, LRT$Accpntr$I, LRT$Airborne$I,
            LRT$Ready1$I, LRT$Ready2$I, LRT$Ready3$I)
 
count = 0
 
#___________________________________________________________________________
# create combination of airborne units
 
    #$% for each entry in the OWN table
for (OWN$Pointer$First; OWN$Pointer$Valid; OWN$Pointer$Next)
    {
    if (xOWN$type$I != $Air$Code) next                  ## is entry an aircft
 
    OWN$Unit$I = xOWN$Unit$I                            ## set pointer to
    UNT$Pointer$To (OWN$Unit$I)
 
#   DYN$POINTER = xUNT$DynaPntr$I                       ## get recover index
 
    UNT$RecoverIndx$I = xUNT$RecoverIndx$I
    OWN$AccPntr$I     = xOWN$AccPntr$I
    OWN$NbrAc$I       = xOWN$NbrAc$I
    OWN$View$I        = xOWN$View$I
 
    for (k=1; k<= count; k=k+1)                         ## look for existing
        {                                               ## combinations
        if (UNT$RecoverIndx$I != unit_indx[k] |
            OWN$AccPntr$I     != airc_pntr[k]  ) next
 
        airborne[k] = airborne[k] + OWN$NbrAc$I         ## found match
 
        next 2                                          ## loop to next OWN
        }
 
    count = count + 1                                   ## build new combo list
 
    unit_indx[count] = UNT$RecoverIndx$I                ## store data
    view_indx[count] = OWN$View$I
    airc_pntr[count] = OWN$AccPntr$I
    airborne[count]  = OWN$NbrAc$I
 
    if (count >= MAX$Combos) break
    }
 
#___________________________________________________________________________
# create combo list for remaining combinations
 
for (UNT$Pointer$First; UNT$Pointer$Ok; UNT$Pointer$Next)
    {
#    UNT$Type$I = xUNT$Type$I
#    if (UNT$Type$I != $SurfaceWithAc$code &             ## if not ship w/ac
#        UNT$Type$I != $ShoreBase$code      ) next       ## or shorebase
 
    if (xUNT$AirCapable$I == $NO) next                ## if no ac # DEW 5/90
 
    iunit = UNT$Pointer$Index
 
#   DYN$Pointer = xUNT$DynaPntr$I
 
    for_DEQ_Chain (iunit)
#    for (DYN$Eq$Index=1; DYN$eq$Index$Ok; DYN$Eq$Index = DYN$Eq$Index + 1)
        {
        if (xDEQ$Ident$I != $Aircraft$Code) next
 
        DEQ$Pntr$I = xDEQ$Pntr$I
 
        for (k=1; k<= count; k=k+1)                     ## look for existing
            {                                           ## combinations
            if (iunit         != unit_indx[k]) next
 
            if (DEQ$Pntr$I != airc_pntr[k]) next
                                                        ## found match
            next 2                                      ## loop to next EQ
            }
 
        count = count + 1                               ## build new combo list
 
        unit_indx[count] = iunit                        ## store data
        view_indx[count] = xUNT$View$I
        airc_pntr[count] = DEQ$Pntr$I
        airborne[count]  = 0
 
        if (count >= MAX$Combos) break 2                ## get out of combo
        }
 
    }
 
 
#___________________________________________________________________________
# update existing LRT entries.
 
n = 0
ilast = 0
 
for (LRT$Pointer$First; LRT$Pointer$Valid; LRT$Pointer$Next)
    {                                   ## get lrt entry
    LRT$UntIndx$I  = xLRT$UntIndx$I
 
    if (LRT$UntIndx$I == 0)             ## save empty slot pointer
        {
        n = n + 1
        ifree[n] = LRT$Pointer
 
        next
        }
 
    ilast = lrt$pointer$index
 
    LRT$AccPntr$I  = xLRT$AccPntr$I
    LRT$Airborne$I = xLRT$Airborne$I
    LRT$Ready1$I   = xLRT$Ready1$I
    LRT$Ready2$I   = xLRT$Ready2$I
    LRT$Ready3$I   = xLRT$Ready3$I
 
    for (j=1; j <= count; j=j+1)        ## if lrt entry matches combo entry
        {
        if (unit_indx[j] == 0) next
 
        if (LRT$AccPntr$I == airc_pntr[j] & LRT$UntIndx$I == unit_indx[j])
            {
            if (LRT$Airborne$I != airborne[j])          ## check if number of
                {                                       ## airborne air is diff
                putLRT$Airborne$I (airborne[j])         ## if so put new entry
                }
 
            unit_indx[j] = 0                            ## zero out data
            view_indx[j] = 0
            airc_pntr[j] = 0
 
            next 2
            }
        }
 
    if (LRT$Ready1$I == 0 & LRT$Ready2$I == 0 &         ##if not found
         LRT$Ready3$I   == 0)
        {
        LRT$Zero
        putLRT$Modified$I (YES)
 
        n = n + 1
        ifree[n] = LRT$Pointer          ## save empty slot
        }
 
    }
 
#___________________________________________________________________________
# create new LRT entries
 
nused = 0
 
for (m=1; m<=count; m=m+1)                      ## loop thru combo list
    {
    if (unit_indx[m] == 0) next
 
    nused = nused + 1
    if (n < nused)                              ## no more empty slots
        {
        call echov ("LRT table full. ")
        break
        }
 
    LRT$Pointer = ifree[nused]                  ## reset pointer to empty slot
 
    putLRT$AccPntr$I  (airc_pntr[m])            ## generate new entry
    putLRT$VueIndx$I  (view_indx[m])
    putLRT$UntIndx$I  (unit_indx[m])
    putLRT$Airborne$I (airborne[m])
    putLRT$Ready1$I   (0)
    putLRT$Ready2$I   (0)
    putLRT$Ready3$I   (0)
    putLRT$Text1$C    ("        ")
    putLRT$Text2$C    ("        ")
    putLRT$Text3$C    ("        ")
    putLRT$Text4$C    ("        ")
 
    ilast = max(ilast, lrt$pointer$index)
    }
 
lrt$used = ilast * lrt$entry
 
return
end
 
 

###    Name: get_deq_entry
###
###    Usage:
###
###    Purpose: Get an available DEQ table entry and insert the entry into
###                chain.
###
###    Arguments:
###
###        Input: UNT$Pointer
###
###        Input/Output:
###
###        Output:  DEQ$Pointer
###
###        COMMON:
###
###            Name            Source                   Use
###
###    Limitations:
###
###    Warnings:
###
###    Notes: Each $$UNT table entry has a corresponding $$DEQ table entry.
###            When equipment is added to the unit, a DEQ entry is removed
###            from a free list and put in appropriate chain. Before
###            equipments are loaded, the DEQ$First$Free points to the first
###            DEQ free entry, e.g. 400 $$UNT slots allocated, DEQ$First$Free
###            points to DEQ entry # 401.
###
###    Author:
###
###        R. E. Hundt
###        Computer Sciences Corporation
###        4045 Hancock Street
###        San Diego CA 92110
###
###        (619) 225-8401
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required:
###
###    Tables Required:
###
###    Algorithm:
###
###    Date Developed: 3/9/89
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###    Waivers:

subroutine get_DEQ_entry (unt$pointer,deq$pointer)
BBcommon
integer     ltsave / -1 /
BBdeclare  (UNT$Pointer,UNT$Nbreq$I,
            DEQ$Pointer,DEQ$Nextdeq$I)
 
UNT$NbrEQ$i = xUNT$NbrEQ$i
 
IF (UNT$NbrEQ$i > 0)  # In this case, we can't use the corresponding slot..
    {
    # if no available DEQ entry
    IF (DEQ$First$FREE == 0)
        {
        DEQ$Pointer = 0
        if (ltsave == game$minute) RETURN
        ltsave = game$minute
        call echor
        call echov ("DEQ Table overflow")
        call echor
        RETURN
        }
 
    for_DEQ_CHAIN
        {
        DEQ$NextDEQ$i = xDEQ$NextDEQ$i
 
        IF (DEQ$NextDEQ$i == 0)                # if last entry in chain
            {
            PUTdeq$NextDEQ$i (DEQ$First$FREE)  # extend chain
            DEQ$Pointer$TO (DEQ$First$FREE)    # set ptr to last entry in chain
            DEQ$First$Free = XDEQ$NextDEQ$i    # set free ptr to 1st avail DEQ
            PUTdeq$NextDEQ$i (0)               # set end of chain marker
            break
            }
        }
    }  # IF (UNT$NbrEQ$i > 0)
ELSE    # This is the FIRST slot in the chain..
    {
    DEQ$POINTER$TO (UNT$Pointer$Index) # Set the same slot as UNT
    PUTdeq$NextDEQ$i (0)               # set end of chain marker
    }
 
UNT$NbrEQ$i = UNT$NbrEQ$i + 1
PUTUNT$NbrEQ$i
 
end
 

subroutine FREE_DEQ_CHAIN ( UNT$Pointer )
BBcommon
 
INTEGER*4    I_DEQ_Save
BBdeclare  (UNT$Pointer, DEQ$Pointer, DEQ$Nextdeq$I)
 
FOR ( DEQ$Pointer$To UNT$Pointer$Index;
      DEQ$Pointer >= DEQ$Base;
      DEQ$Pointer$To I_DEQ_Save )
    {
    I_DEQ_Save = XDEQ$NextDeq$i
    DEQ$ZERO
    IF ( DEQ$Pointer$Index != UNT$Pointer$Index )
        {
        DEQ$NextDeq$i = DEQ$First$Free
        PUTDEQ$NextDeq$i
 
        DEQ$First$Free = DEQ$Pointer$Index
        }
    }
 
PUTunt$NbrEq$i ( 0 )
 
end
 
 

 
subroutine Shrink_DEQ_Chain ( UNT$POINTER )
###################################################################
#$%
#$% Purpose: When GND objects in a unit's DEQ Chain have been ZEROED
#$% (leaving DEQ$NextDeq$i and DEQ$Ident$i still in place),  Do_Amphib
#$% calls Shrink_DEQ_Chain to close up the chain and put the DEQ slots
#$% that have just been emptied onto the FREE list.
#$% In other words, any DEQ entry (beyond the first one) with an Ident
#$% of GND (or NULL), should be removed from the unit's list and moved
#$% to the Free list.
#$%
#$% # ( A restricted application of FREE_DEQ_CHAIN - which see in LBCOMMN )
#$%
#$% Called By: Do_Amphib        ORemove_equipment <wgopexp.rat>
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT    DEQ
#$%
#$% Date:      4 December 1989
#$%
#$% Author:    Joe Bryant/ R. Hundt
#$%
#$% Revised:   19 April 90, DEW
#$%
####################################################################
BBcommon
 
integer*4       first_deq_entry, next_deq_entry
BBdeclare  (UNT$Pointer, UNT$Nbreq$I,
            DEQ$Pointer, DEQ$Nextdeq$I, DEQ$Ident$I,
            DEQ2$Pointer, DEQ2$Ident$I, DEQ2$Nextdeq$I)
 
first_deq_entry = unt$pointer$index
deq$pointer$to first_deq_entry
 
next_deq_entry = Xdeq$NextDeq$i
 
while ( next_deq_entry != 0)            # loop till the end of the chain
    {
    deq2$pointer$to next_deq_entry      # look ahead to the next entry
 
    DEQ2$Ident$i = xDEQ2$Ident$i
 
    If ( DEQ2$Ident$i == $Null$Code |   # should it be excised ?
        (DEQ2$Ident$i == $GND$Code & xDEQ2$Remaining$i == 0 ) )
        {                               # YES, Entry IS to be removed...
        DEQ2$NextDEQ$i = Xdeq2$NextDEQ$i
 
        # at this point:
        #   DEQ2 points to the entry to excise
        #   DEQ points to where we came from
        #   DEQ2$NextDEQ$i points to where we are going
 
        putDEQ$NextDEQ$i ( DEQ2$NextDEQ$i )     # now we jump around it
 
        DEQ2$ZERO                               # clear it out
 
        putDEQ2$NextDeq$i ( DEQ$First$Free )    # point to free list
 
        DEQ$First$Free = DEQ2$Pointer$Index     # Point free list here
 
        unt$NbrEq$i = Xunt$NbrEq$i - 1
        PUTunt$NbrEq$i
        }
    else                                        # No, just move along
        {
        deq$pointer = deq2$pointer              # bump along
        }
 
    next_deq_entry = Xdeq$NextDeq$i
 
    } # end WHILE ( more DEQ entries )
 
#------------------------------------------------------------
# now check if the very first entry is empty....
 
deq$pointer$to unt$pointer$index
 
deq$NextDeq$i = Xdeq$NextDeq$i
deq$Ident$i   = Xdeq$Ident$i
 
if ( deq$NextDeq$i == 0 & deq$Ident$i == $null$code )
    {                                                       # Yes it is
    PUTunt$NbrEq$i ( 0 )
    }
 
return
end        # End Shrink_DEQ_Chain
 
 

# finds active channel for emitter type equipments
subroutine find_active_channel (UNT$Pointer,            # input
                                iequip_code,            # input
                                eqtype,                 # input
                                ichan_Index)            # output
BBCommon
 
real*4       mth$alog2, allbands
INTEGER*4 ichan_Index, litcmp
INTEGER*4 iequip_code
LITERAL   eqtype
literal     cstrip8
BBdeclare  (DEQ$Pointer, UNT$Pointer)
 
ichan_index = 1      # no DEQ's for cruise missile radars 11/8/90
 
# New code to find active operating freq using DEQ EM$Band field, 5/89
FOR_DEQ_CHAIN
    {
    # if match, check on active channel
    IF (xDEQ$Ident$i == iequip_code &
        litcmp(xDEQ$Type$c, eqtype) == 0)
        {
        #$% get operating frequency
        allbands = xDEQ$AllBands$i
        if (AllBands > 0 ) ichan_Index = NINT(mth$alog2(allbands)) + 1
        else               ichan_Index = 1
 
        break
        }
    }
 
return
end
 
 

Subroutine TypeModul (ModulType,
                      ModulSpec,
                      iTYPE)
implicit none
Literal ModulType, ModulSpec
Integer iTYPE
 
if (ModulType == 'PULSE')
   {
    if      (ModulSpec == 'AM') iTYPE = $am$pulse                # A1
    else if (ModulSpec == 'AM2TN') iTYPE = $am$pulse$freq$shift$key # A2
    else if (ModulSpec == 'FM2TN') iTYPE = $fm$pulse$freq$shift$key # F2
    else if (ModulSpec == 'FSK') iTYPE = $freqshiftkey$pulse      # F1
    else if (ModulSpec == 'WIDBN') iTYPE = $pulse$wideband          # P0
    else if (ModulSpec == 'PAM') iTYPE = $pulse$am                # P9D
    else if (ModulSpec == 'WIDTH') iTYPE = $pulse$width$mod         # P9E
    else if (ModulSpec == 'POSIT') iTYPE = $pulse$position$mod      # P9F
    else if (ModulSpec == 'CMPRS') iTYPE = $pulse$compression       # P9G
    else                           iTYPE = 0
   }
ELSE if (ModulType == 'VOICE')
   {
    if      (ModulSpec == 'AM3') iTYPE = $am$voice$1     # A3 (Ms = 0.3)
    else if (ModulSpec == 'AM5') iTYPE = $am$voice$2     # A3 (Ms = 0.5)
    else if (ModulSpec == 'FM1') iTYPE = $fm$voice$1     # F3 (Bs = 1  )
    else if (ModulSpec == 'FM5') iTYPE = $fm$voice$2     # F3 (Bs = 5  )
    else if (ModulSpec == 'ANLGD') iTYPE = $DoubleSideBand$Analog #A3B (dbl sb)
    else if (ModulSpec == 'ANLGS') iTYPE = $SingleSideBand$Analog #AJ (sngl sb)
    else                           iTYPE = 0
   }
ELSE if (ModulType == 'ANLOG')
   {
    if      (ModulSpec == 'AM') iTYPE = $am$Analog  # A9
    else if (ModulSpec == 'PM') iTYPE = $PulseMod$Analog  # F9 (Pulse)
    else                           iTYPE = 0
   }
ELSE if (ModulType == 'FAX')  iTYPE = $am$fax$1             # A4
        # This ignores F4..
ELSE if (ModulType == 'MLTPX')  iTYPE = $FreqDiv$MPX          # F9 (MPX)
ELSE if (ModulType == 'FILTR')  iTYPE = $matched$filter       # P9 (match)
ELSE if (ModulType == 'PHASE')  iTYPE = $phase$lock           # P9 (22.5deg)
ELSE if (ModulType == 'VIDEO')  iTYPE = $tv$video             # A5C
 
return
end

 
Literal Function Astab_Mission (Mission_Code)
 
#---------------------------------------------------------------------------
#   This function returns a common acronym for all possible mission codes
#
#   DEW 21-Dec-1989
#---------------------------------------------------------------------------
implicit none
integer Mission_Code
 
literal All_Missions[0:46]
vmschar*8 All_MissionsC[0:46]
equivalence (all_missions, all_missionsC)
 
data  All_MissionsC[$NoneAssigned$Code]      / "     " /
data  All_MissionsC[$Strike$Code]            / "STRIK" /
data  All_MissionsC[$Cap$Code]               / "CAP  " /
data  All_MissionsC[$SurveillanceCap$Code]   / "SUCAP" /
data  All_MissionsC[$StrikeCap$Code]         / "STCAP" /
data  All_MissionsC[$AEW$Code]               / "AEW  " /
data  All_MissionsC[$AntiSub$Code]           / "ASW  " /
data  All_MissionsC[$Reconn$Code]            / "RECON" /
data  All_MissionsC[$AirTanker$Code]         / "TANKR" /
data  All_MissionsC[$Rescue$Code]            / "RESCU" /
data  All_MissionsC[$Decoy$Code]             / "DECOY" /
data  All_MissionsC[$CommRelay$Code]         / "RELAY" /
data  All_MissionsC[$Surv$Code]              / "SURV " /
data  All_MissionsC[$Jam$Code]               / "JAM  " /
data  All_MissionsC[$Search$Code]            / "SRCH " /
data  All_MissionsC[$EW$Code]                / "EW   " /
data  All_MissionsC[$STtanker$Code]          / "STTKR" /
data  All_MissionsC[$Amphib$Code]            / "AMPHB" /
data  All_MissionsC[$AirDefense$Code]        / "AD   " / #30 3/23/92 SMM
data  All_MissionsC[$AirInteraction$Code]    / "AI   " / #31 3/23/92 SMM
data  All_MissionsC[$Airlift$Code]           / "ALFT " / #32 3/23/92 SMM
data  All_MissionsC[$BattleFieldAirInteraction$Code] / "BAI  " / #33 3/23/92 SMM
data  All_MissionsC[$CloseAirSupport$Code]   / "CAS  " / #34 3/23/92 SMM
data  All_MissionsC[$Escort$Code]            / "ESCRT" / #35 3/23/92 SMM
data  All_MissionsC[$Ferry$Code]             / "FY   " / #36 3/23/92 SMM
data  All_MissionsC[$MaritimePatrol$Code]    / "MP   " / #37 3/23/92 SMM
data  All_MissionsC[$OffensiveCounterAir$Code]/ "OCA  " /#38 3/23/92 SMM
data  All_MissionsC[$SpecialMission$Code]    / "SM   " / #39 3/23/92 SMM
data  All_MissionsC[$Sweep$Code]             / "SWEEP" / #40 3/23/92 SMM
data  All_MissionsC[$Tasmo$Code]             / "TASMO" / #41 3/23/92 SMM
data  All_MissionsC[$TacElecWar$Code]        / "TEW  " / #42 3/23/92 SMM
data  All_MissionsC[$WildWeasel$Code]        / "WW   " / #43 3/23/92 SMM
data  All_MissionsC[$Commerce$Code]          / "COMRC" / #44 - clk 12/96 (E1724)
data  All_MissionsC[$SeaControl$Code]        / "SCTRL" / #45 - clk 12/96 (E1724)
data  All_MissionsC[$SeaLift$Code]           / "SLIFT" / #46 - clk 12/96 (E1724)
 
return ( All_Missions[Mission_Code] )
 
end

 
Literal Function Astab_ROE (ROE_Code,Nuclear_Cleared)
 
#---------------------------------------------------------------------------
#   This function returns a common acronym for all possible
#   Rule of Engagement codes
#
#   DEW 21-Dec-1989
#---------------------------------------------------------------------------
implicit none
integer ROE_Code, Nuclear_Cleared
 
literal All_ROEs[0:1,0:16]
vmschar*8 All_ROEsC[0:1,0:16]
equivalence (All_ROEs, All_ROEsC)
 
data  All_ROEsC[$No ,$IfAttacked$Code]           / "T   " /
data  All_ROEsC[$No ,$AllEnemy$Code]             / "FEX " /
data  All_ROEsC[$No ,$AirEnemy$Code]             / "FEA " /
data  All_ROEsC[$No ,$SurfaceEnemy$Code]         / "FES " /
data  All_ROEsC[$No ,$SubEnemy$Code]             / "FEU " /
data  All_ROEsC[$No ,$SpecTarget$Code]           / "F*  " /
data  All_ROEsC[$No ,$AllNonFriendly$Code]       / "FXX " /
data  All_ROEsC[$No ,$AirNonFriendly$Code]       / "FXA " /
data  All_ROEsC[$No ,$SurfaceNonFriendly$Code]   / "FXS " /
data  All_ROEsC[$No ,$SubNonFriendly$Code]       / "FXU " /
 
data  All_ROEsC[$Yes,$IfAttacked$Code]           / "T   " /
data  All_ROEsC[$Yes,$AllEnemy$Code]             / "FNE " /
data  All_ROEsC[$Yes,$AirEnemy$Code]             / "FNEA" /
data  All_ROEsC[$Yes,$SurfaceEnemy$Code]         / "FNES" /
data  All_ROEsC[$Yes,$SubEnemy$Code]             / "FNEU" /
data  All_ROEsC[$Yes,$SpecTarget$Code]           / "FN* " /
data  All_ROEsC[$Yes,$AllNonFriendly$Code]       / "FNU " /
data  All_ROEsC[$Yes,$AirNonFriendly$Code]       / "FNUA" /
data  All_ROEsC[$Yes,$SurfaceNonFriendly$Code]   / "FNUS" /
data  All_ROEsC[$Yes,$SubNonFriendly$Code]       / "FNUU" /
 
return ( All_ROEs[iand(Nuclear_Cleared,1),ROE_Code] )
 
end
 

 
Integer*4 Function ASTAB_Status (own$status$i)
 
 #######################################################
 #$%
 #$% Purpose:   Defines the status of a force
 #$%
 #$% Called By:
 #$%
 #$% Calls:
 #$%
 #$% Tables:    OWN
 #$%
 #$% Date:      3-Aug-90
 #$%
 #$% Author:    D. Wills
 #$%
 #$% Modified:  James Allen - 2/96 (E1467)
 #$%            Added moor and ipt status'.
 #$%
 #######################################################
 
implicit none
integer*4 own$status$i
integer*4 All_STATs [0:24]
vmschar*4 All_STATsC [0:24] # / 25 * " -- " /
equivalence (All_STATs, All_STATsC)
 
Data All_STATsC [ $ENG$status   ] / "ENG " /
Data All_STATsC [ $ENR$status   ] / "ENR " /
Data All_STATsC [ $FUEL$status  ] / "FUEL" /
Data All_STATsC [ $INT$status   ] / "INT " /
Data All_STATsC [ $LNCH$status  ] / "LNCH" /
Data All_STATsC [ $SINK$status  ] / "SINK" /
Data All_STATsC [ $STA$status   ] / "STA " /
Data All_STATsC [ $FAIL$status  ] / "FAIL" /
Data All_STATsC [ $FLT$status   ] / "FLT " /
Data All_STATsC [ $TOW$status   ] / "TOW " /
Data All_STATsC [ $UTOW$status  ] / "UTOW" /
Data All_STATsC [ $DIW$status   ] / "DIW " /
Data All_STATsC [ $SRCH$status  ] / "SRCH" /
Data All_STATsC [ $BING$status  ] / "BING" /
Data All_STATsC [ $MSHL$status  ] / "MSHL" /
Data All_STATsC [ $HIDE$status  ] / "HIDE" /        #khc 7/92
Data All_STATSC [ $PLAN$status  ] / "PLN " /        # SMM 7/93
Data All_STATSC [ $MOOR$status  ] / "MOOR" /        # joa 2/96 (E1467)
Data All_STATSC [ $IPT$status   ] / "IPT " /        # joa 2/96 (E1467)
 
return ( All_STATs [own$Status$i] )
end
 
Subroutine OWNSTA (own$status$i,istat)  ##
 
#######################################################
#$%
#$% Purpose:   Convert a function to a subroutine
#$%
#$% Author:    D. Wills 3-Aug-90
#$%
#######################################################
implicit none
integer*4   Astab_status
external    Astab_status
integer*4   own$status$i, istat
 
istat = ASTAB_status(own$status$i)
 
return
end
 
 

subroutine get_Performance( Rx_Modulation,            # in ( index )
                            Interference_Modulation,  # in ( index )
                            I_To_N_Ratio,             # input, dB
                            n,             # in, used in some modulation types
                            Interference )            # out
 
#############################################################
#$%
#$% Purpose:   Get_Performance modifies the signal to Noise ratio
#$%     by a performance threshold value.
#$%
#$%
#$% Called By: EMI_Inter_Node_Advance   raddet
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$% Date:      9/89
#$%
#$% Author:    R.E.Hundt
#$%
#############################################################
BBimplicit
 
logical*1    Rx_Modulation
logical*1    Interference_Modulation
integer*4    I_To_N_Ratio
integer*4    n
integer*4    Interference
 
 
integer*2    Threshold
 
# performance threshold table. from Don white, Vol 5, 1972. Table 8.3
integer*2    Performance_Threshold [ $Last$Modulation, $Last$Modulation ]
 
data  Performance_Threshold / 8,
      7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  7,  7,  8,  7,  7,  7,
  9,  6,  0,  0, 11,  7,  6, 11, 11,  5,  6,  6, 11, 11, 11, 11,  9,  6,  6,  6,  9,  6,  6,
-23,-13, -1, -5,  4,  0,-13,  0,  2,-23,  0,  0,  2,  0,  2,  2,-23,-13,-13,-13,-23,-13,-13,
-19,-10,  0, -4,  7,  3,-10,  3,  5,-19,  3,  3,  5,  3,  5,  5,-19,-10,-10,-10,-19,-10,-10,
-36,-24, -7, -7, -7, -7,-24,  3,  3,-36, -7, -7,  3, -7,  3,  3,-36,-24,-24,-24,-36,-24,-24,
-36,-24, -7, -7, -7, -7,-24,  3,  3,-36, -7, -7,  3, -7,  3,  3,-36,-24,-24,-24,-36,-24,-24,
 10, 10,  5,  2, 12,  8, 10, 12, 10, 10, 10, 10, 12, 10, 12, 12, 10, 10, 10, 10, 10, 12, 10,
 41, 41, 36, 32, 45, 41, 41, 45, 41, 41, 41, 41, 45, 41, 45, 45, 26, 41, 41, 41, 41, 45, 41,
 10, 10,  5,  2, 12,  8, 12,  8, 10, 10,  8,  8, 10,  8, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  6, -6,-12,-16, 16, 16, -6, 16, 16,  6, -6, -6, 16, -6, 16, 16,  6, -6, -6, -6,  6, -6, -6,
  6, 16, 16, 16, 16, 16, 16, 16, 16,  6, 16, 16, 16, 16, 16, 16,  6, 16, 16, 16,  6, 16, 16,
  0,  3,  3,  3,  2,  2,  3,  2,  3,  0,  3,  3,  2,  3,  2,  2,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0, -4, -4,  0, -4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 12, 12, 10, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 12, 10, 10,  0, 12, 12, 12, 12, 12, 12,
 22, 22, 22, 22, 25, 25, 22, 25, 25, 22, 22, 22, 25, 22, 25, 25, 15, 15, 15, 15, 15, 15, 22,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  5,  7,  7,  4, 10, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 10, 10, 10, 10, 10, 10,  5,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13/
 
Threshold =
    performance_threshold [ Interference_Modulation, Rx_Modulation ] # in dB
 
#Interference = I_To_N_Ratio - threshold         # commented out 2/9/90, reh
Interference = I_To_N_Ratio + threshold         # in dB
 
#$% do not allow interference to augment the signal in later calcs.
IF ( Interference < 0 )
    {
    Interference = 0
    }
 
return
end
 

define ($my_cm      ,1)
define ($my_torp    ,2)
define ($my_ctm     ,3)
define ($my_fls     ,4)    # jb (Added FALSEtargets)    12/27/90
define ($my_adcru   ,5)    # Alex V. 8/93
define ($my_adsam   ,6)    # SMM 12/93
#define  ($max_types  ,5)   # Alex V. 8/93
define  ($max_types  ,6)   # SMM 12/93 added advanced SAMs
 
 
subroutine Assign_Unique_Unit_Name (Unt$pointer)
 
#######################################################
#$%
#$% Purpose:    The purpose is to provide unique names for PGA that
#$%             are not confused when the object goes away and another
#$%             reappears...
#$%
#$%             This routine is for use for launching Cruise Missiles/
#$%             Smart Torpedoes/Countermeasures; and for False Targets.
#$%             It uses the following information from the specified UNT:
#$%                 Unt$View$i
#$%                 Unt$SuperType$i
#$%             They must be assigned values prior to calling this
#$%             routine....
#$%
#$%             On completion, the UNT$Name$C field will be set to a
#$%             unique name.  Uniqueness is only guaranteed for the
#$%             life of the object + a few minutes.
#$%
#$% Called By:
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT
#$%
#$% Date:      14 May 90
#$%
#$% Author:    Dane Wills
#$%
#$% Modified:  Susan Miller 12/93 added letters for advanced SAMs
#######################################################
#
#  Method:  Create a sequential name based on the side, type, and sequence
#           of the object.
#
#  Format:  X9SSS
#           where:  X is T for torpedo
#                        Q for Blue Cruise Missiles
#                        P for Orange Cruise Missiles
#                        Z for Neutral Cruise Missiles
#                        F for False Targets
#                        H for Orange advance cruise missiles
#                        I for Blue advance cruise missiles
#                        S for Blue advanced SAMs
#                        M for Orange advanced SAMs
#                   9 is 0 for Neutral
#                   9 is 1 for Blue
#                   9 is 2 for Orange
#                   SSS is a sequential number (counter) assigned in order
#                            for that session....
#----------------------------------------------------------------------------
 
BBcommon
 
integer*4       itype
integer*4       iside
integer*4       ix_unt
integer*4       ilen
integer*4       my_ix
literal         unt$name$c
 
character       prefix [ $max_types, 0:2 ]
 
data            prefix [ $my_torp , $neutral$code ]  / $LETT /
data            prefix [ $my_torp , $blue$code    ]  / $LETT /
data            prefix [ $my_torp , $orange$code  ]  / $LETT /
data            prefix [ $my_ctm  , $neutral$code ]  / $LETC /
data            prefix [ $my_ctm  , $blue$code    ]  / $LETC /
data            prefix [ $my_ctm  , $orange$code  ]  / $LETC /
data            prefix [ $my_cm   , $neutral$code ]  / $LETZ /
data            prefix [ $my_cm   , $blue$code    ]  / $LETQ /
data            prefix [ $my_cm   , $orange$code  ]  / $LETP /
data            prefix [ $my_fls  , $neutral$code ]  / $LETF / # jb 12/27/90
data            prefix [ $my_adcru, $blue$code    ]  / $LETI / # Alex V. 8/93
data            prefix [ $my_adcru, $orange$code  ]  / $LETH / # Alex V. 8/93
data            prefix [ $my_adsam, $blue$code    ]  / $LETS / # SMM 12/93
data            prefix [ $my_adsam, $orange$code  ]  / $LETM / # SMM 12/93
 
#------------------------------------------------------------
# The following array will have IBB index values for the named counters
 
integer*4  count_ix [ $max_types, 0:2 ]   # SUBSTR will extract "999" from "IBB[999]"
data count_ix[$my_ctm ,$neutral$code] / substr(Neutral$Torpedo$Count,5,3) /
data count_ix[$my_ctm ,$blue$code   ] / substr(Blue$Torpedo$Count   ,5,3) /
data count_ix[$my_ctm ,$orange$code ] / substr(Orange$Torpedo$Count ,5,3) /
data count_ix[$my_torp,$neutral$code] / substr(Neutral$Torpedo$Count,5,3) /
data count_ix[$my_torp,$blue$code   ] / substr(Blue$Torpedo$Count   ,5,3) /
data count_ix[$my_torp,$orange$code ] / substr(Orange$Torpedo$Count ,5,3) /
data count_ix[$my_cm  ,$neutral$code] / substr(Neutral$Cruise$Count ,5,3) /
data count_ix[$my_cm  ,$blue$code   ] / substr(Blue$Cruise$Count    ,5,3) /
data count_ix[$my_cm  ,$orange$code ] / substr(Orange$Cruise$Count  ,5,3) /
data count_ix[$my_fls ,$neutral$code] / substr(Neutral$False$Count  ,5,3) /
data count_ix[$my_adcru,$blue$code  ] / substr(Blue$adcru$count     ,5,3) /
data count_ix[$my_adcru,$orange$code] / substr(Orange$adcru$count   ,5,3) /
data count_ix[$my_adsam,$blue$code  ] / substr(Blue$adsam$count     ,5,3) /
data count_ix[$my_adsam,$orange$code] / substr(Orange$adsam$count   ,5,3) /
 
#------------------------------------------------------------
integer     icat
BBdeclare  (UNT$Pointer, UNT$View$I, UNT$Type$I, UNT$Supertype$I,
            CMC$Pointer)
 
unt$View$i      = Xunt$View$i
unt$Type$i      = Xunt$Type$i
unt$SuperType$i = Xunt$SuperType$i
cmc$pointer = Xunt$cmcpntr$i
 
icat = Xcmc$cat$i
 
if      (unt$Type$I      == $CruiseMissile$code  )
 { if (icat == $adcru$code) itype = $my_adcru
   else                     itype = $my_cm
 }
else if (UNT$Type$I      == $SAMissile$Code)       itype = $my_adsam
else if (unt$SuperType$I == $CtrMeasure$SuperCode) itype = $my_ctm
else if (unt$SuperType$I == $Torpedo$SuperCode   ) itype = $my_torp
else if (UNT$SuperType$i ==$FalseContact$SuperCode)itype = $my_fls # /90
else
    {
    unt$name$c = 'Z'                    # unknown type....
    ix_unt = unt$pointer$index
 
    ilen = 1
    call smoviz(ix_unt,4,UNT$Name$C,ilen)
    putUNT$Name$C
    return
    }
 
call whside (unt$View$i, iside)
 
my_ix = max ( 1, count_ix [ itype , iside ] )       # don't allow ix == 0
 
IBB [ my_ix ]  = IBB [ my_ix ] + 1
 
ilen = 0
unt$name$c = $BLANKLIT         # clear name to blanks
call smov (prefix [ itype, iside ], UNT$Name$C, ilen)
 
ix_unt = mod ( IBB [ my_ix ], 1000 )                # Ranges from 000..999
 
call smovi (iside,   UNT$Name$C,ilen)     # Side
call smoviz(ix_unt,3,UNT$Name$C,ilen)     # Sequence
 
putUNT$Name$C
 
return
end

 
 
subroutine Assign_Unique_BOY_Name (BOY$pointer)
 
#######################################################
#$%
#$% Purpose:    The purpose is to provide unique names for PGA that
#$%             are not confused when the object goes away and another
#$%             reappears...
#$%
#$%             This routine is for use for deploying sonobuoy barriers
#$%             commbuoys and chaff corridors
#$%
#$%             On completion, the BOY$Name$C field will be set to a
#$%             unique name.  Uniqueness is only guaranteed for the
#$%             life of the object + a few minutes.
#$%
#$% Called By:
#$%
#$% Calls:     None
#$%
#$% Tables:    BOY, UNT
#$%
#$% Date:      July 6, 2005
#$%
#$% Author:    James O. Allen
#$%
#######################################################
#
#  Method:  Create a sequential name based on the side, type, and sequence
#           of the object.
#
#  Format:  X9SSSSS
#           where:  X is B for sonobuoy
#                        C for commbuoy
#                        D for chaff cloud
#                   9 is 0 for Neutral
#                   9 is 1 for Blue
#                   9 is 2 for Orange
#                   SSSSS is a sequential number (counter) assigned in order
#                            for that session....
#----------------------------------------------------------------------------
 
BBcommon
 
integer*4       itype
integer*4       iside
integer*4       ix_unt
integer*4       ilen
integer*4       my_ix
literal         boy$name$c
 
define ($my_ab      ,1)
define ($my_cb      ,2)
define ($my_chaff   ,3)
define ($my_pb      ,4)
define ($my_ta      ,5)
define ($my_vds     ,6)
define ($max_boy_types  ,6)
 
character       prefix [ $max_types, 0:2 ]
data            prefix [ $my_ab ,    $neutral$code ]  / $LETB /
data            prefix [ $my_ab ,    $blue$code    ]  / $LETB /
data            prefix [ $my_ab ,    $orange$code  ]  / $LETB /
data            prefix [ $my_cb ,    $neutral$code ]  / $LETC /
data            prefix [ $my_cb ,    $blue$code    ]  / $LETC /
data            prefix [ $my_cb ,    $orange$code  ]  / $LETC /
data            prefix [ $my_chaff , $neutral$code ]  / $LETD /
data            prefix [ $my_chaff , $blue$code    ]  / $LETD /
data            prefix [ $my_chaff , $orange$code  ]  / $LETD /
data            prefix [ $my_pb ,    $neutral$code ]  / $LETG /
data            prefix [ $my_pb ,    $blue$code    ]  / $LETG /
data            prefix [ $my_pb ,    $orange$code  ]  / $LETG /
data            prefix [ $my_ta ,    $neutral$code ]  / $LETH /
data            prefix [ $my_ta ,    $blue$code    ]  / $LETH /
data            prefix [ $my_ta ,    $orange$code  ]  / $LETH /
data            prefix [ $my_vds ,   $neutral$code ]  / $LETJ /
data            prefix [ $my_vds ,   $blue$code    ]  / $LETJ /
data            prefix [ $my_vds ,   $orange$code  ]  / $LETJ /
 
#------------------------------------------------------------
# The following array will have IBB index values for the named counters
 
integer*4  count_ix [ $max_types, 0:2 ]   # SUBSTR will extract "999" from "IBB[999]"
data count_ix[$my_ab    ,$neutral$code] / substr(Neutral$Sonobuoy$Count,5,3) /
data count_ix[$my_ab    ,$blue$code   ] / substr(Blue$Sonobuoy$Count   ,5,3) /
data count_ix[$my_ab    ,$orange$code ] / substr(Orange$Sonobuoy$Count ,5,3) /
data count_ix[$my_cb    ,$neutral$code] / substr(Neutral$Commbuoy$Count,5,3) /
data count_ix[$my_cb    ,$blue$code   ] / substr(Blue$Commbuoy$Count   ,5,3) /
data count_ix[$my_cb    ,$orange$code ] / substr(Orange$Commbuoy$Count ,5,3) /
data count_ix[$my_chaff ,$neutral$code] / substr(Neutral$Chaff$Count   ,5,3) /
data count_ix[$my_chaff ,$blue$code   ] / substr(Blue$Chaff$Count      ,5,3) /
data count_ix[$my_chaff ,$orange$code ] / substr(Orange$Chaff$Count    ,5,3) /
data count_ix[$my_pb    ,$neutral$code] / substr(Neutral$PassiveBarrier$Count,5,3) /
data count_ix[$my_pb    ,$blue$code   ] / substr(Blue$PassiveBarrier$Count   ,5,3) /
data count_ix[$my_pb    ,$orange$code ] / substr(Orange$PassiveBarrier$Count ,5,3) /
data count_ix[$my_ta    ,$neutral$code] / substr(Neutral$TowedArray$Count,5,3) /
data count_ix[$my_ta    ,$blue$code   ] / substr(Blue$TowedArray$Count   ,5,3) /
data count_ix[$my_ta    ,$orange$code ] / substr(Orange$TowedArray$Count ,5,3) /
data count_ix[$my_vds   ,$neutral$code] / substr(Neutral$VDS$Count,5,3) /
data count_ix[$my_vds   ,$blue$code   ] / substr(Blue$VDS$Count   ,5,3) /
data count_ix[$my_vds   ,$orange$code ] / substr(Orange$VDS$Count ,5,3) /
 
#------------------------------------------------------------
BBdeclare  (UNT$Pointer, UNT$View$I, BOY$Type$I,
            BOY$Pointer)
 
unt$pointer$to XBOY$OwnerIndx$i
unt$View$i      = Xunt$View$i
 
BOY$Type$I = XBOY$Type$i
 
if      (BOY$Type$I == $commbuoy$Code)       itype = $my_cb
else if (BOY$Type$I == $ActiveBarrier$Code)  itype = $my_ab
else if (BOY$Type$I == $PassiveBarrier$Code) itype = $my_pb
else if (BOY$Type$I == $VDS$Code)            itype = $my_vds
else if (BOY$Type$I == $TowedArray$Code)     itype = $my_ta
else if (BOY$Type$I == $Chaff$Code)          itype = $my_chaff
else return
 
call whside (unt$View$i, iside)
 
my_ix = max ( 1, count_ix [ itype , iside ] )       # don't allow ix == 0
 
IBB [ my_ix ]  = IBB [ my_ix ] + 1
 
ilen = 0
boy$name$c = $BLANKLIT         # clear name to blanks
call smov (prefix [ itype, iside ], BOY$Name$C, ilen)
 
ix_unt = mod ( IBB [ my_ix ], 100000 )    # Ranges from 00000..99999
 
call smovi (iside,   BOY$Name$C,ilen)     # Side
call smoviz(ix_unt,5,BOY$Name$C,ilen)     # Sequence
 
putBOY$Name$C
 
return
end

Subroutine Day_Nite_Time (Latitude, Longitude, BUF)
 
########################################################
#$%
#$% Purpose:   DAY_NITE_TIME calculates the longitude of
#$%            the sun and determines whether the
#$%            affected CENTER POINT is in daylight
#$%            or darkness.
#$%
#$% Called By: PLOT_UP
#$%
#$% Calls:     QTRIG      ANGPI
#$%
#$% Tables:    STA
#$%
#$% Date:      JUL 83   (Copy of DAYTST)
#$%
#$% Author     T. Adamos                ## tpa /7/26/83
#$%
########################################################
 
BBcommon
 
real*4          latitude, longitude
character       buf[30]
integer         Game_Time
real sunset, sunrise
 
real        fudge /-.0151/
real        SUNLON, SCOS, SSIN, PLAT, PLON, DIFF, PCOS, PSIN, TERM,
            DELLON, TIL
integer     ILEN
 
sunset  = 00
sunrise = 00
 
 
sunlon = $pi/180. * (180.-(game$time+zulu$starttime)/4.) # JFR 1/13/94 for VTS
sunlon = amod(sunlon,$twopi)                    ## calculate longitude of sun
 
if (sunlon > $pi) sunlon = sunlon - $twopi
 
#call qktrig (sun$latitude,scos,ssin)
scos = cos(sun$latitude)
ssin = sin(sun$latitude)
 
plat = Latitude                           #$% get true lat. & longitude
plon = Longitude
 
diff = plon - sunlon                            ## lon betwn cen pnt and sun
$angpi(diff)
 
pcos = cos(plat)
psin = sin(plat)
 
term = (fudge-ssin*psin)/(scos*pcos)
 
## determine if center point is in daylight and build text
 
ilen = 0
 
if (term <= -1.0)                   #if always daylight
    {
    call smovv ("DAY",buf,ilen)
    }
else if (term >= 1.0)               #if always dark
    {
    call smovv ("NITE",buf,ilen)
    }
else
    {
    dellon = acos(term)
 
                                ### TIME OF NEXT SUNSET
    sunset = 4.*(180.-(180./$pi)*(plon-dellon)) - (zulu$starttime)
 
    call earlst(sunset)                                # adjust sunset time
 
                                ### TIME OF NEXT SUNRISE
    sunrise = 4.*(180.-(180./$pi)*(plon+dellon)) - (zulu$starttime)
 
    call earlst(sunrise)                               # adjust sunrise time
 
    # when game minute has passed sunrise and sunset times (in game
    # minute also)
 
    while (sunrise < game$time &
           sunset  < game$time )
        {
        # if sunrise is less than sunset, ie. sunrise comes first
        # advance sunrise 1440 game minutes or 24 hrs
        if (sunrise < sunset) sunrise = sunrise + $Minutes$Per$Day
 
        # else sunset comes first and is advanced first
        else                    sunset  = sunset  + $Minutes$Per$Day
        }
 
    til = Game$Time + Zulu$StartTime
 
    call earlst(til)
 
    if (abs(diff) <= acos(term))                # Daylight
        {
        call smovv ("DAY/",buf,ilen)
        call smoviz(Game_Time(sunset-til), 4,buf,ilen)
        }
    else                                        # Darkness
        {
        call smovv ("NITE/",buf,ilen)
        call smoviz(Game_Time(sunrise-til),4,buf,ilen)
        }
    }
 
call smovv (" ",buf,ilen)
call smov (EOS,buf,ilen)
 
return
end
 
 

 
Subroutine Sun_Set_Rise (Latitude, Longitude, sunset, sunrise)
########################################################
#$%
#$% Purpose:   SUN_SET_RISE calculates the sunrise/sunset
#$%            time initialization.
#$%
#$% Called By: DAY_NITE_TIME      IR_MOD
#$%
#$% Calls:     EARLST     QTRIG
#$%
#$% Tables:    STA
#$%
#$% Date:      JUL 83           (cop of SUNTIM)
#$%
#$% Author:    T. Adamos                ## tpa /7/26/83
#$%
#$% Updated:   J. Strauch for use in IR detection      9/8/92
#$%
########################################################
 
BBcommon
 
real*4          latitude, longitude
real*4          sunset, sunrise
real        fudge /-.0151/
real        SCOS, SSIN, FCOS, FSIN, TERM, DELLON
 
scos = cos(sun$latitude)
ssin = sin(sun$latitude)
 
fcos = cos(latitude)
fsin = sin(latitude)
 
term = (fudge-ssin*fsin)/(scos*fcos)
 
if (term <= -1.0)                   #if always daylight
    {
    sunrise = 2001            #flag for STATUS
    sunset  = 2001
    }
else if (term >= 1.0)               #if always dark
    {
    sunrise = 1999            #flag for STATUS
    sunset  = 1999
    }
else
    {
    dellon = acos(term)
 
    sunrise = 720.*(1.-(longitude+dellon)/$pi) - zulu$starttime
 
    call earlst(sunrise)                       # adjust sunrise time
 
    sunset = 720.*(1.-(longitude-dellon)/$pi) - zulu$starttime
 
    call earlst(sunset)                        # adjust sunset time
    }
 
if (sunrise != 2001 | sunrise != 1999)
    {
    while (sunrise < game$time & sunset < game$time)
            {
             if (sunrise < sunset) sunrise = sunrise + $Minutes$Per$Day
             else                  sunset  = sunset  + $Minutes$Per$Day
            }
    }
return
end
 

Subroutine inout(xp,yp,                         #point being tested
                 n,                             #number of vertices of polygon
                 x ,y ,                         #arrays of vertices of polygon
                 inside)                        #yes/no flag for inside
########################################################
#$%
#$% Purpose:   INOUT receives and translates X-Y coordinates
#$%            to a latitude and longitude interception
#$%            point for detections.
#$%
#$% Called By: SORDT1
#$%
#$% Calls:     ANGPI
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 81
#$%
#$% Author:    Ron Williams
#$%
########################################################
implicit none
real*4 	   xp, yp, x0, y0, x1, x2, y1, y2
integer*4  n, inside, newtry, ninter, j, i
real*4     ynumer, ydenom
real*4 	   x[n],y[n]
 
 
x0 = xp
y0 = yp
 
repeat
   {
    newtry = $no
 
    ninter = 0
 
    x2 = x[1] - x0                              #translate x-coordinate
    $angPI(x2)
 
    for (i=1;i<=n;i=i+1)
       {
        if (i == n) j = 1
        else        j = i + 1
 
        x1 = x2
        x2 = x[j] - x0                          #translate x-coordinate
        $angPI(x2)
 
        if (x1 == 0.0 | x2 == 0.0)              #if a vertex lies on y-axis
           {
            x0 = x0 + .0001                     #perturb test point slightly
            $angPI(x0)
 
            newtry = $yes
            break
           }
 
        if ((x1 > 0.0 & x2 < 0.0) |             #if side intersects y-axis
            (x1 < 0.0 & x2 > 0.0) )
           {
            y1 = y[i] - y0                      #translate y-coordinates
            $angPI(y1)
 
            y2 = y[j] - y0
            $angPI(y2)
 
            if (y1 > 0.0 & y2 > 0.0)            #if both above x-axis
               {
                ninter = ninter + 1             #increment intersection count
               }
            else if (y1 < 0.0 & y2 < 0.0)       #if both below x-axis
               {
                 next
               }
            else
               {
                ynumer = x1 * y2 - x2 * y1      #y-intercept is
 
                ydenom = x1 - x2                #    ynumer/ydenom
 
                if ((ynumer > 0.0 & ydenom > 0.0)|  #if above x-axis
                    (ynumer < 0.0 & ydenom < 0.0))
                   {
                    ninter = ninter + 1         #increment intersection count
                   }
                else if (ynumer == 0.0)         #if at origin
                   {
                    inside = $yes               #target is on boundary
                    return                      #  so count as inside
                   }
               }
           }
       }
   } until (newtry == $no)
 
if (mod(ninter,2) == 1) inside = $yes
else                    inside = $no
 
return
end
 

#$% find Commsuite channel corresponding to CommPair Freq     12/9/90 trs
subroutine get_commsuite_channel ( SUI$Pointer,     # in
                                   PAI$Pointer,     # in
                                   Channel,         # out
                                   Istat)           # out, flag, added 4/91
 
BBCommon
 
integer*4   SUI$Pointer
integer*4   PAI$Pointer
integer*4   Channel
integer*4   Istat
 
integer*4   SUI$CH$Index
BBdeclare  (SUI$Devicetype$I)
 
Istat = $no
Channel = 1      # default channel
 
SUI$DeviceType$i = xSUI$DeviceType$i  # added 4/91 to handle BEES frequency Hop
 
if (SUI$DeviceType$i == $FixedMode )
    {
    FOR (SUI$CH$Index = 1; SUI$CH$Index$OK; SUI$CH$Index = SUI$CH$Index + 1)
        {
        if ( xPAI$Freq$i/1000.0 == xSUI$CH$Frequency$f & # compare in MHz
             xSUI$CH$Sensitivity$i != 0 )                # flag used in EMI processing
            {
            Channel = SUI$CH$Index
            Istat = $yes
            Break
            }
        }
    } # end if fixed mode commsuite
else if (SUI$DeviceType$i == $FrequencyHopper)
    {
    Istat = $yes
    }
 
return
end

 Subroutine INV_Worse(Env_Det,  # Environment (1,2,3,4) where Target is
                      Env_Tgt,  # Environment (1,2,3,4) where Detector is
                      Env_Num ) #  OUTPUT worse of the 2 Environments
 #######################################################
 #$%
 #$% Purpose:   INV_Worse determines the worse of the two
 #$%            (Env_Tgt and Env_Det) Environments, and sets
 #$%            Env_Num.  If ONE of the Environments is
 #$%            the Default, then Environment$DefaultLevel
 #$%            can affect the outcome
 #$%
 #$% Called By: PASDET    ACTSON
 #$%
 #$% Calls/Invokes:    MIN    MAX
 #$%
 #$% Tables:    none
 #$%
 #$% Date:      NOV. 1990; arguments added and shifted to LBCOMMN, Nov. 1991
 #$%
 #$% Author:    Joe Bryant
 #$%
 #######################################################
BBcommon
 
INTEGER   Env_Num, Env_Tgt, Env_Det # See Arguments, above
INTEGER   MINv  # Local variable to hold MIN(Env_Tgt,Env_Det)
INTEGER   DEFLT # Local variable for DEFAULT environment
 
 ## Environments: 1=GOOD; 2=FAIR; 3=POOR; 4=DEFLT
 ## Environment$DefaultLevel: 0=BEST; 1<GOOD; 2<FAIR; 3<POOR (the "<"
 ##  sign means "WORSE than").  "<GOOD" means 'between GOOD and FAIR'.
 
DEFLT = 4      # See Environment number conventions above (1,2,3,4)
 
If (Env_Tgt < 1 | Env_Det < 1)    # jb Over-cautions re: improper input..
   {
    Env_Num = MAX(Env_Det,Env_Tgt,1)
    Env_Num = MIN(Env_Num,DEFLT)
    RETURN
   }
If (Env_Tgt > DEFLT | Env_Det > DEFLT) # jb Over-cautions re: improper input..
   {
    Env_Num = MIN(Env_Det,Env_Tgt,DEFLT)
    Env_Num = MAX(Env_Num,1)
    RETURN
   }
#  (At this point, values of Env_Tgt and Env_Det range from 1 thru DEFLT)
 
If (Env_Tgt == Env_Det)   # This processes all cases in which BOTH
   {                      #  are in the SAME enviromnent..
    Env_Num = Env_Tgt     # so, in what FOLLOWS, no more than ONE of
    RETURN                #  the two is in the DEFAULT environment.
   }
 
If (Env_Tgt == DEFLT | Env_Det == DEFLT) # jb TGT or DET in DEFAULT Env..
   {
    MINv = MIN(Env_Tgt,Env_Det)     # MINV is NOT the DEFAULT
 
    if(Environment$DefaultLevel > 2 )   # is DEFAULT WORSE than POOR?
                                      Env_Num = DEFLT       # a
    else if( Environment$DefaultLevel > 1 ) # is DEFAULT WORSE than FAIR?
       {
        if( MINv > 2 )               Env_Num = MINv # (POOR)
        else                         Env_Num = DEFLT        # b
       }
    else if( Environment$DefaultLevel > 0 ) # is DEFAULT WORSE than GOOD?
       {
        if( MINv > 1 )               Env_Num = MINv # (FAIR or POOR)
        else                         Env_Num = DEFLT        # c
       }
    else                             Env_Num = MINv         # d
   }
 
ELSE    Env_Num = MAX(Env_Tgt,Env_Det)  # (NEITHER Env. is DEFAULT..)
 
RETURN
end
 

subroutine get_TBL_pointer ($$tbl,              # in, table number
                            TBL$Pointer )       # out, pointer free slot
#############################################################
#$%
#$% Purpose:   get_TBL_Pointer returns a TBL pointer for
#$%     an available table slot
#$%
#$%
#$%
#$% Called By:
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$% Date:
#$%
#$% Author:
#$%
#############################################################
 
BBCommon
integer*4   $$tbl
integer*4   TBL$Pointer
 
integer*2   Last_Cycle  [$$BB$LASTTABLE]
integer*2   Error_Cycle [$$BB$LASTTABLE]
 
$par$Private_All
 
if ($$tbl < 1            |      # check for valid Table number
    $$tbl > $$BB$LastTable)
    {
    TBL$pointer = 0             # return zippo
    return
    }
 
 
if (game$minute != Last_Cycle[$$tbl])      # if the game has cycled,
    {                                      # erase the previous entries
    TBL$Used = 0
    Last_Cycle[$$tbl] = game$minute
    }
 
TBL$pointer = TBL$Base + TBL$used   # Point to beyond last entry (this cycle)
 
if (! TBL$pointer$valid)            # Table Full !!!
    {
    TBL$pointer = 0                 #   return nothing
    if ( error_Cycle[$$tbl] != Game$Minute )
        {
        Error_Cycle[$$tbl] = game$minute
        call echov ("  Overflow of ")
        call echohn(TBL$name,3)
        call echov (" table.")
        }
    }
else
    {
    TBL$used = TBL$Used + TBL$Len # Bump the next available position
    }
 
return
end
 

Subroutine Load_SHC_Equipment(name,            # new unit name
                              SHC$Pointer,     # ship characteristics pointer
                              UNT$Pointer,     # unit pointer
                              successful_load) # flag whether all EQ loaded
########################################################
#$%
#$% Purpose:    Loops through EQ entries of the SHC table
#$%             and puts appropriate information in DEQ table
#$%             If SUCCESSFUL_LOAD if $NO on return, then the
#$%             DEQ table was full at some point in the sequence.
#$%             **** The loadout is not complete, but things are there
#$%
#$% Called By:  create_ship
#$%
#$% Calls:      get_DEQ_entry  NAVERR  SEND  SMOVV
#$%
#$% Tables:     DEQ  NAV  SHC  UNT
#$%
#$% Date:       Jan 1992
#$%
#$% Author:     Code taken from subroutine wglfrc in WILDFRC.RAT
#$%
#$% Modified:   Jonathan Richardson - 8/94
#$%             Added an index to each emitter on a
#$%             platform (JECEWSI Indexing).
#$%
#$%             Susan Miller 4/99 (E1969)
#$%             Set SAMCapable if unit has an advancedSAM
#$%             loaded.
########################################################
 
BBcommon
 
literal     name
integer     unt$pointer, shc$pointer, successful_load
integer*4   UNT$Type$I
integer     e_Indx
BBdeclare  (SHC$EQ$Index, SHC$EQ$ident$I,
            UNT$TNK$Index, UNT$TNK$fuelremaining$F,
            NAV$Pointer, SON$Pointer,
            DEQ$Pointer, DEQ$Pntr$I, DEQ$Limit$I, DEQ$Remaining$I,
            DEQ$Ident$I, DEQ$Oktosend$I, DEQ$Antennablockage$I,
            DEQ$On$I, DEQ$EM$Index,
            IFF$Pointer)
 
successful_load = $no
UNT$Type$I = xUNT$Type$I
 
 e_Indx = 1
 
 # loop thru EQ subtable entries of the SHC table
 For (SHC$EQ$Index = 1; SHC$EQ$Index$OK; SHC$EQ$Index = SHC$EQ$Index + 1)
    {
     SHC$EQ$Ident$I = XSHC$EQ$Ident$I
 
     if ((SHC$EQ$Ident$i == $Fuel$Code)&(UNT$Type$I == $Shorebase$Code))
        {
         UNT$TNK$Index = AviationFuelTank$code
         UNT$TNK$FuelRemaining$F = xSHC$EQ$Remaining$I
         putUNT$TNK$FuelRemaining$F
         next
        }
     else if (SHC$EQ$Ident$I == $NavSensor$Code)
        {
         NAV$Pointer = xSHC$EQ$Pntr$I
         call NAVERR(NAV$Pointer, UNT$Pointer)
         next
        }
 
     # get DEQ pointer to DEQ table
     call get_DEQ_entry (UNT$Pointer, DEQ$Pointer)
 
    If (DEQ$Pointer == 0)  # DEQ table is full, not enough space available
        {                   # for full or partial loading of equipment
         successful_load = $no
         return
        }
    #------------------------------------------------------------
    # available DEQ slot
 
    DEQ$Pntr$I = xSHC$EQ$Pntr$I
    putDEQ$Pntr$I
 
    DEQ$Limit$I = xSHC$EQ$Limit$I
    putDEQ$Limit$I
 
    DEQ$Remaining$I = xSHC$EQ$Remaining$I
    putDEQ$Remaining$I                  # also updates AntHeight field
 
    DEQ$Ident$I = xSHC$EQ$Ident$I
    putDEQ$Ident$I
 
    if (SHC$EQ$Ident$I == $CommSuite$Code |
        SHC$EQ$Ident$I == $AcousticComm$Code )
       {
        DEQ$OkToSend$I = $yes
        putDEQ$OkToSend$I
       }
 
    # indicate if the radar has a blockage zone
    else if (SHC$EQ$Ident$I == $Radar$Code)
       {
        if (xSHC$Eq$ACRIndx$I != 0)
           {
            DEQ$AntennaBlockage$I = $yes
            putDEQ$AntennaBlockage$I
           }
       }
    else if (SHC$EQ$Ident$I == $ESM$Code)
       {
        DEQ$On$I = $default$ESM$setting
        putDEQ$On$I
       }
    else if (SHC$EQ$Ident$I == $PasSonar$Code)
       {
		son$pointer = Xdeq$pntr$i
		if (Xson$TowedArray$i == $YES)
		   {
        	DEQ$On$I = $OFF
        	putDEQ$On$I
		   }
		else
		   {
        	DEQ$On$I = $default$Psonar$setting
        	putDEQ$On$I
		   }
       }
    else if (SHC$EQ$Ident$I == $HFDF$Code)
       {
        DEq$On$I = $default$HFDF$setting
        putDEQ$On$I
 
        # modified to accommodate intra-platform EMI
        DEQ$Remaining$I = 1
        putDEQ$Remaining$I
       }
    else if (SHC$EQ$Ident$I == $IFF$Code)
       {
        IFF$Pointer = DEQ$Pntr$I
        if (xIFF$Function$i == $TRANSPONDER$Code) # If a transponder,
           putDEQ$On$I ($YES)                     # initialize on;
        else                                      # otherwise,
           putDEQ$On$I ($NO)                      # initialize off.
       }
 
    #------------------------------------------------------------
    # Now do a few clean up items
 
    If ((SHC$Eq$Ident$I == $SAM$CODE) |
        (SHC$Eq$Ident$I == $AdvancedSAM$Code)) # SMM 4/99 (E1969)
        {
         putUNT$SAMcapable$I ($YES)
        }
    else if (SHC$EQ$Ident$I == $Aircraft$Code)
        {
         putUNT$AirCapable$I ($YES)
        }
    #------------------------------
    # And finally...
    if (SHC$EQ$Ident$I == $CommSuite$Code |
        SHC$EQ$Ident$i == $RADAR$CODE     |
        SHC$EQ$Ident$i == $ESM$CODE        )
        {
        DEQ$EM$Index = 1
        putDEQ$EM$Band$I (DEQ$On$I)
        }
 
   # load up the emitter index  - JFR 8/8/94
   if (DEQ$Ident$I == $CommunicationJammer$Code |
       DEQ$Ident$I == $Radar$Code               |
       DEQ$Ident$I == $RadarJammer$Code         |
       DEQ$Ident$I == $RadComJammer$code        |
       DEQ$Ident$I == $Jammer$Code              )
      {
       putDEQ$EmitterIndx$I  (e_Indx)     # store the emitter index
       e_Indx = min( e_Indx + 1, jew$or$slots)   # bump up the emitter index
      }
    } # FOR ( SHC$EQ$Index;SHC$EQ$Index$OK; SHC$EQ$Index = SHC$EQ$Index+1)
 
 successful_load = $yes     # all equipment data loaded into DEQ table
 
 return
 end

Subroutine Set_UNT_AntennaHeight(_
                              SHC$Pointer,     # ship characteristics pointer
                              UNT$Pointer,     # unit pointer
                              successful_set)  # flag whether height found
########################################################
#$%
#$% Purpose:    Loops through EQ entries of the SHC table
#$%             and sets unit antenna height to highest equipment height.
#$%
#$% Called By:
#$%
#$% Calls:
#$%
#$% Tables:     SHC  UNT
#$%
#$% Date:       Jun 2010
#$%
#$% Author:     Code taken from subroutine load_shc_equipment
#$%
########################################################
 
BBcommon
 
integer     unt$pointer, shc$pointer, successful_set
integer     maxhgt
integer*4   UNT$Type$I
BBdeclare  (SHC$EQ$Index, SHC$EQ$ident$I)
 
successful_set = $no
maxhgt =  xUNT$AntennaHeight$I
 
 
 # loop thru EQ subtable entries of the SHC table
 For (SHC$EQ$Index = 1; SHC$EQ$Index$OK; SHC$EQ$Index = SHC$EQ$Index + 1)
    {
     SHC$EQ$Ident$I = XSHC$EQ$Ident$I
 
    if (SHC$EQ$Ident$i == $COMMSUITE$CODE |
             SHC$EQ$Ident$i == $JAMMER$CODE |
             SHC$EQ$Ident$i == $COMMUNICATIONJAMMER$CODE |
             SHC$EQ$Ident$i == $RADAR$CODE |
             SHC$EQ$Ident$i == $ESM$CODE |
             SHC$EQ$Ident$i == $IFF$CODE )
        {
         maxhgt = MAX(maxhgt,xSHC$Eq$AntHeight$I)
         successful_set = $yes     # found antenna height
        }
 
    } # end equipment list loop
 
 maxhgt = max(maxhgt, 30)       # 30 ft is default mast height
 putUNT$AntennaHeight$I (maxhgt)
 
 return
 end

Subroutine tblfind($$tbl,name,tbl$pointer)  #find the passed 'name'
 
########################################################
#$%
#$% Purpose:   TBLFIND searches any given table the the
#$%            specifically named item.
#$%
#$% Date:      NOV 2000
#$%
#$% Author:    Ron Williams, Dana Wills
#$%
########################################################
BBcommon                                             # in the blackboard
 
EqErr$common
literal name
BBdeclare  ($$TBL, tbl$entry, tbl$pointer)
 
tbl$entry = max(0,tbl$len)
 
cflg = $No
call eqfind ($$tbl,tbl$entry,name,tbl$pointer)
 
return
end
 

 
Subroutine eqfind($$tbl,tbl$entry,name,tbl$pointer)  #find the passed 'name'
    # WARNING:  $$tbl and tbl$entry MAY BE CONSTANTS:  DONT CHANGE!
########################################################
#$%
#$% Purpose:   EQFIND searches any given equipment
#$%            characteristics table for a specific
#$%            named item.
#$%
#$% Called By: WGLAIR    WGLCRU     WGLSAT
#$%            WGLSHP
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    Variable
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Ron Williams, Dana Wills
#$%            Code taken out of WILD.RAT
#$%
########################################################
 
BBcommon                                             # in the blackboard
 
EqErr$common
literal name
literal     CSTRIP8
integer     LCOMP, litcmp
BBdeclare  ($$TBL, tbl$entry, tbl$pointer,
            ACC$Pointer, SHC$Pointer)
 
#$% if table entry is fixed in length
if (tbl$entry > 0)
   {
    #$% for each table entry
    for (tbl$pointer=tbl$base;
         tbl$pointer<tbl$last;
         tbl$pointer=tbl$pointer+tbl$entry)
       {
        if(lcomp(ibb[tbl$pointer],name) == 0) return   #do a literal compare
       }
   }
else if ($$tbl == $$acc)                        # must be aircraft
   {
    #$% for each aircraft entry
    for (acc$pointer$first;acc$pointer$ok; acc$pointer$next)
       {
        #$% set ACC pointer; if same name, return
        tbl$pointer = acc$pointer
        if(litcmp(Xacc$type$c, name) == 0) return
       }
   }
else if ($$tbl == $$SHC)                        # must be ship/shore
   {
    #$% for each ship/shore entry
    for (SHC$pointer$first;SHC$pointer$ok; SHC$pointer$next)
       {
        #$% set SHC pointer; if same name, return
        tbl$pointer = SHC$pointer
        if(litcmp(XSHC$type$c, name) == 0) return
       }
   }
 
#$% initialize table pointer
tbl$pointer = 0
 
#$% if item not found
if (cflg != $no)
    {
    #$% display error message to user
     call echov ("File: ")
     call echoh (cFile,10)
     call echov ("  Record: ")
     call echoh (Cname,5)
     call echov ("  ")
     call echoh (tbl$name,5)
     call echov (" device ")
     call echohn (name,$$MaxLit)
     call echov (" was not found")
     call echor
    }
 
#$% reset flag
cflg = $yes
 
return
end

 
Subroutine Find_active_RMT (TARGET_UNT_INDEX, # receive target UNT index
                            Rmt$Pointer,      # return RMT pointer
                            IVIEW,            # receive unit view
                            IFOUND,           # return found flag
                            Track_name)       # return track name
 
########################################################
#$%
#$% Purpose:   This subroutine is supposed to find a unit's
#$%            entry in the Remote Detections (BBRMT.inc)
#$%            table. If found, IFOUND = $YES, otherwise $NO
#$%            TARGET_UNT_INDEX = the Unt$Pointer$Index of the unit
#$%            that we are trying to find. IVIEW = the view
#$%            where we are trying to find the detection.
#$%            Rmt$Pointer is returned pointing to the entry
#$%            in the Remote table where it was found.
#$%
#$% Called By: Proc_React   None_found
#$%
#$% Calls:     None
#$%
#$% Tables:    RVU, RMT
#$%
#$% Date:      15 Nov 84
#$%
#$% Author:    TSgt Jim Wise
#$%
########################################################
 
BBcommon
integer iview, lastrmt, ifound, target_unt_index
literal track_name
literal     CSTRIP, A_Track
character   class / $LETA /
BBdeclare  (RVU$Pointer,
            RMT$Pointer, RMT$Lastdettime$F, RMT$Detectiontype$I)
 
 
track_name = $BLANKLIT
 
Rvu$Pointer$to Iview                            #Point to the view that we're
                                                #interested in.
Rmt$Pointer$to XRvu$LastRmtIndx$i               #Get the view's last index in
                                                #the Remote table.
lastrmt = Rmt$Pointer                           #Save the index so that we
                                                #don't have to step thru the
                                                #entire Remote table.
Ifound = $NO                                    #Initialize Ifound.
 
For (Rmt$Pointer$to XRvu$FirstRmtIndx$i;Rmt$Pointer<=lastrmt;Rmt$Pointer$Next)
    {                                           #Step thru the remote table
                                                #entries for this view.
    if (XRmt$InUse$i == $no)                    #Is this entry in use?
        {
        next                                    #No, so move on to the next.
        }
 
    if (XRmt$Detectee$i != target_unt_index)    #Is this the one we are looking
        {                                       #for?
        next                                    #If not, move on to the next.
        }
 
    if(xrmt$ignore$i == $yes) next              # bearing dropped by CORMOD
 
    rmt$LastDetTime$f   = xrmt$LastDetTime$f
 
    if (rmt$LastDetTime$f + max(1.,model$interval) < Game$Time) # Not current track
        {
        next
        }
 
    Rmt$DetectionType$i = XRmt$DetectionType$i  #Get the detection type
 
    if (Rmt$DetectionType$i == $ActiveVisual$code |     #Is it an active visual
        Rmt$DetectionType$i == $ActiveNonVisual$code)   #or nonvisual detection
        {
        Ifound = $yes                           #If yes, say we found it.
        break                                   #And break out of the loop.
        }
    }
 
if (Ifound == $no)
    Rmt$Pointer = 0
else    # build the track name
    {
    track_name = a_track(xRVU$TrackCode$c,class,xRMT$TrackNumber$i) # E2172 dew
    }
 
return
end # of subroutine find_active_RMT

Literal Function Astab_EOIR_Class (IRD$pointer)
 
#---------------------------------------------------------------------------
#   This function returns a consistent Classification for EOIR detections
#
#   DEW 8-May-1992
#---------------------------------------------------------------------------
 
BBcommon
 
literal     D_Type
integer*4   IRD$Pointer, IRD$TargetType$I
integer*4   ACC$Pointer
integer*4   SHC$Pointer
integer*4   UNT$Pointer, UNT$Type$I
integer     I_switch_1
literal     cstrip8
 
Logical Target_Identified, Target_Recognized, Target_Detected
 
if (level$ir == 0)
  {
  IRD$TargetType$I = xIRD$TargetType$I
 
  IF  (IRD$TargetType$I == $Air$Code) ACC$pointer = (xIRD$ACCPntr$I)
  ELSE                                SHC$pointer = (xIRD$SHCPntr$I)
 
  D_Type = xIRD$TargetName$C
 
  Target_Detected   = ( xIrd$Recognized$I  == $No )       #
  Target_Recognized = ( (xIrd$Recognized$I == $Yes) &     # Level of identifi-
                      (xIrd$Identified$I == $No) )      # cation of target
  Target_Identified  = ( xIrd$Identified$I  == $Yes )     #
 
  IF  (Target_Identified)                                 # Highest level
    {
     IF  ( xIrd$Motion$I == $UAV$Fixed )                # Land base
          D_Type      = xIRD$TargetName$C
     ELSE
         {
          IF  ( IRD$TargetType$I == $Air$Code)         # It's a plane !
               D_Type   =  xACC$Type$C                 # Get airplane name
          ELSE                                         # Ship or boat
               D_Type   =  xSHC$Type$C                 # Get vessel type
         }
    }
  ELSE
    {
     IF  (Target_Recognized)                           # Next highest level
         {
          IF  ( xIrd$Motion$I == $UAV$Fixed )          # Land base
                D_Type      = xIRD$TargetName$C
          ELSE
              {
               IF  ( IRD$TargetType$I == $Air$Code )   # It's a plane !
                   {
                    SWITCH ( xACC$Category$I )
                           {
                            Case $Jet$Code  :
                                 D_Type = 'JET'
                            Case $Prop$Code :
                                 D_Type = 'PROP'
                            DEFAULT         :          #$% I.e. helicopter
                                 D_Type = 'HELO'
                           }
                   }
               ELSE                                    # Ship or boat
                    {
                     IF  ( xSHC$SmallBoat$I == $YES )
                         D_Type = 'BOAT'
                     ELSE
                         D_Type = 'SHIP'
                    }
              }
         }
     ELSE                                              # Target merely detected
         D_Type   =  'UNKNOWN'
     }
  }
 
else  # level$ir == 1
  {
  UNT$Pointer$to (xIRD$Target$I)
  UNT$Type$I = xUNT$Type$I
 
  IF  (UNT$Type$I == $Air$Code) ACC$pointer = (xUNT$ACCPntr$I)
  ELSE                          SHC$pointer = (xUNT$SHCPntr$I)
 
  D_Type = xUNT$Name$C
 
  Target_Detected   = ( xIrd$Recognized$I  == $No )       #
  Target_Recognized = ( (xIrd$Recognized$I == $Yes) &     # Level of identifi-
                        (xIrd$Identified$I == $No) )      # cation of target
  Target_Identified  = ( xIrd$Identified$I  == $Yes )     #
 
  IF  (Target_Identified)                                 # Highest level
    {
    D_Type = xUNT$Name$C
    }
  ELSE
    {
    IF  (Target_Recognized)                  # Next highest level
      {
      IF  ( UNT$Type$I == $Air$Code)         # It's a plane !
        D_Type   =  xACC$Type$C              # Get airplane name
      ELSE                                   # Ship or boat
        D_Type   =  xSHC$Type$C              # Get vessel type
      }
    ELSE                                     # Target merely detected
      {
      IF (UNT$Type$I == $Air$Code )          # It's a plane !
        {
        SWITCH ( xACC$Category$I )
          {
          Case $Jet$Code  :
            D_Type = 'JET'
          Case $Prop$Code :
            D_Type = 'PROP'
          DEFAULT         :                  # I.e. helicopter
            D_Type = 'HELO'
          }
        }
      ELSE                                   # Ship or boat
        {
        IF ( xSHC$SmallBoat$I == $YES )
          D_Type = 'BOAT'
        ELSE
          D_Type = 'SHIP'
        }
      }
    }
  }
 
return ( D_Type )
 
end

 
subroutine expord (iview,   # I            # generate list of addressees
                   iaddr,   # L            # given addressee
                   cnta,    # I            # return count of receipents
                   stka,    # I            # array of unit pointers
                   flga,    # I   # collective-flag or MISSION CODE
                   nord)    # I            # order number
 
########################################################
#$%
#$% Purpose:   EXPORD generates a list of unt$pointers
#$%            for a given addressee reference.  The
#$%            reference may be a task number, collec-
#$%            tive group name, or unit name.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     None (other than exho..)
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Note:      Kirk Chang - 4/93 (E1075)
#$%            This routine was previously located in wgop.rat.
#$%
########################################################
 
define ($DEBUGT,#)
BBcommon
 
integer stka[$Max$Taskgroup],cnta,flga, litcmp
integer match_wildcard          # Function to Handle * and % wildcard characters
logical maneuver_order          # Function to determine maneuver order category
literal iaddr                   # iaddr can be 0, task no 5 char name,
                                # or mission LEX code           # jb    4/7/87
literal     cstrip8
integer     msncod, isnumber, iview, ilo, ihi, k, nord,
            unt$pointer, unt$type$i, unt$mission$i, UNT$Hierarchyid$i,
            unt$status$i
 
 
$DEBUGT call echov ("<EXPORD:")
cnta    = 0                                       # initialize
stka[1] = 0
flga    = $no
MSNcod = 0              # jb Initialize for ALLMISSION  4/14/87
 
IF (iaddr == 0)                                # no addressee (plot,label,..).
 {
  continue
 }
 
ELSE IF ($isNumeric(iaddr))                   # task number
 {
    ##-------------- Is this a ALLMISSION order?? 4/7/87  ---------------
  if     (iaddr ==$lex$STRIKE$) MSNcod = $Strike$Code   # 1
  else if(iaddr ==$lex$CAP$)    MSNcod  = $Cap$Code     # 2
  else if(iaddr ==$lex$STRCAP$)MSNcod = $StrikeCap$Code # 4
  else if(iaddr ==$lex$AEW$)    MSNcod = $AEW$Code      # 5
  else if(iaddr ==$lex$ASW$)    MSNcod = $AntiSub$Code  # 6
  else if(iaddr ==$lex$RECONN$) MSNcod = $Reconn$Code   # 7
  else if(iaddr ==$lex$TANKER$) MSNcod =$AirTanker$Code#8
  else if(iaddr ==$lex$RELAY$)  MSNcod = $CommRelay$Code#11
  else if(iaddr ==$lex$SURVEILLANCE$) MSNcod =$Surv$Code#12
  else if(iaddr ==$lex$JAMMER$) MSNcod = $Jam$Code      #13
  else if(iaddr ==$lex$EW$)     MSNcod = $EW$Code       #15
  else if(iaddr ==$lex$STTANKER$) MSNcod=$STtanker$Code #16
  ####
  else if(iaddr ==$lex$SURCAP$)MSNcod =$SurveillanceCap$Code# 3
  else if(iaddr ==$lex$RESCUE$)MSNcod = $Rescue$Code    # 9
  else if(iaddr ==$lex$DECOY$) MSNcod  = $Decoy$Code    #10
  else if(iaddr ==$lex$SEARCH$)MSNcod = $Search$Code    #14
  else if(iaddr ==$lex$AD$)   MSNcod = $AirDefense$Code #30 #air-to-air upgrade
  else if(iaddr ==$lex$AI$)MSNcod =$AirInteraction$Code #31 # 3/23/92
  else if(iaddr ==$lex$ALFT$)   MSNcod = $Airlift$Code #32
  else if(iaddr ==$lex$BAI$)  MSNcod=$BattleFIeldAirInteraction$Code #33
  else if(iaddr ==$lex$CAS$)  MSNcod=$CloseAirSupport$Code #34
  else if(iaddr ==$lex$ESCORT$)   MSNcod = $Escort$Code #35
  else if(iaddr ==$lex$FY$)   MSNcod = $Ferry$Code #36
  else if(iaddr ==$lex$MP$)   MSNcod = $MaritimePatrol$Code #37
  else if(iaddr ==$lex$OCA$)  MSNcod=$OffensiveCounterAir$Code #38
  else if(iaddr ==$lex$SM$)   MSNcod=$SpecialMission$Code #39
  else if(iaddr ==$lex$SW$)   MSNcod=$Sweep$Code #40
  else if(iaddr ==$lex$TASMO$) MSNcod=$TASMO$Code #41
  else if(iaddr ==$lex$TEW$)  MSNcod=$TacElecWar$Code #42
  else if(iaddr ==$lex$WW$)   MSNcod = $WildWeasel$Code #43
 
  if (MSNcod != 0)              # jb    add ALLMISSION   4/7/87
   {
    for (unt$pointer$first;Still_OK(unt);unt$pointer$next)
     {
      unt$type$i = xunt$type$i
 
      #$% if not an addressable platform, or being deleted, SKIP
      if (unt$type$i != $AIR$Code       |
         xunt$status$i == $beingdeleted$code)  NEXT     #
 
      if (xunt$view$i != iview &                # ignore other views
                0    != iview)  NEXT    # (unless wildcard view)
 
      unt$Mission$i = Xunt$Mission$i
      if (unt$Mission$i == MSNcod)
       {
        if (cnta >= $Max$TaskGroup) next
        flga = MSNcod +8 #retrn (MSNcod +8) to identify FOR MISSION orders
        cnta = cnta + 1         # jb   /\               4/15/87
        stka[cnta] = unt$pointer
       }
     }          #  End of loop thru UNT table
   }    #  End if MSNcod != 0
 
  ##------end is this a ALLMISSION order  4/7/87 -------------------
 
  else          # $isnumeric(iaddr)) but NOT a ALLMISSION order
   {
    ilo = iaddr
    if (ilo <= 9999) ilo = ilo * 10  # convert from 4 to 5-digit task numbers
 
    ihi = ilo
 
    k = 1
    repeat
       {
        if (mod(ilo,k*10) != 0) break
 
        k = k * 10
       }
    ihi = ihi + k - 1
 
    for (unt$pointer$first;Still_OK(unt);unt$pointer$next)
       {
        unt$type$i = xunt$type$i
 
        #$% if not an addressable platform, get next entry
        if (unt$type$i != $Surface$Code      &               #17NOV1983
#           unt$type$i != $SurfacewithAC$Code&               #
            unt$type$i != $Air$Code          &               #
            unt$type$i != $Sub$Code          &               #
            unt$type$i != $Shorebase$Code    ) next          #
 
        if (xunt$status$i == $beingdeleted$code)  NEXT  #       6/3/86
 
        if (xunt$view$i != iview &              # ignore other views
                0       != iview) next          # (unless wildcard view)
 
        #$% get heirarchy ID
        UNT$HierarchyId$i = XUNT$HierarchyId$i
        if (UNT$HierarchyId$i >= ilo & UNT$HierarchyId$i <= ihi)
           {
            if (cnta >= $Max$TaskGroup) next
            cnta = cnta + 1
            stka[cnta] = unt$pointer
           }
       }
   }            # End $isnumeric(iaddr)) AND NOT a ALLMISSION order
 }      # End  else if ($isnumeric(iaddr))
 
else    # NAME;  i.e., iaddr != 0 and NOT $isnumeric(addr))..
 {
    #$% for each unit entry
    for (unt$pointer$first;Still_OK(unt);unt$pointer$next)
       {
        if (xunt$view$i != iview &              # ignore other views
                0       != iview)       NEXT    # (unless wildcard view)
 
        unt$status$i = Xunt$status$i
        if (unt$status$i == $beingdeleted$code) # jb X removed 8/30/90
                                        NEXT    # sunk or destroyed
        unt$type$i = xunt$type$i
 
        #$% if not an addressable platform, get next entry
        if (unt$type$i != $Surface$Code       &              #17NOV1983
            unt$type$i != $Air$Code           &              #
            unt$type$i != $Sub$Code           &              #
            unt$type$i !=$CruiseMissile$Code &               # 7/16/85
            unt$type$i != $Shorebase$Code    ) NEXT          #
 
 
        if (match_wildcard( xunt$name$c, iaddr) == $YES)    #JOA 8/1/95E1423
           {
            if (cnta >= $Max$TaskGroup) next
            if (flga != $NO) next  # ignore cause collective name 5/18/87
 
            cnta = cnta + 1
            stka[cnta] = unt$pointer
           }
        else if (Analytical$Run == $YES       &   # If not Training exercise...
                 unt$type$i     == $Air$Code  &   # for Aircraft.....
                 litcmp(xunt$Event$c, iaddr) == 0 )   # check EVENT name
           {
            iview = xunt$view$i
 
            if (cnta >= $Max$TaskGroup) next
 
            cnta = cnta + 1
            stka[cnta] = unt$pointer
           }
        else if (Analytical$Run == $YES       &   # If not Training exercise...
                 Xunt$SuperType$i == $SmallBoat$SuperCode  &   # for Boats...
                 litcmp(xunt$Event$c, iaddr) == 0 )   # check EVENT name
           {
            iview = xunt$view$i
 
            if (cnta >= $Max$TaskGroup) next
 
            cnta = cnta + 1
            stka[cnta] = unt$pointer
           }
        else if (litcmp(xunt$forcename$c, iaddr) == 0)  # check Collective names
           {
            iview = xunt$view$i
 
            if (cnta >= $Max$TaskGroup) next
            if (cnta != 0 & flga == $no) next   # ignore cause std name
 
            flga = $yes
 
            if (xunt$Leader$i == $no)           # is this a leader of group
               {                                #   no....
                if (nord == ALTITUDE$order  |   # drop if manuver order
                    nord == DEPTH$order     |
                    nord == SPEED$order     |
                    nord == SURFACE$order   |
                    maneuver_order(nord))     next
               }
            cnta = cnta + 1
            stka[cnta] = unt$pointer
           }
       }
 }      # End  NAME;  i.e., iaddr != 0 and NOT $isnumeric(addr))..
 
if (nord == CANCEL$order |
    nord == ORDERS$order  )
  {
    if (cnta < 1) cnta = 1              # always at least one.......
  }
 
$DEBUGT call echoi (cnta)
$DEBUGT call echo ($GREAT)
 
return
end

Subroutine EQ_Identify ($$tbl, name, tbl$pointer, ident)
###################################################################
#$%
#$%  Purpose:       EQ_Identify searches any given equipment
#$%                 characteristics table for a specific
#$%                 named item.
#$%
#$%  Called By:     Find_EQ_By_Name     <wgopexp.rat>
#$%
#$%  WARNING:       $$tbl & tbl$entry MAY BE CONSTANTS:  DONT CHANGE!
#$%
#$%  Tables:        Variable
#$%
#$%  Date:          APR 92
#$%
#$%  Author:        Dana Wills
#$%
#$%  Modified:      Susan Miller 4/99 (E2078)
#$%                 Added countermeasure as ident type.
###################################################################
BBcommon                                        # in the blackboard
 
integer     $$tbl, tbl$pointer, ident
literal     name
literal     cstrip8
 
integer     i_match, tbl$entry, i_switch_1
integer     SON$Pointer, BOM$Pointer, TOR$Pointer, MC$Pointer
integer     JAM$Pointer  # JFR 11/27/94 for jecewsi
 
tbl$pointer = 0         # set up default return values
ident       = 0
 
I_Match     = 0
 
if (tbl$len > 0)        # This only works for tables w/Fixed Length Entries
    {
     tbl$entry = tbl$len
     for (tbl$pointer$first; tbl$pointer<tbl$last; tbl$pointer$next)
        {
         if (Xtbl$Name$c != name)                # Match ? (if no, next...)
           next
         I_Match = tbl$pointer                   # Got It!
         break                                   # get out of this loop
        }
    }
 
if (I_Match != 0)       # if there was a name match in the specified table
   {
    tbl$pointer = I_Match
 
    switch ($$tbl)
       {
        case $$rad: ident = $RADAR$CODE
        case $$esm: ident = $ESM$CODE
        case $$jam:
          {
           ident = $JAMMER$CODE       # non jecewsi default - JFR 11/18/94
           if (jecewsi$game == $yes)  # jecewsi - JFR 11/18/94
              {# jecewsi idents from jam$category$i
               jam$pointer = tbl$pointer
               if (xjam$category$i == $RadarJammer$Code)
                 ident = $RadarJammer$Code
               if (xjam$category$i == $RadComJammer$Code)
                 ident = $RadComJammer$Code
               if (xjam$category$i == $CommunicationJammer$Code)
                 ident = $CommunicationJammer$Code
              }
          }
        case $$cjc: ident = $COMMUNICATIONJAMMER$CODE
        case $$sui: ident = $COMMSUITE$CODE
        case $$son:
           {
            son$pointer = tbl$pointer
            if      (Xson$ActiveSonar$I == $YES) ident = $sonar$code
            else if (Xson$AcousticCom$I == $YES) ident = $ACOUSTICCOMM$CODE
            else                                 ident = $passonar$code
           }
        case $$iff: ident = $IFF$Code
        case $$bom:
           {
            bom$pointer = tbl$pointer
            ident = Xbom$type$i
           }
        case $$cmc: ident = $CRUISEMISSILE$CODE
        case $$trp: ident = $SmartTorpedo$CODE
        case $$tor:
           {
            tor$pointer = tbl$pointer
            ident = Xtor$ident$i
           }
        case $$cob: ident = $commbuoy$CODE
        case $$sob: ident = $SONOBUOY$CODE
        case $$gnd: ident = $gnd$CODE
        case $$ctm: ident = $Countermeasure$Code # SMM 4/99 (E2078)
        case $$mc:
           {
            mc$pointer = tbl$pointer
            ident = Xmc$type$i
           }
       }
   }
 
if (ident == 0) tbl$pointer = 0         # if no ident, scrap the pointer
 
return
end

 
Subroutine Lex_to_Mission_Code (lex_value, mission_code)
###################################################################
#$%
#$%  Purpose:       Lex_to_Mission_Code will determine what a
#$%                 mission code translation is from a lexical
#$%                 value.  If the mission is not matched, a value
#$%                 of -1 will be returned in the mission_code.
#$%
#$%  Called By:     Omissn    <wgopord.rat>
#$%                 Feair     <frenter.rat>
#$%
#$%  Tables:        None
#$%
#$%  Date:          April 1995
#$%
#$%  Author:        Carol L. Kropp
#$%                 From Omissn <wgopord.rat> rather than having
#$%                 duplicate code floating around.
#$%
#$%  Modified:      Carol Kropp - 12/96 (E1724)
#$%                 Added new missions ships (COMMERCE, PATROL,
#$%                 SEA_CONTROL and SEALIFT) for ships.
#$%
###################################################################
BBcommon
 
literal  lex_value
integer  mission_code
 
  if      (lex_value == $lex$ad$)           mission_code = $airdefense$code
  else if (lex_value == $lex$ai$)           mission_code = $airinteraction$code
  else if (lex_value == $lex$aew$)          mission_code = $aew$code
  else if (lex_value == $lex$tanker$)       mission_code = $airtanker$code
  else if (lex_value == $lex$alft$)         mission_code = $airlift$code
  else if (lex_value == $lex$amphibious$)   mission_code = $amphib$code
  else if (lex_value == $lex$asw$)          mission_code = $antisub$code
  else if (lex_value == $lex$bai$)          mission_code = $battlefieldairinteraction$code
  else if (lex_value == $lex$cap$)          mission_code = $cap$code
  else if (lex_value == $lex$cas$)          mission_code = $closeairsupport$code
  else if (lex_value == $lex$commerce$)     mission_code = $commerce$code
  else if (lex_value == $lex$decoy$)        mission_code = $decoy$code
  else if (lex_value == $lex$escort$)       mission_code = $escort$code
  else if (lex_value == $lex$ew$)           mission_code = $ew$code
  else if (lex_value == $lex$fy$)           mission_code = $ferry$code
  else if (lex_value == $lex$jammer$)       mission_code = $jam$code
  else if (lex_value == $lex$mp$)           mission_code = $maritimepatrol$code
  else if (lex_value == $lex$none$)         mission_code = $noneassigned$code
  else if (lex_value == $lex$oca$)          mission_code = $offensivecounterair$code
  else if (lex_value == $lex$patrol$)       mission_code = $maritimepatrol$code
  else if (lex_value == $lex$reconn$)       mission_code = $reconn$code
  else if (lex_value == $lex$relay$)        mission_code = $commrelay$code
  else if (lex_value == $lex$rescue$)       mission_code = $rescue$code
  else if (lex_value == $lex$sea_control$)  mission_code = $seacontrol$code
  else if (lex_value == $lex$sealift$)      mission_code = $sealift$code
  else if (lex_value == $lex$search$)       mission_code = $search$code
  else if (lex_value == $lex$sm$)           mission_code = $specialmission$code
  else if (lex_value == $lex$strcap$)       mission_code = $strikecap$code
  else if (lex_value == $lex$strike$)       mission_code = $strike$code
  else if (lex_value == $lex$sttanker$)     mission_code = $sttanker$code
  else if (lex_value == $lex$surcap$)       mission_code = $surveillancecap$code
  else if (lex_value == $lex$surveillance$) mission_code = $surv$code
  else if (lex_value == $lex$sw$)           mission_code = $sweep$code
  else if (lex_value == $lex$tasmo$)        mission_code = $tasmo$code
  else if (lex_value == $lex$tew$)          mission_code = $tacelecwar$code
  else if (lex_value == $lex$ww$)           mission_code = $wildweasel$code
  else                                      mission_code = -1
 
return
end   # end Lex_to_Mission_Code

 
Subroutine Update_NAM_Unt_Index (Platform_Name, New_UNT_Index, status)
##########################################################################
#$%
#$%  Purpose:       Update_NAM_Unt_Index will updated the NAM$UNTIndx$I
#$%                 value for the specified platform name.  If no
#$%                 unit name entry is located which matches the
#$%                 specified name a value status will = -1.
#$%
#$%  Called By:     create_ship <wgopcreate.rat>
#$%
#$%  Tables:        NAM
#$%
#$%  Date:          April 1995
#$%
#$%  Author:        Carol L. Kropp
#$%
##########################################################################
bbcommon
 
literal  Platform_Name
integer  New_UNT_Index, status
 
literal  cstrip8      # literal function for name extract
integer  NAM$Pointer, NAM$UNTIndx$I, litcmp
literal  NAM$Name$C
 
  status = -1
  for (NAM$Pointer$First; NAM$Pointer$Ok; NAM$Pointer$Next)
    {
     if (xNAM$Type$I == $Name$Unit)
      {
       NAM$Name$C = xNAM$Name$C
       if (litcmp(NAM$Name$C, Platform_Name) == 0)
         {
          NAM$UNTIndx$I = New_UNT_Index
          putNAM$UNTIndx$I
          status = 0
          break
         }   # end of if the name matches
      }   # end of if the NAM entry is for a unit name
   }   #end of loop through the NAM table
 
return
end

 
 
Subroutine ckdig (tdig, ickdig)
####################################################################
#
#      Finds a check sum digit
#
####################################################################
implicit none
integer mod, tdig
integer ickdig, itot, idig, ipos, irem
 
itot = 0
 
idig = tdig
 
for (ipos = 1; ipos <= 6; ipos = ipos + 1)
   {
    irem = mod(idig,10)
    itot = itot + irem
    idig = idig/10
   }
 
ickdig = mod(itot,10)
 
return
end

 
Subroutine Get_Characteristic_Pointer (_
                UNT$Pointer,       # in:  unit
                TBL$Pointer)       # out: characteristic ptr of unit
##################################################################
#$%
#$%  Purpose:   Get_Characteristic_Pointer determines the
#$%             characteristics pointer for the unit.
#$%
#$%  Called By: Get_JTMD_UAV_Probs           <jtmd_uav.rat>
#$%             Process_JTMD_UAV_Detections  <jtmd_uav.rat>
#$%             Determine_SOF_UGS_Detection  <jtmd_sof_ugs.rat>
#$%
#$%  Calls:     None
#$%
#$%  Tables:    UNT   ACC   CMC   SHC   TRP   CTM
#$%
#$%  Date:      March 1996 (E1561)
#$%
#$%  Author:    Carol Kropp
#$%
##################################################################
BBCommon
 
integer  UNT$Pointer, TBL$Pointer
 
integer  UNT$Type$I, UNT$SubType$I
 
  TBL$Pointer = $Null$Code
 
  UNT$Type$I = xUNT$Type$I
  if (UNT$Type$I == $Air$Code)
     TBL$Pointer = xUNT$ACCPntr$I
  else if (UNT$Type$I == $CruiseMissile$Code |
		   UNT$Type$I == $SAMissile$Code)
     TBL$Pointer = xUNT$CMCPntr$I
  else if (UNT$Type$I == $Surface$Code | UNT$Type$I == $Shorebase$Code)
     TBL$Pointer = xUNT$SHCPntr$I
  else if (UNT$Type$I == $Sub$Code)
    {
     UNT$SubType$I = xUNT$SubType$I
     if (UNT$SubType$I == $Torpedo$SubCode)
       TBL$Pointer = xUNT$TRPPntr$I
     else if (UNT$SubType$I == $CtrMeasure$SubCode)
       TBL$Pointer = xUNT$CTMPntr$I
     else
       TBL$Pointer = xUNT$SHCPntr$I
    }
  else
    TBL$Pointer = 0
 
return
end

 
subroutine parse_field (_
                       str,         # in, string
                       char,        # in, delimeter char
                       n_field,     # in, field number (starting at 1) to find
                       field,       # out, field
                       field_len,   # out, field length
                       str_pos)     # out, position in input string field found
#################################################################
#$%
#$% Purpose:    Returns a field depending on delimeters and
#$%             field number.
#$%
#$% Called By:
#$%
#$% Calls:      LEN
#$%
#$% Tables:     None
#$%
#$% Date:       July 1996  (E1602)
#$%
#$% Author:     James Allen
#$%
#################################################################
implicit none
 
vaxcharacter*(*)    str
vaxcharacter*(1)    char
integer*4           n_field
vaxcharacter*(*)    field
integer*4           field_len
integer*4           str_pos
 
logical*1           begin_field
integer*4           count
logical*1           delimeter_found
integer*4           field_count
integer*4           length
integer*4           pfield_length
 
  str_pos = 0
  field_len = 0
 
  length = LEN(str)
  pfield_length = LEN(field)
  begin_field = $yes
  field_count = 0
  delimeter_found = $no
 
  #$% loop thru segment until last section is parsed
  FOR ( count = 1; count <= length & field_len < pfield_length; count = count + 1)
    {
     #$% if this is the beginning of a field
     if (str [count:count] != char & begin_field == $yes )
       {
        field_count = field_count + 1
 
        #$% if we have the parsed field
        if ( field_count > n_field )
           {
            return
           }
 
        begin_field = $no
 
        if (field_count == n_field)
           {
            str_pos = count
           }
       }
     else if ( str [count:count] == char )
       {
        delimeter_found = $yes
        begin_field = $yes
       }
 
     if (field_count == n_field &
        str [count:count] != char)
       {
        field_len = field_len + 1
        field[field_len:field_len] = str [count:count]
       }
    }
 
  if (delimeter_found != $yes)
    {
     field_len = 0
    }
 
return
end   # end of parse_field

 
Subroutine Add_NAM_Route_Retasking (_
                retasking_id,     # in:  literal name
                nam_index)        # out: index of NAM entry when name placed
#############################################################################
#$%
#$% Purpose:   Add_NAM_Route_Retasking will add the route retasking id to
#$%            the NAM table, returning the index of the NAM entry.
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:    NAM
#$%
#$% Date:      March 1997  (E1781)
#$%
#$% Author:    Carol Kropp
#$%
#############################################################################
BBcommon
 
literal  retasking_id
integer  nam_index
 
integer  NAM$Pointer, NAM$Type$I
literal  NAM$Name$C
 
  nam_index = 0
  call getnam (NAM$Pointer)
  if (NAM$Pointer$Valid)
    {
     NAM$Type$I = $Name$RouteRetaskingId
     putNAM$Type$I
     NAM$Name$C = retasking_id
     putNAM$Name$C
     nam_index = NAM$Pointer$Index
 
     if (NAM$Used < (nam_index * NAM$Entry))
       NAM$Used = nam_index * NAM$Entry
    }
 
return
end

 
integer function MATCH_WILDCARD (wesnam,   # in:  Name
                                 wespat)   # in:  Pattern
#################################################################
#$%
#$% Purpose:    Match name and pattern. $YES returned if match
#$%
#$% Called By:  expord
#$%
#$% Calls:      none
#$%
#$% Tables:     none
#$%
#$% Date:       December 1997 (E1833)
#$%
#$% Author:     James Allen
#$%
#################################################################
implicit none
 
#declare variables
literal wesnam, wespat
character name1[16],      # string input by user
          name2[16],      # eight character unit or force name
          name3[16],      # normalized form of name 1
          char
 
integer len1,             #length of name 1
        len2,             # length of name 2 ( <= $$MaxName )
        dif               # difference in length between name1 and name2
 
literal name1lit, name2lit, name3lit
equivalence (name1, name1lit)
equivalence (name2, name2lit)
equivalence (name3, name3lit)
 
integer     loc, ispct, i, len3
 
  loc = 0        # Location of asterisk in pattern
  ispct = $NO
  name1lit = wespat
  for(i = 1; i <= $$MaxName; i = i + 1)
    {
     char = name1[i]
     if (char == $SPACE) break
     if (char == $ASTER) loc = i
     if (char == $PERCENT) ispct = $YES
    }
 
  if (loc == 0)         # No pattern should occur a large pct of time
    if (ispct == $NO)
      if (wesnam != wespat) return[ $NO ]
      else                  return[ $YES ]
 
  len1 = i - 1
 
  name2lit = wesnam
  for(i = 1;i <= $$MaxName; i = i + 1)
    {
     if (name2[i] == $SPACE) break
    }
  len2 = i - 1
 
  # change name2 to form containing only letters and percent signs
  match_wildcard = $NO
 
  # test for presence of (single) asterisk
  if (loc == 0)                      # no asterisk
    {
     if(len1 != len2) return    #obvious non-match
     name3lit = name1lit
     len3 = len2
    }
  else                               # asterisk
    {
     if (loc == len1)        # Last char in pattern is *
       {
        name3lit = name1lit
        len3 = len1 - 1
       }
     else
       {
        dif = len2 - len1            # to find out how many % will be needed
        for (i = 1;i <= loc-1;i = i +1)
          name3[i] = name1[i]        # write name1 into name3 up to #
        for (i = loc;i <= loc + dif;i = i + 1)
          name3[i] = $PERCENT        # replace * with 1 + dif %
        for (i = loc + dif + 1;i <= len2;i = i + 1)
          name3[i] = name1[i - dif]  # copy last part of name1
        len3 = len2	
       }
    }
 
  # see if name3 and name2 match except for possible percent sign
  for (i = 1; i <= len3; i = i + 1)
    {
     if(name3[i] == $PERCENT) next
     if(name3[i] != name2[i]) return # leave on 1st unmatched char which is not %
    }
 
  match_wildcard = $yes
 
return
end

 
real function  RadToDMS (radians)
##########################################################################$%
#$%
#$% Purpose:    Convert from radians to DMS (dddmm.ss).
#$%
#$% Called By:  ALSP_Receive_Create
#$%
#$% Calls:      ABS         INT         FLOAT        SIGN
#$%
#$% Tables:     None
#$%
#$% Date:       May 13, 1992
#$%
#$% Author:     Carol L. Kropp
#$%             Reused code from file:  LBSMOV.RAT  routine:  smovlls
#$%
#########################################################################
BBCommon
 
real     radians
 
integer  ideg, imin, isec
real     rdeg, rmin, rsec
real     DMS
 
 rdeg = ABS (radians * $Rad2Deg)         # convert to absolute degrees
 ideg = INT (rdeg)                       # take integer part
 
 rmin = $Deg2Min * (rdeg - FLOAT (ideg)) # convert excess to minutes
 imin = INT (rmin)                       # take integer part
 
 rsec = $Min2Sec * (rmin - FLOAT (imin)) # convert excess to seconds
 isec = INT (rsec + .5)                  # round to nearest whole second
 
 if(isec >= 60)                          # if 60 seconds
   {
    imin = imin + 1                      # make one more minute
    isec = 0                             # and zero seconds
   }
 
 if(imin >= 60)                          # if 60 minutes
   {
    ideg = ideg + 1                      # make one more degree
    imin = 0                             # and zero minutes
   }
 
 DMS = (ideg * 100) + imin + (isec * 0.01)
 
 RadToDMS = SIGN (DMS, radians)
 
return
end

 
Logical function maneuver_order (nord)  # Order code:I:IN
##############################################################################
#$%
#$% Purpose:   Is this a maneuver order
#$%
#$% Called By:  exeord, ocancl
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$% Date:      December 1997 (E1370)
#$%
#$% Author:    James Allen
#$%
#$% Modified:  James Allen 3Jul03 (E2350)
#$%            Addd formation order to list of maneuver orders
##############################################################################
implicit none
# Returns logical true if order code is a maneuver order
 
integer nord
 
  if (nord == ATTACK$order  |
      nord == BARRIER$order |
      nord == BINGO$order   |
      nord == CAPSTATION$order |
      nord == COURSE$order  |
      nord == COURSENOSPEED$order  |
      nord == COVER$order   |
      nord == DETACH$order  |
      nord == FORMATION$order    |
      nord == FUEL$order    |
      nord == HIDE$order    |
      nord == LAND$order    |
      nord == MOOR$order    |
      nord == ORBIT$order   |
      nord == PAIR$order    |
      nord == PERFORM$order |
      nord == PROCEED$order |
      nord == PROCEEDROUTE$order |
      nord == RECALL$order  |
      nord == RECONN$order  |
      nord == RECOVER$order |
      nord == REFUEL$order  |
      nord == REFUELPOS$order  |
      nord == RESUME$order  |
      nord == SEARCH$order  |
      nord == STATION$order |
      nord == STRIKE$order  |
      nord == TAKE$order    |
      nord == TOW$order)
      maneuver_order = .true.
  else
      maneuver_order = .false.
 
return
end

 
Subroutine inoutxy(xp,yp,                       #point being tested
                   n,                           #number of vertices of polygon
                   x ,y ,                       #arrays of vertices of polygon
                   inside)                      #yes/no flag for inside
########################################################
#$%
#$% Purpose:   INOUTXY determines if a point is within a
#$%            polygon.  The vertices are assumed to be
#$%            in a rectilinear coordinate system
#$%
#$% Called By: SORDT1
#$%
#$% Calls:     ANGPI
#$%
#$% Tables:    None
#$%
#$% Date:      SEP 1998 (E2016)
#$%            Code reused from "inout" except $angpi
#$%            call removed.
#$%
#$% Author:    Jim Allen
#$%
########################################################
implicit none
real*4    xp, yp, x0, y0, x1, y1, x2, y2
real*4    ynumer, ydenom
integer*4 n, inside, i, j, newtry, ninter
real x[n],y[n]
 
  x0 = xp
  y0 = yp
 
  repeat
    {
     newtry = $no
     ninter = 0
 
     x2 = x[1] - x0                              #translate x-coordinate
 
     for (i=1;i<=n;i=i+1)
       {
        if (i == n) j = 1
        else        j = i + 1
 
        x1 = x2
        x2 = x[j] - x0                          #translate x-coordinate
 
        if (x1 == 0.0 | x2 == 0.0)              #if a vertex lies on y-axis
          {
           x0 = x0 + 0.1                        #perturb test point slightly
           newtry = $yes
           break
          }
 
        if ((x1 > 0.0 & x2 < 0.0) |             #if side intersects y-axis
            (x1 < 0.0 & x2 > 0.0) )
          {
           y1 = y[i] - y0                      #translate y-coordinates
           y2 = y[j] - y0
 
           if (y1 > 0.0 & y2 > 0.0)            #if both above x-axis
             {
              ninter = ninter + 1             #increment intersection count
             }
           else if (y1 < 0.0 & y2 < 0.0)       #if both below x-axis
             {
              next
             }
           else
             {
              ynumer = x1 * y2 - x2 * y1      #y-intercept is
              ydenom = x1 - x2                #    ynumer/ydenom
 
              if ((ynumer > 0.0 & ydenom > 0.0)|  #if above x-axis
                  (ynumer < 0.0 & ydenom < 0.0))
                {
                 ninter = ninter + 1         #increment intersection count
                }
              else if (ynumer == 0.0)         #if at origin
                {
                 inside = $yes               #target is on boundary
                 return                      #  so count as inside
                }
             }
          }
       }
    } until (newtry == $no)
 
  if (mod(ninter,2) == 1) inside = $yes
  else                    inside = $no
 
return
end

 
integer function VUE_TK_Index (Detection_Type, Unit_Class)
 
########################################################
#$%
#$% Purpose:    VUE_TK_Index determines the VUE$TK$Index
#$%             for a specific Detection type and Unit Class.
#$%             Watch for a returned value of ZERO if error.
#$%
#$%             The VUE table now has an array of 7 (TK)
#$%             track number counters.  This routine allows
#$%             for the consistant pick of the correct index.
#$%
#$% Invoked By: OBTAIN_VIEW_TRACK_NBR
#$%             FIND_FREE_TK_NBRS
#$%
#$% Calls:      n/a
#$%
#$% Tables:     None
#$%
#$% Date:       Nov 1999 (E2172)
#$%
#$% Author:     Dane Wills
#$%
########################################################
implicit none
integer Detection_Type, Unit_Class
 
if      (Detection_Type == $ESM$Code         ) VUE_TK_Index = VUE$TK_Index_ESM
else if (Detection_Type == $PassiveSonar$Code) VUE_TK_Index = VUE$TK_Index_Snr
else if (Detection_Type == $EOIR$Code        ) VUE_TK_Index = VUE$TK_Index_IR
else if (Detection_Type == $OTH$Code         ) VUE_TK_Index = VUE$TK_Index_OTH
else if (Unit_Class     == $Air$Code         ) VUE_TK_Index = VUE$TK_Index_Air
else if (Unit_Class     == $Sub$Code         ) VUE_TK_Index = VUE$TK_Index_Sub
else if (Unit_Class     == $Surface$Code     ) VUE_TK_Index = VUE$TK_Index_Surf
else                                           VUE_TK_Index = 0
 
#----------------------------------------
# If we wanted to allow tracks to shift between classes, we could always
# return the same index.
#
# This did occur at one point in time for low flying aircraft detected by
# surface search radar.  they were tagged as Surface contacts.
#
# Also for Surfaced Submarines as Surface contracts, then changed to
# Sub-surface when the sub submerged, and active sonar picked it up.
#                                       dew
#----------------------------------------
 
return
end

literal function A_Track (code_c,class_c,sequence)
 
########################################################
#$%
#$% Purpose:    A_Track will create a track number (literal)
#$%             for the specified Code/Class/Sequence.
#$%             This routine supports the new (wider) track
#$%             number format, using 3/4/5 digit numerics as
#$%             required.  (E2172)
#$%
#$% Date:       Nov 99
#$%
#$% Author:     Dane Wills
#$%
########################################################
 
BBimplicit
 
literal     code_c
character   Class_c
integer     sequence, kk
integer     wid / 3 /       # Default Width is 3, if it fits
literal     a_track_HC, a_track_wide
 
repeat
    {
    break
    entry A_Track_HC (code_c,class_c,sequence)
    break
 
    #---------------
    entry A_Track_Wide (code_c,class_c,sequence)
    wid = 5
    }
 
if      (sequence > 9999) wid = max(wid,5)
else if (sequence >  999) wid = max(wid,4)
 
kk = 0
a_track = $BLANKLIT
call smov   (code_c,        a_track,KK)
call smov   (class_c,       a_track,KK)
call smoviz (sequence, wid, a_track,KK)
 
wid = 3                 # Restore default for next go-round
 
return
end # A_TRACK
 

Subroutine TRKNUM(ivchar,idtype,iclass,isnmbr,itrack)
 
########################################################################
#$%
#$% Purpose:    TRKNUM determines complete target TRACK NUMBER.
#$%
#$% Called By:  ENGDATA
#$%
#$% Calls:      A_TRACK
#$%
#$% Tables:     None
#$%
#$% Date:       28 JAN 82, (REVISED JULY 1985) for engagement log data
#$%
#$% Author:     F. Jones,   REVISED by RUSS GOLISH
#$%
#$% Modified:   Dane Wills, Gathered from WGMDENG.RAT with mods for
#$%             implementing 3-5 digit track numbers (E2172)
#$%
########################################################################
 
BBimplicit
integer     idtype,     # Detection type
            iclass,     # Target class
            isnmbr,     # Track Sequence number
            ichar2
literal     itrack,     # Generated Track Number
            ivchar,     # View Track Character
            a_track
 
itrack = $BLANKLIT
 
if (ivchar == 0) return
if (isnmbr == 0) return
 
#$% set display character
if      (idtype == $PassiveSonar$code)    ichar2 = $letP
else if (idtype == $Esm$code         )    ichar2 = $letE
else if (iclass == $Air$code         )    ichar2 = $letA
else if (iclass == $CruiseMissile$Code)   ichar2 = $letA
else if (iclass == $Surface$code     )    ichar2 = $letS
else if (iclass == $Sub$code         )    ichar2 = $letU
else                                      ichar2 = $letX  # for debug purposes
 
itrack = a_track(ivchar, ichar2, isnmbr)
 
return
end    # End TRKNUM

include "bbrtl.inc"
 
VMScharacter*9 Function Astab_Class (RMT$Pointer)
 
#---------------------------------------------------------------------------
#   This function returns a common classification for a given RMT Track
#
#   DEW 15-Feb-2000
#---------------------------------------------------------------------------
BBcommon
 
BBdeclare   (RMT$Pointer, RMT$DetectionType$i, rmt$classscore$i,
             rmt$detectee$i, rmt$lastdettype$i, rmt$class$i)
BBdeclare   (Unt2$pointer, unt2$rtlindx$i )
BBdeclare   (rtl$pointer)
VMSCHAR     my_class*arith($$MaxName,+,1), user_flag*1
literal     class, cstrip8
integer     kk
 
rmt$DetectionType$i = xrmt$DetectionType$i
 
kk = 0
user_flag  = ""
class      = $BLANKLIT
call smovhn (xRMT$UserClass$C, $$MaxName, class, kk)
 
if (kk != 0)                            # was there a USER classification?
    {
    user_flag  = "-"
    }
else if (rmt$DetectionType$i == $PassiveSonar$code)
    {
    # The following PassiveSonar Logic acquired from STPASIV.RAT
 
    RMT$ClassScore$I = xRMT$ClassScore$I
    RMT$Detectee$I   = xRMT$Detectee$I
    UNT2$Pointer$To   RMT$Detectee$I
 
    RMT$LastDetType$I = xRMT$LastDetType$I
 
    if      (RMT$LastDetType$I == $Bistatic$Type) class = 'BSTAT'
    else if (RMT$LastDetType$I == $LFASteal$Type) class = 'STEAL'
    else
        {
        UNT2$RTLindx$I = xUNT2$RTLindx$I            # detectee RTL index
        RTL$Pointer$To    UNT2$RTLindx$I
        if (RTL$Pointer$Valid)
            {
            if      (RMT$ClassScore$I == $SonFP1$Code) class = xRTL$Classification1$C
            else if (RMT$ClassScore$I == $SonFP2$Code) class = xRTL$Classification2$C
            else if (RMT$ClassScore$I == $SonFP3$Code) class = xRTL$Classification3$C
            else if (RMT$ClassScore$I == $SonFP4$Code) class = xRTL$Classification4$C
            }
        }
 
    #$% smart torpedo model, addition 5/15/90,reh
    if ( xUNT2$SuperType$i == $Torpedo$SuperCode &
         xUNT2$TrueSpeed$F >= 30.0 )                   class = 'TORP'
 
    if (xUNT2$Type$I == $AIR$CODE)  # either passive detection of aircraft or
        {                           # detection of an active buoy owned by the a/c
         #$% if there is no echo frequency then passive detection of aircraft
         if (xRMT$EchoFreq$I == 0)                     class = 'ACFT'
         else                                          class = 'BUOY'
        }
    } # end if Passive sonar track
 
# The following logic collected from STTRACK.RAT
else if (rmt$DetectionType$i == $ActiveVisual$code |
         rmt$DetectionType$i == $ActiveNonVisual$code  )
    {
    if (Xrmt$classified$i != $NO)               # if classification has been made
        {
        if   (Xrmt$class$i == $air$code)                class = xrmt$accname$c
        else                                            class = xrmt$shcname$c
        }
    else
        {
        rmt$LastDetType$i = Xrmt$LastDetType$i
 
        if      (rmt$LastDetType$i == $MAD$type  )      class = 'MAD'
        else if (rmt$LastDetType$i == $LIDAR$type)      class = 'LIDAR'
        else if (rmt$LastDetType$i == $Bistatic$type)   class = $BLANKLIT
        else if (Xrmt$VisualClass$i == $YES)
            {
            RMT$Class$I = xRMT$Class$I
            if        (rmt$class$i == $air$code)        class = 'AIR'
            else if   (rmt$class$i == $sub$code)        class = 'SUB'
            else                                        class = 'SHIP'
            }
        }
    } # end if not passive
 
#--------------------
# Prepare the final result...
 
my_class = ""
kk = 0
call vmovv  (user_flag,         my_class, kk)
call vmovhn (class, $$MaxName,  my_class, kk)
 
return (my_class)
end

Subroutine GETTGT(itargt,namtgt)
####################################################
#$%
#$% Purpose:   GETTGT get target data for air event status board.
#$%		Latest time of detection governs first; then, priority:
#$%		non-TMA; TMAquality$i =$TMA$GOOD/FAIR/POOR$Code	4/8/86
#$% Called By: AIRENT
#$%
#$% Calls:     TRKNUM
#$%
#$% Tables:    UNT    RVU     RMT
#$%
#$% Date:      25 JAN 82
#$%
#$% Author:    F. Jones
#$%
#$% Revised to select targets on priority basis  jb	4/10/86
#####################################################
BBcommon
StatusCommon
 
Literal namtgt, RVU$TrackCode$C, CSTRIP, CSTRIP8    # jb  E2145   2/9/00
real    LtstTMAtime    # Game Min. For latest TMA so far... 4/10/86
real    latest, RMT$LastDetTime$F                   # jb  E2145   2/9/00
Integer itargt,i_code, ifirst,ilast, latept,        # jb  E2145   2/9/00
        RMT$Pointer,RMT$Class$I,RMT$TrackNumber$I,  # jb  E2145   2/9/00
        rmt$TMAquality$i, RMT$DetectionType$I,      # jb  E2145   2/9/00
        UNT$Pointer, RVU$Pointer                    # jb  E2145   2/9/00
 
integer i_bestTMA # For lcl$Pointer for the best-quality TMA so- 4/9/86
integer i_bestQUAL	# For best TMA QUALity so far..		 4/9/86
 
 
i_bestTMA   = 0	 # Best TMA, in case no acceptable active track	 4/9/86
i_bestQUAL  = 0	 # 0 for POOR; 1 for FAIR; 2 for GOOD		 4/9/86
LtstTMAtime = 0.0  # Latest game-minute for TMA contact		 4/10/86
 
namtgt = $BLANKLIT
 
#$% if CONTROL, return
if (iview == $neutral$view) return
 
#$% set UNT pointer to target
UNT$pointer$to itargt
 
#$% if shorebase
if (xUNT$type$i == $shorebase$code)
   {
    #$% get name
    namtgt = xUNT$Name$c
    return
   }
 
#$% set view pointer
RVU$pointer$to iview
 
#$% set RMT pointer to beginning, save start of RMT table
rmt$pointer$to xRVU$FirstRmtIndx$i
ifirst = rmt$pointer
 
#$% set RMT pointer to end, save end of RMT table
rmt$pointer$to xRVU$LastRmtIndx$i
ilast = rmt$pointer
 
#$% initialize variables
latest = 0.0
latept = 0
 
#$% search RMT table
for (rmt$pointer=ifirst; rmt$pointer<=ilast ; rmt$pointer$next)
   {
    #$% if slot not in use, get next slot
    if (Xrmt$InUse$i    == $no) next
    if (xRMT$Detector$I == $no) next
 
    #$% if detectee not target, get next slot
    if (Xrmt$Detectee$i != itargt) next
 
    rmt$DetectionType$i = xrmt$DetectionType$i
    RMT$LastDetTime$F	= xRMT$LastDetTime$F
 
#   if (rmt$DetectionType$i != $ActiveVisual$code    &	#	4/10/86
#   	rmt$DetectionType$i != $ActiveNonVisual$code )	#	4/10/86
##--------------------------------------------------------------------
## Priorities: non-TMA; TMAquality$i =$TMA$GOOD/FAIR/POOR$Code	4/8/86
    if( rmt$DetectionType$i == $PassiveSonar$code )
     {
      rmt$TMAquality$i  = Xrmt$TMAquality$i		#	4/8/86
      if( rmt$TMAquality$i  >  i_bestQUAL   &		#	4/8/86
    	  RMT$LastDetTime$F >= LtstTMAtime     )	#	4/10/86
    	    {			     # Save the lcl pointer for
    	     i_bestTMA =  rmt$Pointer # the best-quality at the	4/8/86
    	     i_bestQUAL = rmt$TMAquality$i	# latest	4/9/86
    	     LtstTMAtime = RMT$LastDetTime$F	#   time...	4/10/86
    	    }   	# --but keep looking for an
      NEXT    	   	#    acceptable active track.	5/26/87
     }
##--------------------------------------------------------------------
 
    #$% if not most recent, get next slot
    if (RMT$LastDetTime$F <= latest) next
 
    #$% save most recent detection time and pointer
    latest = RMT$LastDetTime$F
    latept = rmt$pointer
 
   }   #$% end for
 
 
if(latept == 0) latept = i_bestTMA  # If no ACTIVE, use best TMA  4/10/86
 
if (latept == 0)
   {
    #$% clear target name
    namtgt = 0
    return
   }
 
#$% set RMT pointer to target
rmt$pointer = latept
 
if (xRMT$TmaFlag$I == YES & xrmt$DetectionType$i == $PassiveSonar$Code)
    {
    i_code = $PassiveSonar$Code
    }
else
    {
    i_code = $ActiveNonVisual$Code
    }
 
RVU$TrackCode$c   = xRVU$TrackCode$c
rmt$Class$i       = xrmt$Class$i
rmt$TrackNumber$i = xrmt$TrackNumber$i
 
call TRKNUM(RVU$TrackCode$c,
    	    i_code,
    	    rmt$Class$i,
    	    rmt$TrackNumber$i,
    	    namtgt)
 
return
end

integer function find_agd_slot (key,stop_at_zero)
bbcommon
integer key
logical stop_at_zero
integer i, k
bbdeclare (agd$pointer, agd$alspid$i)
 
i = 1 + mod(key, 99991)     # Hash function should use a prime number as long as
                            # it is less than number than slots
k = i                       # hold initial slot
repeat                      # find key or empty slot
{
    agd$pointer$to i
    agd$ALSPID$i = Xagd$ALSPID$i
    if ( (stop_at_zero==$YES & agd$ALSPID$i == 0) | agd$ALSPID$i == key) break
    i = i + 1
    if (i > agd$slots) i = 1
    if (i == k)
    {
        i = 0
        break
    }
}
 
return (i)      # 0 means table full
end
 

Subroutine polygon_overlap(_
                 n1,                            #number of vertices of polygon1
                 x1,y1,                         #arrays of vertices of polygon1
                 n2,                            #number of vertices of polygon1
                 x2,y2,                         #arrays of vertices of polygon1
                 overlap)                       #yes/no flag for overlap
########################################################
#$%
#$% Purpose:   Polygon_overlap determines if two polygons overlap on earth
#$%            surface.
#$%
#$%
#$% Called By: mark route Q
#$%
#$% Calls:     ANGPI
#$%
#$% Tables:    None
#$%
#$% Date:      March 2007
#$%
#$% Author:    James O. Allen
#$%
########################################################
implicit none
integer*4  n1, n2, overlap
real*4 	   x1[n1],y1[n1]
real*4 	   x2[n2],y2[n2]
 
integer    inside, i, j
integer    intersect, superimposed
 
overlap = $no
#----------------------------------------------------------------------------
# If vector endpoints of first polygon are within second polygon, polygons overlap
inside = $no
for (i=1; i<=n1; i=i+1)       #
{
    call inout (x1[i], y1[i], n2, x2, y2, inside)
    if (inside == $yes) break
}
 
if (inside == $yes)
{
    overlap = $yes
    return
}
for (i=1; i<=n2; i=i+1)       #
{
    call inout (x2[i], y2[i], n1, x1, y1, inside)
    if (inside == $yes) break
}
if (inside == $yes)
{
    overlap = $yes
    return
}
#----------------------------------------------------------------------------
# If vectors intersect or are superimposed, polygons overlap
intersect = $no
for (i=1; i<n1; i=i+1)       #
{
    for (j=1; j<n2; j=j+1)
    {
        call vector_intersect(x1[i], y1[i], x2[j], y2[j], intersect)
        if (intersect == $yes) break 2
 
        call vector_superimposed(x1[i], y1[i], x2[j], y2[j], superimposed)
        if (superimposed == $yes) break 2
    }
}
 
if (intersect == $yes)
    overlap = $yes
if (superimposed == $yes)
    overlap = $yes
 
return
end

Subroutine vector_intersect(_
                            x1,
                            y1,
                            x2,
                            y2,
                            intersect)
implicit none
integer*4  intersect
real*4 	   x1[10],y1[10]
real*4 	   x2[10],y2[10]
 
real a,b,c,d,det,t0,p0
 
intersect = $no
 
a = x1[2] - x1[1]
b = x2[1] - x2[2]
c = y1[2] - y1[1]
d = y2[1] - y2[2]
 
det = (a * d) - (c * b)
 
if (det != 0.0)
{
    t0 = ((y2[1]-y2[2]) * (x2[1]-x1[1]) - ((x2[1]-x2[2]) * (y2[1]-y1[1]))) / det
    p0 = ((x1[2]-x1[1]) * (y2[1]-y1[1]) - ((y1[2]-y1[2]) * (x2[1]-x1[1]))) / det
}
 
# if det != 0 and 0 <= (t0, p0) <= 1.0 then vectors intersect
if (det != 0.0)
{
    if ( 0.0 < t0 & t0 < 1.0)
    {
        if (0.0 < p0 & p0 < 1.0)
            intersect = $yes
    }
}
 
return
end

Subroutine vector_superimposed(_
                               x1,
                               y1,
                               x2,
                               y2,
                               superimposed)
implicit none
integer*4  superimposed, colinear
real*4 	   x1[10],y1[10]
real*4 	   x2[10],y2[10]
 
real       vcp, p1, p2
 
superimposed = $no
colinear = $no
#  vector is colinear if vcp = 0
vcp = (y1[1] - y2[1]) * (x2[2] - x2[1]) - (x1[1] - x2[1]) * (y2[2] - y2[1])
 
if (vcp == 0.0)
    colinear = $yes
 
if (colinear == $yes)
{
    if (x2[1] == x2[2])
    {
        if (y2[1] == y2[2]) return        # avoid divide by zero
        p1 = (y1[1] - y2[2]) / (y2[1] - y2[2])
        p2 = (y1[2] - y2[2]) / (y2[1] - y2[2])
    }
    else
    {
        if (x2[1] == x2[2]) return        # avoid divide by zero
        p1 = (x1[1] - x2[2]) / (x2[1] - x2[2])
        p2 = (x1[2] - x2[2]) / (x2[1] - x2[2])
    }
 
    # if 0 < p1 or p2 < 1, then vectors are superimposed
    if (0.0 < p1 & p2 < 1.0)
        superimposed = $yes
 
}
 
return
end
