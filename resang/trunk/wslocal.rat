# WSLOCAL.RAT - Process commands local to the station

include "ptcolor.inc"         
include "bbalz.inc"         
include "bbctl.inc"         
include "bbboy.inc"         
include "bbcode.inc"         
include "bbunt.inc"         
include "bbsta.inc"         
include "bbsbi.inc"         
include "bbsat.inc"         
include "bbrmt.inc"         
include "bbplc.inc"         
include "bbpim.inc"         
include "bbown.inc"         
include "bbnuc.inc"         
include "bbmrk.inc"         
include "bbbmk.inc"         
include "bblin.inc"                     # jb    11/14/89
include "orders.inc"         
#include "csf.inc"         
include "bbrte.inc"         
include "bbprt.inc"         
include "ascii.inc"         
include "bbrth.inc"         
include "wgmdrot.inc"         
#include "bbler.inc"         
include "bbswb.inc"         
include "bbacc.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbshc.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbaml.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbbml.inc"                # cl 6/18/91, for DISPLAY UNIT command
include "bbspa.inc"                # clk 10/91 for Submarine Patrol Areas (SPAs)
include "bbpsp.inc"                # clk 10/91 for plotting SPAs
include "bbpat.inc"                # clk 9/92  for display reporting policy
include "bbrvu.inc"                # clk 9/92  for display reporting policy
include "bbcmc.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbctm.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbhfd.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbird.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbsos.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbssr.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbswd.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbtrp.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbvue.inc"                # clk 12/1/92 for DISPLAY TRACK
include "bbnrt.inc"                # SMM 12/92 PER #E1101
include "bbrad.inc"                # bmb 3/30/93 for SUPPRESS command (H1082)
include "bbmc.inc"                 # clk 9/95 (E1456) - PLOT/ERASE GROUND SAM
include "bbagd.inc"                # clk 12/95 (E1456/E1530) - DISPLAY ALSPSTAT   
include "bbmfd.inc"         
include "bbswp.inc"         
include "plplay.inc"          

define (BBImplicit, Implicit None) # MJC 4/19/2000 - (E2145)
define($no$vue,)                   # clk 4/96 - (E1467)  This define needed for including
include "wixprint.rin"             # wixprint.rin for DISPLAY FUEL command.


subroutine pl_exeord (STA$pointer,nord,nargs,args)      ## 3 Aug TDB 

#$% Modified:  Jim Allen - 2/98 (E1864)
#$%            Added argument to PL_xcir to return the PLC table entry
#$%            index, used for Improved Cruise Missile Model, so the
#$%            CM planning knows the location.

bbcommon

BBDeclare  (sta$pointer,
            sta$plotmap$I,
            sta$geodisp$C)                # MJC 7/25/2000
integer nargs, ista, nord, indx           # MJC 4/20/2000
integer ierr, iflag, igbyte               # MJC 4/20/2000
literal cstrip8                           # MJC 4/20/2000
literal args[nargs]
integer Game_DTG

ista = STA$Pointer$Index        ## Changed VUE to STA, iview to ista 3 Aug TDB

if      (args[1] == $lex$Show$)     call PL_oshow (nord,STA$pointer,nargs,args)
else if (args[1] == $lex$Bearing$)  call PL_rbto  (nord,ista,       nargs,args)
else if (args[1] == $lex$Delete$)   call PL_xcir  (nord,ista,  nargs,args,indx)
else if (args[1] == $lex$Define$)   call PL_xcir  (nord,ista,  nargs,args,indx)
else if (nord == DisplayControlInfo$order)  call xprint   (args[2], ierr)    # PER E1232 -- clf 1/25/94
else if (args[1] == $lex$Envelope$) call PL_envel (nord,ista,       nargs,args)
else if (args[1] == $lex$Label$)    call PL_label (nord,ista,       nargs,args)
#else if (args[1] == $lex$LOB$)     call PL_lob   (nord,ista,       nargs,args)
#else if (args[1] == $lex$Mark$)     call PL_marku (nord,ista,       nargs,args)
#else if (args[1] == $lex$Unmark$)   call PL_marku (nord,ista,       nargs,args)
#else if (args[1] == $lex$Place$)    call PL_xcir  (nord,ista,   nargs,args,indx)
else if (args[1] == $lex$Color$)    call PL_xcir  (nord,ista,   nargs,args,indx)
else if (args[1] == $lex$Plot$)     call PL_plot  (nord,ista,       nargs,args)
else if (args[1] == $lex$Erase$)    call PL_plot  (nord,ista,       nargs,args)
else if (args[1] == $lex$Radius$)   call PL_center(nord,ista,       nargs,args)
else if (args[1] == $lex$Shift$)    call PL_center(nord,ista,       nargs,args)
else if (args[1] == $lex$Center$)   call PL_center(nord,ista,       nargs,args)
else if (nord == DisplayPlayerInfo$order)  call PL_Disply(nord,sta$pointer,nargs,args)
else if (args[1] == $lex$Print$)    call PL_pASTAB(nord,ista,       nargs,args)
else if (args[1] == $lex$CPA$)      call PL_cpa   (nord,ista,       nargs,args)
else if (args[1] == $lex$Suppress$)   call suppress_emit (ista, nargs, args) # bmb 3/93 (H1082)
else if (args[1] == $lex$Unsuppress$) call unsuppress_emit (ista, nargs, args) # bmb 3/93 (H1082)
else if (nord == ORDERS$order) call Pl_orders (nord,sta$pointer,nargs,args)    # khc 4/93 (E1075)
else if (nord == sitrep$order) call ositrep (nord, sta$pointer, nargs,args)    # av  8/96 (E1722)
#else if (args[1] == $lex$SYMBOLS$)    call PL_symbols(nord,ista,nargs,args)    # joa 7/96 (E1602) 
else if (args[1] == $lex$PLAN$) call PL_PlanFire(nord,ista,nargs,args)         # joa 2/98 (E1864)
else 
    {
    call echov ("Sorry, the command was not understood.")
    call echor
    return
    }

call echov  ("(")
call echoiz (Game_DTG(GAME$TIME), 6)
call echov  (") Order executed.")
call echor

if (args[1] == $lex$Show$ | 
    ( args[1] == $lex$Print$ & args[2] == $lex$Astab$ ) )
    {
	putSTA$AstabWakeup$i ($YES)
    }
else if (args[1] == $lex$Label$  | 
         args[1] == $lex$Mark$   |
         args[1] == $lex$UnMark$ |  
         args[1] == $lex$Color$  |  
         args[1] == $lex$Plot$   | 
         args[1] == $lex$Erase$  |  
         args[1] == $lex$Radius$ |  
         args[1] == $lex$Center$ | 
         args[1] == $lex$Shift$  )
	{
	putSTA$PlotWakeup$i ($YES)						# cycle Plot
    }

return
end


Subroutine PL_Disply(nord, STA$Pointer, nargs, args) 

BBcommon

integer*4       nord, sta$pointer, nargs
literal         args[ARB]
integer*4       iview
# string msg1 "      ROTHR Base not found.    "

iview = Xsta$View$i

if (args[2] == $lex$PLOT$)
    {
    call PL_Disply_plot (nord, STA$Pointer, nargs, args)        # DEW 2/92
    }
else if (args[2] == $Lex$ASTAB$)
    {
    call PL_Disply_astab (nord, STA$Pointer, nargs, args)       # DEW 2/92
    } # end display astab

#______________________________________________________________________
# DISPLAY PIM <name>    (or DISPLAY PIM ALL)

else if (args[2] == $Lex$PIM$)
    {
    call PL_Disply_PIM (nord, STA$Pointer, nargs, args)       # DEW 2/92
    }

#______________________________________________________________________
# DISPLAY SWABS (region) <number> (information)

else if (args[2] == $Lex$SWABS$)
    {
    call PL_Disply_SWABS (nord, STA$Pointer, nargs, args)       # DEW 2/92
    } # end if $lex$SWABS

#______________________________________________________________________
# DISPLAY POLYGON/LIN <name>    (or DISPLAY POLYGON/LIN ALL)

else if (args[2] == $Lex$LINE$ | args[2] == $Lex$POLYGON$ )
    {
    call PL_Disply_Poly_Line (nord, STA$Pointer, nargs, args) 
    }

#______________________________________________________________________
# Display Circles or Ellipses

else if ( (args[2] == $Lex$CIRCLE$) | (args[2] == $Lex$RECTANGLE$))
    {
    call PL_Disply_Circle_Ell (nord, STA$Pointer, nargs, args) 
    }

#______________________________________________________________________
# display marked tracks and bearings, and xmarks

else if (args[2] == $Lex$MARK$)
    {
    call PL_Disply_Mark (nord, STA$Pointer, nargs, args) 
    }

#______________________________________________________________________
# display DIR information (ROTHR)

else if (args[2] == $lex$DIRS$)
    {
    call PL_Disply_DIRS (nord, STA$Pointer, nargs, args) 
    }

#______________________________________________________________________
# display Unit information

else if (args[2] == $lex$UNIT$)
    {
    call PL_Disply_Unit (nord, STA$Pointer, nargs, args) 
    }
else if (args[2] == $lex$OTG$)
    {
    call PL_Disply_OTG (nord, STA$Pointer, nargs, args) 
    }
else if (args[2] == $lex$TRACK$)    # clk 11/30/92 - E1020
    {
    call PL_Disply_TRACK (nord, STA$Pointer, nargs, args)
    }
else if (args[2] == $lex$ALSP$)
    {
    call PL_Disply_ALSP (nord, STA$Pointer, nargs, args)
    }
else if (args[2] == $lex$REPORT$)       # clk 9/92
    call PL_Disply_Rptpol (nord, STA$Pointer, nargs, args) 

else 
    {
    call echov ("Sorry, that command is not enabled.")
    call echor
    }


return
end # PL_Disply


Subroutine PL_Disply_plot (nord, STA$Pointer, nargs, args) 

#$% Modified:  Jim Allen - 2/98 (E1864)
#$%            The PIM table index is stored in the STA table,
#$%            rather than the PIM name - changed usage.

BBcommon

BBDeclare  (STA$Plotesm$I, STA$Plotsonar$I,
            STA$Satindx$I, SAT$Pointer,
            STA$Plotall$I, STA$Plotenemy$I,
            STA$Rothrorder$I, STA$Rothrindx$I,
            STA$Plotunknown$I, STA$Plotfriendly$I,
            STA$Plotneutral$I, STA$Plotspeed$I)             # MJC 7/25/2000
BBDeclare  (STA$Plotpimindx$I, STA$Plotsonarreg$I,
            STA$Plotsosus$I, STA$Plotlidar$I,
            STA$Plotswabs$I, STA$Plotl16forceindx$I,
            STA$Plotl16enemy$I, STA$Plotl16friendly$I,
            STA$Plotsourcetype$I, STA$Plotsource$I,
            STA$Plotl16neutral$I, STA$Plotl16unknown$I)
BBDeclare  (STA$Envelopesource$I,
            STA$Bearingsource$I, STA$Altbearingsource$I,
            STA$Rothrairsurfpca$I, STA$Rothrdaynightpca$I,
            STA$Firstlat$F, STA$Lastlat$F)                  # MJC 7/25/2000
BBDeclare  (UNT$Pointer, OWN$Pointer,
            RMT$Pointer, RTH$Pointer)                       # MJC 7/25/2000
BBDeclare  (sta$PlotGhostGround$i,sta$PlotGhostGroundSize$I, sta$PlotGhostSide$i)
literal   CSTRIP8                                           # MJC 4/21/2000
integer   IPNT, IANY, ILLAT, IFLAT                          # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
character work[ARB], cflat[ARB], cllat[ARB]
integer*4 iview

iview = Xsta$View$i

#______________________________________________________________________
# Center Point & Radius    polyg pgn lin

call echov ("Center ")

sta$PlotSourceType$i = Xsta$PlotSourceType$i 
sta$PlotSource$i     = Xsta$PlotSource$i     

if (sta$PlotSourceType$i == $null$code)
    {
    call echov ("Position ")

    ipnt = 0
    call smovlls (Xsta$latitude$f, "NS",work,ipnt)
    call echoh (work,ipnt)

    call echov (" ")

    ipnt = 0
    call smovlls (Xsta$longitude$f,"EW",work,ipnt)
    call echoh (work,ipnt)
    }
else if (sta$PlotSourceType$i == $True$code)
    {
    call echov ("Force (true) ")

    unt$pointer$to sta$PlotSource$i

    call echohn (Xunt$name$c,$$MaxLit)
    }
else if (sta$PlotSourceType$i == $OwnForce$code)
    {
    call echov ("Force ")
    own$pointer$to sta$PlotSource$i

    unt$pointer$to Xown$Unit$i

    call echohn (Xunt$name$c,$$MaxLit)
    }
else if (sta$PlotSourceType$i == $OtherForce$code)
    {
    call echov ("Track ")

    rmt$pointer$to sta$PlotSource$i

    call echov ("XX")                     # expand these ?????
    call echoi (Xrmt$TrackNumber$i)
    }

call echov ("  Radius ")
call echoi (Xsta$PlotRadius$i)

#______________________________________________________________________
# Labels....

call echor 
call echov ("Label ")

if (Xsta$Label$i == NO) call echov ("Off")
else                    call echov ("All")

#______________________________________________________________________
# Selection....

sta$PlotAll$i = Xsta$PlotAll$i 

if (sta$PlotAll$i == NO)
    {
    call echor
    call echov ("Erase ALL")
    }
else if (sta$PlotAll$i == $Hi_sta$PlotAll$i)
    {
    call echor
    call echov ("Plot ALL")
    }
else     
    {
    #____________________________________________________________
    sta$PlotEnemy$i = Xsta$PlotEnemy$i 

    if (sta$PlotEnemy$i == $Hi_sta$PlotEnemy$i)
        {           
        call echor
        call echov ("Plot Enemy")
        }
    else if (sta$PlotEnemy$i != NO)
        {
        call echor
        call echov ("Plot ")

        if (Xsta$PlotEnemyAir$i  == YES) call echov ("Enemy-Air ")
        if (Xsta$PlotEnemySurf$i != NO ) 
            {
            call echov ("Enemy-Surf ")
            if (Xsta$PlotEnemyBoat$i == NO ) call echov ("(no boats) ")
            }
        if (Xsta$PlotEnemySub$i  == YES) call echov ("Enemy-Sub ")
        if (Xsta$PlotEnemyBase$i == YES) call echov ("Enemy-Base")
        }

    #____________________________________________________________
    sta$PlotUnknown$i = Xsta$PlotUnknown$i 

    if (sta$PlotUnknown$i == $Hi_sta$PlotUnknown$i)
        {           
        call echor
        call echov ("Plot Unknown")
        }
    else if (sta$PlotUnknown$i != NO)
        {
        call echor
        call echov ("Plot ")

        if (Xsta$PlotUnknownAir$i  == YES) call echov ("Unknown-Air ")
        if (Xsta$PlotUnknownSurf$i != NO ) 
            {
            call echov ("Unknown-Surf ")
            if (Xsta$PlotUnknownBoat$i == NO ) call echov ("(no boats) ")
            }
        if (Xsta$PlotUnknownSub$i  == YES) call echov ("Unknown-Sub ")
        if (Xsta$PlotUnknownBase$i == YES) call echov ("Unknown-Base")
        }

    #____________________________________________________________
    sta$PlotFriendly$i = Xsta$PlotFriendly$i 

    if (sta$PlotFriendly$i == $Hi_sta$PlotFriendly$i)
        {           
        call echor
        call echov ("Plot Friendly")
        }
    else if (sta$PlotFriendly$i != NO)
        {
        call echor
        call echov ("Plot ")

        if (Xsta$PlotFriendlyAir$i  == YES) call echov("Friendly-Air ")
        if (Xsta$PlotFriendlySurf$i != NO ) 
            {
            call echov("Friendly-Surf ")
            if (Xsta$PlotFriendlyBoat$i == NO ) call echov ("(no boats) ")
            }
        if (Xsta$PlotFriendlySub$i  == YES) call echov("Friendly-Sub ")
        if (Xsta$PlotFriendlyBase$i == YES) call echov("Friendly-Base")
        }

    #____________________________________________________________
    sta$PlotNeutral$i = Xsta$PlotNeutral$i 

    if (sta$PlotNeutral$i == $Hi_sta$PlotNeutral$i)
        {           
        call echor
        call echov ("Plot Neutral")
        }
    else if (sta$PlotNeutral$i != NO)
        {
        call echor
        call echov ("Plot ")

        if (Xsta$PlotNeutralAir$i  == YES) call echov ("Neutral-Air ")
        if (Xsta$PlotNeutralSurf$i != NO ) 
            {
            call echov ("Neutral-Surf ")
            if (Xsta$PlotNeutralBoat$i == NO ) call echov ("(no boats) ")
            }
        if (Xsta$PlotNeutralSub$i  == YES) call echov ("Neutral-Sub ")
        if (Xsta$PlotNeutralBase$i == YES) call echov ("Neutral-Base")
        }
    }

#____________________________________________________________
sta$PlotSpeed$i = Xsta$PlotSpeed$i 

if (sta$PlotSpeed$i != NO)
    {
    call echor
    call echov ("Plot")

    if (sta$PlotSpeed$i != $Hi_sta$PlotSpeed$i)
        {           
        if (Xsta$PlotSpeedAir$i == YES)  call echov (" AIR")

        if (Xsta$PlotSpeedShip$i == YES) call echov (" SHIP")
        }

    call echov (" Speed vectors")
    }
#___________________________________________________________

if (Xsta$PlotTrackHistory$i != NO)
    {
    call echor
    call echov ("Plot Track History")
    }
#____________________________________________________________

if (Xsta$PlotEmiArea$i != NO)
    {
    call echor
    call echov ("Plot EMI (affected areas for xsect of) ")
    call echoi (xSTA$EmiTcs$I)
    }
#____________________________________________________________

sta$PlotGhostGroundSize$I = Xsta$PlotGhostGroundSize$I
if (sta$PlotGhostGroundSize$I == $Hi_sta$PlotGhostGroundSize$i)
	{
	call echor
	call echov ("Plot Ghost Ground Size")
	}
else if (sta$PlotGhostGroundSize$I == NO)
	{
	call echor
	call echov ("Erase Ghost Ground Size")
	}
else
{
	call echor	
	if (Xsta$PlotGhostGroundArmy$I      == YES) call echov ("Army ")
	if (Xsta$PlotGhostGroundArmyGroup$I == YES) call echov ("ArmyGroup ")
	if (Xsta$PlotGhostGroundBattalion$I == YES) call echov ("Battalion ")
	if (Xsta$PlotGhostGroundBrigade$I   == YES) call echov ("Brigade ")
	if (Xsta$PlotGhostGroundCompany$I   == YES) call echov ("Company ")
	if (Xsta$PlotGhostGroundCorps$I     == YES) call echov ("Corps ")
	if (Xsta$PlotGhostGroundDivision$I  == YES) call echov ("Division ")
	if (Xsta$PlotGhostGroundPlatoon$I   == YES) call echov ("Platoon ")
	if (Xsta$PlotGhostGroundRegiment$I  == YES) call echov ("Regiment ")
	if (Xsta$PlotGhostGroundSection$I   == YES) call echov ("Section ")
	if (Xsta$PlotGhostGroundSquad$I     == YES) call echov ("Squad ")
	if (Xsta$PlotGhostGroundTeam$I      == YES) call echov ("Team ")
}
#____________________________________________________________

sta$PlotGhostSide$i = Xsta$PlotGhostSide$i
if (sta$PlotGhostSide$i == $Hi_sta$PlotGhostSide$i)
	{
    call echor
    call echov ("Plot Ghost Side")
	}
else if (sta$PlotGhostSide$i == NO)
	{
    call echor
    call echov ("Erase Ghost Side")
	}
else
	{
	call echor
    call echov ("Plot Ghost Side ")
	if (Xsta$PlotGhostBlue$I == YES) call echov ("Blue ")
	if (Xsta$PlotGhostOrange$I == YES) call echov ("Orange ")
	if (Xsta$PlotGhostNeutral$I == YES) call echov ("Neutral ")
	}
#____________________________________________________________

if (Xsta$PlotGhostUnits1$I != NO | Xsta$PlotGhostAir$i != NO)
    {
    call echor
    call echov ("Plot Ghost ")

	if (Xsta$PlotGhostSubsurface$I  == YES) call echov ("Subsurface ")
	if (Xsta$PlotGhostSurface$I     == YES) call echov ("Surface ") 
	if (Xsta$PlotGroundSAMRanges$I == YES) call echov ("SAM Range ")  
	if (Xsta$PlotGhostMinefield$I   == YES) call echov ("Minefield ")   
	if (Xsta$PlotGhostSweepArea$I   == YES) call echov ("SweepArea ")
	if (Xsta$PlotGhostAir$i         == YES) call echov ("Air ")
    }

#____________________________________________________________

sta$PlotGhostGround$i = Xsta$PlotGhostGround$i 

if (sta$PlotGhostGround$i == $Hi_sta$PlotGhostGround$i)
    {           
    call echor
    call echov ("Plot Ghost Ground")
    }
else if (sta$PlotNeutral$i == NO)
    {           
    call echor
    call echov ("Erase Ghost Ground")
    }
else
    {
       call echor
       call echov ("Plot Ghost Ground ")
	   if (XSTA$PlotGhostGroundBase$I    == YES) call echov ("Base ")
	   if (XSTA$PlotGhostGroundRadar$I   == YES) call echov ("RADAR ")
	   if (XSTA$PlotGhostGroundSAM$I     == YES) call echov ("SAM ")
	   if (XSTA$PlotGhostGroundHIMAD$I   == YES) call echov ("HIMAD ")
	   if (XSTA$PlotGhostGroundALLRAD$I  == YES) call echov ("ALLRAD ")
	   if (XSTA$PlotGhostGroundTEL$I     == YES) call echov ("TEL ")
	   if (XSTA$PlotGhostGroundCombat$I  == YES) call echov ("Combat ")
	   if (XSTA$PlotGhostGroundSupport$I == YES) call echov ("Support ")
	   if (XSTA$PlotGhostGroundConvoy$I  == YES) call echov ("Convoy ")
	   if (XSTA$PlotGhostGroundSunit$I   == YES) call echov ("SUnit ")

    }
#____________________________________________________________

STA$SatIndx$I = xSTA$SatIndx$I

if (STA$SatIndx$I != 0)                     ## 6/27/83 tpa
    {
    STA$FirstLat$F = xSTA$FirstLat$F        
    STA$LastLat$F  = xSTA$LastLat$F         

    iflat = 0; call smovlls(STA$FirstLat$F,"NS",cflat,iflat)

    illat = 0; call smovlls(STA$LastLat$F, "NS",cllat,illat)

    SAT$Pointer$To STA$SatIndx$I

    call echor
    call echov ("Plot SURVSAT ")
    call echohn(xSAT$SatelliteName$C,  8)
    call echov (" revolutions ")
    call echoi (xSTA$FirstOrbit$I )
    call echov (" thru ")
    call echoi (xSTA$LastOrbit$I  )
    call echov (" from ")
    call echoh (cflat,       iflat)
    call echov (" to ")
    call echoh (cllat,       illat)
    }

#____________________________________________________________
STA$PlotPIMIndx$I = xSTA$PlotPIMIndx$I 

if (STA$PlotPIMIndx$I != NO)
   {
    call echor
    call echov  ("Plot PIM ")
    UNT$Pointer$To STA$PlotPIMIndx$I
    call echohn (xUNT$Name$C, $$MaxLit)
   }
#____________________________________________________________
if (Xsta$PlotRivers$i == YES)
    {
    call echor
    call echov ("Plot Rivers ")
    }

if (Xsta$PlotBoundaries$i == YES)
    {
    call echor
    call echov ("Plot Boundaries")
    }

#____________________________________________________________
if (Xsta$PlotChaff$i == YES)
    {
    call echor
    call echov ("Plot Chaff Barriers")
    }

if (Xsta$PlotSonoBuoy$i == YES)
    {
    call echor
    call echov ("Plot SonoBuoy Barriers")
    }

if (Xsta$PlotMineFields$i == YES)
    {
    call echor
    call echov ("Plot MineField(s)")
    }

#____________________________________________________________
if (Xsta$PlotLandingZones$i != NO)
    {
    call echor
    call echov ("Plot Landing Zones")
    }

#______________________________________________________________________
# Sosus Regions / Sonar Regions             ## 6/16/83  tpa
# LIDAR Regions / SWABS Regions             ## 2/28/91  SMM & CLK

STA$PlotSonarReg$I = xSTA$PlotSonarReg$I    ## extract flags
STA$PlotSosus$I    = xSTA$PlotSosus$I
STA$PlotLIDAR$I    = xSTA$PlotLIDAR$I
STA$PlotSWABS$I    = xSTA$PlotSWABS$I

if (STA$PlotSonarReg$I == YES) 
  {
   call echor
   call echov ("Plot Sonar")
  }
if (STA$PlotLIDAR$I    == YES)
  {
   call echor
   call echov ("Plot LIDAR")
  }

if (iview <= $lastBlue$view)                ## if blue or control
    {
     if (STA$PlotSosus$I    == YES)
       {
        call echor
        call echov ("Plot Sosus")
       }
     if (STA$PlotSWABS$I    == YES)
       {
        call echor
        call echov ("Plot SWABS")
       }
    }

if (xSTA$PlotL16Data$I != $no)   # clk 12/95 (E1469)
  {
   STA$PlotL16ForceIndx$I = xSTA$PlotL16ForceIndx$I
   UNT$Pointer$To  (STA$PlotL16ForceIndx$I)

   call echor                                   # expanded for selective
   call echov  ("JTIDS TRACKS FOR PLATFORM ")   # plotting - clk 12/96 (E1707)
   call echohn (xUNT$Name$C, $$MaxLit)
   if (xSTA$PlotL16Local$I == $yes)     
     call echov  (" - (LOCAL DETECTIONS)")
   call echor
     call echov ("   TYPES: ")
   if (xSTA$PlotL16All$I == $Hi_STA$PlotL16All$I)
     call echov ("ALL")
   else   # selective plotting of JTIDS tracks
     {
      STA$PlotL16Enemy$I = xSTA$PlotL16Enemy$I
      if (STA$PlotL16Enemy$I != $no)
        {
         call echov  (" ENEMY - ")
         if (STA$PlotL16Enemy$I == $Hi_STA$PlotL16Enemy$I)
            call echov  ("ALL, ")
         else
           {
            if (xSTA$PlotL16EnemyAir$I == $yes)
              call echov  ("AIR, ")
            if (xSTA$PlotL16EnemyLand$I == $yes)
              call echov  ("LAND, ")
            if (xSTA$PlotL16EnemySurf$I == $yes)
              call echov  ("SURF, ")
           }
        }   # end of if plotting ENEMY JTIDS tracks
      STA$PlotL16Friendly$I = xSTA$PlotL16Friendly$I
      if (STA$PlotL16Friendly$I != $no)
        {
         call echov  (" FRIENDLY - ")
         if (STA$PlotL16Friendly$I == $Hi_STA$PlotL16Friendly$I)
            call echov  ("ALL, ")
         else
           {
            if (xSTA$PlotL16FriendlyAir$I == $yes)
              call echov  ("AIR, ")
            if (xSTA$PlotL16FriendlyLand$I == $yes)
              call echov  ("LAND, ")
            if (xSTA$PlotL16FriendlySurf$I == $yes)
              call echov  ("SURF, ")
           }
        }   # end of if plotting FRIENDLY JTIDS tracks
      STA$PlotL16Neutral$I = xSTA$PlotL16Neutral$I
      if (STA$PlotL16Neutral$I != $no)
        {
         call echov  (" NEUTRAL - ")
         if (STA$PlotL16Neutral$I == $Hi_STA$PlotL16Neutral$I)
            call echov  ("ALL, ")
         else
           {
            if (xSTA$PlotL16NeutralAir$I == $yes)
              call echov  ("AIR, ")
            if (xSTA$PlotL16NeutralLand$I == $yes)
              call echov  ("LAND, ")
            if (xSTA$PlotL16NeutralSurf$I == $yes)
              call echov  ("SURF, ")
           }
        }   # end of if plotting NEUTRAL JTIDS tracks
      STA$PlotL16Unknown$I = xSTA$PlotL16Unknown$I
      if (STA$PlotL16Unknown$I != $no)
        {
         call echov  (" UNKNOWN - ")
         if (STA$PlotL16Unknown$I == $Hi_STA$PlotL16Unknown$I)
            call echov  ("ALL, ")
         else
           {
            if (xSTA$PlotL16UnknownAir$I == $yes)
              call echov  ("AIR, ")
            if (xSTA$PlotL16UnknownLand$I == $yes)
              call echov  ("LAND, ")
            if (xSTA$PlotL16UnknownSurf$I == $yes)
              call echov  ("SURF, ")
           }
        }   # end of if plotting UNKNOWN JTIDS tracks
     }   # end of if slectively plotting tracks
  }   # end of if plotting JTIDS tracks

if (xSTA$PlotPEMData$I != $no)   # clk 2/97 (E1731)
  {
   call echor
   call echov  ("Plot Persistent Effect Munitions")
   if (iview == $Neutral$View)
     {
      call echov (" for")
      if (xSTA$PlotPEMData$I == 7)  # three bits flipped true
        call echov (" ALL SIDES")
      else
        {
         if (xSTA$PlotPEMDataBlue$I == $yes)
           call echov (" BLUE")
         if (xSTA$PlotPEMDataNeutral$I == $yes)
           call echov (" NEUTRAL")
         if (xSTA$PlotPEMDataOrange$I == $yes)
           call echov (" ORANGE")
        }   # end of if not ALL
     }   # end of if this is a control view
  }   # end of if plotting PEM data
#______________________________________________________________________
# Envelopes

#call echor
#call echov ("Envelopes ")

#if (Xsta$envelopes$i == YES)
#    {
#    sta$EnvelopeSource$i = Xsta$EnvelopeSource$i 

#    if     (sta$EnvelopeSource$i == $ALL$CODE    ) call echov ("All"    )
#    else if(sta$EnvelopeSource$i == $SUB$CODE    ) call echov ("Sub"    )
#    else if(sta$EnvelopeSource$i == $SURFACE$CODE) call echov ("Surface")

#    call echov (" Radius ")
#    call echoi (Xsta$EnvRadius$i)
#    }
#else
#    {
#    call echov ("Off")
#    }

#______________________________________________________________________
# LOB....

call echor
call echov ("LOB ")

sta$BearingSource$I = Xsta$BearingSource$I

if (sta$BearingSource$I == 0)
    {
    call echov ("Off")
    }
else 
    {       
    if (Xsta$BearingSource$I == unt$SLOTS+1)
        {
        call echov ("All")
        }
    else 
        {
        unt$pointer$to      sta$BearingSource$i 

        call echov ("Force ")
        call echohn (Xunt$Name$C,$$MaxLit)

        sta$AltBearingSource$i = Xsta$AltBearingSource$i
        if (sta$AltBearingSource$i >  0       &
            sta$AltBearingSource$i <= unt$Slots)
            {
            unt$pointer$to sta$AltBearingSource$i 

            call echov (" & Force ")
            call echohn (Xunt$Name$C,$$MaxLit)
            }
        }

    sta$PlotESM$i   = Xsta$PlotESM$i
    sta$PlotSonar$i = Xsta$PlotSonar$i 

    iany = sta$PlotESM$i + sta$PlotSonar$i 

    if (iany            != NO ) call echov (" (")
    if (sta$PlotESM$i   == YES) call echov ("ESM")
    if (iany            >  YES) call echov (" & ")
    if (sta$PlotSonar$i == YES) call echov ("Sonar")
    if (iany            != NO ) call echov (")")

    call echor
    call disp_eerlist(sta$pointer)
    }

#______________________________________________________________________
# Last PLOT ROTHR command

STA$RothrOrder$i = Xsta$RothrOrder$i

if ( (STA$RothrOrder$i == $Plot$Rothr) |          # get last PLOT ROTHR
     (STA$RothrOrder$i == $Evaluate$Rothr) )      #  command entered
  {
   call echov ("Plot rothr")
   if (STA$RothrOrder$i == $Plot$Rothr)
     call echov (" coverage")
   else
     call echov (" performance")

   call echov (" (for site) ")
   STA$RothrIndx$i = Xsta$RothrIndx$i
   RTH$Pointer$to STA$RothrIndx$i
   call echohn (Xrth$Basename$c,$$MaxLit)                # display base name

   call echov (" (air/surface)")
   STA$RothrAirSurfPCA$i = Xsta$RothrAirSurfPCA$i
   STA$RothrDayNightPCA$i = Xsta$RothrDayNightPCA$i
   if (STA$RothrAirSurfPCA$i == air$pca)
     call echov (" air")
   else
     call echov (" surface")

   call echov (" (day/night)")
   if (STA$RothrDayNightPCA$i == day$rth)
     call echov (" day")
   else
     call echov (" night")
   call echor
  }

#______________________________________________________________________
# All Done.... (with PLOT)

call echor

return
end     # pl_disply_plot


Subroutine PL_Disply_Astab (nord, STA$Pointer, nargs, args) 
#$%
#$% Modified:  Susan Miller - 3/98 (E1955) 
#$%            Removed references to FOTCP, FOTCS, and RxSignal ASTABS
#$%

BBcommon

BBDeclare  (STA$Nbrastabs$I, STA$Lastsbi$I,
            SBI$Pointer, SBI$Currboard$I,
            SBI$Currpage$I, SBI$Currside$I,
            SBI$Currplayer$I)                    # MJC 7/25/2000 
integer     JJ, ILEN, NOT_AVAIL, I_SWITCH_1      # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
character       bname[ARB]
integer*4       iview

iview = Xsta$View$i

#______________________________________________________________________
## display ASTAB

STA$NbrASTABS$I = xSTA$NbrASTABS$I          ## get no. of active astabs

SBI$Pointer$To xSTA$SbiIndex$I              ## set SBI pointer

sta$LastSBI$I = Xsta$LastSBI$I              # get default display number

for (jj = 1; jj <= STA$NbrASTABS$I; jj = jj + 1)  ## loop for nbr of astabs
    {
    SBI$CurrBoard$I = xSBI$CurrBoard$I
    SBI$CurrPage$I  = xSBI$CurrPage$I

    if (sta$LastSBI$I == jj) call echov ("*")
    else                     call echov (" ")

    if (SBI$CurrPage$I == 0 & SBI$CurrBoard$i == 0 &
                              xSBI$NbrLines$I == 0 ) 
        {
        ilen = 0; call smovv (")  Not Available   ", bname,ilen)

        call echoib (jj,2)
        call echoh  (bname, 19)
        call echor

        not_avail = YES
        }
    else
        {
        not_avail = NO

        ilen=0
        Switch (SBI$CurrBoard$I) #Air/Surf ESM added 6/9/86
            {
            case $AirEvents$Board:
                call smovv (")  AIR EVENTS       ",bname,ilen);
            case $Availability$Board:
                call smovv (")  AIR AVAILABILITY ",bname,ilen);
            case $DownedAircraft$Board:                           # clk 3/92
                call smovv (")  AIR DESTROYED    ", bname, ilen);
            case $AirBDA$Board:                                   # JFR (E1104)
                call smovv ("   AIRCRAFT BDA     ", bname, ilen);
            case $ShipBDA$Board:                                  # JFR (E1104)
                call smovv ("   SHIP BDA         ", bname, ilen);
            case $ShorebaseBDA$Board:                             # JFR (E1104)
                call smovv ("   SHOREBASE BDA    ", bname, ilen);
            case $BogeyTote$Board:
                call smovv (")  BOGEY            ",bname,ilen);
            case $Damage$Board:
                call smovv (")  DAMAGE           ",bname,ilen);
            case $DamageTime$Board:
                call smovv (")  DAMAGE           ",bname,ilen);
            case $AirEsm$Board:
                call smovv (")  AIR ESM          ",bname,ilen);
            case $SurfEsm$Board:
                call smovv (")  SURFACE ESM      ",bname,ilen);
            case $Esm$Board:
                call smovv (")  ESM              ",bname,ilen);
            case $Flight$Board: 
                call smovv (")  FLIGHT           ",bname,ilen);
            case $Hfdf$Board:
                call smovv (")  HFDF             ",bname,ilen);
            case $PassiveSonar$Board:
                call smovv (")  PASSIVE          ",bname,ilen);
            case $ReportPolicy$Board:
                call smovv (")  REPORTING        ",bname,ilen);
            case $DefinedRoute$Board:                       # 11/20/89 reh
                call smovv (")  ROUTE            ",bname,ilen);
            case $Assault$Board:                            # 12/7/89 reh
                call smovv (")  ASSAULT          ",bname,ilen);
            case $Ship$Board:
                call smovv (")  SHIP             ",bname,ilen);
            case $Shorebase$Board:
                call smovv (")  SHORE            ",bname,ilen);
            case $Sosus$Board:
                call smovv (")  SOSUS            ",bname,ilen);
            case $Sub$Board:
                call smovv (")  SUBMARINE        ",bname,ilen);
            case $Survsat$Board:
                call smovv (")  SURVEILLANCE     ",bname,ilen);
            case $Track$Board:
                call smovv (")  ACTIVE TRACKS    ",bname,ilen);
            case $Weather$Board:
                call smovv (")  WEATHER          ",bname,ilen);
            case $ActiveAir$Board:
                call smovv (")  AIR TRACKS       ",bname,ilen);
            case $ActiveSurface$Board:
                call smovv (")  SURFACE          ",bname,ilen);
            case $ActiveSub$Board:
                call smovv (")  ACTIVE SONAR     ",bname,ilen);
            case $AirAlert$Board:
                call smovv (")  AIR ALERT        ",bname,ilen);
            case $IntellReport$Board:
                call smovv (")  INTELL           ",bname,ilen);
            case $Help$Board:
                call smovv (")  HELP             ",bname,ilen);
            case $AAWCFlight$Board:                                 ## TPA
                call smovv (")  AAWC FLIGHT      ",bname,ilen);
            case $ASWCFlight$Board:
                call smovv (")  ASWC FLIGHT      ",bname,ilen);
            case $ASUWCFlight$Board:
                call smovv (")  ASUWC FLIGHT     ",bname,ilen);
            case $AAWCEvents$Board:                                 ## TPA
                call smovv (")  AAWC AIR EVENTS  ",bname,ilen);
            case $ASWCEvents$Board:
                call smovv (")  ASWC AIR EVENTS  ",bname,ilen);
            case $ASUWCEvents$Board:
                call smovv (")  ASUWC AIR EVENTS ",bname,ilen);
            case $AirMissionHist$Board:                       # clk 12/96 (E1726)
                call smovv (")  AIRCRAFT MISSION HISTORY",bname,ilen);
            case $AirDefenseSAM$Board:                        # SMM 12/93
                call smovv (")  AIR DEFENSE      ",bname,ilen);
            case $BoatAvail$Board:                            # AM  6/8/89
                call smovv (")  BOAT AVAILABILITY",bname,ilen);
            case $BoatOps$Board:                              # AM  6/8/89
                call smovv (")  BOAT OPERATIONS  ",bname,ilen);
            case $EWCEvents$Board:                            # DEW 9/27/89
                call smovv (")  EWC Air Events   ",bname,ilen);
            case $EWCFlight$Board:                            # DEW 9/27/89
                call smovv (")  EWC Flight       ",bname,ilen);
            case $EMIStat$Board:                              # DEW 9/27/89
                call smovv (")  EMI              ",bname,ilen);
            case $AmphibEvents$Board:                         # dew 12/11/89
                call smovv (")  AMPHIBIOUS AIR   ",bname,ilen);
            case $AmphibFlight$Board:                         # dew 12/11/89
                call smovv (")  AMPHIBIOUS FLIGHT",bname,ilen);
            case $AmphibBoatOps$Board:                        # dew 12/11/89
                call smovv (")  AMPHIBIOUS BOATOP",bname,ilen);
            case $Rothr$Board:                                # cml 6/12/90
                call smovv (")  ROTHR            ",bname,ilen);
            case $SPA$Board:                                  # clk 10/91
                call smovv (")  SPA              ",bname,ilen);
            case $MineField$Board:                            # clk 1/96 (E1364)
                call smovv (")  MINEFIELDS       ",bname,ilen);
            case $JTIDSTrack$Board:                           # clk 12/95 (E1469)
                call smovv (")  L-16 TRACKS      ",bname,ilen);
            case $JTIDSAirTrack$Board:                        # clk 12/95 (E1469)
                call smovv (")  L-16 AIR TRACKS  ",bname,ilen);
            case $JTIDSLandTrack$Board:                       # clk 12/95 (E1469)
                call smovv (")  L-16 LAND TRACKS ",bname,ilen);
            case $JTIDSSurfTrack$Board:                       # clk 12/95 (E1469)
                call smovv (")  L-16 SURF TRACKS ",bname,ilen);
            case $Extension$Board:                            # DEW 3/7/91
                {
                call smovv (")  Extension        ",bname,ilen);
                not_avail = YES
                }
            default:
                call smovv (")  ????             ",bname,ilen);

            } ## end switch

        call echoib (jj,2)                          ## output astab no.
        call echoh  (bname,ilen)                    ## output current board

        if (iview     == $Neutral$View  &           ## if control output
            not_avail == NO)
            {                                       ## side of board
            SBI$CurrSide$I   = xSBI$CurrSide$I
            SBI$CurrPlayer$I = xSBI$CurrPlayer$I
            
            Switch (SBI$CurrSide$I)
                {
                case $Neutral$Code:
                    {
                    call echovn ("NEUTRAL ")
                    call echov  ("  ")
                    }
                case $Blue$Code:
                    {
                    call echovn ("BLUE   ")
                    call echoib (SBI$CurrPlayer$I,2)
                    call echov  ("   ")
                    }
                case $Orange$Code:
                    {
                    call echovn ("ORANGE ")
                    call echoib (SBI$CurrPlayer$I,2)
                    call echov  (" "               )
                    }
                }
            }               

        if (not_avail == NO)
            {
            call echov  ("  page ")               ## output current page 
            call echoib (SBI$CurrPage$I,2)        ## of board
            }

        call echor
        }##  end else

    SBI$Pointer$Next
    }                       ## end for

#______________________________________________________________________
# All Done.... (with ASTAB)

call echor

return
end # PL_Disply_ASTAB


Subroutine PL_Disply_PIM (nord, STA$Pointer, nargs, args) 

BBcommon

BBDeclare  (UNT$Pointer, 
            UNT$View$I,
            UNT$Type$I, 
            UNT$Pimindx$I,
            UNT$Name$C,
            PIM$Nlegs$I, 
            PIM$PTS$Index,
            PIM$Pointer,
            PIM$Legnumber$I,
            PIM$PTS$latitude$F,
            PIM$PTS$longitude$F)            # MJC 7/25/2000
literal   CSTRIP8                           # MJC 4/21/2000
integer   ILOITER,
          J, N_POINTS,
          ISPEED, NLEN                      # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
character pim_work[ARB]
integer*4 iview

iview = Xsta$View$i

#______________________________________________________________________
# DISPLAY PIM <name>    (or DISPLAY PIM ALL)

j = 0
for(unt$POINTER$FIRST;unt$POINTER$VALID;unt$POINTER$NEXT)
    {     
    unt$View$I    = xunt$View$I
    unt$Name$C    = xunt$Name$C
    unt$Type$I    = xunt$Type$I
    unt$PimIndx$I = xunt$PimIndx$I

########### Substitution <<<>>>                     1/28/86
    if (unt$PimIndx$I == 0) NEXT
    else if (IView != $Neutral$view) 
        {                                      #       7/6/86
        if (unt$View$I != IView ) NEXT
        }                                      #       7/6/86

    if (args[3] == 'ALL')
        {
        j = j + 1
        call echoi   (j)
        call echov   (")")
        call echov  (" PIM ")
        call echohn (unt$Name$C,$$MaxLit)

        if (unt$Type$I != $Pim$Code &
              xunt$Status$i != $LayingBarrier$Code) # jb /\  8/17/87
            call echov  (" (Orbit)")

        call echor
        Next
        }

    if (unt$Name$C != args[3]) Next

    PIM$Pointer$To (unt$PimIndx$I)          ## init PIM pointer

    PIM$LegNumber$I = xPIM$LegNumber$i              ## current leg number

    PIM$NLegs$I = xPIM$NLegs$i                      ## get number of legs
    n_points = PIM$NLegs$I+1                        ## compute nbr points

    for (PIM$PTS$Index=1; PIM$PTS$Index <= n_points;        
         PIM$PTS$index = PIM$PTS$index+1)   ## loop for lat/long
        {
        PIM$PTS$Latitude$F  = xPIM$PTS$Latitude$F
        PIM$PTS$Longitude$F = xPIM$PTS$Longitude$F
        iLoiter = xPim$PTS$Delay$I   
        iSpeed  = xPim$PTS$Speed$I
                    
        if (PIM$PTS$Index == 1)
            {
            call echov  ("INITIAL POSITION ")
            }
        else
            {
            call echov  ("PROCEED POSITION (")
            j = j + 1
            call echoi (J)
            call echov (") ")
            }  

        nlen = 0
        call smovlls(PIM$PTS$LATITUDE$F,"NS",PIM_WORK,nlen)  #get lat 
        call echoh  (PIM_WORK,nlen)
        call echov   (" ")

        nlen = 0
        call smovlls(PIM$PTS$LONGITUDE$F,"EW",PIM_WORK,nlen) #get long
        call echoh  (PIM_WORK,nlen)

        call echov  (" SPEED ")                   #unit speed 
        call echoi  (ispeed) 
          
        if (iloiter != 0)
            {            
            call echov  (" LOITER ")                      #loiter time
            call echoi  (iloiter)          
            }

        if (PIM$LegNumber$I+1 == pim$pts$index)
            {            
            call echov  (" (current destination)")
            }

        call echor
        }
    }    

if (j == 0)         # was anything displayed ???
    {
    call echov ("Pim not found.")
    call echor
    }

return
end  # pl_disply_pim


Subroutine PL_Disply_SWABS (nord, STA$Pointer, nargs, args) 

BBcommon

BBDeclare  (SWB$Pointer, SWB$VER$Index,
            SWB$VER$longitude$F, SWB$VER$latitude$F)    # MJC 7/25/2000
integer   NLEN                                          # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
character work[ARB], msg[ARB]
integer   nvert, iview

iview = Xsta$View$i

#______________________________________________________________________
# DISPLAY SWABS (region) <number> (information)

if (iview <= $lastBlue$view)   # blue or control
    {
     call echov ("DISPLAY BLUE SWABS REGION #")
     call echoi (int(args[3]))
     call echor

     nlen = 0
     for (SWB$Pointer$First; SWB$Pointer$OK; SWB$Pointer$Next)        
        {                     # loop through SWABS regions
        if ($Blue$Code != xSWB$Side$I)  # not a blue region
            next
        if (args[3] == xSWB$RegionNumber$I) # region requested found
            break
        else         # region requested not found
            {
             call smov ($space,msg,nlen)                 
             call smovi (int(xSWB$RegionNumber$I),msg,nlen)
             next
            }
        } # end of loop through SWABS regions

    if (SWB$Pointer$OK)
        {       
         nvert = xSWB$NbrVertices$i       # how many vertices
         for (SWB$VER$index = 1; SWB$VER$index <= nvert;
              SWB$VER$index = SWB$VER$index + 1)  # loop for lat/long
            {
             SWB$VER$Longitude$F = xSWB$VER$Longitude$F
             SWB$VER$Latitude$F = xSWB$VER$Latitude$F
      
             call echov ("POINT (")
             call echoi (SWB$VER$Index)
             call echov (") ")

             nlen = 0
             call smovlls(SWB$VER$Latitude$F,"NS",work,nlen)  
             call echoh  (work,nlen)
             call echov  (" ")

             nlen = 0
             call smovlls(SWB$VER$Longitude$F,"EW",work,nlen)
             call echoh  (work,nlen)

             call echor
            } # loop through points in region
        }  # end if SWB$Pointer$OK
    else  # region not found
        {
         call echov("REGION NOT FOUND, TRY ")
         call echoh (msg, nlen)
         call echor
        }
    }   # end if blue or control
     
if (iview == $neutral$view | iview > $lastBlue$view)  
    {                                               # orange or control
     call echov ("DISPLAY ORANGE SWABS REGION #")
     call echoi (int(args[3]))
     call echor
         
     nlen = 0
     for (SWB$Pointer$First; SWB$Pointer$OK; SWB$Pointer$Next)        
        {                     # loop through SWABS regions
        if ($Orange$Code != xSWB$Side$I)  # not an orange region
            next
        if (args[3] == xSWB$RegionNumber$I ) # region requested found
            break
        else         # region requested not found
            {
             call smov ($space,msg,nlen)                 
             call smovi (int(xSWB$RegionNumber$I),msg,nlen)
             next
            }
        } # end of loop through SWABS regions

     if (SWB$Pointer$OK)
        {       
         nvert = xSWB$NbrVertices$i       # how many vertices
         for (SWB$VER$index = 1; SWB$VER$index <= nvert;
              SWB$VER$index = SWB$VER$index + 1)  # loop for lat/long
            {
             SWB$VER$Longitude$F = xSWB$VER$Longitude$F
             SWB$VER$Latitude$F = xSWB$VER$Latitude$F
      
             call echov ("POINT (")
             call echoi (SWB$VER$Index)
             call echov (") ")

             nlen = 0
             call smovlls(SWB$VER$Latitude$F,"NS",work,nlen)  
             call echoh  (work,nlen)
             call echov  (" ")

             nlen = 0
             call smovlls(SWB$VER$Longitude$F,"EW",work,nlen)
             call echoh  (work,nlen)

             call echor
            } # loop through points in region
        }  # end if SWB$Pointer$OK
    else  # region not found
        {
         call echov("REGION NOT FOUND, TRY ")
         call echoh (msg, nlen)
         call echor
        }
    }   # end if orange or control


return
end # PL_Disply_SWABS


Subroutine PL_Disply_Poly_Line (nord, STA$Pointer, nargs, args) 

#$% Modified:  Carol Kropp - 2/96 (E1543)
#$%            When control enters the DISPLAY POLYGON (named) ALL command,
#$%            the polygons for all stations are displayed.  There was no
#$%            way to see which ones were defined for the particular control
#$%            station, so the station is listed after the line/polygon name.

BBcommon

BBDeclare  (LIN$Pointer, LIN$Station$I, LIN$Line$I,
            LIN$Numpts$I, LIN$PTS$Index, LIN$Name$C, 
            LIN$PTS$latitude$F, LIN$PTS$longitude$F)     # MJC 4/21/2000
literal   CSTRIP8                                        # MJC 4/21/2000
integer   ISTA, J, NLEN                                  # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
character work[ARB]
integer*4 iview

iview = Xsta$View$i

#______________________________________________________________________
# DISPLAY POLYGON/LIN <name>    (or DISPLAY POLYGON/LIN ALL)

ista = STA$Pointer$Index
j = 0
for(LIN$POINTER$FIRST;LIN$POINTER$OK;LIN$POINTER$NEXT)
    {
    LIN$Station$i = xLIN$Station$i      
    if (LIN$Station$i == 0) NEXT
    else if (IView != $Neutral$view) 
       {
        if (LIN$Station$i != ista) NEXT
       }

    LIN$LINE$i = xLIN$LINE$i
    if( args[2] == $Lex$LINE$ )    # If this is a LINE order, 
       {                            #  then disregard POLYGONs..
         if  (LIN$LINE$i != $YES) 
            { NEXT }
       }
    ELSE      # This is a POLYGON order, so disregard LINEs..
       {
        if  (LIN$LINE$i == $YES)
            { NEXT }
       }

    LIN$Name$C = xLIN$Name$C
    if (args[3] == 'ALL' |
        args[3] == $LEX$ALL$)    #<<<>>>
        {
        j = j + 1
        call echoib (j,3)
        call echov   (")")

        if (args[2] == $Lex$LINE$)
              call echov  (" Line ")
        else  call echov  (" Poly ")

        call echohn (LIN$Name$C,$$MaxLit)
        if (iview == $Neutral$view)    # clk 2/96 (E1543)
          {
           call echo   ($Tab)
           call echov  (" station ")
           call echoib (LIN$Station$I, 2)
          }
        call echor
        NEXT
        }

    ELSE if (args[3] != LIN$Name$C & args[4] != LIN$Name$C &
                                    args[2] != LIN$Name$C )
        {  NEXT }    # ( [3] for polygon; [4] for line )

    LIN$NumPTS$I = xLIN$NumPTS$i

    for (LIN$PTS$Index=1; LIN$PTS$Index <= LIN$NumPTS$i;
         LIN$PTS$index = LIN$PTS$index+1)   ## loop for lat/long
        {
        LIN$PTS$Latitude$F  = xLIN$PTS$Latitude$F
        LIN$PTS$Longitude$F = xLIN$PTS$Longitude$F
                    
        if (LIN$PTS$Index == 1)
            {
             if (iview == $Neutral$view)    # clk 2/96 (E1543)
               {
                call echohn (LIN$Name$C,$$MaxLit)
                call echo   ($Tab)
                call echov  (" station ")
                call echoib (LIN$Station$I, 2)
                call echor
               }
             call echov  ("  Initial position ")
            }
        else
            {
            call echov  ("  Next position ")
            call echoi (LIN$PTS$Index)
            call echov (") ")
            }  

        nlen = 0
        call smovlls(LIN$PTS$LATITUDE$F,"NS",WORK,nlen)  #get lat 
        call echoh  (WORK,nlen)
        call echov  (" ")

        nlen = 0
        call smovlls(LIN$PTS$LONGITUDE$F,"EW",WORK,nlen) #get long
        call echoh  (WORK,nlen)
        j = j + 1

        call echor
        }
    }    

if (j == 0)         # was NOTHING displayed ???
    {
    if (args[2] == $Lex$LINE$)
        call echov ("  Line NOT FOUND")
        else  call echov  ("  Polygon NOT FOUND")
    call echor
    }


return
end # end PL_Disply_Poly_Line

Subroutine PL_Disply_Circle_Ell (nord, STA$Pointer, nargs, args) 

BBcommon

BBDeclare  (PLC$Pointer, PLC$Type$I)                # MJC 7/25/2000
integer         IFOUND, IPNT                        # MJC 4/21/2000
integer*4       nord, sta$pointer, nargs
literal         args[ARB]
character       work[ARB]
integer*4       iview

iview = Xsta$View$i

#______________________________________________________________________
# Display Circles or Ellipses

ifound = $NO
for (PLC$Pointer$First; PLC$Pointer$OK; PLC$Pointer$Next)
  {
   if (xPLC$Station$i != STA$Pointer$Index) next   # object belongs to a
                                                   # different station

   if (xPLC$ReferenceType$i != $null$code) next    # object not plotted
                                                   # by position

   PLC$Type$i = xPLC$Type$i    # extract type of object

   if (args[2] == $Lex$CIRCLE$)
     {
      if (PLC$Type$i == $Circle$CODE)
        {
         ifound = $YES
         call echov ("Place (a) circle (around) position ")
        }
      else if (PLC$Type$i == $GRID$CODE)
        {
         ifound = $YES
         call echov ("Place (a) grid (on) position ")
        }
      else
        {
         next
        }

      ipnt = 0
      call smovlls (xPLC$Latitude$f, "NS",work,ipnt)
      call echoh (work,ipnt)

      call echov (" ")

      ipnt = 0
      call smovlls (xPLC$Longitude$f, "EW",work,ipnt)
      call echoh (work,ipnt)

      call echov (" (with radius) ")
      call echoi (xPLC$Radius$i)

      call echor
     }
   else if (args[2] == $Lex$RECTANGLE$)
     {
      if (PLC$Type$i == $RECTANGLE$CODE)
        {
         ifound = $YES
         call echov("Place (a) rectangle (around) position ")
        }
      else
        {
         next
        }

      ipnt = 0
      call smovlls (xPLC$Latitude$f, "NS",work,ipnt)
      call echoh (work,ipnt)

      call echov (" ")

      ipnt = 0
      call smovlls (xPLC$Longitude$f, "EW",work,ipnt)
      call echoh (work,ipnt)

      call echov (" (length) ")
      call echoi (xPLC$Length$i)

      call echov (" (orientation) ")
      call echoi (xPLC$Orient$i)

      call echov (" (width) ")
      call echoi (xPLC$Width$i)

      call echor
     }

  }  # end of for-loop

if (ifound == $NO)
  {
   if (args[2] == $Lex$Circle$)
     {
      call echov ("No circles or grids have been plotted by position.")
      call echor
     }
   else if (args[2] == $Lex$Rectangle$)
     {
      call echov ("No rectangles or ellipses have ")
      call echov ("been plotted by position.")
      call echor
     }
  }
call echor

return
end # PL_Disply_Circle_Ell


Subroutine PL_Disply_Mark (nord, STA$Pointer, nargs, args) 

BBcommon

BBDeclare  (MRK$Pointer,
            MRK$Cat$I,
            MRK$Type$I,
            PLC$Pointer,
            BMK$Pointer)              # MJC 7/25/2000
literal   CSTRIP8                     # MJC 4/21/2000
integer   IFOUND, IPNT, IBRG          # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
character work[ARB]
integer*4 iview

iview = Xsta$View$i

#______________________________________________________________________
# display marked tracks and bearings, and xmarks

ifound = $NO
for (PLC$Pointer$First; PLC$Pointer$OK; PLC$Pointer$Next)
  {
   if (xPLC$Station$i != STA$Pointer$Index) next  # this object belongs to
                                                  # a different station

   if (xPLC$ReferenceType$i != $null$code) next   # object not plotted by
                                                  # position

   if (xPLC$Type$i != $XMARK$CODE) next           # object is not an XMARK

   ifound = $YES
   call echov ("Place (a) XMARK (around) position ")

   ipnt = 0
   call smovlls (xPLC$Latitude$f, "NS",work,ipnt)
   call echoh (work,ipnt)

   call echov (" ")

   ipnt = 0
   call smovlls (xPLC$Longitude$f, "EW",work,ipnt)
   call echoh (work,ipnt)

   call echor
  }
if (ifound == $NO)
  {
   call echov ("No XMARKs have been plotted by position.")
   call echor
  }

##  display positions of marked tracks
ifound = $NO
for (MRK$Pointer$First; MRK$Pointer$OK; MRK$Pointer$Next)
  {
   if (xMRK$Station$i == 1 & xSTA$View$i == $Neutral$View) continue  # Control stations dispplay location of sunk ships
   else if (xMRK$Station$i != STA$Pointer$Index) next  			     # this mark belongs to a different station

   ifound = $YES
   call echov ("Mark track ")

   MRK$Cat$i = xMRK$Cat$i     # extract category (air, sub, surface)
                              # of mark

   MRK$Type$i = xMRK$Type$i   # extract type (enemy, friendly, neutral,
                              # unknown ) of mark

   if (MRK$Type$i == $ENEMY$CODE) call echov ("enemy ")
   else if (MRK$Type$i == $FRIENDLY$CODE) call echov ("friendly ")
   else if (MRK$Type$i == $NEUTRAL$CODE) call echov ("neutral ")
   else call echov ("unknown ")

   if (MRK$Cat$i == $AIR$CODE) call echov ("air (at position) ")
   else if (MRK$CAT$I == $SUB$CODE) call echov ("sub (at position) ")
   else call echov ("surface (at position) ")

   ipnt = 0
   call smovlls (xMRK$Latitude$f, "NS",work,ipnt)
   call echoh (work,ipnt)

   call echov (" ")

   ipnt = 0
   call smovlls (xMRK$Longitude$f, "EW",work,ipnt)
   call echoh (work,ipnt)

   call echov ("  (and name it) ")
   call echohn (xMRK$Label1$C,$$MaxLit)
   call echov (" ")
   call echohn (xMRK$Label2$C,$$MaxLit)

   call echor

  }  # end of for-loop
if (ifound == $NO)
  {
   call echov ("No tracks marked at this station.")
   call echor
  }

##  display positions of marked bearings
ifound = $NO
for (BMK$Pointer$First; BMK$Pointer$OK; BMK$Pointer$Next)
  {
   if (xBMK$Station$i != STA$Pointer$Index) next  # this bearing belongs
                                                  # to a different station

   ifound = $YES
   call echov ("Mark bearing (on) ")
   call echohn (xBMK$Name$C,$$MaxLit)
   call echov (" (bearing at) ")
   ibrg = INT(xBMK$Bearing$f*(180./$pi) + .5)     #get bearing in degrees
   call echoi (ibrg)
   call echor
  }
if (ifound == $NO)
  {
   call echov ("No bearings marked at this station.")
   call echor
  }

call echor



return
end # PL_Disply_Mark

Subroutine PL_Disply_DIRS (nord, STA$Pointer, nargs, args) 

BBcommon

BBDeclare  (RTH$Pointer)            # MJC 8/8/2000
integer   IFOUND, IBASE,
          IAIR_DAY_LEFT,
          IAIR_DAY_USED,
          IAIR_NIGHT_LEFT,
          IAIR_NIGHT_USED,
          ISURF_DAY_LEFT,
          ISURF_DAY_USED,
          ISURF_NIGHT_LEFT,
          ISURF_NIGHT_USED,
          INUM_AIR_RINGS,
          INUM_SURF_RINGS           # MJC 4/21/2000
literal   CSTRIP8                   # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
integer*4 iview

iview = Xsta$View$i

#______________________________________________________________________
# display DIR information

ifound = $NO
ibase = $NO
for (RTH$Pointer$First; RTH$Pointer$OK; RTH$Pointer$Next)
  {
   if (Xrth$InUse$i == $NO) NEXT
   ibase = $YES                     # there is at least one ROTHR base
   if ( (args[3] == $lex$Base$) & (Xrth$Basename$c != args[4]) ) NEXT
   ifound = $YES                    # a ROTHR base of interest has
                                    # been found
   call dirsleft(RTH$Pointer$Index,air$pca,day$rth,iair_day_left,
                 iair_day_used)
   call dirsleft(RTH$Pointer$Index,surf$pca,day$rth,isurf_day_left,
                 isurf_day_used)
   call dirsleft(RTH$Pointer$Index,air$pca,night$rth,iair_night_left,
                 iair_night_used)
   call dirsleft(RTH$Pointer$Index,surf$pca,night$rth,isurf_night_left,
                 isurf_night_used)
   inum_air_rings = (Rothr$Last$Air$DIR - 500) / air$dir$length
   inum_surf_rings = (Rothr$Last$Surface$DIR - 500) / surf$dir$length

   call echor
   call echov (" ROTHR BASE ")
   call echohn (Xrth$Basename$c,$$MaxLit)
   call echor
   call echov ("   AIR DIRS:  Day -- ")        # display number of
   call echoi (iair_day_used)                     #  AIR DIRs used for
   call echov (" Activated;  ")                #  DAY
   call echoi (iair_day_left)                     # display number of
   call echov (" Remaining")                   #  AIR DIRs remaining
   call echor                                     #  for DAY
   if (iair_day_used != 0)                        
     {
      call echov ("              ( ")
      call disp_dirlist(RTH$Pointer$Index,        # call subroutine
                        inum_air_rings,air$pca,   # to display DIR
                        day$rth)                  # numbers
      call echov (")")
      call echor
     }
   call echov ("              Night -- ")      # display number of
   call echoi (iair_night_used)                   #  AIR DIRs used for
   call echov (" Activated;  ")                  #  NIGHT
   call echoi (iair_night_left)                   # display number of
   call echov (" Remaining")                     #  AIR DIRs remaining
   call echor                                     #  for NIGHT
   if (iair_night_used != 0)
     {
      call echov ("              ( ")  
      call disp_dirlist(RTH$Pointer$Index,        # call subroutine
                        inum_air_rings,air$pca,   # to display DIR
                        night$rth)                # numbers
      call echov (")")  
      call echor
     }
   call echov ("   SURFACE DIRS:  Day -- ")      # display number of
   call echoi (isurf_day_used)                    #  SURFACE DIRs used
   call echov (" Activated;  ")                  #  for DAY
   call echoi (isurf_day_left)                    # display number of
   call echov (" Remaining")                     #  SURFACE DIRs
   call echor                                     #  remaining for DAY
   if (isurf_day_used != 0)
     {
      call echov ("                  ( ")  
      call disp_dirlist(RTH$Pointer$Index,        # call subroutine
                        inum_surf_rings,surf$pca, # to display DIR
                        day$rth)                  # numbers
      call echov (")")  
      call echor
     }
   call echov ("                  Night -- ")    # display number of
   call echoi (isurf_night_used)                  #  SURFACE DIRs used
   call echov (" Activated;  ")                  #  for NIGHT
   call echoi (isurf_night_left)                  # display number of
   call echov (" Remaining")                     #  SURFACE DIRs
   call echor                                     #  remaining for NIGHT
   if (isurf_night_used != 0)
     {
      call echov ("                  ( ")  
      call disp_dirlist(RTH$Pointer$Index,        # call subroutine
                        inum_surf_rings,surf$pca, # to display DIR
                        night$rth)                # numbers
      call echov (")")  
      call echor
     }
  }
if (ibase == $NO)                         # if no rothr bases
  {
   call echov ("There are no rothr bases.")   # display message no rothr
   call echor                                  # base found
   return
  }
if (ifound == $NO)                        # if a particular rothr base
  {                                       # not found
   call echohn (args[4],$$MaxLit)
   Call echov  (" ROTHR Base not found. ")
   call echo   ($BELL)                      # not found
   call echor
  }

return
end # PL_Disply_DIRS


Subroutine PL_Disply_Unit (nord, STA$Pointer, nargs, args) 

#$%  Carol Kropp - January 1994
#$%  Moved code which actually extracts and display information
#$%  moved to a new routine Display_Unit_Information.

BBcommon

BBDeclare  (STA$View$I, UNT$Pointer, UNT$View$I)     # MJC 7/25/2000
literal   CSTRIP8                                    # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
integer*4 icount

icount = 0
STA$View$i = xSTA$View$i

for (UNT$Pointer$First; UNT$Pointer$Valid; UNT$Pointer$Next)
    {
    if (xUNT$Name$c != args[3]) NEXT

    # the unit has been found
    UNT$View$i = xUNT$View$i
    if (STA$View$i == $Neutral$View |     # if control view or unit is
        STA$View$i == UNT$View$i)         # in station view, get info
        {
        icount = icount + 1
        call Display_Unit_Information (STA$Pointer, UNT$Pointer)
        }
    }

if (icount == 0)
    {
    call echov ("No such unit ")
    call echohn (args[3],$$MaxLit)
    call echor
    }

return
end # PL_Disply_Unit


Subroutine PL_Disply_OTG (nord, STA$Pointer, nargs, args) 

#$%  Jim Allen - Aug 2001

BBcommon

BBDeclare  (STA$View$I, UNT$Pointer, UNT$View$I)     # MJC 7/25/2000
literal   CSTRIP8                                    # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
integer*4 icount

icount = 0
STA$View$i = xSTA$View$i

for (UNT$Pointer$First; UNT$Pointer$Valid; UNT$Pointer$Next)
    {
    if (xUNT$Nosicid$i != args[3]) NEXT

    # the unit has been found
    UNT$View$i = xUNT$View$i
    if (STA$View$i == $Neutral$View |     # if control view or unit is
        STA$View$i == UNT$View$i)         # in station view, get info
        {
        icount = icount + 1
        call Display_Unit_Information (STA$Pointer, UNT$Pointer)
        }
    }

if (icount == 0)
    {
    call echov ("No unit with nosic id ")
    call echoi (int(args[3]),$$MaxLit)
    call echor
    }

return
end # PL_Disply_OTG




Subroutine PL_Oshow(nord, STA$Pointer, nargs, args)     # Revised 6/10/88 DEW 
#
# Revision was done to provide clarity, using Switch statements
# All lexical checks are now done in alphabetical order
#
# Modified:  Susan Miller 3/98 (E1955) 
#            Removed references to FOTCP, FOTCS, and RxSignal ASTABS

BBCommon

BBDeclare  (STA$Pointer,  
            SBI$Pointer, 
            SBI$KEY$Index,
            SBI$KEY$req$C)                            # MJC 7/25/2000
integer   IMAX, IDSPLY, IBOARD, ISIDE,                # MJC 4/21/2000
          IVIEW, IREQST, IPNT, IERR, NARGS,           # MJC 4/21/2000
          I_SWITCH_1, I_SWITCH_2, I_SWITCH_3          # MJC 4/21/2000  
integer*4 nord
integer   isValidForceBoard
literal   args[ARB], fname, findText

imax   = xSTA$NbrASTABS$I                       ##extract the number of ASTABS 

if (imax == 0)                                  ## if no ASTABS available
    {
    call echov(" ** ERROR **    No ASTABs available ")  
    call echor
    return
    }

idsply = xSTA$LastSBI$I                         ## extract last req screen nbr
iboard = -1                                     ## set requested board
iside  = -1                                     ## set requested side
iview  = -1                                     ## set requested player
ireqst = $New$Code                              ## update request is NEW
fname  = 0                                      ## force name
findText = 0

ipnt = 2
ierr = NO

switch (args[ipnt])
    {
    case $lex$AAWC$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AIR$:    iboard = $AAWCEvents$Board 
            case $LEX$FLIGHT$: iboard = $AAWCFlight$Board 
            default:           ierr = YES
            }
        }
    case $lex$ACTIVE$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$SONAR$:  iboard = $ActiveSub$board
            case $LEX$TRACKS$: iboard = $Track$Board
            default:           ierr = YES
            }
        }
    case $lex$AIR$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AVAILABILITY$: iboard = $Availability$board
            case $LEX$ALERT$:        iboard = $AirAlert$Board
            case $LEX$EVENTS$:       iboard = $AirEvents$Board
            case $LEX$TRACKS$:       iboard = $ActiveAir$Board
            case $LEX$DESTROYED$:    iboard = $DownedAircraft$Board    # clk 3/92
            case $LEX$DEFENSE$:      iboard = $AirDefenseSAM$Board  # SMM 12/93
            case $LEX$MISSION$:      iboard = $AirMissionHist$Board  # clk 12/96 (E1726)
            case $LEX$ATO$:          iboard = $ATO$Board
            default:                 ierr = YES
            }
        }
    case $lex$AMPHIBIOUS$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AIR$:    iboard = $AmphibEvents$Board 
            case $LEX$FLIGHT$: iboard = $AmphibFlight$Board 
            case $LEX$BOAT$:   
                {
                ipnt = ipnt + 1
                switch (args[ipnt])
                    {
                    case $LEX$OPERATIONS$: iboard = $AmphibBoatOps$Board 
                    default:               ierr = YES
                    }               
                }
            default:           ierr = YES
            }
        }
    case $lex$ASSAULT$:       # reh 12/7/89
        {
        iboard = $Assault$Board
        }
    case $lex$ASUWC$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AIR$:    iboard = $ASUWCEvents$Board 
            case $LEX$FLIGHT$: iboard = $ASUWCFlight$Board 
            default:           ierr = YES
            }
        }
    case $lex$ASWC$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AIR$:    iboard = $ASWCEvents$Board 
            case $LEX$FLIGHT$: iboard = $ASWCFlight$Board 
            default:           ierr = YES
            }
        }
    case $lex$BDA$:                                           # JFR (E1104)
        {
         ipnt = ipnt + 1                                     
         switch (args[ipnt])                                 
             {
             case $LEX$AIR$:    iboard = $AirBDA$Board       
             case $LEX$SHIP$:   iboard = $ShipBDA$Board      
             case $lex$SHORE$:  iboard = $ShorebaseBDA$Board 
             default:           ierr = YES
             }
        }
    case $lex$BOGEY$:
        {
        iboard = $BogeyTote$Board 
        }
    case $lex$CONTINUATION$:
        {
        ireqst = $Continue$Code
        }
    case $lex$DAMAGE$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$UNIT$: iboard = $Damage$Board 
            case $LEX$TIME$: iboard = $DamageTime$Board 
            default:           ierr = YES
            }
        }
    case $lex$EMI$:
        {
        iboard = $EMIstat$Board 
        }
    case $lex$ROUTE$:       # reh 11/20/89
        {
        iboard = $DefinedRoute$Board
        }
    case $lex$EOIR$:
        {
        iboard = $EOIRtrack$Board 
        }
    case $lex$ESM$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AIR$:     iboard = $AirESM$Board 
            case $LEX$SURFACE$: iboard = $SurfESM$Board 
            case $LEX$TRACKS$:  iboard = $ESM$Board 
            default:            ierr = YES
            }
        }
    case $lex$EWC$:
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$AIR$:    iboard = $EWCEvents$Board 
            case $LEX$FLIGHT$: iboard = $EWCFlight$Board 
            default:           ierr = YES
            }
        }
    case $LEX$FLIGHT$:   
        {
        iboard = $Flight$Board 
        }
    case $lex$FORCE$:
        {
        ipnt  = ipnt + 1
        fname = args[ipnt]
        }
    case $lex$HFDF$:
        {
        iboard = $HFDF$Board 
        }
    case $lex$INTELL$:
        {
        iboard = $IntellReport$Board 
        }
    case $lex$JTIDS$:       # clk 12/95 (E1469)
        {
         ipnt = ipnt + 1
         switch (args[ipnt])
           {
            case $Lex$Air$:      iboard = $JTIDSAirTrack$Board
            case $Lex$Land$:     iboard = $JTIDSLandTrack$Board
            case $Lex$Surface$:  iboard = $JTIDSSurfTrack$Board
            default:
              {
               iboard = $JTIDSTrack$Board 
               ipnt = ipnt - 1
              }
           }   # end switch on type specification
        }   # end of if JTIDS
    case $lex$JTMD$:          # clk 5/97 (E1791)
        {
         ipnt = ipnt + 1
         if (args[ipnt] == $lex$ATTACK$)
           iboard = $JTMDAirToGround$Board
        }
    case $lex$MINEFIELD$:   # clk 1/96 (E1364)
        {
        iboard = $MineField$Board 
        }
#    case $lex$NTDS$:          # since this status board wasn't used
#        {                     # it has been replaced with AIRCRAFT
#        ipnt = ipnt + 1       # MISSION HISTORY - clk 12/96 (E1726)
#        switch (args[ipnt])
#            {
#            case $LEX$ACTIVE$:  iboard = $NTDSAct$Board 
#            default:             ierr = YES
#            }
#        }
    case $lex$PASSIVE$:
        {
        iboard = $PassiveSonar$Board 
        }
    case $lex$REPORTING$:
        {
        iboard = $ReportPolicy$Board 
        }
    case $lex$SHIP$:
        {
        iboard = $Ship$Board 
        }
    case $lex$SHORE$:
        {
        iboard = $ShoreBase$Board 
        }
    case $lex$SOSUS$:
        {
        iboard = $Sosus$Board 
        }
    case $lex$SPA$:               # 10/91 clk
        {
        iboard = $SPA$Board 
        }
    case $lex$SUBMARINE$:
        {
        iboard = $Sub$Board 
        }
    case $lex$SURFACE$:
        {
        iboard = $ActiveSurface$Board 
        }
    case $lex$SURVEILLANCE$:
        {
        iboard = $SurvSat$Board 
        }
    case $lex$TEXT$:
        {
        ipnt  = ipnt + 1
        findText = (args[ipnt])
        ireqst = $Find$Code
        }
    case $lex$WEATHER$:
        {
        iboard = $Weather$Board 
        }
    case $lex$ROTHR$:
        {
        iboard = $Rothr$Board
        }
    case $lex$Extension$:                           # DEW 3/7/91
        {
        iboard = $Extension$Board
        }
    case $lex$BOAT$:                                # AM.  added 6/8/89
        {
        ipnt = ipnt + 1
        switch (args[ipnt])
            {
            case $LEX$OPERATIONS$:      iboard = $BoatOps$Board 
            case $LEX$AVAILABILITY$:    iboard = $BoatAvail$Board 
            default:                    ierr = YES
            }
        }
    case $lex$NRT$:                                 # SMM 12/92
        {
        iboard = $NonRealTimeTrack$Board
        }
    default:
        {
        ierr = YES
        }
    }

if (ierr == YES)
   {
    call echov(" Sorry but that information does not exist")  
    call echor
    return
   }

ipnt = ipnt + 1

if (nargs >= ipnt)                              ## if three or more args
    {
    switch (args[ipnt])
        {
        case 1-6:          idsply = args[ipnt]
        case $LEX$Blue$:   iside  = $Blue$code
        case $LEX$Orange$: iside  = $Orange$code
        default:           iside  = $Neutral$Code
        }
  
   if (nargs >= ipnt+1)                                 ## if four or more args
        {
        switch (args[ipnt+1])
            {
            case 1-20:          iview = args[ipnt+1]
            case $LEX$Blue$:    iside = $Blue$Code
            case $LEX$Orange$:  iside = $Orange$Code
            default:            iside = $Neutral$Code
            }

        if (nargs == ipnt+2)                            ## if five args
            {
            switch (args[ipnt+2])
                {
                case 1-20:          iview = args[ipnt+2]
                }
            }
        }  
    }    

if (idsply < 1)         idsply = 1              ## If no screen nbr set default
if (idsply > imax)      idsply = imax           ## never more than max screen
                                                ## 3 Aug TDB

if (iboard == $Extension$Board) idsply = max (idsply, 2)    # DEW 3/7/91
                                                # Cannot extend 1st ASTAB

putSTA$LastSBI$I(idsply)                        ## put screen number in STA
                                                ## 3 Aug TDB
SBI$Pointer$To (xSTA$SBIindex$I + idsply -1)    ## set SBI pointer      

if (iboard >= 0)   putSBI$ReqBoard$I(iboard)    ## if req board changed
if (iside  >= 0)   putSBI$ReqSide$I(iside)      ## if requested side changed
if (iview  >= 0)   putSBI$ReqPlayer$I(iview)    ## if requested player changed

if (findText != 0)                              ## show text
    {
                   putSBI$AstabFindText$c(findText)
    }

if (ireqst != $Find$code)               # Clear position on page for found text
    {
                   putSBI$CurrFindLine$i(0)
                   putSBI$CurrFindCol$i(0)
    }

for(SBI$KEY$Index = 1;SBI$KEY$Index$Ok;SBI$KEY$Index =SBI$KEY$Index + 1)
   {
    SBI$KEY$Req$C = 1
    putSBI$KEY$Req$C
   } 

if (fname != 0)
{
    if (IsValidForceBoard(XSBI$CurrBoard$i) == $yes)
    {
        SBI$KEY$Index = 1
    
        putSBI$KEY$Req$C (fname)

        if (XSBI$CurrBoard$i == $BoatAvail$Board)
        {
            SBI$KEY$Index = 2
    
            putSBI$KEY$Req$C (" ")      # Clear class key
        }        
    }
    else
    {
        call echov(" Sorry but SHOW FORCE not appropriate for current board.")  
        call echor
        return
    }
} 

putSBI$ReqSect$I(1)                             ## set for first section
putSBI$UpdateRequest$I(ireqst)                  ## put updated request in SBI

return
end

Integer function IsValidForceBoard(iboard)
integer iboard, isvalid
integer I_SWITCH_1

isvalid = $NO

switch (iboard)
{
    case $Availability$board:       isvalid = $YES
    case $AirAlert$Board:           isvalid = $YES
    case $AirEvents$Board:          isvalid = $YES
    case $Assault$Board:            isvalid = $YES
    case $ASUWCEvents$Board:        isvalid = $YES
    case $ASUWCFlight$Board:        isvalid = $YES
    case $ASWCEvents$Board:         isvalid = $YES
    case $ASWCFlight$Board:         isvalid = $YES
    case $DefinedRoute$Board:       isvalid = $YES
    case $EWCEvents$Board:          isvalid = $YES
    case $EWCFlight$Board:          isvalid = $YES
    case $Flight$Board:             isvalid = $YES
    case $ReportPolicy$Board:       isvalid = $YES
    case $Ship$Board:               isvalid = $YES
    case $ShoreBase$Board:          isvalid = $YES
    case $Sub$Board:                isvalid = $YES
    case $BoatOps$Board:            isvalid = $YES
    case $BoatAvail$Board:          isvalid = $YES
    default:                        isvalid = $NO
}

return(isvalid)
end



Subroutine PL_RBTO(ionum,                              #receive order number 
                   ista,                               #receive station
                   iword,                              #receive word count
                   ilex)                               #receive command string

##################################################################
#$%
#$% Purpose:    PL_RBTO generates range and bearing (or bearing only
#$%             in certain cases) to a target based on lat/long (true
#$%             if target held visually - otherwise apparent)
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      FNDOWN     GTACT     ECHOH    ECHOHN     RLL2RB
#$%             ECHOI      ECHOIZ    ECHOR
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
####################################################################

BBcommon

BBDeclare  (sta$pointer, own$pointer, rmt$pointer,
            unt$pointer, unt$view$I)                    # MJC 7/25/2000
literal cstrip8                                         # MJC 4/20/2000
real    range, brg                                      # MJC 4/20/2000
integer iword, irng, ibrg, ista, iview,
        ionum, i, ipnt, ibonly, idummy, noroom          # MJC 4/20/2000
literal ilex[iword], hold[28],  ierror[4]
integer hlen, kk
real    lat[2],lon[2],clat[2], DMS2rad

STA$POINTER$TO ista
iview = xSTA$View$I

#$% initialize values
hold[1] = 0
hold[2] = 0
hold[3] = ionum

#$% for each word, get input string
for (i = 1; i <= iword; i = i + 1) hold[i+3] = ilex[i]

#$% get length of string
hlen = iword + 3

#$% initialize the array position
ipnt = 2

 for (i = 1; i <= 2; i = i + 1)
    {
     ierror[1] = 'ok'                        #initialize
     ibonly    = $no

     #$% if input string is Force
     if (ilex[ipnt] == $Lex$Force$)
        {
         call untfnd(iview,
                ILEX[ipnt+1],
                unt$POINTER)

         #$% if pointer not in range
         if (! unt$pointer$Valid)
            {
             #$% set error flag
             ierror[1] = '?????'
             break
            }

         unt$View$i = xunt$View$i               # jb            12/8/86
         #$% if CONTROL is requesting view or unit is a shorebase
         if (iview == $neutral$view | xunt$type$i == $shorebase$code)
            {
             #$% get true position
             lat[i] = Xunt$TrueLatitude$f
             lon[i] = Xunt$TrueLongitude$f
            }
         #$% else if own view is the requesting view 
         else if (unt$View$i == iview)          # jb - no X   12/8/86
            {
             #$% find available slot on OWN table
             call FNDOWN(own$pointer,unt$pointer$index,idummy,noroom)

             #$% if OWN table full or own unit not found
             if (noroom == $yes | Xown$Unit$i == 0)
                {
                 #$% set error flag and break
                 ierror[1] = '?????'
                 break
                }
             #$% get own position
             lat[i] = Xown$Latitude$f
             lon[i] = Xown$Longitude$f
            }
         else if (iview > $LASTBLUE$view & unt$View$i < $FIRSTORANGE$View |
                  iview < $FIRSTORANGE$View & unt$View$i > $LASTBLUE$view )
            {                           # jb                    12/8/86
                 #$% Only CONTROL may specify forces on opposing sides..
                 ierror[1] = '?????'
                 break
            }

         #$% go to next position in the array
         ipnt = ipnt + 2
        }                                           #end if to or from force

     #$% else if input string is Track
     else if (ilex[ipnt] == $Lex$Track$)
        {
         #$% initialize remote track pointer
         RMT$Pointer = 0

         #$% get active track from remote track table
         call gtact(iview,ilex[ipnt+1],rmt$pointer,ibonly)

         #$% if track not found
         if (RMT$Pointer == 0)
            {
             #$% set error flag and break
             ierror[1] = '?????'
             break
            }

         #$% if Control is requesting view
         if (iview == $neutral$view)      
            {
             #$% set pointer to detectee in remote track table
             unt$pointer$to xrmt$detectee$i

             lat[i] = Xunt$truelatitude$F        #true position of detectee
             lon[i] = Xunt$truelongitude$F
            }
         #$% if the track is active
         else if (ibonly == $no)
            {
             #$% get apparent position
             lat[i] = Xrmt$ApparentLat$f
             lon[i] = Xrmt$ApparentLon$f
            }
         else
            {
             #$% set error flag and break
             ierror[1] = '?????'
             break
            }

         #$% go to next position in the array
         ipnt = ipnt + 2
        }
     else
        {
         #$% get position in radians
#         lat[i] = DEGMRA(int(ilex[ipnt+1]))
#         lon[i] = DEGMRA(int(ilex[ipnt+2]))
         lat[i] = DMS2rad(ilex[ipnt+1])
         lon[i] = DMS2rad(ilex[ipnt+2])

         #$% go to next position in the array
         ipnt = ipnt + 3
        }
    }

 #$% if error flag activated
 if (ierror[1] == '?????')  
    {
     #$% get error values and display
     ierror[2] = ilex[ipnt+1]
     call echohn(ilex[ipnt+1],$$MaxLit)

     #$% if track is active
     if (ibonly == $no)
        {
         #$% get word "unknown" and display         
         ierror[3] = $Lex$Unknown$
         kk = 0; call smovv ("        ", ierror[4], kk)
         call echov(" Unknown ")  
        }
     else
        {
         #$% if bearing known, get and display "bearing only"
         ierror[3] = $Lex$Bearing$
         ierror[4] = 'ONLY'
         call echov(" Bearing Only ")  
        }

     #$% set all four ierror data entries to the hold array
     do i=1,4
        {
         hlen = hlen + 1
         hold[hlen] = ierror[i]
        }
    }

 else
    {
     clat[1] = COS(lat[1])                     #get cosine of from lat
     clat[2] = COS(lat[2])                     #get cosine of to lat

     #$% convert target range and bearing from lat/long
     call RLL2RB(lat[1],lon[1],clat[1],lat[2],lon[2],clat[2],range,brg)

     irng = INT(range + .5)                     #get range as integer

     ibrg = INT(brg*(180./$pi) + .5)            #get bearing in degrees

     if (ibrg > 359) ibrg = ibrg - 360

     #$% add range and bearing data to hold array
     hlen = hlen+1 ; hold[hlen] = ibrg
     hlen = hlen+1 ; hold[hlen] = 'RANGE'
     hlen = hlen+1 ; hold[hlen] = irng

     #$% display target range and bearing
     call echov(" BEARING ")  
     call echoiz(ibrg,3)
     call echov(" RANGE ")  
     if (range <= 10.0)
        {
        call echof(range,2)
        }
     else
        {
        call echoi(irng)
        }
    }                                           #end if inputs were valid
 
# call send_(iview ,"LEX ",hlen,hold)
 call echor

 return
 end




Subroutine PL_XCIR(ionum,                              #receive order number 
                   ista,                               #receive station
                   iwords,                             #receive number words
                   ilex,                               #receive parameters
                   indx)                               # out: plc or lin indx
##################################################################
#$%
#$% Purpose:    PL_XCIR generates an XMARK, CIRCLE, RECTANGLE,
#$%             POLYGON, LINE SEQUENCE or GRID on a geographic plot
#$%             with characteristics as requested by the player
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      FNDOWN     GTACT     ECHOH    untfnd
#$%             SMOVH      ECHOR     send_
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
#$% Modified:  Jim Allen - 2/98 (E1864)
#$%            Added argument to PL_xcir to return the PLC table entry
#$%            index, used for Improved Cruise Missile Model, so the
#$%            CM planning knows the location.
#$%
####################################################################

BBcommon

############################################################################
#ILEX
#1         2               3         4                       5          6
#
#PLACE (a) GRID (around) FORCE    <force-name> (w/radius) <nau-miles>
#PLACE (a) GRID (around) TRACK    <track-no>
#PLACE (a) GRID (around) POSITION <latitude>              <longitude><nau-mi>
#
#PLACE (a) CIRCLE (around) FORCE    <force-name> (w/radius) <nau-miles>
#PLACE (a) CIRCLE (around) TRACK    <track-no>
#PLACE (a) CIRCLE (around) POSITION <latitude>              <longitude><nau-mi>
#                                             
#PLACE (a) XMARK (on)      FORCE    <force-name>
#PLACE (a) XMARK (around) TRACK    <track-no>
#PLACE (a) XMARK (around) POSITION <latitude>              <longitude>
#
#  1        2     
#PLACE (a) RECTANGLE (around)
#               [FORCE <force-name> |   [4]    
#               POSITION <latitude> <longitude> |  [4] and [5]
#               TRACK <track-no> ]      [4]
#                 [3]           (length) <nautical-miles> [5] or [6]
#                               (orientation) <degrees>   [6] or [7] 
#                               (width) <nautical-miles>; [7] or [8]
#
#CANCEL    CIRCLE          ALL 
#          XMARK           FORCE    <name> 
#          GRID            TRACK    <track-no> 
#          RECTANGLE       POSITION <latitude> <longitude>
###############################################################################

BBDeclare  (NUC$Pointer, NUC$Radius$I,
            PLC$Orient$I, PLC$Width$I, PLC$Pointer,
            PLC$Referencetype$I, PLC$Reference$I,
            PLC$Station$I, PLC$Type$I, PLC$Radius$I,
            PLC$Latitude$F, PLC$Longitude$F,
            STA$Pointer, UNT$Pointer, OWN$Pointer,
            RMT$Pointer)                            # MJC 8/1/2000
integer   IWORDS, ISTA, IVIEW, IONUM, IPLUS,        # MJC 4/20/2000
          IDUMMY, NOROOM, JJ, IBONLY                # MJC 4/20/2000
literal   ILEX[iwords]
real      DMS2rad
Character msg[ARB]
integer   indx
real*4    DLAT, DLON                                # MJC 5/11/2000
#String msg1 "      not found for circle or x-mark.   "
#String msg2 "Passive track        invalid for circle or x-mark.  "

indx = 0
PLC$STATION$I = ista

STA$Pointer$To ista
iview = xSTA$View$I

#$% determine if XMARK or CIRCLE requested and set PLC$TYPE$I
if      (ILEX[2] == $LEX$XMARK$ ) PLC$TYPE$I = $XMARK$CODE
else if (ILEX[2] == $LEX$CIRCLE$) PLC$TYPE$I = $Circle$CODE
else if (ILEX[2] == $LEX$GRID$)   PLC$TYPE$I = $GRID$CODE
else if (ILEX[2] == $LEX$RECTANGLE$) PLC$TYPE$I = $RECTANGLE$CODE
else if (ILEX[2] ==$LEX$POLYGON$ | ILEX[2] ==$LEX$LINE$ | ILEX[2] ==$LEX$COLOR$)
    {   #  jb                                                9/19/90
    CALL PL_XLIN(ionum,                              #receive order number 
                   ista,                               #receive station
                   iwords,                             #receive number words
                   ilex,                               #receive parameters
                   indx)
    RETURN
    }                           

iPLUS = 0       # jb - initlz for [  +iPLUS]    6/30/87

#$% if the mark/circle is to be placed on a force: 
if (ILEX[3] == $LEX$FORCE$)
    {
    #$% find the unit
    call untfnd(iview,
                ILEX[4],
                unt$POINTER)

     #$% if unit found and view is not the Control view
     if (unt$pointer != 0 & iview != $neutral$view)
        {
         #$% find available slot on OWN table
         call FNDOWN(own$pointer,
                     unt$pointer$index,
                     idummy,
                     noroom)

         #$% if OWN table full or owm unit not found, zero pointer
         if (noroom == $yes | Xown$Unit$i == 0) unt$pointer = 0
        }

     if (unt$POINTER == 0)                 #if force not found
        {
         #$% move unit name into message array, display message(1)
         #$% to requesting view and return
         jj = 0
         call SMOVHN(ilex[4],$$MaxLit,msg,jj)   
         Call SMOVV(" not found for circle or x-mark.  ",msg,jj)
#        call send_(PLC$STATION$I,0,jj,msg)  # formerly msg1
         call echoh(msg,jj) 
         call echor
         return
        }

     #$% if view is the Control view
     if (iview == $neutral$view)
        {
         #$% use true (vice apparent) reference 
         plc$ReferenceType$i = $True$code
         #$% set reference to pointer index
         plc$Reference$i = unt$pointer$index
        }
     #$% else if view is not the Control view
     else
        {
         #$% set own force as reference
         plc$ReferenceType$i = $OwnForce$code
         #$% set reference to OWN pointer index
         plc$Reference$i = own$pointer$index
        }

    PLC$RADIUS$I = ILEX[5]      # (overlays $Length$i)
    }

 #$% else if the mark/circle is to be placed on a track:
 else if (ILEX[3]  == $LEX$TRACK$)
    {
     #$% set remote track pointer to zero
     RMT$Pointer = 0

     #$% get active track from remote track table
     call gtact(iview,
                ILEX[4],
                RMT$POINTER,
                ibonly)

     if (rmt$POINTER == 0)                 #if track not found
        {
         #$% move track ID into message array, display message(1)
         #$% to requesting view and return
         jj = 0
         call SMOVHN(ilex[4],$$MaxLit,msg,jj)
         Call SMOVV(" not found for circle or x-mark.  ",msg,jj)
#        call send_(PLC$STATION$I,0,jj,msg) # formerly msg1
         call echoh(msg,jj)
         call echor
         return
        }

     if (ibonly == $yes)                  #if track passive
        {
         #$% move track ID into message array, display message(2)
         #$% to requesting view and return
         jj = 0
         Call SMOVV("Passive track ",msg,jj)
         call SMOVHN(ilex[4],$$MaxName,msg,jj) # SMM 8/99 E2141
         Call SMOVV(" invalid for circle or x-mark.  ",msg,jj)
#        call send_(PLC$STATION$I,0,jj,msg) # formerly msg2
         call echoh(msg,jj)
         call echor
         return
        }

     plc$ReferenceType$i = $OtherForce$code
     plc$Reference$i = rmt$pointer$index
     PLC$RADIUS$I = ILEX[5]     # (overlays $Length$i)
    }
    #$% if input is a position
else #  if (ILEX[3] == $LEX$POSITION$)
    {
     iPLUS = 1  # jb (see IF (plc$TYPE$i, below) 6/30/87

    #$% get Lat/Long in radians and save
    PLC$LATITUDE$F  = DMS2rad(ILEX[4])
    PLC$LONGITUDE$F = DMS2rad(ILEX[5])
    PLC$RADIUS$I    = ILEX[6]   # (overlays $Length$i)

    plc$ReferenceType$i = $null$code
    plc$Reference$i = 0

    }

if (PLC$TYPE$I == $RECTANGLE$CODE)      # jb    6/30/87
 {
  PLC$ORIENT$I = ILEX[ 6 +iPLUS ]       # jb    6/30/87
  PLC$Width$I  = ILEX[ 7 +iPLUS ]       # jb    6/30/87
 }

#$% if command entered to cancel
if (ILEX[1] == $Lex$Erase$)
    {
    for (PLC$POINTER$FIRST;PLC$POINTER$Valid;PLC$POINTER$NEXT) #search arry
        {
        if (XPLC$STATION$I != PLC$STATION$I |
            Xplc$type$i != plc$type$i ) NEXT

        if (ILEX[3] == $LEX$ALL$)
           {
            #$% clear marks/circles
            PLC$ZERO
            next
           }
        
        if (Xplc$ReferenceType$i != plc$ReferenceType$i | 
            Xplc$Reference$i     != plc$Reference$i     ) next

        if (ILEX[3] == $LEX$POSITION$)          ## 5/17/83 tpa
            {                                           ## if cancel on posi
            dlat = abs (XPLC$Latitude$F  - PLC$Latitude$F )
            dlon = abs (XPLC$Longitude$F - PLC$Longitude$F)

            if (dlat <= ($pi/180)/(60/2) &              # within 2 minutes
                dlon <= ($pi/180)/(60/2) )   PLC$ZERO
            }

        else 
           {
            PLC$ZERO            # clear marks/circles/grids
           }
        }

    if (Nuclear$Capable == $YES & ilex[2] == $LEX$CIRCLE$ &
        ilex[3]         == $Lex$All$)   ## can all nuc circles
        {
        for (NUC$Pointer$First;NUC$Pointer$Valid;NUC$Pointer$Next) #search arry
            {
            NUC$Radius$I = xNUC$Radius$I

            if (NUC$Radius$I == 0) next

            NUC$ZERO
            }
        }
    }        # End if this is a ERASE order
    ######################################################
else    # (This is a "PLACE" rather than a "ERASE" order..)
    {
    for (PLC$POINTER$FIRST;PLC$POINTER$VALID;PLC$POINTER$NEXT) #search array
        {
         #$% if station owner of mark/circle not found, break
         if (XPLC$STATION$I == 0)  break
        }

    #$% if table full
    if (!plc$pointer$valid)
       {
        call echov ("  Table full.")  
        return
       }

    #$% save the data

    plc$Radius$i = min(max(plc$Radius$i, 1), 2000)

    PUTplc$View$i  (iview)      # jb            7/8/87
    PUTplc$Radius$i             # (overlays LENGTH$i)
    PUTplc$Type$i
    PUTPLC$STATION$I
    PUTplc$Reference$i
    PUTplc$ReferenceType$i
    PUTPLC$LATITUDE$F
    PUTPLC$LONGITUDE$F

    if (PLC$TYPE$I == $RECTANGLE$CODE)             # jb       6/30/87
     {
      if(PLC$Width$I < 1) PLC$Width$i = 1 # jb  protect ATAN2 8/17/88
      putPLC$Width$I                                # jb      6/30/87
      putPLC$ORIENT$I                               # jb      6/30/87
     }

    #$% reset pointer
    if (!plc$pointer$OK) plc$last$to plc$pointer + plc$entry - 1
    indx = plc$pointer$index
    }

 return
 end



Subroutine PL_ENVEL(ionum,                               #receive order number
                    ista,                                #receive station
                    iwords,                              #receive number words
                    ilex)                                #receive parameters

##################################################################
#$%
#$% Purpose:    PL_ENVEL generates an envelop on the geogrphic plot
#$%             whose characteristics are entered by the player
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      NONE
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
####################################################################

BBcommon

BBDeclare  (STA$Envelopesource$I,
            STA$Envradius$I,
            STA$Envelopes$I,
            STA$Pointer)                # MJC 4/20/2000
integer IWORDS, ISTA, Ionum             # MJC 4/20/2000
literal ilex[iwords]

STA$POINTER$TO ista                             #get sta pointer

STA$ENVELOPES$I = $NO                           #indicate no envelops

if(ILEX[2] != $LEX$OFF$)                        #if envelopes are not off
   {
    #$% get envelop source
    if     (ILEX[2] == $LEX$ALL$)       STA$ENVELOPESOURCE$I = $ALL$CODE
    else if(ILEX[2] == $LEX$SUBMARINE$) STA$ENVELOPESOURCE$I = $SUB$CODE
    else if(ILEX[2] == $LEX$SURFACE$)   STA$ENVELOPESOURCE$I = $SURFACE$CODE

    STA$ENVRADIUS$I = ILEX[3]                   #enter radius
    PUTSTA$ENVRADIUS$I

    putSTA$ENVELOPESOURCE$I                     #store envelope source

    STA$ENVELOPES$I = $YES                      #enable envelopes
   }                                            #endif envelopes are not off

putSTA$ENVELOPES$I                              #store envelope status

return

end




Subroutine PL_LABEL(nord,                       #receive order number 
                    ista,                       #receive station
                    nargs,                      #receive number words
                    args)                       #receive parameters

###########################################################################
#$%
#$% Purpose:    PL_LABEL generates labels (unit name, track number and
#$%             other data) on the geogrphic plot as requested by the player
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      NONE
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
#$% Modified:   Carol Kropp - 11/96 (E1677)
#$%             Added branch to handle new LABEL ROUTE ... command.
#$%
############################################################################

BBcommon

BBDeclare  (STA$Pointer)            # MJC 8/1/2000
integer     NARGS, ISTA, Nord, iarg
literal     args[nargs]

STA$Pointer$To ista                             #get view pointer

if (args[1] == $lex$LABEL$) iarg = 2
else                        iarg = 3

if      (args[iarg] == $LEX$ALL$)     PUTsta$Label$I ($YES)     # labels on
else if (args[iarg] == $LEX$OFF$)     PUTsta$Label$I ($NO)      # labels off
else if (args[iarg] == $LEX$ON$)      PUTsta$Label$I ($YES)     # labels on
else if (args[iarg] == $LEX$ROUTE$)   call pl_label_routes (ista, nargs, args)
else if (args[iarg] == $LEX$SPA$)     call pl_label_spas (ista, nargs, args)
else if (args[iarg] == $LEX$LINE$)    call pl_label_lines (ista, nargs, args)
else if (args[iarg] == $LEX$POLYGON$) call pl_label_lines (ista, nargs, args)
else if (args[iarg] == $LEX$LANDING$) call pl_label_landings (ista, nargs, args)

return
end


Subroutine PL_LOB(IONUM,                          #receive order number 
                  ista,                           #receive station
                  IWORDS,                         #receive number of words
                  ILEX)                           #receive parameters

#########################################################################
#$%
#$% Purpose:    PL_LOB generates a line of bearing on the geogrphic plot
#$%             whose characteristics are entered by the player
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      untfnd
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
############################################################################

BBcommon

BBDeclare  (UNT$Pointer, STA$Pointer)           # MJC 8/1/2000 
integer     IWORDS, ISTA, IVIEW                 # MJC 4/20/2000
integer     INEW, IOLD, Ionum                   # MJC 4/20/2000
literal     ILEX[iwords]

STA$POINTER$TO ista                             #get view pointer
iview = xSTA$View$I

if (ILEX[2] == $LEX$OFF$)                       #if bearings off
   {
    putSTA$BearingSource$I    (0)
    putSTA$AltBearingSource$I (0)
   }
else if (ILEX[2] == $LEX$ALL$)                  #if bearings from all
   {
    putSTA$BearingSource$I    (unt$SLOTS+1)
    putSTA$AltBearingSource$I (0)

    PUTsta$PlotSonar$i    (YES)
    PUTsta$PlotEsm$i      (YES)
   }
else if(ILEX[2] == $LEX$FORCE$)                 #if bearings from a force
   {
    call untfnd(IVIEW,                          #locate the force
                ILEX[3],
                unt$POINTER)                    #receive the force pointer

    #$% if force pointer found, match it to bearing souce, else set to zero

    if (unt$pointer != 0) 
        {
        inew = unt$POINTER$INDEX                # get new source/and save it
        iold = Xsta$BearingSource$i             # get old bearing source

        PUTsta$BearingSource$i (inew)

        PUTsta$AltBearingSource$i (iold)
        }
    else
        {
        # error... could not find the force (maybe call SEND and tell him)
        }
    }

return
end






Subroutine PL_MARKU(IONUM,                        #receive order number 
                    ista,                         #receive station
                    IWORDS,                       #receive number of words
                    ILEX)                         #receive parameters

#########################################################################
#$%
#$% Purpose:    PL_MARKU generates the data for an X positioned on a track 
#$%             if mark track is requested or a bearing line from a track
#$%             if mark bearing is requested.  Also clears mark track and
#$%             mark #$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      NONE
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
############################################################################

BBcommon

BBDeclare  (MRK$Pointer, MRK$Type$I, MRK$Cat$I,
            MRK$Station$I, MRK$Latitude$F, MRK$Longitude$F,
            MRK$Label2$C, MRK$Label1$C,
            BMK$Station$I, BMK$Pointer,
            BMK$Bearing$F, BMK$Name$C, 
            STA$Pointer)                                    # MJC 8/1/2000 
integer IWORDS, ISTA, IVIEW, IGOT, Ionum, kk
literal CSTRIP8                                             # MJC 4/20/2000
literal ILEX[iwords]
real    DMS2rad

STA$Pointer$To ista
iview = xSTA$View$I                                     #       3/16/83

repeat
   {
    #$% if mark (ie. mark track or mark bearing) entered
    if (ILEX[1] == $LEX$PLOT$)                  
       {
        #$% if mark is to cover a track (ie. mark track)
        if (ILEX[2] == $LEX$TRACK$)    
           {
            #$% set flag to default value
            IGOT = $NO                   

            #$% for each mark entry
            for (MRK$POINTER$FIRST;MRK$POINTER$VALID;MRK$POINTER$NEXT)
               {
                #$% if mark label (track name) not found, next
                if (XMRK$LABEL1$C != 0) next 

                #$% if mark pointer is in last position
                if(MRK$POINTER > MRK$LAST)
                   {
                    #$% reset last pointer position
                    MRK$LAST$TO MRK$POINTER + MRK$ENTRY -1
                   }

                IGOT = $YES                     #indicate found

                break                           
               }                                
            #$% if label (track name) not found, break
            if (IGOT == $NO) break 

            #$% get mark type requested and save
            if      (ILEX[3] == $LEX$ENEMY$)    MRK$TYPE$I = $ENEMY$CODE
            else if (ILEX[3] == $LEX$FRIENDLY$) MRK$TYPE$I = $FRIENDLY$CODE
            else if (ILEX[3] == $LEX$NEUTRAL$)  MRK$TYPE$I = $NEUTRAL$CODE
            else if (ILEX[3] == $LEX$UNKNOWN$)  MRK$TYPE$I = $UNKNOWN$CODE
            PUTMRK$TYPE$I                       

            PUTMRK$TYPE$I                       

            #$% get ID category and save
            if      (ILEX[4] == $LEX$AIR$)       MRK$CAT$I = $AIR$CODE
            else if (ILEX[4] == $LEX$SUBMARINE$) MRK$CAT$I = $SUB$CODE
            else if (ILEX[4] == $LEX$SURFACE$)   MRK$CAT$I = $SURFACE$CODE
            PUTMRK$CAT$I                        

            #$% get station from where the request originated
            MRK$Station$I = ista
            putMRK$Station$I

            #$% get latitude/longitude is radians from player input and save 
            MRK$LATITUDE$F = DMS2rad(ILEX[5])
            MRK$LONGITUDE$F = DMS2rad(ILEX[6])

            PUTMRK$LATITUDE$F
            PUTMRK$LONGITUDE$F

            #$% get entered track name and save
            MRK$LABEL1$C = ILEX[7]    
            PUTMRK$LABEL1$C

            #$% get entered amplifying data on track entered 
            #$% above (if any) and save
            MRK$LABEL2$C = ILEX[8]              #enter label 2
            if (ilex[8]== 'XXXXX')
            {
                kk = 0
                call smovv ("        ", MRK$LABEL2$C, kk)
            }
            PUTMRK$LABEL2$C

            break                               #exit the subroutine
           }                                    #endif track

        #$% set flag to default value
        IGOT = $NO                   

        #$% if first player input was "Mark" but second was NOT "Track,"
        #$% then is has to be "Bearing" (ie. Mark Bearing)
        #$% for each bearing mark 
        for (BMK$POINTER$FIRST;BMK$POINTER$VALID;BMK$POINTER$NEXT)
           {
            #$% if track name not found, next
            if (XBMK$NAME$C != 0) next 

            #$% if mark bearing pointer in last position
            if(BMK$POINTER > BMK$LAST)
               {
                #$% reset position of last pointer
                BMK$LAST$TO BMK$POINTER + BMK$ENTRY -1
               }

            #$% indicate track name found
            IGOT = $YES                  

            break                               
           }                                    

        #$% if track name not found, break
        if (IGOT == $NO) break     

        #$% get name of track that bearing is requested for
        BMK$NAME$C = ILEX[3]                    

        #$% set flag to default value
        IGOT = $NO                              #indicate no mark match

        #$% for each mark
        for (MRK$POINTER$FIRST;MRK$POINTER$VALID;MRK$POINTER$NEXT)
           {
            #$% search until mark track name same as mark bearing name
            if(XMRK$LABEL1$C != BMK$NAME$C) next

            #$% name found
            IGOT = $YES   

            break         
           }                                    #end search for mark

        #$% if name not found, break
        if (IGOT == $NO) break 

        #$% save the mark bearing name
        PUTBMK$NAME$C    

        BMK$Station$I = ista                    #enter the station
        putBMK$Station$I

        #$% get the bearing entered by the player and save
        BMK$BEARING$F = (ILEX[4]/180.) * $PI    
        PUTBMK$BEARING$F

        break                                   #exit the subroutine
       }                                        #endif mark order


    #$% if the first input is NOT "Mark", then it is "Unmark" by
    #$% default and if second input is Bearing (ie. Unmark Bearing)
    if (ILEX[2] == $LEX$BEARING$)       
       {
        if (ILEX[3] == $LEX$ALL$)               #if unmark all
           {
            #$% clear all entries
            for(BMK$POINTER$FIRST;BMK$POINTER$VALID;BMK$POINTER$NEXT)
                {
                if (xBMK$Station$i != ista) next

                BMK$ZERO                        
                }
            break                               #exit the subroutine
           }
        #$% find one name (vice all) and clear entry
        for(BMK$POINTER$FIRST;BMK$POINTER$VALID;BMK$POINTER$NEXT)
           {
            if(XBMK$NAME$C != ILEX[4]) next     

            if (xBMK$Station$i != ista) next

            BMK$ZERO                            
           }

        break                                   #exit the subroutine
       }                                        #endif unmark bearing

    #$% if third entry is All
    if (ILEX[3] == $LEX$ALL$)
       {
        #$% clear all "Mark Track" entries
        for(MRK$POINTER$FIRST;MRK$POINTER$VALID;MRK$POINTER$NEXT)
            {
            if (xMRK$Station$i != ista) next

            MRK$ZERO            
            }
        break                                   #exit the subroutine
       }
    #$% for each "Mark Track" entered
    for (MRK$POINTER$FIRST;MRK$POINTER$VALID;MRK$POINTER$NEXT)
       {
        #$% find mark track entered and clear the entry
        if (XMRK$LABEL1$C != ILEX[4]) next 

        if (XMRK$STATION$i != ista) next 

        MRK$ZERO                                
       }

    break                                       
   }                                            

return
end


Subroutine PL_PLOT (IONUM,                      #receive order number 
                    ista,                       #receive station
                    IWORDS,                     #receive number of words
                    ILEX)                       #receive parameters

#########################################################################
#$%
#$% Purpose:    PL_PLOT generates data to set the radius of a plot in NM
#$%             and plots (updates) the graphics displays as requested
#$%             by a player (responding to ERASE as well as PLOT commands).
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      NONE
#$%
#$% Author:     D. Wills
#$%
#$% Date:       MAY 1983
#$%
#$% Modified:   Carol Kropp - 12/92  (E1036)
#$%             When a control station enters the PLOT STATION x command
#$%             extract the geo center and radius data from that station
#$%             and store it in the control station's STA slot.  PTMAIN
#$%             will get the geo center and radius data from the control
#$%             station - this permits resizing and recentering of the geo.
#$%
#$%             Carol Kropp - 1/94
#$%             Added station ability to plot/erase ghost units.
#$%
#$%             Carol Kropp - 9/95 (E1456)
#$%             Expanded PLOT/ERASE GHOST command to allow unit types.
#$%             Added PLOT/ERASE GROUND SAM (missile radius information).
#$%
#$%             Carol Kropp - 12/95 (E1469)
#$%             Added station ability to plot/erase incoming JTIDS data.
#$%
#$%             Carol Kropp - 11/96 (E1695)
#$%             Added station ability to plot/erase incoming CEC data.
#$%
#$%             Carol Kropp - 12/96 (E1707)
#$%             Rather than process [ PLOT | ERASE ] JTIDS directly,
#$%             branch off to a subroutine.
#$%
#$%             James Allen - 7/96 (E1602)
#$%             Added processing of new PLOT MDM commands.
#$%
#$%             Carol Kropp - 2/97 (E1731)
#$%             Added station ability to plot/erase persistent munitions.
#$%
#$%             Carol Kropp - 10/97 (E1513)
#$%             Handle hide sites differently for plot/erase all, since
#$%             only the sides hide sites are to be seen.  Also fixed the
#$%             plot/erase hide so that play viewswould not see neutral.
#$%
#$%             James Allen - 12/97 (E1636)
#$%             Set the PlotMap flag when processing PLOT STATION OWN,
#$%             so the graphic program will redisplay.
#$%
#$%             Jim Allen - 2/98 (E1864)
#$%             The PIM table index is stored in the STA table,
#$%             rather than the PIM name - changed usage.  Added
#$%             plotting of cruise missile plans.
#$%
############################################################################

BBcommon

BBDeclare  (STA$Pointer, STA$Plotmap$I,
            STA$Geotype$I, STA$TRK$Index, STA$Mcpntr$I,
            STA$Samrange$I, STA$Emitcs$I, STA$Plotpimindx$I,
            STA$Rothrairsurfpca$I, STA$Rothrdaynightpca$I,
            STA$Rothrorder$I, STA$Rothrindx$I,
            STA$Firstlat$F, STA$Lastlat$F)                  # MJC 8/1/2000
BBDeclare  (PLC$Reference$I, PLC$Referencetype$I, PLC$Type$I,
            PLC$Station$I, PLC$Pointer, SAT$Pointer,
            UNT$Pointer, PIM$Pointer, LIN$Pointer,
            RTH$Pointer, RMT$Pointer, MC$Pointer)           # MJC 8/1/2000
integer IWORDS, ISTA, IVIEW, IOK, ICK, MSG, K, ISET, nset, iside,
        ICAT, IONUM, IFOUND, IBONLY, READONLY, ITYPE,
        ISTATION_HOLD, IRADIUS, indx, iold, inew,
        IPLOT_SOURCE, IPLOT_SOURCE_TYPE, JJ                 # MJC 4/20/2000
literal CSTRIP8                                             # MJC 4/20/2000
real*4  FCEN_LAT, FCEN_LON                                  # MJC 5/25/2000
literal ILEX[iwords]
real    DMS2rad

#String  saywhat "Sorry, the command was not understood"
#String  msg2    "      not found for plotting ground tracks.   "  ##6/27/83 TpA
#String  msg3    "      ROTHR Base not found.   "

STA$POINTER$TO ista                     # set station pointer
iview = xSTA$View$I

iok = YES
nset = 0

if (ilex[2] == $Lex$SURVSAT$ & ilex[3] == $Lex$GROUND$)  ## khc 12/92, new keyword GROUND (E1066)
    {
    if (ilex[1] == $Lex$PLOT$)
        {
        ick = NO                                ## set SAT match to NO

# 12/92 khc, updated the index of 'ilex' as the prompt syntax has an extra
#            keyword "GROUND".  (E1066)

        for (SAT$Pointer$First; SAT$Pointer$Ok; SAT$Pointer$Next)
            {
            if (xSAT$SatelliteName$C != ilex[4]) next   ##Sat name not the same
            if (xsat$orbiting$i == NO) next             # no plot for orbiters

#           UNT$Pointer$To xSAT$GrdTrkStation$I         ## set index to UNT
#
#           if (xUNT$View$I != iview)  next             ## if views different

#           STA$FirstLat$F = DEGMRA(int(ilex[6]))       ## save inputs
#           STA$LastLat$F  = DEGMRA(int(ilex[7]))
            STA$FirstLat$F = DMS2rad(ilex[7])   ## save inputs
            STA$LastLat$F  = DMS2rad(ilex[8])

            putSTA$SatIndx$I    (SAT$Pointer$Index)
            putSTA$FirstOrbit$I (int(ilex[5]))
            putSTA$LastOrbit$I  (int(ilex[6]))
            putSTA$FirstLat$F 
            putSTA$LastLat$F  

            ick = YES                           ## found SAT match

            break
            }

        if(ick == NO)
            {
            jj = 0
            call SMOVHN(ilex[4],$$MaxLit,msg,jj)        
            Call SMOVV(" not found for plotting ground tracks.",msg,jj)
            call echoh(msg,jj)  # formerly msg2
            call echor
            return
            }
        }
    else  putSTA$SatIndx$I  (0)
    }
# 12/92 khc, process plot wide area surveillance tracks (E1066).
else if ( (ilex[2] == $lex$SURVSAT$  |  ilex[2] == $lex$HFDF$   |
           ilex[2] == $lex$SWABS$    |  ilex[2] == $lex$SOSUS$  )  &
          (ilex[3] == $lex$DETECTION$) )
    {
     if (ilex[1] == $lex$Plot$)
       call Pl_Wide_Tracks(ista,IWORDS,ILEX)                     
     else if (ilex[1] == $lex$Erase$)
       call Erase_Wide_Tracks(ista,IWORDS,ILEX)
    }
else if (ilex[2] == $lex$RADIUS$ |    # joa 3/05 per_ordsyntax
         ilex[2] == $lex$SHIFT$  |
         ilex[2] == $lex$CENTER$)
{
    call PL_center(ionum,ista,iwords-1,ilex[2])
}
else if (ilex[2] == $lex$Label$)
{
    call PL_label (ionum,ista,iwords,ilex)
}

else if (ilex[2] == $lex$Station$ & ilex[1] == $lex$Plot$)      # NWS00
    {                                                           # NWS00
    #$% if the third player entry is "Own", set plot copy to zero
    if (ilex[3] == $lex$Own$  | ilex[3] == ista  )  # UFL03 JOA
      {
       putSTA$PlotCopy$I (0)
       putSTA$PlotMap$i ($yes)           # joa - 12/97 (E1636)
      }
    #$% else set plot copy to station desired w/ new map - for Control only
    else
        {
        k = int(ilex[3])
        if (k > sta$size/sta$entry) k = 0        # check for valid STA index

        putSTA$PlotCopy$I (k)                     # NWS00

        STA$PlotMap$I = $YES                      # NWS00
        putSTA$PlotMap$I                          # NWS00

        #$% CLK 12/92 - (E1036)
        #$% Get the center position, radius and source center of the station which is
        #$% to be plotted and store the data in the new Copy... variables of the control
        #$% station STA slot - so that the display can be recentered and resized.
        istation_hold = STA$Pointer                 # save the control station's pointer

        STA$Pointer$To  (k)                         # set the sta pointer to the station
        fcen_lat = xSTA$Latitude$F                  # to be plotted and get the center
        fcen_lon = xSTA$Longitude$F                 # position,
        iradius = xSTA$PlotRadius$I                 # radius,
        iplot_source = xSTA$PlotSource$I            # OWN index of unit (if centered on one), and
        iplot_source_type = xSTA$PlotSourceType$I   # display center code

        STA$Pointer = istation_hold                 # reset back to the control station
        putSTA$CopyLatitude$F   (fcen_lat)          # store the display center data
        putSTA$CopyLongitude$F  (fcen_lon)          # and radius in the control
        putSTA$CopyPlotRadius$I (iradius)           # station's STA slot
        putSTA$CopyPlotSource$I (iplot_source)
        putSTA$CopyPlotSourceType$I (iplot_source_type)
        }
    }                                   
else if (ilex[2] == $lex$NEW$ & ilex[1] == $lex$Plot$)          # dew 8/16/91
    {
    putSTA$GeoMap$C (ilex[3])

    sta$GeoType$i = Xsta$GeoType$i 
    if (sta$GeoType$i == $geo$xWindow |
        sta$GeoType$i == $geo$MapDrawModule)
        {
        STA$PlotMap$I = $YES
        putSTA$PlotMap$I
        }
    else
        {
        call recycle_plot (sta$pointer)                     # dew 8/16/91
        }
    } 
else if (ilex[2] == $lex$SYMBOLS$)
{
    call PL_symbols(ionum,ista,iwords-1,ilex[2])
}
else if (ilex[2] == $lex$PASSIVE$)
{
    call PL_passive(ionum,ista,iwords,ilex)
}
else if (ilex[2] == $lex$RADAR$)
{
    call PL_radar(ionum,ista,iwords,ilex)
}
else if (ilex[1] == $lex$Erase$ |       # if the first player entry is 'ERASE'
         ilex[1] == $lex$Plot$   )      # if first player input is 'PLOT'
    {
    if (ilex[1] == $lex$Erase$) iset = NO
    else                        iset = ! NO
 
    if      (ILEX[2] == $LEX$ALL$     ) 
        {
        if      (iwords  == 2              )
            {
            # Erase all plotted objects
            PUTsta$PlotAll$i        (iset)
     
            #$% KHC, 1/93 - reset flags for wide area surveillance track plotting (E1066) 
            PUTsta$PlotSurvSatTrk$i (iset)
            PUTsta$PlotHFDFTrk$i    (iset)
            PUTsta$PlotSwabsTrk$i   (iset)
            PUTsta$PlotSosusTrk$i   (iset)
            for (STA$TRK$Index = 1; STA$TRK$Index$ok; STA$TRK$Index = STA$TRK$Index + 1)
               PUTsta$TRK$PlotTrk$I (iset)

            putSTA$PlotGhostUnits$I (iset)        # clk 1/94
            putSTA$PlotGhostUnits1$I (iset)     # Do not set ghost ground
            #putSTA$PlotGhostSide$I (iset)	# Exempt side from plot/erase all
            putSTA$PlotMissileObject$I (iset)   # SMM 1/94

            call STATNUM (ista,iside,iview,readonly)     # determine station number
            if (iview != $Neutral$View)            # player stations should only
              {                                    # see their side's hide sites
               putSTA$PlotNeutralSite$i ($no)      # clk 10/97 (E1513)
               putSTA$PlotEnemySite$i ($no)
               putSTA$PlotFriendlySite$i (iset)
              }

            if (ilex[1] == $lex$Erase$)     # clk 12/95 (E1469)
              {
               putSTA$PlotL16Data$I (0)      # Have ERASE ALL erase JTIDS
              }
            }
        else if (ilex[3] == $LEX$Air$      ) 
            {
            PUTsta$PlotEnemyAir$i    (iset)
            PUTsta$PlotFriendlyAir$i (iset)
            PUTsta$PlotUnknownAir$i  (iset)
            PUTsta$PlotNeutralAir$i  (iset)
            }
        else if (ilex[3] == $LEX$Submarine$) 
            {
            PUTsta$PlotEnemySub$i    (iset)
            PUTsta$PlotFriendlySub$i (iset)
            PUTsta$PlotUnknownSub$i  (iset)
            PUTsta$PlotNeutralSub$i  (iset)
            }
        else if (ilex[3] == $LEX$Surface$  ) 
            {
            PUTsta$PlotEnemySurf$i    (iset)
            PUTsta$PlotFriendlySurf$i (iset)
            PUTsta$PlotUnknownSurf$i  (iset)
            PUTsta$PlotNeutralSurf$i  (iset)
            }
        else if (ilex[3] == $LEX$BOAT$  ) 
            {
            PUTsta$PlotEnemyBoat$i    (iset)
            PUTsta$PlotFriendlyBoat$i (iset)
            PUTsta$PlotUnknownBoat$i  (iset)
            PUTsta$PlotNeutralBoat$i  (iset)
            }
        else if (ilex[3] == $LEX$Shore$) 
            {
            PUTsta$PlotEnemyBase$i    (iset)
            PUTsta$PlotFriendlyBase$i (iset)
            PUTsta$PlotUnknownBase$i  (iset)
            PUTsta$PlotNeutralBase$i  (iset)
            }
        else if (ilex[3] == $LEX$hide$)             # khc 10/92
            {
             call STATNUM (ista,iside,iview,readonly)     # determine station number
             if (iview == $Neutral$View)            # process the plot/erase hide
               {                                    # differently for control and
                putSTA$PlotNeutralSite$i (iset)     # player stations.   clk 10/97 (E1513)
                putSTA$PlotEnemySite$i (iset)
                putSTA$PlotFriendlySite$i (iset)
               }
             else  # play views only see their side's hide sites
               {
                putSTA$PlotNeutralSite$i ($no)
                putSTA$PlotEnemySite$i ($no)
                putSTA$PlotFriendlySite$i (iset)
               }
            }                    
        else                               iok = NO
        }
    else if (ILEX[2] == $LEX$Ghost$)                # clk 1/94
        {                                           # clk 9/95 (E1456)
         if (iwords == 2)                           # entended command
          {
           putSTA$PlotGhostUnits$I  (iset)
           putSTA$PlotGhostUnits1$I (iset)
           putSTA$PlotGhostSide$I   (iset)
          }
         else
           {
            if (ilex[3] == $lex$Air$)
              putSTA$PlotGhostAir$I  (iset)

            if (ilex[1] == $lex$Plot$ & ilex[3] == $lex$Polygon$)
            {
                # Find polygon by name
                call find_polygon (sta$pointer, ilex[4], lin$pointer)
                if (lin$pointer$ok)
                {
                    putSTA$PlotGhostPolygonIndx$i (lin$pointer$index)
                }
                else
                {
                    jj = 0
                    call SMOVHN(ilex[4],$$MaxLit,msg,jj)        
                    Call SMOVV(" polygon for ghost geo filter not found.",msg,jj)
                    call echoh(msg,jj)  # formerly msg2
                    call echor
                    return
                }                                        
            }

            if (ilex[1] == $lex$Erase$ & ilex[3] == $lex$Polygon$)
            {
                putSTA$PlotGhostPolygonIndx$i (0)
            }

            if (ilex[3] == $lex$Side$)
            {
               if (iwords == 3)
                 putSTA$PlotGhostSide$I  (iset)
               else
               {
                if (ilex[4] == $lex$Blue$)        putSTA$PlotGhostBlue$I (iset)
                else if (ilex[4] == $lex$Orange$) putSTA$PlotGhostOrange$I (iset)
                else if (ilex[4] == $lex$Neutral$) putSTA$PlotGhostNeutral$I (iset)
               }
            }

            if (ilex[3] == $lex$Size$)
            {
               if (iwords == 3)
                 putSTA$PlotGhostGroundSize$I  (iset)
               else
               {
                if (ilex[4] == $lex$Army$)
                {
                 if (iwords == 4)
                 {
                   putSTA$PlotGhostGroundArmyGroup$I (iset)
                   putSTA$PlotGhostGroundArmy$I      (iset)
                   putSTA$PlotGhostGroundCorps$I     (nset)
                   putSTA$PlotGhostGroundDivision$I  (nset)
                   putSTA$PlotGhostGroundBrigade$I   (nset)
                   putSTA$PlotGhostGroundRegiment$I  (nset)
                   putSTA$PlotGhostGroundBattalion$I (nset)
                   putSTA$PlotGhostGroundCompany$I   (nset)
                   putSTA$PlotGhostGroundPlatoon$I   (nset)
                   putSTA$PlotGhostGroundSection$I   (nset)
                   putSTA$PlotGhostGroundSquad$I     (nset)
                   putSTA$PlotGhostGroundTeam$I      (nset)
                 }
                 else
                 {          
                   putSTA$PlotGhostGroundArmyGroup$I (iset)
                   putSTA$PlotGhostGroundArmy$I      (nset)
                   putSTA$PlotGhostGroundCorps$I     (nset)
                   putSTA$PlotGhostGroundDivision$I  (nset)
                   putSTA$PlotGhostGroundBrigade$I   (nset)
                   putSTA$PlotGhostGroundRegiment$I  (nset)
                   putSTA$PlotGhostGroundBattalion$I (nset)
                   putSTA$PlotGhostGroundCompany$I   (nset)
                   putSTA$PlotGhostGroundPlatoon$I   (nset)
                   putSTA$PlotGhostGroundSection$I   (nset)
                   putSTA$PlotGhostGroundSquad$I     (nset)
                   putSTA$PlotGhostGroundTeam$I      (nset)
                 }
                }
                else if (ilex[4] == $lex$Battalion$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (iset)
                 putSTA$PlotGhostGroundCompany$I   (nset)
                 putSTA$PlotGhostGroundPlatoon$I   (nset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Brigade$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (nset)
                 putSTA$PlotGhostGroundBattalion$I (nset)
                 putSTA$PlotGhostGroundCompany$I   (nset)
                 putSTA$PlotGhostGroundPlatoon$I   (nset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Company$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (iset)
                 putSTA$PlotGhostGroundCompany$I   (iset)
                 putSTA$PlotGhostGroundPlatoon$I   (nset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Corps$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (nset)
                 putSTA$PlotGhostGroundBrigade$I   (nset)
                 putSTA$PlotGhostGroundRegiment$I  (nset)
                 putSTA$PlotGhostGroundBattalion$I (nset)
                 putSTA$PlotGhostGroundCompany$I   (nset)
                 putSTA$PlotGhostGroundPlatoon$I   (nset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Division$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (nset)
                 putSTA$PlotGhostGroundRegiment$I  (nset)
                 putSTA$PlotGhostGroundBattalion$I (nset)
                 putSTA$PlotGhostGroundCompany$I   (nset)
                 putSTA$PlotGhostGroundPlatoon$I   (nset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Platoon$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (iset)
                 putSTA$PlotGhostGroundCompany$I   (iset)
                 putSTA$PlotGhostGroundPlatoon$I   (iset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Regiment$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (nset)
                 putSTA$PlotGhostGroundCompany$I   (nset)
                 putSTA$PlotGhostGroundPlatoon$I   (nset)
                 putSTA$PlotGhostGroundSection$I   (nset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Section$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (iset)
                 putSTA$PlotGhostGroundCompany$I   (iset)
                 putSTA$PlotGhostGroundPlatoon$I   (iset)
                 putSTA$PlotGhostGroundSection$I   (iset)
                 putSTA$PlotGhostGroundSquad$I     (nset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Squad$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (iset)
                 putSTA$PlotGhostGroundCompany$I   (iset)
                 putSTA$PlotGhostGroundPlatoon$I   (iset)
                 putSTA$PlotGhostGroundSection$I   (iset)
                 putSTA$PlotGhostGroundSquad$I     (iset)
                 putSTA$PlotGhostGroundTeam$I      (nset)
                }
                else if (ilex[4] == $lex$Team$)
                {
                 putSTA$PlotGhostGroundArmyGroup$I (iset)
                 putSTA$PlotGhostGroundArmy$I      (iset)
                 putSTA$PlotGhostGroundCorps$I     (iset)
                 putSTA$PlotGhostGroundDivision$I  (iset)
                 putSTA$PlotGhostGroundBrigade$I   (iset)
                 putSTA$PlotGhostGroundRegiment$I  (iset)
                 putSTA$PlotGhostGroundBattalion$I (iset)
                 putSTA$PlotGhostGroundCompany$I   (iset)
                 putSTA$PlotGhostGroundPlatoon$I   (iset)
                 putSTA$PlotGhostGroundSection$I   (iset)
                 putSTA$PlotGhostGroundSquad$I     (iset)
                 putSTA$PlotGhostGroundTeam$I      (iset)
                }
               }
            }

            if (ilex[3] == $lex$Ground$)
              {
               if (iwords == 3)
                 putSTA$PlotGhostGround$I  (iset)
               else
                 {
                  if (ilex[4] == $lex$Base$)
                    putSTA$PlotGhostGroundBase$I   (iset)
                  if (ilex[4] == $lex$Radar$)
                    putSTA$PlotGhostGroundRadar$I  (iset)
                  if (ilex[4] == $lex$SAM$)
                    putSTA$PlotGhostGroundSAM$I    (iset)
                  if (ilex[4] == $lex$HIMAD$)
                    putSTA$PlotGhostGroundHIMAD$I (iset)
                  if (ilex[4] == $lex$ALLRAD$)
                    putSTA$PlotGhostGroundALLRAD$I (iset)
                  if (ilex[4] == $lex$TEL$)
                    putSTA$PlotGhostGroundTEL$I (iset)
                  if (ilex[4] == $lex$Combat$)
                    putSTA$PlotGhostGroundCombat$I (iset)

                  if (ilex[4] == $lex$Support$)
                   {
                    if (iwords == 4)
                        putSTA$PlotGhostGroundSupport$I    (iset)
                    else
                    {
                        if (ilex[5] == $lex$Convoy$)
                            putSTA$PlotGhostGroundConvoy$I    (iset)
                        if (ilex[5] == $lex$Unit$)
                            putSTA$PlotGhostGroundSUnit$I    (iset)
                    }
                   } # end of support

                 }  # end of keywords entered after GROUND
              }   # end of PLOT/ERASE GHOST GROUND
            if (ilex[3] == $lex$Submarine$)
              putSTA$PlotGhostSubsurface$I  (iset)
            if (ilex[3] == $lex$Surface$)
              putSTA$PlotGhostSurface$I  (iset)
            if (ilex[3] == $lex$Minefield$)
              putSTA$PlotGhostMinefield$I  (iset)
            if (ilex[3] == $lex$SweepArea$)
              putSTA$PlotGhostSweepArea$I  (iset)
           }   # end of optional keyword entered
        }    # end of PLOT/ERASE GHOST
    else if (ILEX[2] == $LEX$Ground$)               # clk 9/95 (E1456)
        {
         if (ilex[3] == $lex$SAM$)                  # PLOT/ERASE GROUND SAM
           {
            if (iwords > 3)   # if optional information entered (not for ERASE)
              {
               call EQ_Identify ($$MC, ilex[4], MC$Pointer, itype)
               if (MC$Pointer$Valid & itype == $SAM$Code)
                 {
                  STA$MCPntr$I = MC$Pointer
                  putSTA$MCPntr$I
                 }
               else
                 {
                  call echohn (ilex[4], $$MaxLit)
                  call echov  (" is not in the game database.")
                  call echor
                  return
                 }     # end of if no SAM found
               if (iwords > 4)   # if radius was entered
                 {
                  STA$SAMRange$I = ilex[5]
                  putSTA$SAMRange$I
                 }
               else
                  putSTA$SAMRange$I (0)
              }     # end of if optional information in command
            else
              {
               putSTA$MCPntr$I   (0)
               putSTA$SAMRange$I (0)
              }     # end of no optional information entered
            putSTA$PlotGroundSAMRanges$I  (iset)
           }     # end of PLOT/ERASE GROUND SAM
        }    # end of PLOT/ERASE GROUND
    else if (ILEX[2] == $LEX$EMI$     )             # DEW 8 Feb 90
        {
        # ERASE EMI (affected areas)
        # PLOT EMI (affected areas for) <target-cross-section> 
        # PLOT EMI (affected areas for) <target_type> 

        PUTsta$PlotEmiArea$i    (iset)

        if (iwords >= 3)
            {
            if (ilex[3] >= -30 & ilex[3] <= 30) 
                {
                STA$EmiTcs$i = ilex[3]
                PUTsta$EmiTcs$i
                }
            else 
                {
                STA$EmiTcs$i = 0            #@! need to look up XSECT #@!
                PUTsta$EmiTcs$i
                }
            }
        }
    else if (ILEX[2] == $LEX$SAM$)
        { 
         putSTA$PlotMissileObject$I (iset)   # SMM 1/94
        }
    else if (ILEX[2] == $LEX$SPEED$     ) 
        {
        if      (iwords  == 2              ) PUTsta$PlotSpeed$i     (iset)
        else if (ilex[3] == $LEX$Air$      ) PUTsta$PlotSpeedAir$i  (iset)
        else if (ilex[3] == $LEX$Surface$  ) PUTsta$PlotSpeedShip$i (iset)
        else                                 iok = NO

        if (iok != NO & iset != NO)             # if turning Speed-Vectors ON,
            PUTsta$PlotTrackHistory$i (NO)      # turn OFF Track-History
        }
    else if (ILEX[2] == $LEX$TRACK$ & iwords == 2) 
        {
        PUTsta$PlotTrackHistory$i (iset)

        if (iset != NO)                         # if turning Track-History ON,
            PUTsta$PlotSpeed$i (NO)             # turn OFF Speed-Vectors 
        }
    else if (ILEX[2] == $LEX$PIM$) 
        {
        if   (ilex[1] == $LEX$ERASE$    ) sta$PlotPIMIndx$I = 0
        else 
            {
            call untfnd($NEUTRAL$VIEW, ilex[3], unt$pointer)
            if (unt$pointer == 0)
                sta$PlotPIMIndx$i = 0
            else
                sta$PlotPIMIndx$i = unt$pointer$index
            }
        PUTsta$PlotPIMIndx$I
        }
    else if (ILEX[2] == $LEX$PLAN$)      # joa - 2/98 (E1864)
        {
         if (xSTA$PlanCMUntIndx$I != 0)
           {
            UNT$Pointer$To xSTA$PlanCMUntIndx$I
            putSTA$PlanCMUntIndx$I  (0)

            PIM$Pointer$To xUNT$PIMIndx$I
            if (PIM$Pointer$Ok)
              {
               PIM$Zero
              }
            if (xUNT$CMFireMode$I == $CMBOL$code)
              {
               LIN$Pointer$To xSTA$PlanCMPolygonIndx$I
               if (LIN$Pointer$Ok)
                 {
                  LIN$Zero
                  putSTA$PlanCMPolygonIndx$I  (0)
                 }
              }
            else if (xUNT$CMFireMode$I == $CMRBL$code)
              {
               PLC$Pointer$To xSTA$PlanCMCircleIndx$I
               if (PLC$Pointer$Ok)
                 {
                  PLC$Zero
                  putSTA$PlanCMCircleIndx$I  (0)
                 }
              }
            UNT$Zero
           }
        }
    else if (ILEX[2] == $LEX$EOIR$         ) PUTsta$PlotEoir$i      (iset)
    else if (ILEX[2] == $LEX$Rivers$       ) PUTsta$PlotRivers$i    (iset)
    else if (ILEX[2] == $LEX$Boundaries$   ) PUTsta$PlotBoundaries$i(iset)
    else if (ILEX[2] == $LEX$Map$          ) PUTsta$PlotTerrain$i(iset)
    else if (ILEX[2] == $LEX$Chaff$        ) PUTsta$PlotChaff$i     (iset)
    else if (ILEX[2] == $LEX$Declutter$    ) PUTsta$PlotLabelDeclutter$i(iset)
    else if (ILEX[2] == $LEX$ROUTE$        ) 
        {
        PUTsta$PlotROUTES$i    (iset) # 11/21/89
        if (ILEX[3] == $LEX$QUEUE$) PUTsta$PlotQROUTES$i (iset)
        call PL_Route ( IONUM,ista,iwords,ilex )
        } 
    else if (ILEX[2] == $LEX$SPA$          ) 
        {
        putSTA$PlotSPAs$i      (iset)         # clk 10/91
        call PL_SPA (ionum, ista, iwords, ilex)
        }
    else if (ILEX[2] == $LEX$LANDING$ ) 
        {
        PUTsta$PlotLandingZones$i    (iset) # 11/21/89
        }
    else if (ILEX[2] == $LEX$Sonobuoy$     ) PUTsta$PlotSonobuoy$i  (iset)
    else if (ILEX[2] == $LEX$MineField$    ) PUTsta$PlotMineFields$i(iset)
    else if (ILEX[2] == $LEX$REGIONS$      )            #2/28/91
        {
        if      (ilex[3] == $LEX$SOSUS$) putSTA$PlotSosus$I    (iset)
        else if (ilex[3] == $LEX$SONAR$) putSTA$PlotSonarReg$I (iset)
        else if (ilex[3] == $LEX$LIDAR$) putSTA$PlotLIDAR$I    (iset)
        else if (ilex[3] == $LEX$SWABS$) putSTA$PlotSWABS$I    (iset)
        else if (ilex[3] == $LEX$ALL$  ) 
            {
            putSTA$PlotSosus$I    (iset)
            putSTA$PlotSonarReg$I (iset)
            putSTA$PlotLIDAR$I    (iset)
            putSTA$PlotSWABS$I    (iset)
            }
        else                                                  iok = NO
        }
    else if (ILEX[2] == $LEX$LOB$     )                 ## 6/16/83  TPA
        {
        if (ILEX[1] == $LEX$ERASE$ & iwords == 2)        #if bearings off
           {
            putSTA$BearingSource$I    (0)
            putSTA$AltBearingSource$I (0)
           }
        if (ILEX[3] == $LEX$ALL$)         #if bearings from all
           {
            putSTA$BearingSource$I    (unt$SLOTS+1)
            putSTA$AltBearingSource$I (0)

            PUTsta$PlotSonar$i    (YES)
            PUTsta$PlotEsm$i      (YES)
           }
        else if(ILEX[3] == $LEX$FORCE$)                 #if bearings from a force
           {
            call untfnd(IVIEW,                          #locate the force
                ILEX[3],
                unt$POINTER)                    #receive the force pointer

            #$% if force pointer found, match it to bearing souce, else set to zero

            if (unt$pointer != 0) 
                {
                inew = unt$POINTER$INDEX                # get new source/and save it
                iold = Xsta$BearingSource$i             # get old bearing source

                PUTsta$BearingSource$i (inew)

                PUTsta$AltBearingSource$i (iold)
                }
            else
                {
                # error... could not find the force (maybe call SEND and tell him)
                }
            }

        else if (ilex[3] == $LEX$Sonar$) putSTA$PlotSonar$I     (iset)
        else if (ilex[3] == $LEX$ESM$  )        # jb    6/18/86
            {
            putSTA$PlotESMair$I   (iset)          # jb    6/18/86
            putSTA$PlotESMsurf$I  (iset)          # jb    6/18/86
            }                                      # jb \/ 6/18/86
        else if (ilex[3] == $LEX$AIR$ )     putSTA$PlotESMair$I  (iset)
        else if (ilex[3] == $LEX$SURFACE$ ) putSTA$PlotESMsurf$I (iset)
        else if (ilex[3] == $LEX$EMITTER$ ) 
            {
            call pl_lobemit(ionum,ista,iwords,ilex)
            }
        else if (ilex[3] == $LEX$JAMMER$ ) # JFR 7/26/94 PER #E1147
             {
              putSTA$PlotESMjam$I (iset)   # JFR 7/26/94 PER #E1147
             }
        else
            {
            iok = NO
            }
        }
#    else if (ilex[2] == $lex$Rothr$)
#        {
#        if (ilex[1] == $lex$Erase$)           # erase rothr command CML 5/8/90
#            {
#            PUTsta$RothrOrder$i ($Erase$Rothr)
#            PUTsta$RothrNewOrder$i ($YES)
#            }
#        else if (iview < $FirstOrange$View)   # plot rothr command CML 6/12/90
#            {
#            ifound = $NO
#            for (RTH$Pointer$First; RTH$Pointer$OK; RTH$Pointer$Next)
#                {
#                if (Xrth$Basename$c == ilex[4])
#                    {
#                    ifound = $YES
#                    BREAK
#                    }
#                }
#            if (ifound == $NO)    # echo message base not found...
#                {   
#                call echor
#                jj = 0
#                call smovhn (ilex[4],$$MaxLit,msg,jj)
#                Call SMOVV(" ROTHR Base not found.",msg,jj)
#                call echoh (msg,ARB) # formerly msg3
#                call echo ($BELL)
#                call echor
#                return
#                }
#
#            if (ilex[3] == $lex$Coverage$)
#                STA$RothrOrder$i = $Plot$Rothr
#            else
#                STA$RothrOrder$i = $Evaluate$Rothr
#
#            STA$RothrIndx$i = RTH$Pointer$Index
#
#            if (ilex[5] == $lex$AIR$)
#                STA$RothrAirSurfPCA$i = air$pca
#            else
#                STA$RothrAirSurfPCA$i = surf$pca
#
#            if (ilex[6] == $lex$DAY$)
#                STA$RothrDayNightPCA$i = day$rth
#            else
#                STA$RothrDayNightPCA$i = night$rth
#
#            PUTsta$RothrOrder$i
#            PUTsta$RothrIndx$i
#            PUTsta$RothrAirSurfPCA$i
#            PUTsta$RothrDayNightPCA$i
#            PUTsta$RothrNewOrder$i ($YES)
#            }
#        else 
#            {
#            iok = NO
#            }
#        } # end if ROTHR in second word
    else if ( ilex[2] == $lex$ELLIPSE$)
        {
         #$% initialize RMT pointer to zero
         RMT$Pointer = 0

         call gtact(iview,ILEX[3],RMT$Pointer,ibonly)

         if (RMT$Pointer == 0)                        # track not found
           {
            jj = 0
            call smovhn (ILEX[3],$$MaxLit,msg,jj)
            call smovv (" not found in remote track table.",msg,jj)
            call echoh (msg,ARB)
            call echo ($BELL)
            call echor
            return
           }

         if (xRMT$LastDetType$i != $Bistatic$Type)    # track not bistatic
           {
            jj=0
            call smovhn (ILEX[3],$$MaxLit,msg,jj)
            call smovv (" is not a bistatic track.",msg,jj)
            call echoh (msg,ARB)
            call echo ($BELL)
            call echor
            return
           }

         if (ILEX[1] == $lex$plot$)           # plot the ellipse
           {
            #$% track is bistatic
            for (PLC$Pointer$First; PLC$Pointer$OK; PLC$Pointer$Next)
              {
               #$% check station owner of this slot
               if (xPLC$Station$i == 0)   # this slot is available for use
                 break
              }
            #$% if table is full
            if (!PLC$Pointer$Valid)
              {
               call echov ("Cannot display ellipse -- table full.")
               return
              }

            #$% table not full, store data
            PLC$Reference$i = RMT$Pointer$Index   # store pointer to RMT entry
            putPLC$Reference$i

            PLC$ReferenceType$i = $OtherForce$Code   # store reference type
            putPLC$ReferenceType$i

            PLC$Type$i = $BistaticEllipse$Code       # store type of mark
            putPLC$Type$i

            PLC$Station$i = STA$Pointer$Index     # store station index
            putPLC$Station$i
           }
         else           # erase ellipse
           {
            for (PLC$Pointer$First; PLC$Pointer$OK; PLC$Pointer$Next)
              {
               #$% check reference index
               if (xPLC$Reference$i != RMT$Pointer$Index) next

               #$% check reference type
               if (xPLC$ReferenceType$i != $OtherForce$Code) next

               #$% check type of mark
               if (xPLC$Type$i != $BistaticEllipse$Code) next

               #$% check station
               if (xPLC$Station$i != STA$Pointer$Index) next

               #$% found the entry, zero it out
               PLC$ZERO
               break
              }   # end of search through RMT table
           }
        }   # end if ELLIPSE in second word
    else if ( ilex[2] == $lex$NRT$)
        {
         call Pl_NRTs (ista,iwords,ilex)
        }
    else if (ilex[2] == $lex$JTIDS$)   # clk 12/95 (E1469)
       call pl_plot_jtids (STA$Pointer, iwords, ilex)
#    else if (ilex[2] == $lex$PERSISTENT$)   # clk 2/97 (E1731)
#      {
#       if (iview == $Neutral$View)
#         {
#          if (ilex[3] == $lex$ALL$)
#            {
#             putSTA$PlotPEMDataBlue$I (iset)
#             putSTA$PlotPEMDataNeutral$I (iset)
#             putSTA$PlotPEMDataOrange$I (iset)
#            }
#          else if (ilex[3] == $lex$Blue$)
#             putSTA$PlotPEMDataBlue$I (iset)
#          else if (ilex[3] == $lex$Neutral$)
#             putSTA$PlotPEMDataNeutral$I (iset)
#          else if (ilex[3] == $lex$Orange$)
#             putSTA$PlotPEMDataOrange$I (iset)
#         }   # end of if a control view
#       else
#         {
#          if (iview <= $LastBlue$View)
#            putSTA$PlotPEMDataBlue$I (iset)
#          else
#            putSTA$PlotPEMDataOrange$I (iset)
#         }   # player station
#      }   # end of if PLOT PERSISTENT
    else if (ilex[2] == $lex$CIRCLE$    |    # joa 3/05 per_ordsyntax
             ilex[2] == $lex$GRID$      |
             ilex[2] == $lex$POLYGON$   |
             ilex[2] == $lex$LINE$      |
             ilex[2] == $lex$RECTANGLE$ |
             ilex[2] == $lex$XMARK$)

    {
        call PL_xcir  (ionum,ista,iwords,ilex,indx)
    }
    else if (ilex[2] == $lex$COLOR$)        # joa 3/05 per_ordsyntax
    {
        call PL_xcir  (ionum,ista,iwords-1,ilex[2],indx)
    }
    else if (ilex[2] == $lex$BEARING$   |    # joa 3/05 per_ordsyntax
             ilex[2] == $lex$TRACK$)
    {
        call PL_marku (ionum,ista,iwords,ilex)
    }
    else
        {
        if      (iwords  == 2              ) itype = 0
        else if (ilex[3] == $LEX$Air$      ) itype = 1
        else if (ilex[3] == $LEX$Submarine$) itype = 2
        else if (ilex[3] == $LEX$Surface$  ) itype = 3
        else if (ilex[3] == $LEX$Shore$    ) itype = 4
        else if (ilex[3] == $LEX$Boat$     ) itype = 5
        else if (ilex[3] == $LEX$Hide$     ) itype = 6      # khc 10/92
        else                                 itype = 0

        #____________________________________________________________
        if     (ILEX[2] == $LEX$BLUE$    |
                ILEX[2] == $LEX$FRIENDLY$) icat  = 1 # Friendly
        else if(ILEX[2] == $LEX$ORANGE$  |
                ILEX[2] == $LEX$ENEMY$   ) icat  = 2 # Enemy
        else if(ILEX[2] == $LEX$NEUTRAL$ ) icat  = 3 # Neutral
        else if(ILEX[2] == $LEX$UNKNOWN$ ) icat  = 4 # Unknown
        else if(ILEX[2] == $LEX$OTHER$   ) 
            { 
            if (iview == $Neutral$view)    icat  = 1 # Friendly
            else                           icat  = 3 # Neutral 

            if      (itype == 1) PUTsta$PlotEnemyAir$i (iset)
            else if (itype == 2) PUTsta$PlotEnemySub$i (iset)
            else if (itype == 3) PUTsta$PlotEnemySurf$i(iset)
            else if (itype == 4) PUTsta$PlotEnemyBase$i(iset)
            else if (itype == 5) PUTsta$PlotEnemyBoat$i(iset)
            else if (itype == 6) PUTsta$PlotEnemySite$i(iset)       # khc 10/92
            else                 PUTsta$PlotEnemy$i    (iset)
        
            if      (itype == 1) PUTsta$PlotUnknownAir$i (iset)
            else if (itype == 2) PUTsta$PlotUnknownSub$i (iset)
            else if (itype == 3) PUTsta$PlotUnknownSurf$i(iset)
            else if (itype == 4) PUTsta$PlotUnknownBase$i(iset)
            else if (itype == 5) PUTsta$PlotUnknownBoat$i(iset)
            else                 PUTsta$PlotUnknown$i    (iset)
            }
        else if(ILEX[2] == $LEX$OWN$     ) 
            { 
            if (iview != $Neutral$view)    icat = 1 # Friendly
            else                           icat = 3 # Neutral
            }
        else                               iok = NO
    
        if (iok == YES)
            {
            if (icat == 1)                                      # Friendly
                {
                if      (itype == 1) PUTsta$PlotFriendlyAir$i (iset)
                else if (itype == 2) PUTsta$PlotFriendlySub$i (iset)
                else if (itype == 3) PUTsta$PlotFriendlySurf$i(iset)
                else if (itype == 4) PUTsta$PlotFriendlyBase$i(iset)
                else if (itype == 5) PUTsta$PlotFriendlyBoat$i(iset)
                else if (itype == 6) PUTsta$PlotFriendlySite$i(iset)       # khc 10/92
                else                 PUTsta$PlotFriendly$i    (iset)
                }
            else if (icat == 2)                                 # Enemy
                {
                if      (itype == 1) PUTsta$PlotEnemyAir$i (iset)
                else if (itype == 2) PUTsta$PlotEnemySub$i (iset)
                else if (itype == 3) PUTsta$PlotEnemySurf$i(iset)
                else if (itype == 4) PUTsta$PlotEnemyBase$i(iset)
                else if (itype == 5) PUTsta$PlotEnemyBoat$i(iset)
                else if (itype == 6) PUTsta$PlotEnemySite$i(iset)       # khc 10/92
                else                 PUTsta$PlotEnemy$i    (iset)
                }
            else if (icat == 3)                                 # Neutral
                {
                if      (itype == 1) PUTsta$PlotNeutralAir$i (iset)
                else if (itype == 2) PUTsta$PlotNeutralSub$i (iset)
                else if (itype == 3) PUTsta$PlotNeutralSurf$i(iset)
                else if (itype == 4) PUTsta$PlotNeutralBase$i(iset)
                else if (itype == 5) PUTsta$PlotNeutralBoat$i(iset)
                else if (itype == 6) PUTsta$PlotNeutralSite$i(iset)       # khc 10/92
                else                 PUTsta$PlotNeutral$i    (iset)
                }
            else if (icat == 4)                                 # Unknown
                {
                if      (itype == 1) PUTsta$PlotUnknownAir$i (iset)
                else if (itype == 2) PUTsta$PlotUnknownSub$i (iset)
                else if (itype == 3) PUTsta$PlotUnknownSurf$i(iset)
                else if (itype == 4) PUTsta$PlotUnknownBase$i(iset)
                else if (itype == 5) PUTsta$PlotUnknownBoat$i(iset)
                else                 PUTsta$PlotUnknown$i    (iset)
                }
            }
        }
    }
else iok = NO

if (iok == NO)
    {
#   call echoh (saywhat,ARB)             # send warning message
    call echov ("Sorry, the command was not understood")
    call echor
    }

return
end



Subroutine PL_Center(IONUM,                     #receive order number 
                     ista,                      #receive station
                     IWORDS,                    #receive number of words
                     ILEX)                      #receive parameters

#########################################################################
#$%
#$% Purpose:    PL_Center generates data to set the radius of a plot in NM
#$%             and center Point of the graphics displays as requested
#$%             by a player
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      NONE
#$%
#$% Author:     D. Wills
#$%
#$% Date:       FEBRUARY 1982
#$%
#$% Modified:   Carol Kropp 12/92 - (E1036)
#$%             Added checks to determine if the station is currently
#$%             plotting another.  If the station is plotting another,
#$%             then the recenter or radius change needs to be stored
#$%             in the Copy.. variables of the STA table.
#$%
############################################################################

BBcommon

BBDeclare  (STA$Plotradius$I, STA$Copyplotradius$I, STA$Pointer)    # MJC 8/1/2000
integer IWORDS, IPNT, ISTA, IVIEW, IOK, ICOPY_PLOT, Ionum           # MJC 4/20/2000
real    F_LATITUDE, F_LONGITUDE                                     # MJC 4/20/2000
literal ILEX[iwords]
real    range, brg, cos, fcos

# string  saywhat "Sorry, the command was not understood"

#$% set station pointer to requesting view
STA$POINTER$TO ista
iview = xSTA$View$I

iok = NO

icopy_plot = $no
if (iview == $Neutral$View)       # if a control station, need to     CLK 12/92
   if (xSTA$PlotCopy$I != $no)    # check for plot other station
      icopy_plot = $yes

if (ilex[iwords-1] == $lex$Radius$)     # if next-to-last entry is 'RADIUS'
   {
    if (icopy_plot == $no)   # if not plotting another station      # clk 12/92
      {
       #$% get last player entry which should be value of radius in NM
       STA$PlotRadius$i = ilex[iwords]
         putSTA$PlotRadius$i

       # check for truncation of High-order bits of radius value

       if (xSTA$PlotRadius$i < STA$PlotRadius$i)
         putSTA$PlotRadius$i (-1)    # put in max value
      }
    else        # a control station plotting some other station's geo
      {
       STA$CopyPlotRadius$I = ilex[iwords]    # store the data in the Copy...
       putSTA$CopyPlotRadius$I                # variable added to the STA table

       # check for truncation of High-order bits of radius value
       if (xSTA$CopyPlotRadius$I < STA$CopyPlotRadius$I)
          putSTA$CopyPlotRadius$I (-1)   # put in max value
       icopy_plot = $yes
      }

    putSTA$PlotMap$I ($YES)             # request new map to be drawn

    iok = YES
   }

if (ilex[1] == $lex$Center$)            # if the first player entry is 'CENTER'
    {
    #$% generate data to establish a center point
    ipnt = 2
    call PL_PLOTC (ipnt,ista,iwords,ilex)        
    iok = YES
    }
else if (ilex[1] == $lex$Shift$)        # if the first player entry is 'SHIFT'
    {
    range = ilex[2]
    brg   = ilex[3] * ($pi/180.)        # convert degrees to radians

    if (icopy_plot == $no)   # it not plotting another station     # clk 12/92
      {
       f_latitude  = Xsta$latitude$f
       f_longitude = Xsta$longitude$f
      }
    else        # a control station plotting some other station's geo
      {
       f_latitude  = xSTA$CopyLatitude$F        # get the current center location
       f_longitude = xSTA$CopyLongitude$F       # from the Copy... posit.
      }

    fcos = cos(f_latitude)

    call RRB2LL(f_latitude,         
                f_longitude,
                range,
                brg,
                0.0,
                fcos)

    if (icopy_plot == $no)   # if not plotting another station    # clk 12/92
      {
       PUTsta$latitude$f  (f_latitude)
       PUTsta$longitude$f (f_longitude)
       putSTA$PlotSourceType$I($Null$code) ## set plot source type to null
      }
    else        # a control station plotting some other station's geo
      {
       putSTA$CopyLatitude$F  (f_latitude)      # store the new center posit
       putSTA$CopyLongitude$F (f_longitude)     # in the Copy... variables and
       putSTA$CopyPlotSourceType$I($Null$code)  # set Copy plot source type to null
      }

    putSTA$PlotMap$I ($YES)             # request new map to be drawn
    iok = YES
    }

if (iok == NO)
    {
#   call echoh (saywhat,ARB)             # send warning message
    call echov ("Sorry, the command was not understood")
    call echor
    }

return
end



Subroutine PL_PLOTC(ipnt,                     # set up center point 
                    ista,                     #ipnt= pointer to FORCE/TRACK/POS
                    IWORDS,
                    ILEX)

#########################################################################
#$%
#$% Purpose:    PL_PLOTC generates and validates data to find the center
#$%             reference of a Force, Track or geographic Position.
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      untfnd
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       FEBRUARY 1982
#$%
#$% Modified:   Carol Kropp 12/92 - (E1036)
#$%             Added checks to determine if the station is currently
#$%             plotting another.  If the station is plotting another,
#$%             then the recenter data needs to be stored in the Copy...
#$%             variables of the STA table.
#$%
############################################################################

BBcommon

BBDeclare  (STA$Pointer, STA$Plotcopy$I, STA$Plotmap$I, 
            STA$Plotsource$I, STA$Plotsourcetype$I,
            RMT$Pointer, UNT$Pointer, OWN$Pointer)      # MJC 8/1/2000
integer   IWORDS, ISTA, IVIEW, IPNT,
          JJ, IDUMMY, NOROOM, IBONLY                    # MJC 4/20/2000
real      F_LATITUDE, F_LONGITUDE                       # MJC 4/20/2000
literal   ILEX[iwords]
real      DMS2rad
Character msg[ARB]
#String msg1 "      cannot be found for PLOT "
#String msg2 "Can't center plot on passive track      "

#$% set station pointer to requesting view
STA$Pointer$To ista
iview = xSTA$View$I

STA$PlotCopy$I = xSTA$PlotCopy$I        # clk 12/92
if (STA$PlotCopy$I == $no)              # check for if control is plotting another station
  STA$PLOTSOURCE$I = XSTA$PLOTSOURCE$I
else
  STA$PlotSource$I = xSTA$CopyPlotSource$I

#$% if player entry is "Force"
if (ILEX[ipnt] == $LEX$FORCE$)
   {
    #$% go to force name in array
    ipnt = ipnt + 1

    #$% move force name into msg1 array
    jj = 0   
    call SMOVHN(ilex[ipnt],$$MaxLit,msg,jj)
    Call SMOVV(" cannot be found for PLOT ",msg,jj)
    
    call untfnd(IVIEW,                          #locate the unit
                                                #IVIEW = the view (in)
                ILEX[ipnt],                     #pass the force name
                unt$POINTER)                    #receive unit pointer or zero

    #$% if unit found and view is not the Contol view
    if (unt$pointer != 0 & iview != $neutral$view)
       {
        #$% find available slot on OWN table
        call FNDOWN(own$pointer,                     #locate the unit
                    unt$pointer$index,
                    idummy,
                    noroom)

        #$% if OWN table full or owm unit not found, zero pointer
        if (noroom == $yes | Xown$Unit$i == 0) unt$pointer = 0
       }

    #$% go to next position in the array
    ipnt = ipnt + 1

    if(unt$pointer == 0)                        #if unit not found
       {
        #$% display msg with force name added (smov line, above) & return
        #call send_(iview,0,jj,msg)
        call echoh(msg,jj) # former msg1
        call echor
        return
       }

    #$% if neutral view
    if (iview == $neutral$view)
       {
        #$% set plot source type to true and match pointer index
        STA$PlotSourceType$i = $True$code
        STA$PlotSource$i     = unt$pointer$index
       }
    else
       {
        #$% set plot source type to own and match own pointer index
        STA$PlotSourceType$i = $OwnForce$code
        STA$PlotSource$i     = own$pointer$index
       }
   }
#$% if entry is "Position"
else if (ILEX[ipnt] == $LEX$POSITION$)
   {
    #$% go to latitude position in the array   
    ipnt = ipnt + 1
    #$% get latitude in radians
    f_LATITUDE = DMS2rad(ILEX[ipnt])

    #$% go to longitude position in the array
    ipnt = ipnt + 1
    #$% get longitude in radians
    f_LONGITUDE = DMS2rad(ILEX[ipnt])

    #$% Store the center latitude and longitude
    if (STA$PlotCopy$I == $no)      # if not plotting another station   # clk 12/92
      {
       putSTA$Latitude$F   (f_latitude)
       putSTA$Longitude$F  (f_longitude)
      }
    else                            # control plotting another station
      {
       putSTA$CopyLatitude$F   (f_latitude)
       putSTA$CopyLongitude$F  (f_longitude)
      }

    #$% go to next position in the array
    ipnt = ipnt + 1

    #$% set plot source type to null
    STA$PlotSourceType$I = $Null$code
   }
#$% else if entry is "TRACK"
else if (ILEX[ipnt] == $LEX$TRACK$)
   {
    #$% go to next position in the array to get track ID
    ipnt = ipnt + 1

    #$% initialize the remote track detection pointer
    RMT$Pointer = 0

    call gtact (iview,                          #locate track
                ilex[ipnt],                     #pass track number
                RMT$Pointer,                    #receive detection pointer
                ibonly)

    if(RMT$Pointer == 0)                        #if track invalid for this STA
       {
        #$% move track ID into msg array    
        jj = 0  
        call SMOVHN(ilex[ipnt],$$MaxName,msg,jj) # SMM 8/99 E2141
        Call SMOVV(" cannot be found for PLOT ",msg,jj)
        #$% display msg1 with track name added & return
        #call send_(iview,0,jj,msg) # former msg1
        call echoh(msg,jj)
        call echor
        return
       }

    if(ibonly == $yes)                          #if track passive
       {
        #$% move track ID into msg1 array    
        jj = 0  
        Call SMOVV("Can't center plot on passive track ",msg,jj)
        call SMOVHN(ilex[ipnt],$$MaxName,msg,jj) # SMM 8/99 E2141
        #$% display msg with track name added & return
        #call send_(iview,0,jj,msg) # former msg2
        call echoh(msg,jj)
        call echor
        return
       }

    #$% set plot source type to other force
    STA$PlotSourceType$i = $OtherForce$code
    STA$PlotSource$i     = rmt$pointer$index
   }                                            #endif track centered

#$% save data
if (STA$PlotCopy$I == $no)      # if not plotting another station   # clk 12/92
  {
   PUTSTA$PlotSourceType$i
   PUTSTA$PlotSource$i
  }
else                            # control plotting another station
  {
   putSTA$CopyPlotSourceType$I  (STA$PlotSourceType$I)
   putSTA$CopyPlotSource$I      (STA$PlotSource$I) 
  }

STA$PlotMap$i = $yes                            #flag new map
PUTSTA$PlotMap$i

return
end


Subroutine PL_pASTAB (ionum, ista, iwords, ilex) 

#########################################################################
#$%
#$% Purpose:    PL_pASTAB generates and validates data to print the
#$%             ASTAB for the station.
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      Print_ASTAB
#$%
#$% Author:     TIMOTHY ADAMOS
#$%
#$% Date:       JANUARY 83
#$%
############################################################################

#PRINT ASTAB <astab>
#            ALL
#

BBcommon

BBDeclare  (STA$Pointer, STA$Sbiindex$I,
            STA$Nbrastabs$I, STA$Plotprtint$I,
            SBI$Pointer)                                # MJC 8/1/2000
integer IWORDS, ISTA, IASTB, M, N, Ionum                # MJC 4/20/2000
literal ILEX[iwords]

STA$Pointer$To ista

if (ilex[2] == $LEX$ASTAB$)
    {
    STA$NbrAstabs$I = xSTA$NbrAstabs$I

    if (ilex[3] == $LEX$All$)
        {
        m = 1
        n = STA$NbrAstabs$I
        }
    else
        {
        m = ilex[3]
        n = m

        if (n > STA$NbrAstabs$I) n = STA$NbrAstabs$I
        }

    STA$SBIindex$I = xSTA$SBIindex$I

    for (iastb=m; iastb<=n; iastb=iastb+1)
        {
        SBI$Pointer$To (STA$SBIindex$I+iastb-1)

        putSBI$PrintRequest$I (YES)
        }
    }
else if (ilex[2] == $LEX$PLOT$)
    {
    if (iwords == 2)
        PUTsta$PlotPrint$i (YES)
    else if (ilex[3] == $LEX$INTERVAL$) # Check for entry of a plot
        {                               # print interval        
        STA$PlotPrtInt$I = ilex[4]      # save the interval entered
        STA$PlotPrtInt$I = min(255, STA$PlotPrtInt$I)
        putSTA$PlotPrtInt$I             #      CLF 2/11/87      
        }
    }

return
end




Subroutine PL_CPA (iord_num,                           #receive order number 
                   ista_num,                           #receive station
                   iword_cnt,                          #receive word count
                   ilex)                               #receive command string

##################################################################
#$%
#$% Purpose:    PL_CPA generates closest point of approach 
#$%             of a target/force/position from a target or force 
#$%             based on lat/long (true if target held visually
#$%              - otherwise apparent)
#$%
#$% Called by:  PL_EXEORD
#$%
#$% Calls:      CPA
#$%             
#$% Author:     Theresa Scileppi
#$%
#$% Date:       July 1984
#$%
#$% Modified:   John McCormick - 1/16/98 (E1926)
#$%             Corrected call to Game_DTG to be a real.
#$%
####################################################################

BBcommon

BBDeclare  (STA$Pointer, UNT$Pointer,
            OWN$Pointer, RMT$Pointer)               # MJC 8/1/2000
integer IWORD_CNT, ISTA_NUM, IVIEW,
        IORD_NUM, I, IPNT, ISPD,
        IBONLY, IDUMMY, NOROOM, IBRG,
        IRANGE, KTIME, KDIST, ICSE                  # MJC 4/20/2000
real    RANGE, BEARING, DMS2RAD                     # MJC 4/20/2000
literal cstrip8                                     # MJC 4/20/2000
literal ilex[iword_cnt], hold[28],  ierror[4]
integer hlen,Game_DTG, kk
real    lat[2],lon[2],clat[2],course[2],speed[2]
real    rdist, rtime

STA$POINTER$TO ista_num
iview = xSTA$View$I

#$% initialize values
hold[1] = 0
hold[2] = 0
hold[3] = iord_num

#$% for each word, get input string
for (i = 1; i <= iword_cnt; i = i + 1) hold[i+3] = ilex[i]

hlen = iword_cnt + 3

#$% initialize the array position
ipnt = 2

for (i = 1; i <= 2; i = i + 1)
    {
     ierror[1] = 'ok'                        #initialize
     ibonly    = $no

     #$% if input string is Force
     if (ilex[ipnt] == $Lex$Force$)
        {
         call untfnd(IVIEW,                          #locate the unit
                                                #IVIEW = the view (in)
                ILEX[ipnt+1],                     #pass the force name
                unt$POINTER)                    #receive unit pointer or zero

         #$% if pointer not in range
         if (! unt$pointer$Valid)
            {
             #$% set error flag
             ierror[1] = '?????'
             break
            }

         #$% if CONTROL is requesting view or unit is a shorebase
         if (iview == $neutral$view | xunt$type$i == $shorebase$code)
            {
             #$% get true position course and speed
             course[i] = xunt$TrueCourse$F
             speed[i]  = xunt$TrueSpeed$F
             lat[i]    = xunt$TrueLatitude$F
             lon[i]    = xunt$TrueLongitude$F
            }
         #$% else if own view is the requesting view 
         else if (xunt$View$i == iview)
            {
             #$% find the Force's slot in the OWN table
             call FNDOWN(own$pointer,unt$pointer$index,idummy,noroom)

             #$% if OWN table full or own unit not found
             if (noroom == $yes | Xown$Unit$i == 0)
                {
                 #$% set error flag and break
                 ierror[1] = '?????'
                 break
                }
             #$% get own position course and speed

####         course[i] = DEGMRA(int(xOWN$Course$I))     #       8/20/84
             course[i] = xOWN$Course$I * $PI/180.       #       8/20/84
             speed[i]  = xOWN$Speed$I                   # float 8/23/84 
             lat[i]    = xOWN$Latitude$F
             lon[i]    = xOWN$Longitude$F
            }

         #$% go to next position in the array
         ipnt = ipnt + 2
        }                                           #end if to or from force
     else if (ilex[ipnt] == $Lex$Track$)            # must be a track number
        {
         #$% initialize remote track pointer
         RMT$Pointer = 0

         #$% get active track from remote track table
         call gtact(iview,ilex[ipnt+1],rmt$pointer,ibonly)

         #$% if track not found
         if (RMT$Pointer == 0)
            {
             #$% set error flag and break
             ierror[1] = '?????'
             break
            }

         #$% if Control is requesting view
         if (iview == $neutral$view)      
            {
           #$% set pointer to detectee in remote track table
             unt$pointer$to xrmt$detectee$i

##           course[i] = DEGMRA(int(xunt$Course$I))     #       8/20/84
             course[i] = xunt$TrueCourse$F              #       8/24/84
             speed[i]  = xunt$TrueSpeed$F               #       8/20/84
             lat[i]    = Xunt$truelatitude$F        #true position of detectee
             lon[i]    = Xunt$truelongitude$F
            }
         #$% else if the track is active
         else if (ibonly == $no)
            {
             #$% get apparent position

####         Course[i] = DEGMRA(int(xRMT$Course$I))     #       8/20/84
             Course[i] = xRMT$Course$I * $PI/180.       #       8/20/84
             speed[i]  = xRMT$Speed$I
             lat[i]    = Xrmt$ApparentLat$f
             lon[i]    = Xrmt$ApparentLon$f
            }
         else
            {
             #$% set error flag and break
             ierror[1] = '?????'
             break
            }

         #$% go to next position in the array
         ipnt = ipnt + 2                        
        }                                       # end if from/to TRACK
    else # if (ilex[ipnt] == $Lex$Position$)    # must be TO a position
        {
        Course[i] = 0
        speed[i]  = 0
        lat[i]    = DMS2rad(ilex[ipnt+1])
        lon[i]    = DMS2rad(ilex[ipnt+2])
        }
    }

 #$% if error flag activated
 if (ierror[1] == '?????')  
    {
     #$% get error values and display
     ierror[2] = ilex[ipnt+1]
     call echohn(ilex[ipnt+1],$$MaxLit)

     #$% if track is active
     if (ibonly == $no)
        {
         #$% get word "unknown" and display         
         ierror[3] = $Lex$Unknown$
         kk = 0; call smovv ("        ", ierror[4], kk)
         call echov(" Unknown ")  
        }
     else
        {
         #$% if bearing known, get and display "bearing only"
         ierror[3] = $Lex$Bearing$
         ierror[4] = 'ONLY'
         call echov(" Bearing Only ")  
        }

     #$% set all four ierror data entries to the hold array
     do i=1,4
        {
         hlen = hlen + 1
         hold[hlen] = ierror[i]
        }
    }

 else
    {
     clat[1] = COS(lat[1])                     #get cosine of from lat
     clat[2] = COS(lat[2])                     #get cosine of to lat

     #$% convert target range and bearing from lat/long
     call RLL2RB(lat[1],lon[1],clat[1],lat[2],lon[2],clat[2],range,bearing)

     irange = INT(range + .5)                     #get range as integer
     if (range < 1.1  | irange < 1)               #jb Prevent ZERO 6/14/89
      {
        call echov(" Range is now within 1 mile: ")  
        call echor
        call echov("   [ Station transfer-at-sea detail or ")
        call echov("sound collision alarm! ] ")  
        call echor
        RETURN
      }
          
     call RCPA(_
              rdist,            # Returned:  CPA distance (naut. miles)
              course[1],                  # (radians):course of object-1
              speed[1],                   # (knots  ):speed  of object-1
              course[2],                  # (radians):course of object-2
              speed[2],                   # (knots  ):speed  of object-2 
              range,                      # Initial range between objects 
              bearing,                    # (radians) init. brg from OBJ1 to 2
              rtime )            # Returned:  (min.) - elapsed time

      ktime = int (rtime + 0.5)    # perform type conversion - jhm  1/16/98 (E1926) 
      kdist = rdist

     if (ktime == -12)                            # jb    6/14/89
      {
       call echov(" No CPA in next 12 hours.  Range is now ")  
        if      (range >= 50.0)  call echoi(irange)
        else if (range >=  5.0)  call echof(range,1)
        else                     call echof(range,2)
       call echov(" n.mi. ")  
      }  

     else if (ktime < 0)   # Flag:  range not closing (else: 6/14/89)
      {
        call echov(" Range NOT CLOSING:  now is ")  
        if      (range >= 50.0)  call echoi(irange)
        else if (range >=  5.0)  call echof(range,1)
        else                     call echof(range,2)
        call echov(" n.mi. ")  
      }

     else
      {
        rtime = game$minute + rtime        # Game-minute of CPA
        call echov(" CPA ")  

        if      (rdist >= 50.0)  call echoi(kdist)
        else if (rdist >=  5.0)  call echof(rdist,1)
        else                     call echof(rdist,2)
    
        call echov(" n.mi. at ")  
        call echoiz(Game_DTG(rtime),6)
        call echov(" ZULU ")  
      }
     call echor

    }                                           #end if inputs were valid

 return
 end            # End Subroutine PL_CPA


subroutine pl_lobemit (ionum,ista,iwords,ilex)
###########################################################################
#$%
#$%  PL_LOBEMIT inserts or deletes names of the emitters specified into
#$%  the emitter list.  The emitter list is used for plotting of esm lines
#$%  of the specified emitters only.  The player is shown what the current
#$%  list is upon completion of the request.
#$%
###########################################################################

bbcommon

BBDeclare  (STA$Pointer, STA$EER$Index, STA$Eernum$I)       # MJC 8/1/2000
literal CSTRIP8                                             # MJC 4/20/2000
literal ILEX[30],name
integer ista,iwords,found,i,j,iptr,litcmp,ionum

  sta$pointer$to ista
  if (ilex[1] == $lex$erase$)            # remove emitter name(s) from list
    {
     if (iwords == 3)          # clear list with nulls
       {
        for (sta$eer$index = 1; sta$eer$index <= sta$eer$slots; 
             sta$eer$index = sta$eer$index + 1)
          putsta$eer$name$c ($NULL)
        putsta$eernum$i (0)
        call echov("Emitter list cleared")  
        call echor
        return
       }
     for ( i = 4; ilex[i] != $NULL; i = i + 1)  # for each emitter (up to 8)
       {
        found = $no
        sta$eernum$i = xsta$eernum$i
        for (sta$eer$index = 1; sta$eer$index <= sta$eernum$i; # search list
             sta$eer$index = sta$eer$index + 1)
          if (xsta$eer$name$c == ilex[i])
            {
             found = $yes
             for (j = sta$eer$index + 1; j <= sta$eernum$i; j = j + 1)
               {
                sta$eer$index = j                # delete name, bring the 
                name = Xsta$eer$name$c           # rest of the list up
                sta$eer$index = j - 1
                PUTsta$eer$name$c (name)
               }
             sta$eer$index = sta$eernum$i
             putsta$eer$name$c ($NULL)           # clear last entry
             BREAK
            }
        call echov("Emitter ")  
        call echohn(ilex[i],$$MaxLit)
        if (found == $NO)
          call echov(" not found in list")  
        else 
          {
           call echov(" removed from list")  
           putsta$eernum$i (sta$eernum$i - 1)
          }
        call echor
     }
    }

  else   # ilex[1] == $lex$plot$
    {
     if (iwords == 3)                   # not possible
       {
        call echov("Try PLOT LOB ESM instead")  
        call echor
        return
       }
     for (i = 4; ilex[i] != $NULL; i = i + 1)     # up to 8 possible names
       {
        found = $no
        sta$eernum$i = xsta$eernum$i
        iptr = 0
        if (sta$eernum$i < sta$eer$slots)  # if there is room
          for (sta$eer$index = 1; sta$eer$index <= sta$eernum$i; 
               sta$eer$index = sta$eer$index + 1)
            {
             j = litcmp(ilex[i],xsta$eer$name$c)  # compare name to list
             if (j == 0)
               {                                  # already in list
                found = $yes
                BREAK
               }
             else if (j < 0)                      # less than current list name
               {
                iptr = sta$eer$index
                BREAK                             # found the place 
               }
            }
        call echov("Emitter ")
        call echohn(ilex[i],$$MaxLit)
        if (found == $no)
          {
           if (sta$eernum$i == sta$eer$slots)
             call echov(" not entered")  
           else 
             {
              if (iptr == 0)
                iptr = sta$eernum$i + 1
              else
                for (j = sta$eernum$i; j >= iptr; j = j - 1)
                  {
                   sta$eer$index = j
                   name = xsta$eer$name$c
                   sta$eer$index = j + 1
                   putsta$eer$name$c (name)
                  }
              sta$eer$index = iptr
              putsta$eer$name$c (ilex[i])
              putsta$eernum$i (sta$eernum$i + 1)
              call echov(" entered.")  
             }
          }
        else
          call echov(" previously entered")  
        call echor
       }
    }
  call echor
  call disp_eerlist(sta$pointer)
  call echor

  return
  end


subroutine disp_eerlist (sta$pointer)

######################################################################
#$%
#$%  Disp_eerlist displays the list of emitters chosen to display on
#$% the graphics terminal for orange or blue players.
#$%
######################################################################

bbcommon

BBDeclare  (STA$Eernum$I, STA$Pointer, STA$EER$Index)       # MJC 8/1/2000
literal CSTRIP8                                             # MJC 4/20/2000

  call echov("Emitter List: ")  
  sta$eernum$i = xsta$eernum$i
  if (sta$eernum$i == 0)
    call echov("<NONE>")  
  else
    for (sta$eer$index = 1; sta$eer$index <= sta$eernum$i; 
         sta$eer$index = sta$eer$index + 1)
      {
       call echohn(xsta$eer$name$c,$$MaxLit)
       call echov(" ")
      }
  call echor
  return
  end



Subroutine PL_XLIN(ionum,                              #receive order number 
                   ista,                               #receive station
                   iwords,                             #receive number words
                   ilex,                               #receive parameters
                   indx)                               # out: index of plc or lin
##################################################################
#$%
#$% Purpose:    PL_XLIN generates a POLYGON or LINE-SEQUENCE on
#$%             the geographic plot, using latitudes/longitudes
#$%             in the sequence entered by the player
#$%
#$% Called by:  PL_XCIR
#$%
#$% Calls:      send_    SMOVH
#$%
#$% Author:    Joe Bryant
#$%
#$% Date:       November 1989
#$%
#$% Modified:   Carol Kropp - 2/96 (E1543)
#$%             When a control station entered the COLOR command
#$%             and multiple stations had a line/polygon with the
#$%             specified name, the last station which entered
#$%             the PLOT command would receive the color change
#$%             not the station which requested the color change.
#$%
#$%             Jim Allen - 2/98 (E1864)
#$%             Added argument to PL_xlin to return the LIN table entry
#$%             index, used for Improved Cruise Missile Model, so the
#$%             CM planning knows the location.
#$%
####################################################################

BBcommon

############################################################################
# {902,AB      }                 DELETE [ POLYGON | LINE (sequence) ]
#                                            [ ALL | NAMED <name>];
# {915,AB      }                 DEFINE (a) [POLYGON ( | LINE (sequence ]
#                                     named) <name>
#                                    (point 1) <latitude> <longitude> 
# {915,AB      }                 COLOR [POLYGON ( | LINE (sequence ]
#                                     named) <name>
#                                    [name of color]
# {917,ABQ     }                 [PLOT | ERASE] [POLYGON | LINE (sequence) ] 
#                                            [ ALL | NAMED <name>];
###############################################################################

BBDeclare  (LIN$Numpts$I, LIN$Line$I, LIN$Pointer,
            LIN$Station$I, LIN$PTS$Index, LIN$Name$C,
            LIN$PTS$latitude$F, LIN$PTS$longitude$F,
            STA$Pointer)                                # MJC 8/1/2000
integer     IWORDS, ISTA, IVIEW, INDXLAT, Ionum         # MJC 4/20/2000
literal     CSTRIP8                                     # MJC 4/20/2000
literal     ILEX[iwords]
real        DMS2rad
integer     color_indx
integer     empty_entry
integer     matching_entry
integer     indx
integer     op_Given
integer     type_Given
integer     iTEST_type    # jb                            9/19/90
literal     name_Given
logical     all_entries
BBDeclare (sta$PlotLines$i)
#----------------------------------------
# parse the command for the values given

indx        = 0
op_Given    = ilex[1] # $DEFINE$ $ERASE$ or $COLOR$ or $PLOT$ or $DELETE$

type_Given  = ilex[2]             # $LEX$LINE$ or $LEX$POLYGON$
all_entries = ilex[3] == $LEX$All$
if (! All_Entries)
    {
    if (ilex[3] == $LEX$Named$) name_Given = ilex[4]
    else                        name_Given = ilex[3]
    }

STA$Pointer$To ista
iview = xSTA$View$I

# If sta$plotlines$i = $no plot will not attempt to plot any lines
sta$PlotLines$i = $yes
if (ALL_Entries & OP_Given == $lex$Erase$) sta$PlotLines$i = $no
PUTsta$plotLines$i

#----------------------------------------
# Look for the matching entry

empty_entry     = 0
matching_entry  = 0

for(LIN$POINTER$FIRST;LIN$POINTER$valid;LIN$POINTER$NEXT)
    {
    LIN$Station$i = xLIN$Station$i      

    if (LIN$Station$i == 0)
        {
        if (empty_entry == 0) 
            empty_entry = lin$pointer

        next
        }

    if (LIN$Station$i != ista) NEXT 

    iTEST_type = xLIN$LINE$i    # jb                9/19/90
    if (type_given == $Lex$LINE$ & iTEST_type != $YES)  NEXT # 9/19/90 
    if (type_given != $Lex$LINE$ & iTEST_type == $YES)  NEXT # 9/19/90  

    if (All_Entries)
        {
        # Don't erase plan fire polygon - joa 2/98 (E1864)
        if (LIN$Pointer$Index == xSTA$PlanCMPolygonIndx$I)
           next
        matching_entry = lin$pointer
        }
    else if (xLIN$Name$C == name_given)   # NAMED <xxx>
        {
        matching_entry = lin$pointer
        }
    else 
        {
        next
        }

    if (OP_Given == $lex$Delete$)
    {
        # Don't erase polygon used for ghost geo filter
        if (LIN$Pointer$Index == xSTA$PlotGhostPolygonIndx$I)
        {
            call echov (" Polygon not deleted.  Used as ghost geo filter.")  
            call echor
        }
        else
        {
            lin$zero
        }

        next
    }

    else if (OP_Given == $lex$Erase$)
        {
        PUTlin$PlotFlag$i (0)
        next
        }

    else if (OP_Given == $lex$Plot$)
        {
        PUTlin$PlotFlag$i (1)
        next
        }

    if (matching_entry != 0 & empty_entry != 0) break

    }    # End FOR thru LIN table

#----------------------------------------
# report results...

if (OP_given == $Lex$Define$ & empty_entry == 0)
    {
    call echov ("  Table FULL")  
    call echor

    }
else if (OP_given != $Lex$Define$ & matching_entry == 0)
    {
    if (type_given == $Lex$LINE$)
        call echov ("  Line NOT FOUND")  
    else  
        call echov ("  Polygon NOT FOUND")  
    call echor
    }

##--------------------------------------------------------------

if (ilex[1] == $Lex$COLOR$)
    {
    lin$pointer = matching_entry

    # get the specified color index
    call Trans_Color (ilex,4,Color_indx)      # Get the color specified

    putLIN$color$i (color_Indx)    

    } # end IF COLOR 
##--------------------------------------------------------------

else if (ilex[1] == $Lex$DEFINE$)
   {
#$% determine if LineSequence or POLYGON and set LIN$LINE$I

    LIN$NumPTS$I = (iwords-3)/2
    if  (type_given == $LEX$LINE$ | LIN$NumPTS$I < 3 )
            LIN$LINE$I = $YES
    else    LIN$LINE$I = $NO

    lin$pointer = empty_entry

    indxlat = 4
    for(LIN$PTS$Index=1; LIN$PTS$Index <=LIN$NumPTS$I;
                                LIN$PTS$Index=LIN$PTS$Index +1)
       {
        LIN$PTS$Latitude$F  = DMS2rad(ILEX[indxlat])
        LIN$PTS$Longitude$F = DMS2rad(ILEX[indxlat +1])
        PUTLIN$PTS$LATITUDE$F
        PUTLIN$PTS$LONGITUDE$F
        indxlat = indxlat +2
       }

    putLIN$NumPTS$I

    LIN$Name$c = ILEX[3]
    putLIN$Name$c
    PUTLIN$View$i  (iview)
    PUTLIN$STATION$I (ista)
    putLIN$LINE$I
    PUTlin$PlotFlag$i (1)           # Will currently be plotted

    #$% reset high-water mark in LIN table..
    if (!LIN$pointer$OK) LIN$last$to LIN$pointer + LIN$entry - 1

    indx = LIN$Pointer$Index
   }

 return
 end



Subroutine PL_ROUTE (IONUM,                     #receive order number
                    ista,                       #receive station
                    IWORDS,                     #receive number of words
                    ILEX)                       #receive parameters

########################################################
#$%
#$% Purpose:   PL_ROUTE loads the route sub table in the STA table 
#$%            with the indexes of the routes to be plotted and the
#$%            color to plot them in.
#$%
#$% Called By: PL_PLOT
#$%
#$% Calls:
#$%
#$% Tables:    STA    RTE
#$%
#$% Date:      7 Janruary 89
#$%
#$% Author:    Sgt. Allen Griffin  (AWSIMS)
#$%
#$% Modified:  Carol Kropp - 11/96 (E1659)
#$%            Rewrote the routine to add extra arguments
#$%            for plotting/erasing all routes for a view.
#$%
#$% The following are control commands (blue and orange
#$% do not have the [ | NEUTRAL | ... ] option):
#$%
#$%    PLOT ROUTE [ ALL | NAMED <route-name> | QUEUE ] (for view)
#$%               [ | NEUTRAL | BLUE | ORANGE ]
#$%               [ | COLOR [ ORANGE   | BROWN | YELLOW | GREY    | GREEN |
#$%                           MUDGREEN | NAVY  | PURPLE | MAGENTA |
#$%                           [ | DARK ] [ RED | BLUE ] | [ | OFF ] WHITE ] ];
#$%    ERASE ROUTE [ ALL | NAMED <route-name> | QUEUE ] (for view)
#$%                [ | NEUTRAL | BLUE | ORANGE ];
#$%
########################################################
BBCommon

BBDeclare  (STA$Pointer, STA$View$I,
            RTE$Pointer, RTE$PAS$Index, RTE$View$I, RTE$Name$C,
            PRT$Pointer, PRT$RTE_Index$I, PRT$STA_Index$I)          # MJC 8/1/2000
integer    IONUM                                                    # MJC 4/20/2000
literal    CSTRIP8                                                  # MJC 4/21/2000
integer    ista, iwords
literal    ilex [iwords]
integer    ilex_index
integer    plot_all_routes, plot_all_Qroutes
literal    specified_route_name
integer    specified_route_side   # $Neutral$Code, $Blue$Code, $Orange$Code, $All$Code
integer    current_route_side
integer    route_color
integer    route_located_flag
integer    current_rte_index
integer    empty_prt_ptr
integer    desired_route_prt_ptr

  STA$Pointer$To (ista)
  STA$View$I = xSTA$View$I

  if (ilex[3] == $lex$All$)
    {
     plot_all_routes = $yes
     plot_all_Qroutes = $no
     specified_route_name = $Blank_Literal
     ilex_index = 4
    }
  else if (ilex[3] == $lex$Queue$)
    {
     plot_all_routes = $no
     plot_all_Qroutes = $yes
     specified_route_name = $Blank_Literal
     ilex_index = 4
    }
  else
    {
     plot_all_routes = $no
     plot_all_Qroutes = $no
     specified_route_name = ilex[4]
     ilex_index = 5
    }

  if (ilex[ilex_index] == $lex$Neutral$)
    {
     specified_route_side = $Neutral$Code
     ilex_index = ilex_index + 1
    }
  else if (ilex[ilex_index] == $lex$Blue$)
    {
     specified_route_side = $Blue$Code
     ilex_index = ilex_index + 1
    }
  else if (ilex[ilex_index] == $lex$Orange$)
    {
     specified_route_side = $Orange$Code
     ilex_index = ilex_index + 1
    }
  else  # no specific view was specified
    {
     if (STA$View$I == $Neutral$View)
       specified_route_side = $All$Code
     else if (STA$View$I <= $LastBlue$View)
       specified_route_side = $Blue$Code
     else
       specified_route_side = $Orange$Code
    }

  if (ilex[ilex_index] == $lex$Color$)
    {
     ilex_index = ilex_index + 1
     call Trans_Color (ilex, ilex_index, route_color)
    }  
  else
    route_color = $Color$Route

  route_located_flag = $no
  for (RTE$Pointer$First; RTE$Pointer$OK; RTE$Pointer$Next)
    {
     RTE$Name$C = xRTE$Name$C
     RTE$View$I = xRTE$View$I
     call whside (RTE$View$I, current_route_side)
     if (plot_all_routes == $yes |
         (specified_route_name == RTE$Name$C &
         (specified_route_side == $All$Code |
          specified_route_side == current_route_side)) |
         (plot_all_Qroutes == $yes & xRTE$QrouteFlag$i == $yes))
       {
           route_located_flag = $yes

           current_rte_index = RTE$Pointer$Index
           empty_prt_ptr = $no
           desired_route_prt_ptr = $no
           for (PRT$Pointer$First; PRT$Pointer$Ok; PRT$Pointer$Next)
             {
              PRT$RTE_Index$I = xPRT$RTE_Index$I
              PRT$STA_Index$I = xPRT$STA_Index$I 

              if (empty_prt_ptr == $no & PRT$RTE_Index$I == 0)  # here's an empty
                empty_prt_ptr = PRT$Pointer

              if (desired_route_prt_ptr == $no & 
                  PRT$RTE_Index$I == current_rte_index &
                  PRT$STA_Index$I == ista)
                {
                 desired_route_prt_ptr = PRT$Pointer
                 break
                }   # end of if we have located the desired route
             }   # end of loop looking for route or and empty slot

           if (ilex[1] == $lex$PLOT$)
             {
              if (desired_route_prt_ptr != $no)
                 PRT$Pointer = desired_route_prt_ptr
              else if (empty_prt_ptr != $no)
                 PRT$Pointer = empty_prt_ptr
              else   # the route was not already plotted and
                {    # there is no space is the PRT table for it
                 call echov  ("PLOT ROUTE ")
                 if (plot_all_routes == $yes)
                    call echov ("ALL")
                 else if (plot_all_Qroutes == $yes)
                    call echov ("QUEUE")
                 else
                   {
                    call echov  ("NAMED ")
                    call echohn (specified_route_name, $$MaxLit)
                   }
                 call echov (" command cannot be completed -")
                 call echor
                 call echov ("No more routes can be plotted.")  
                 call echor
                 return
                }   # end of if the route was not already plotted & there is no room

              putPRT$View$I      (RTE$View$I)
              putPRT$STA_Index$I (ista) 
              putPRT$RTE_Index$I (current_rte_index)   
              putPRT$Color$I     (route_color)       
             }   # end of if plotting routes
           else   # routes are being erased
             {
              if (desired_route_prt_ptr != $no)
                {
                 PRT$Pointer = desired_route_prt_ptr
                 PRT$Zero
                }   # end of if the current route was located in the table
             }   # end of if route are being erased
       }   # end of if this route is eligible to be plotted
    }   # end of loop through the route table

  if (route_located_flag == $no & ilex[1] == $lex$Plot$)
    {
     call echov ("PLOT ROUTE ")
     if (plot_all_routes == $yes)
       call echov ("ALL")
     else if (plot_all_Qroutes == $yes)
       call echov ("QUEUE")
     else
       {
        call echov  ("NAMED ")
        call echohn (specified_route_name, $$MaxLit)
       }
     call echov (" command cannot be completed -")
     call echor
     call echov ("The route was not located.")  
     call echor
    }   # end of if no routes to be plotted were located

return
end    


Subroutine PL_SPA (ionum,      # input - order number
                   ista,       # input - station
                   iwords,     # input - number of words
                   ilex)       # input - order parameters

########################################################
#$%
#$% Purpose:   PL_SPA loads the PSP (Plot Submarine
#$%            Patrol area) table with the index
#$%            of the Submarine Patrol Area to be
#$%            plotted and the color which to plot it.
#$%
#$% Called By: PL_PLOT
#$%
#$% Calls:
#$%
#$% Tables:    STA     SPA     PSP
#$%
#$% Date:      October 1991
#$%
#$% Author:    Carol L. Kropp
#$%
#$% Modified:
#$%            James O. Allen  April 28, 2005 per_ordsyntax
#$%            New plot and erase syntax to plot/erase all or named spas
#$%            Internal table of effective spas created to handle latest
#$%             effective SPAs. 
########################################################
BBCommon

integer    ista, iwords
literal    ilex [iwords]
Character  msg[ARB]
integer    msg_len, ionum
integer    spa_color, spa_index, spa_side
integer    plot_all_spas, i, ilex_index, found_dup
real       spa_effective_time
integer    free_PSP_slot, match_PSP
integer    STA$Pointer, STA$View$I
integer    SPA$Pointer, SPA$View$I
real       spa$EffectiveTime$f
literal    SPA$Name$C
integer    PSP$Pointer
literal    specified_spa_name
literal    CSTRIP8               # MJC 4/21/2000
# Table of effective SPAs to plot
integer  plot_spa_index
integer  plot_spa_pointer [SPA$Slots]
real     plot_spa_EffectiveTime [SPA$Slots]
literal  plot_spa_name [SPA$Slots]

#{916,ABQ      }   PLOT [ SPA | AOA] [ ALL | NAMED <name> ]
#                       [ | COLOR
#                              [ ORANGE   | BROWN | YELLOW | GREY    | GREEN |
#                                MUDGREEN | NAVY  | PURPLE | MAGENTA |
#                                [ | DARK ] [ RED | BLUE ] | [ | OFF ] WHITE ] ];
#
#{916,ABQ      }   ERASE [ SPA  | AOA ] [ALL | NAMED <name> ];

STA$Pointer$To  ista           # set station pointer
STA$View$I = xSTA$View$I

if (ilex[3] == $lex$All$)
{
    plot_all_spas = $yes
    specified_spa_name = $Blank_Literal
    ilex_index = 4
}
else
{
    plot_all_spas = $no
    specified_spa_name = ilex[4]
    ilex_index = 5
}

if (ilex [1] == $LEX$Plot$)
{
    if (ilex [ilex_index] == $LEX$Color$ )
    {
       ilex_index = ilex_index + 1
       call Trans_Color (ilex, ilex_index, spa_color) # get the color the spa is to be
    }
    else
    {
        if (spa_side == $Blue$Code)
          spa_color = $Default$Blue$SPA$Color
        else  # spa_side = orange
          spa_color = $Default$Orange$SPA$Color
    }
}

plot_spa_index = 0     
for (SPA$Pointer$First; SPA$Pointer$Valid; SPA$Pointer$Next)
{
    SPA$Name$C = xSPA$Name$C

    SPA$View$I = xSPA$View$I
    if (SPA$View$I >= $FirstBlue$View &    # if the SPA is blue
         SPA$View$I <= $LastBlue$View)
       spa_side = $Blue$Code
    else
       spa_side = $Orange$Code
       
    if (STA$View$i != $Neutral$View)    # if this is not control
    {
        if ((STA$View$I >= $FirstBlue$View &    # if the station is blue
             STA$View$I <= $LastBlue$View) &    #     and
            (spa_side == $Orange$Code))         # the spa is orange - next
          next                           

        if ((STA$View$I >= $FirstOrange$View &  # if the station is orange
             STA$View$I <= $LastOrange$View) &  #     and
            (spa_side == $Blue$Code))           # the spa is blue - next
          next                           
    }

    spa$EffectiveTime$f = xspa$EffectiveTime$f
    if (spa$EffectiveTime$f > Game$Time)  # if the SPA is not effective yet - next
       next

    found_dup = $no
    for (i = 1; i <= plot_spa_index; i = i + 1)
    {
        if (spa$Name$c != plot_spa_name[i]) next

        found_dup = $yes

        if (plot_spa_effectivetime[i] < xspa$EffectiveTime$f) 
        {
           plot_spa_effectivetime[i] = xspa$EffectiveTime$f
        }
    }
    if (found_dup == $no)
    {
        plot_spa_index = plot_spa_index + 1
        plot_spa_name[plot_spa_index] = spa$name$c
        plot_spa_pointer[plot_spa_index] = spa$pointer
        plot_spa_effectiveTime[plot_spa_index] = Xspa$EffectiveTime$f
    }
}

if (plot_all_spas == $no)
{
    spa_index = 0     
    for (i = 1; i <= plot_spa_index; i = i + 1)
    {
        spa$pointer = plot_spa_pointer[i]
    
        SPA$Name$C = xSPA$Name$C
    
        SPA$View$I = xSPA$View$I
        if (SPA$View$I >= $FirstBlue$View &    # if the SPA is blue
             SPA$View$I <= $LastBlue$View)
           spa_side = $Blue$Code
        else
           spa_side = $Orange$Code
           
        if (specified_spa_name != SPA$Name$C) next

        spa_index = spa$pointer$index
    
        free_PSP_slot = 0
        match_PSP = 0
    
        # loop through the PSP table to find the SPA or a free table slot
        for (PSP$Pointer$First; PSP$Pointer$Valid; PSP$Pointer$Next)
        {
            if (xPSP$InUse$I == $no)
            {
                if (free_PSP_slot == 0)
                  free_PSP_slot = PSP$Pointer
            }
            else    # the slot is in use
            {
                SPA$Pointer$To  (xPSP$SPA_Index$I)
                if (match_PSP == 0           &     
                    xPSP$STA_Index$I == ista &   # the SPAs station = the station and
                    xSPA$Name$C == specified_spa_name) # it is the correct SPA name
                {
                   match_PSP = PSP$Pointer
                   break
                }
            }
        }    
        if (ilex[1] == $lex$plot$)
        {
            if (match_PSP != 0)
                PSP$Pointer = match_PSP
            else if (free_PSP_slot != 0)
                PSP$Pointer = free_PSP_slot
            else
            {
                call echov ("Table full - cannot plot SPA")  
                call echor
                return
            }
            
            putPSP$Side$I (spa_side)
            putPSP$STA_Index$I (ista) 
            putPSP$SPA_Index$I (spa_index)   
            putPSP$Color$I (spa_color)       

            #$% reset high-water mark in PSP table..
            if (!PSP$pointer$OK) PSP$last$to PSP$pointer + PSP$entry - 1

        }
        else if (ilex[1] == $lex$erase$)
        {
            if (match_PSP != 0)
            {
                PSP$Pointer = match_PSP
                PSP$Zero
            }
        }
    }
    if (spa_index == 0)               # if it wasn't found 
    {
        msg_len = 0
        call smovv  ("No currently active SPA named ", msg, msg_len)
        call smovhn (specified_spa_name, $$MaxLit, msg, msg_len) # SMM 8/99 E2141
        call smovv  (" was not found for your side. ", msg, msg_len)
        call echoh  (msg, msg_len)
        call echor
        return
    }
}
else                            # plot/erase all SPAs
{
    # Erase all SPAs
    if (ilex[1] == $lex$erase$)
    {
        # loop through the PSP table to find the SPA or a free table slot
        for (PSP$Pointer$First; PSP$Pointer$Valid; PSP$Pointer$Next)
        {
            if (xPSP$InUse$I == $no) next
            if (xPSP$STA_Index$I == ista)  # the SPAs station = the station
            {
                PSP$Zero
            }
        }    
    }
    else        # PLOT
    {
        for (i = 1; i <= plot_spa_index; i = i + 1)
        {
            spa$pointer = plot_spa_pointer[i]
        
            SPA$Name$C = xSPA$Name$C
        
            SPA$View$I = xSPA$View$I
            if (SPA$View$I >= $FirstBlue$View &    # if the SPA is blue
                 SPA$View$I <= $LastBlue$View)
               spa_side = $Blue$Code
            else
               spa_side = $Orange$Code
               
            spa_index = spa$pointer$index
        
            free_PSP_slot = 0
            match_PSP = 0
        
            # loop through the PSP table to find the SPA or a free table slot
            for (PSP$Pointer$First; PSP$Pointer$Valid; PSP$Pointer$Next)
            {
                if (xPSP$InUse$I == $no)
                {
                    if (free_PSP_slot == 0)
                      free_PSP_slot = PSP$Pointer
                }
                else    # the slot is in use
                {
                    SPA$Pointer$To  (xPSP$SPA_Index$I)
                    if (xPSP$STA_Index$I == ista &   # the SPAs station = the station and
                        xSPA$Name$C == plot_spa_name[i])     # it is the correct SPA name
                    {
                       match_PSP = PSP$Pointer
                       break
                    }
                }
            }    
            if (match_PSP != 0)
                PSP$Pointer = match_PSP
            else if (free_PSP_slot != 0)
                PSP$Pointer = free_PSP_slot
            else
            {
                call echov ("Table full - cannot plot SPA")  
                call echor
                return
            }
                
            putPSP$Side$I (spa_side)
            putPSP$STA_Index$I (ista) 
            putPSP$SPA_Index$I (spa_index)   
            putPSP$Color$I (spa_color)       

            #$% reset high-water mark in PSP table..
            if (!PSP$pointer$OK) PSP$last$to PSP$pointer + PSP$entry - 1


        }
    }
}

return
end    



#Subroutine PL_FIND_STATION (station_name,sta_found,iview,STA$Pointer)
#
########################################################
#$%
#$% Purpose:   PL_FIND_STATION search the station table
#$%            using sta$GeoName$c as it's key.
#$%
#$% Called By:    NOBODY AT ALL
#$%
#$% Calls:     none
#$%
#$% Tables:    STA
#$%
#$% Date:      14 SEPTEMBER 88
#$%
#$% Author:    Sgt. Allen Griffin
#$%
#$% Modified:  R. Hundt      11/21/89
########################################################
#
#BBCommon
#
#literal    station_name
#integer    sta_found, az
#
#String msg4 "         is not in your view.         "
#
#sta_found = 0
#
#for (STA$Pointer$First; STA$Pointer$Valid; STA$Pointer$Next)
#    {
#     STA$GeoName$c = xSTA$GeoName$c 
#     if (STA$GeoName$c != station_name)
#         {
#         next
#         }
#     sta_found = 1
#     STA$View$i = xSTA$View$I
#     if  (iview != $Neutral$View & iview != STA$View$I) # this keeps the player
#         {                                             # from changing teks not
#          az = 0                                        # in his view.
#          call smovh(station_name,$$MaxLit,msg4,az)      
#          call echoh(msg4,38)
#          call echor
#          sta_found = 3
#         }         
#     break
#    }
#return
#end


Subroutine Trans_Color (ilex,   #Receive the order lexical string
                        ii,     #Receive the number of where the color lex is
                        color)  #Return the color

#######################################################
#$%
#$% Purpose:   Trans_Color takes the lexical values from the line drawing
#$%            and modifying orders, and translates the lexicals into a
#$%            color value. On input, ii points to where the lexical
#$%            $Lex$COLOR$ is. On output, ii points to where the next
#$%            lexical, if any, is.
#$%
#$% Called By: pl_route
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      22 Jan 88
#$%
#$% Author:    MSgt James H. Wise
#$%
#######################################################

literal         ILEX[$max$args]
integer         color, ii

color = 0

if (ilex[ii] == $Lex$DARK$)
    {
#    ii = ii + 1
    if      (ilex[ii + 1] == $Lex$RED$)
        {
        color = $Color$Dark_Red
        }
    else if (ilex[ii + 1] == $Lex$BLUE$)
        {
        color = $Color$Dark_Blue
        }
    }
else if (ilex[ii] == $Lex$OFF$)
    {
#    ii = ii + 1
    if (ilex[ii + 1] == $Lex$WHITE$)
        {
        color = $Color$Off_White
        }
    }
else
    {
    if (ilex[ii] == $Lex$ORANGE$)
        {
        color = $Color$orange
        }
    else if (ilex[ii] == $Lex$BROWN$)
        {
        color = $Color$brown
        }
    else if (ilex[ii] == $Lex$YELLOW$)
        {
        color = $Color$yellow
        }
    else if (ilex[ii] == $Lex$GREY$)
        {
        color = $Color$grey
        }
    else if (ilex[ii] == $Lex$GREEN$)
        {
        color = $Color$Green
        }
    else if (ilex[ii] == $Lex$NAVY$)
        {
        color = $Color$Navy_Blue
        }
    else if (ilex[ii] == $Lex$MUDGREEN$)
        {
        color = $Color$Mud_Green
        }
    else if (ilex[ii] == $Lex$BLUE$)
        {
        color = $Color$Blue
        }
    else if (ilex[ii] == $Lex$PURPLE$)
        {
        color = $Color$Light_Purple
        }
    else if (ilex[ii] == $Lex$MAGENTA$)
        {
        color = $Color$Magenta
        }
    else if (ilex[ii] == $Lex$WHITE$)
        {
        color = $Color$White
        }
    else if (ilex[ii] == $Lex$RED$)
        {
        color = $Color$Red
        }
    }

#ii = ii + 1

return
end



subroutine disp_dirlist(irot,               # index of rothr base
                        inum_rings,         # number of rings
                        irotas,             # flag to indicate AIR or SURFACE
                        irotdn)             # flag to indicate DAY or NIGHT

######################################################################
#$%
#$% Purpose:   Disp_dirlist displays the numbers of those DIRs that
#$%            are currently activated.
#$%
#$% Called By: pl_disply
#$%
#$% Calls:     None
#$%
#$% Tables:    RTH$PCA
#$%
#$% Date:      13 Jun 90
#$%
#$% Author:    C. Leaf
#$%
#######################################################

BBcommon
BBDeclare  (RTH$Pointer, RTH$PCA$Index)                 # MJC 8/1/2000
integer  II, JJ, INUM_RINGS, IDIR_NUM, 
         IROTDN, IROT, IROTAS                           # MJC 4/21/2000

RTH$Pointer$to irot

if (irotas == air$pca)
  RTH$PCA$Index = air$pca$base
else
  RTH$PCA$Index = surf$pca$base

for (ii = 1; ii <= inum_rings; ii = ii + 1)   # each PCA ring
  {
   for (jj = 1; jj <= 8; jj = jj + 1)         # each DIR in PCA ring
     {
      RTH$PCA$Index = RTH$PCA$Index + 1
      if ( ( (irotdn == day$rth) & (Xrth$PCA$DayOn$i == $YES) ) |
           ( (irotdn == night$rth) & (Xrth$PCA$NiteON$i == $YES) ) )
        {
         if (irotas == air$pca)
           idir_num = RTH$PCA$Index - air$pca$base
         else
           idir_num = RTH$PCA$Index - surf$pca$base
         call echoi (idir_num)                        # echo DIR number
         call echov (" ")                             # to screen
        }

     }
  }

return
end



subroutine  PL_Disply_Rptpol (nord, STA$Pointer, nargs, args) 
################################################################
#$%
#$% Purpose:   PL_Disply_Rptpol displays the reporting policy of
#$%            the unit to the I/O terminal.
#$%
#$% Called By: PL_Disply
#$%
#$% Calls:     None
#$%
#$% Tables:    STA      UNT      PAT
#$%
#$% Date:      July 8, 1992
#$%
#$% Author:    Chris P. Acantilado
#$%
#$% Modified:  Carol L. Kropp - 9/15/92
#$%            No longer part of the DISPLAY UNIT command,
#$%            now DISPLAY REPORT...
#$%            Added embark status information at end.
#$%
################################################################
BBcommon

BBDeclare  (UNT$Pointer, UNT$View$I, UNT$Name$C,
            RVU$Pointer, RVU$Embarkindx$I,
            PAT$Pointer, STA$View$I, UNT2$Pointer)      # MJC 8/1/2000 
literal   CSTRIP8                                       # MJC 4/21/2000
integer*4 nord, sta$pointer, nargs
literal   args[ARB]
integer   valid_inquiry, side_view

  #$% Locate the unit in the UNT table
  for (UNT$Pointer$First; UNT$Pointer$Valid; UNT$Pointer$Next)
    {
     if (xUNT$Name$c != args[3])
       next
     else
       break
    }

  valid_inquiry = $no           # initialize to no
  if (UNT$Pointer$Valid)        # check to see if unit was found
    {
     STA$View$i = xSTA$View$i
     UNT$View$i = xUNT$View$i
     if (STA$View$i == $Neutral$View |   # if control view or the unit is
         STA$View$i == UNT$View$i)       # in this station view, the
       valid_inquiry = $yes              # inquiry is valid
    }

  if (valid_inquiry == $no)
    {    
     call echov  ("No such unit - ")
     call echohn (args[3], $$MaxLit)
     call echor
     return
    }

  #$% display reporting policy headings
  UNT$Name$C = xUNT$Name$C
  call echov  ("REPORTING POLICY FOR ")
  call echohn (UNT$Name$C, $$MaxLit)
  call echor
  call echov  ("                      -----------REPORTING ")
  call echov  ("INTERVAL-------------")
  call echor
  call echov  ("CIRCUIT  VIOLATE      POSITION  -----TRACK")
  call echov  ("----        --DAMAGE--")
  call echor
  call echov  ("PRI ALT  EMCON        & LOGIST  SHIP  AIR  ")
  call echov  ("ESM        OWN  ENEMY")
  call echor
  call echov  ("--- ---  -------      --------  ----  ---  ")
  call echov  ("---        ---  -----")
  call echor

  #$% get reporting policy data from the unit table and display to the I/O terminal

  PAT$Pointer = xUNT$Path1Pntr$I       # get primary path pointer
  call echoib (xPAT$Circuit$I, 3)

  PAT$Pointer = xUNT$Path2Pntr$I       # get secondary path pointer
  call echoib (xPAT$Circuit$I, 4)

  if (xUNT$ViolateEmcon$I == $yes)     # determine if unit is to 
    call echov ("    YES           ")  # violate emcon or not
  else
    call echov ("     NO           ")
 
  call echoib (xUNT$OwnInterval$I, 3)            # display track
  call echoib (xUNT$ShipTrackInterval$I, 8)      # reporting
  call echoib (xUNT$AirTrackInterval$I, 5)       # intervals
  call echoib (xUNT$ESMTrackInterval$I, 5)

  call echov ("         W")
  call echov ("     W")
  call echor

  RVU$Pointer$To  UNT$View$I                # Determine the view's
  RVU$EmbarkIndx$I = xRVU$EmbarkIndx$I      # embark status         clk 9/92
  if (RVU$EmbarkIndx$I == 0)                        # if view embarked on all
    call echov ("Embarked on ALL")
  else if (RVU$EmbarkIndx$I == UNT$Pointer$Index)   # if view embarked on unit
    {
     if (UNT$View$I >= $FirstBlue$View &
         UNT$View$I <= $LastBlue$View)
       {
        side_view = UNT$View$I - $FirstBlue$View + 1
        call echov  ("All units in Blue view #")
        call echoiz (side_view, 2)
       }
     else if (UNT$View$I >= $FirstOrange$View &
              UNT$View$I <= $LastOrange$View)
       {
        side_view = UNT$View$I - $FirstOrange$View + 1
        call echov  ("All units in Orange view #")
        call echoiz (side_view, 2)
       }
     else  # Neutral/Control
       {
        call echov  ("All Neutral units")
       }
     call echov  (" reporting to ")
     call echohn (UNT$Name$C, $$MaxLit)
    }
  else  # unit is embarked on another in view
    {
     call echov ("Reporting to ")
     UNT2$Pointer$To  RVU$EmbarkIndx$I
     call echohn (xUNT2$Name$C, $$MaxLit)
    }
  call echor

return
end



Subroutine PL_Disply_TRACK (nord, STA$Pointer, nargs, args)
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK processes the DISPLAY TRACK
#$%            order.  The view and detection type are
#$%            determined from the track number and the
#$%            appropriate detection table is searched.
#$%            The track information is then printed on the
#$%            i/o screen.
#$%
#$% Called By: PL_Disply
#$%
#$% Calls:     PL_Disply_TRACK_RMT
#$%            PL_Disply_TRACK_SAT
#$%            PL_Disply_TRACK_EOIR
#$%            PL_Disply_TRACK_HFDF
#$%            PL_Disply_TRACK_SWABS
#$%            PL_Disply_TRACK_SOSUS
#$%
#$% Tables:    STA     VUE
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

#$%     args[1] == $lex$Display$
#$%     args[2] == $lex$Track$
#$%     args[3] == track number  (ccxxx)

BBDeclare  (VUE$Pointer, VUE$Trackcode$C)               # MJC 8/1/2000 
integer      IGBYTE                                     # MJC 4/21/2000
literal      CSTRIP                                     # MJC 4/21/2000
integer*4    nord, sta$pointer, nargs
literal      args[ARB]
integer      iside, sequence_number, valid_track_number, kk, ctoi
character    detection_code, side_indicator

  detection_code = igbyte (args[3], 2)

  #$% Determine which view the track number belongs to
  if (detection_code == $LETH |       # HFDF
      detection_code == $LETT |       # SWABS
      detection_code == $LETZ )       # SOSUS
    {
     side_indicator = igbyte (args[3], 1)   # 1st character of track number
     if (side_indicator == $LETB)
       iside = $Blue$Code
     else if (side_indicator == $LETO)
       iside = $Orange$Code
     else
       {
        call echohn (args[3], 5)
        call echov (" is not a valid track number.")
        call echor
        return
       }
    }
  else
    { 
     for (VUE$Pointer$First; VUE$Pointer$Valid; VUE$Pointer$Next)
       {
        VUE$TrackCode$C = xVUE$TrackCode$C
        if (igbyte (VUE$TrackCode$c, 1) == igbyte (args[3], 1))
          break
       }
     if (!VUE$Pointer$Valid)   # if the track code didn't match any of the views
       {
        call echohn (args[3], 5)
        call echov (" is not a valid track number.")
        call echor
        return
       }
    }

  #$% Calculate the value of the track sequence number
  kk = 3
  sequence_number = ctoi(%%ref(args[3]),kk)                 # DEW 11/99 (E2172)

  #$% Determine which table the detection is in
  if (detection_code == $LETA |       # SATELLITE
      detection_code == $LETE |
      detection_code == $LETS |
      detection_code == $LETU )
    {
     call PL_Disply_TRACK_SAT (VUE$Pointer,    args[3],
                               detection_code, sequence_number,
                               valid_track_number)
     if (valid_track_number == $yes)      # if the track number was found, return
       return                     # This is done as satellite and active
    }                             # tracks share the same track number form


  if (detection_code == $LETA |       # ACTIVE AIR           All of these
      detection_code == $LETE |       # ESM                  types of 
      detection_code == $LETO |       # ROTHR OTH            detections are
      detection_code == $LETP |       # PASSIVE SONAR        in the RMT table
      detection_code == $LETS |       # ACTIVE SURFACE
      detection_code == $LETU )       # ACTIVE SUBSURFACE
     call PL_Disply_TRACK_RMT (VUE$Pointer,    args[3],
                               detection_code, sequence_number,
                               valid_track_number)

  else if (detection_code == $LETH)        # HFDF
    call PL_Disply_TRACK_HFDF (iside,          args[3],
                               detection_code, sequence_number,
                               valid_track_number)

  else if (detection_code == $LETI)        # EOIR
    call PL_Disply_TRACK_EOIR (VUE$Pointer,    args[3],
                               detection_code, sequence_number,
                               valid_track_number)

  else if (detection_code == $LETT)        # SWABS
    call PL_Disply_TRACK_SWABS (iside,          args[3],
                                detection_code, sequence_number,
                                valid_track_number)

  else if (detection_code == $LETZ)        # SOSUS
    call PL_Disply_TRACK_SOSUS (iside,          args[3],
                                detection_code, sequence_number,
                                valid_track_number)

  if (valid_track_number == $no)
    {
     call echohn (args[3], 5)
     call echov (" is not a valid track number.")
     call echor
    }

return
end             # end PL_Disply_Track



Subroutine PL_Disply_TRACK_RMT (VUE$Pointer,        # input  - VUE table pointer
                                track_number,       # input  - literal
                                detection_code,     # input  - character designator
                                sequence_number,    # input  - 3 digit track number
                                valid_track_number) # output - $yes or $no
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK_RMT searches the RMT table
#$%            for the requested track and gathers the
#$%            necessary data.
#$%
#$% Called By: PL_Disply_TRACK
#$%
#$% Calls:     Display_Track_Info
#$%
#$% Tables:    VUE      RVU     RMT
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (RVU$Pointer, RVU$Firstrmtindx$I, RVU$Lastrmtindx$I, 
            RMT$Pointer, RMT$Tracknumber$I, RMT$Detectiontype$I, 
            RMT$Class$I, RMT$Overhoriz$I, RMT$Detectee$I, 
            RMT$Composition$I)                                  # MJC 7/25/2000
integer    VUE$Pointer
literal    track_number
character  detection_code
integer    sequence_number, valid_track_number

  RVU$Pointer$To  (VUE$Pointer$Index)
  RVU$FirstRmtIndx$I = xRVU$FirstRmtIndx$I
  RVU$LastRmtIndx$I  = xRVU$LastRmtIndx$I

  valid_track_number = $no

  for (RMT$Pointer$To RVU$LastRmtIndx$I;
       RMT$Pointer$Index >= RVU$FirstRmtIndx$I;
       RMT$Pointer$To (RMT$Pointer$Index-1))
    {
     if (xRMT$InUse$I == $no)        # if the slot isn't in use
       next                          # or
     if (xRMT$Detector$I == $no)     # there is no detector recorded
       next                          # skip this entry and go to the next

     RMT$TrackNumber$I = xRMT$TrackNumber$I      # if the detection sequence
     if (RMT$TrackNumber$I != sequence_number)   # number doesn't match,
       next                                      # go to the next entry

     RMT$DetectionType$I = xRMT$DetectionType$I
     RMT$Class$I = xRMT$Class$I
     RMT$OverHoriz$I = xRMT$OverHoriz$I

     if (RMT$OverHoriz$I == $yes &     # if a rothr detection and
          detection_code == $LETO)     # a rothr track number
       {
        break
       }
     else if (RMT$DetectionType$I == $PassiveSonar$Code &  # if a passive detection and
              detection_code == $LETP)                     # a passive track number
       {                                                                 
        break
       }
     else if (RMT$DetectionType$I == $ESM$Code &    # if an esm detection and
              detection_code == $LETE)              # an esm track number
       {
        break
       }
     else if ((RMT$DetectionType$I == $ActiveVisual$Code   |     # if an active
               RMT$DetectionType$I == $ActiveNonVisual$Code)  &  # track and
             ((RMT$Class$I == $Air$Code     &                    # the detected
               detection_code == $LETA)       |                  # unit type
              (RMT$Class$I == $Sub$Code     &                    # matches the
               detection_code == $LETU)       |                  # track number
              (RMT$Class$I == $Surface$Code &                    # unit code
                detection_code == $LETS)))
       {
        break
       }
    }    # end of loop through rmt table entries for view

  if (RMT$Pointer$Index < RVU$FirstRmtIndx$I)         # if outside of the views rmt
    {                                                 # entries, then the track isn't valid
     return
    }

  #$% Get the detectee information
  RMT$Detectee$I = xRMT$Detectee$I
  RMT$Composition$I = xRMT$Composition$I

  if (RMT$Composition$I >= 3)
    call Display_Track_Info_Composition (track_number, RMT$Detectee$I, "MANY")
  else if (RMT$Composition$I > 1)
    call Display_Track_Info_Composition (track_number, RMT$Detectee$I, "FEW")
  else
    call Display_Track_Info (track_number, RMT$Detectee$I)
  valid_track_number = $yes

return
end         # end of PL_disply_TRACK_RMT



Subroutine PL_Disply_TRACK_SAT (VUE$Pointer,        # input  - VUE table pointer
                                track_number,       # input  - literal
                                detection_code,     # input  - character designator
                                sequence_number,    # input  - 3 digit track number
                                valid_track_number) # output - $yes or $no
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK_SAT searches the SSR table
#$%            for the requested track and gathers the
#$%            necessary data for surveillance satellite
#$%            detections..
#$%
#$% Called By: PL_Disply_TRACK
#$%
#$% Calls:     Display_Track_Info
#$%
#$% Tables:    VUE      SSR     SAT
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (SSR$Pointer, SSR$Tracknumber$I,
            SSR$Dettype$I, SSR$Detecteeindx$I)       # MJC 8/1/2000
integer    VUE$Pointer
literal    track_number
character  detection_code
integer    sequence_number, valid_track_number

  valid_track_number = $no
  for (SSR$Pointer$First; SSR$Pointer$Valid; SSR$Pointer$Next)
    {
     if (xSSR$ReporteeView$i != VUE$Pointer$Index)   # check for the correct view
       next

     SSR$TrackNumber$I = xSSR$TrackNumber$I
     if (SSR$TrackNumber$I != sequence_number)       # check for the correct number
       next

     SSR$DetType$I = xSSR$DetType$I
     if ((SSR$DetType$I == $Null$Code     &           # check for the correct
          detection_code == $LETE)          |         # detection code
         (SSR$DetType$I == $Air$Code      &           # E - ESM
          detection_code == $LETA)          |         # A - Air
         (SSR$DetType$I == $Surface$Code  &           # S - Surface
          detection_code == $LETS)          |         # U - Subsurface
         (SSR$DetType$I == $Sub$Code      &
          detection_code == $LETU))
       {
        valid_track_number = $yes
        break
       }
    }       # end of loop through SSR table

  if (valid_track_number == $yes)
    {
     #$% Get the detectee information
     SSR$DetecteeIndx$I = xSSR$DetecteeIndx$I
     call Display_Track_Info (track_number, SSR$DetecteeIndx$I)
    }       # end of a valid satellite track number

return
end



Subroutine PL_Disply_TRACK_HFDF (iside,              # input  - $Blue$Code | $Orange$Code
                                 track_number,       # input  - literal
                                 detection_code,     # input  - character designator
                                 sequence_number,    # input  - 3 digit track number
                                 valid_track_number) # output - $yes or $no
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK_HFDF searches the HFD table
#$%            for the requested track and gathers the
#$%            necessary data for High Frequency Detection
#$%            Finder detections..
#$%
#$% Called By: PL_Disply_TRACK
#$%
#$% Calls:     Display_Track_Info
#$%
#$% Tables:    HFD
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (HFD$Pointer, HFD$Detectee$I, HFD$Sequencenmbr$I)   # MJC 8/1/2000
character  detection_code                                      # MJC 5/3/2000
integer    iside
literal    track_number
integer    sequence_number, valid_track_number

  valid_track_number = $no
  for (HFD$Pointer$First; HFD$Pointer$Valid; HFD$Pointer$Next)
    {
     HFD$Detectee$I = xHFD$Detectee$I
     if (HFD$Detectee$I == 0)       # if no recorded detectee (empty)
       next                         # or
     if (xHFD$Color$I != iside)     # detection for wrong side
       next                         # go to the next entry

     HFD$SequenceNmbr$I = xHFD$SequenceNmbr$I
     if (HFD$SequenceNmbr$I == sequence_number)  # check for the correct number
       {
        valid_track_number = $yes
        break
       }
    }       # end of loop through SSR table
    
  if (valid_track_number == $yes)
    {
     #$% Get the detectee information
     HFD$Detectee$I = xHFD$Detectee$I
     call Display_Track_Info (track_number, HFD$Detectee$I)
    }

return
end



Subroutine PL_Disply_TRACK_EOIR (VUE$Pointer,        # input  - VUE table pointer
                                 track_number,       # input  - literal
                                 detection_code,     # input  - character designator
                                 sequence_number,    # input  - 3 digit track number
                                 valid_track_number) # output - $yes or $no
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK_EOIR searches the IRD table
#$%            for the requested track and gathers the
#$%            necessary data for EOIR detections.
#$%
#$% Called By: PL_Disply_TRACK
#$%
#$% Calls:     Display_Track_Info
#$%
#$% Tables:    VUE     IRD      UNT
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (IRD$Pointer, IRD$Trackseq$I, IRD$Targetindx$I,
            UNT2$Pointer, UNT2$Name$C)                         # MJC 8/1/2000
literal    CSTRIP8                                             # MJC 4/21/2000
character  detection_code                                      # MJC 5/3/2000
integer    VUE$Pointer
literal    track_number
integer    sequence_number, valid_track_number
literal    detectee_name

  valid_track_number = $no
  for (IRD$Pointer$First; IRD$Pointer$Valid; IRD$Pointer$Next)
    {
     if (xIRD$InUse$I == $no)
       next

     if (xIRD$View$I != VUE$Pointer$Index)
       next

     IRD$TrackSeq$i = xIRD$TrackSeq$I
     if (IRD$TrackSeq$i == sequence_number)     # check for the correct number
       {
        valid_track_number = $yes
        break
       }
    }       # end of loop through IRD table
    
  if (valid_track_number == $yes)
    {
     detectee_name    = xIRD$TargetName$C      # Get the detectee info
     IRD$TargetIndx$I = xIRD$TargetIndx$I
     UNT2$Pointer$To   (IRD$TargetIndx$I)
     UNT2$Name$C      = xUNT2$Name$C
     if (detectee_name == UNT2$Name$C)         # if still the same unit
       call Display_Track_Info (track_number, IRD$TargetIndx$I)
     else
       call Display_Track_Info_No_UNT (track_number, detectee_name)
    }

return
end



Subroutine PL_Disply_TRACK_SWABS (iside,              # input  - $Blue$Code | $Orange$Code
                                  track_number,       # input  - literal
                                  detection_code,     # input  - character designator
                                  sequence_number,    # input  - 3 digit track number
                                  valid_track_number) # output - $yes or $no
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK_SWABS searches the SWD table
#$%            for the requested track and gathers the
#$%            necessary data for SWABS detections.
#$%
#$% Called By: PL_Disply_TRACK
#$%
#$% Calls:     SMOVIZ
#$%            Display_Track_Info
#$%
#$% Tables:    SWD
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (SWD$Pointer, SWD$Sequencenmbr$I, SWD$Detectee$I)    # MJC 8/1/2000
character  detection_code                                       # MJC 5/3/2000
integer    iside
literal    track_number
integer    sequence_number, valid_track_number

  valid_track_number = $no
  for (SWD$Pointer$First; SWD$Pointer$Valid; SWD$Pointer$Next)
    {
     if (xSWD$DetectorSide$I != iside)
       next

     SWD$SequenceNmbr$I = xSWD$SequenceNmbr$I
     if (SWD$SequenceNmbr$I == sequence_number)  # check for the correct number
       {
        valid_track_number = $yes
        break
       }
    }       # end of loop through SWD table
    
  if (valid_track_number == $yes)
    {
     #$% Get the detectee information
     SWD$Detectee$I = xSWD$Detectee$I
     call Display_Track_Info (track_number, SWD$Detectee$I)
    }

return
end



Subroutine PL_Disply_TRACK_SOSUS (iside,              # input  - $Blue$Code | $Orange$Code
                                  track_number,       # input  - literal
                                  detection_code,     # input  - character designator
                                  sequence_number,    # input  - 3 digit track number
                                  valid_track_number) # output - $yes or $no
############################################################
#$%
#$% Purpose:   PL_Disply_TRACK_SOSUS searches the SOS table
#$%            for the requested track and gathers the
#$%            necessary data for SOSUS detections.
#$%
#$% Called By: PL_Disply_TRACK
#$%
#$% Calls:     SMOVIZ
#$%            Display_Track_Info
#$%
#$% Tables:    SOS
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (SOS$Pointer, SOS$Sequencenmbr$I, SOS$Detectee$I)    # MJC 8/1/2000
character  detection_code                                       # MJC 5/3/2000
integer    iside
literal    track_number
integer    sequence_number, valid_track_number

  valid_track_number = $no
  if (iside != $Blue$Code)
    return

  for (SOS$Pointer$First; SOS$Pointer$Valid; SOS$Pointer$Next)
    {
     SOS$SequenceNmbr$I = xSOS$SequenceNmbr$I
     if (SOS$SequenceNmbr$I == sequence_number)  # check for the correct number
       {
        valid_track_number = $yes
        break
       }
    }       # end of loop through SOS table
    
  if (valid_track_number == $yes)
    {
     #$% Get the detectee information
     SOS$Detectee$I = xSOS$Detectee$I
     call Display_Track_Info (track_number, SOS$Detectee$I)
    }

return
end



Subroutine Display_Track_Info (track_number,       # input - literal
                               unit_index)         # input - integer
############################################################
#$%
#$% Purpose:   Display_Track_Info takes the information from
#$%            the various display track routines and prints
#$%            the data to the requesting control i/o terminal.
#$%
#$% Called By: PL_Disply_TRACK_RMT
#$%            PL_Disply_TRACK_SAT
#$%            PL_Disply_TRACK_EOIR
#$%            PL_Disply_TRACK_HFDF
#$%            PL_Disply_TRACK_SWABS
#$%            PL_Disply_TRACK_SOSUS
#$%
#$% Calls:     ECHO..     <lbecho.rat>
#$%            Game_DTF   <lbtime.rat>
#$%            FGTASK     <lbcommn.rat>
#$%
#$% Tables:    UNT      ACC     SHC     TRP     CTM
#$%
#$% Date:      November 1992
#$%
#$% Author:    Carol Kropp
#$%
############################################################
BBcommon

BBDeclare  (UNT$Pointer, UNT$Type$I, 
            UNT$Subtype$I,
            ACC$Pointer, ACC$Type$C, 
            CMC$Pointer, CMC$Type$C, 
            TRP$Name$C, TRP$Pointer,
            CTM$Name$C, CTM$Pointer,
            UNT2$Pointer, UNT2$Name$C, 
            SHC$Pointer, SHC$Type$C,UNT$NAME$C)     # JHM 6/02 UNT$NAME$C
literal  CSTRIP8                                    # MJC 4/21/2000
VMSchar  composition*(*)
literal  track_number, detectee_name, detectee_name2
integer  unit_index
integer  composition_entry_called, no_unt_entry_called
literal  task_number, detectee_view_info
integer  detectee_view
integer  length       # used for moving the view number into literals

  composition_entry_called = $no
  no_unt_entry_called = $no
  goto 6001                                                 # E2143 dew 10/99
    {
     entry Display_Track_Info_Composition (track_number, unit_index, 
                                            composition)
     composition_entry_called = $yes
    }
  goto 6001                                                 # E2143 dew 10/99
    {
     entry Display_Track_Info_No_UNT (track_number, detectee_name)
     no_unt_entry_called = $yes
    }
  6001                                                      # E2143 dew 10/99

  if (no_unt_entry_called == $no)
    {
     UNT$Pointer$To  (unit_index)
     detectee_view  = xUNT$View$I
     detectee_name2 = xUNT$Name$C         # JHM 6/02
     call fgtask (xUNT$HierarchyId$i, task_number)
    }
  else 
   {
     detectee_view = 0  # no longer the same unit in the UNT table
     detectee_name2 = detectee_name
    }
  if (detectee_view == $Neutral$View)
    detectee_view_info = '(N)'
  else if (detectee_view >= $FirstBlue$View &
           detectee_view <= $LastBlue$View  )
    {
     detectee_view_info = '(B )'
     length = 2
     call smovib ((detectee_view - $FirstBlue$View + 1), 1, detectee_view_info, length)
    }
  else if (detectee_view >= $FirstOrange$View &
           detectee_view <= $LastOrange$View  )
    {
     detectee_view_info = '(O )'
     length = 2
     call smovib ((detectee_view - $FirstOrange$View + 1), 1, detectee_view_info, length)
    }
  else
    detectee_view_info = '(UNK)'

  call echov  (">> Track ")
  call echohn (track_number, $$MaxLit)
  call echov  (" is ")
  call echohn (detectee_name2, $$MaxLit)
  call echov  (" -- ")

  if (no_unt_entry_called == $no)
    {
     call echohn (task_number, $$MaxLit)
     call echov  (" ")
     call echohn (detectee_view_info, $$MaxLit)

     #$% Determine the unit type and get class info
     UNT$Type$I = xUNT$Type$I
     if (UNT$Type$I == $Air$Code)
       {
        ACC$Pointer = xUNT$AccPntr$I
        ACC$Type$C = xACC$Type$C
        UNT2$Pointer$To  (xUNT$LaunchIndx$I)
        if (unt2$pointer$ok)
            UNT2$Name$C = xUNT2$Name$C
        else
            UNT2$Name$C = 'None'
            
        call echov ("  Type: ")
        call echohn (ACC$Type$C, $$MaxLit)
        call echov ("  Owner: ")
        call echohn (UNT2$Name$C, $$MaxLit)
       }
     else if (UNT$Type$I == $Surface$Code)      # ships, boats
       {
        SHC$Pointer = xUNT$ShcPntr$I
        SHC$Type$C = xSHC$Type$C

        call echov ("  Class: ")
        call echohn (SHC$Type$C, $$MaxLit)
       }
     else if (UNT$Type$I == $CruiseMissile$Code)
       {
        CMC$Pointer = xUNT$CMCPntr$I
        CMC$Type$C = xCMC$Type$C

        call echov ("  Type: ")
        call echohn (CMC$Type$C, $$MaxLit)
       }
     else if (UNT$Type$I == $Sub$Code)          # submarines, torpedos, countermeasures
       {
        UNT$SubType$I = xUNT$SubType$I
        if (UNT$SubType$I == $Standard$SubCode)
          {
           SHC$Pointer = xUNT$ShcPntr$I
           SHC$Type$C = xSHC$Type$C

           call echov ("  Class: ")
           call echohn (SHC$Type$C, $$MaxLit)
          }
        else if (UNT$SubType$I == $Torpedo$SubCode)
          {
           TRP$Pointer = xUNT$TrpPntr$I
           TRP$Name$C = xTRP$Name$C

           call echov ("  Type: ")
           call echohn (TRP$Name$C, $$MaxLit)
          }
        else if (UNT$SubType$I == $CtrMeasure$SubCode)
          {
           CTM$Pointer = xUNT$CtmPntr$I
           CTM$Name$C = xCTM$Name$C

           call echov ("  Class: ")
           call echohn (CTM$Name$C, $$MaxLit)
          }
        else if (UNT$SubType$I == $FalseContact$SubCode)
          {
           call echov ("  False contact sub.")
          }
       }
    }
  else
     call echov ("  No longer an active unit.")

  if (composition_entry_called == $yes)
    {
     call echov ("  Composition: ")
     call echovn (composition)
    }
  call echor

return
end         # end of Display_Track_Info


define($SINGLE,9)
define($ALL,10)

Subroutine Pl_NRTs (ista,       # input - station
                    iwords,     # input - number of words
                    ilex)       # input - order parameters
########################################################
#$%
#$% Purpose:   Pl_NRTs processes the ERASE NRT ALL command
#$%            and calls NRT_Named to handle the other
#$%            NRT plotting commands
#$%
#$% Called By: PL_PLOT
#$%
#$% Calls:     NRT_Named
#$%
#$% Tables:    STA
#$%
#$% Date:      December 1992
#$%
#$% Author:    Susan Miller
#$%
########################################################
BBCommon

# parameters
BBDeclare  (STA$Pointer, STA$Plotnrt$I)     # MJC 8/1/2000 (E2145)
integer    ista, iwords
literal    ilex [20]

 STA$POINTER$TO ista                        # set station pointer

 # [PLOT | ERASE] NRT [ALL | NAMED <track-name> [|<track-name-b> ]];
 if (ilex[3] == $lex$ALL$) 
    {
     if (ilex[1] == $lex$ERASE$)            # ERASE NRT ALL
        {
         STA$PlotNRT$I = xSTA$PlotNRT$I
         if (STA$PlotNRT$I >= 1 | STA$PlotNRT$I < 9) 
            {                               # zero out all the index values
             putSTA$NRTTwoNameIndx1$I (0)
             putSTA$NRTTwoNameIndx2$I (0)
             putSTA$NRTTwoNameIndx3$I (0)
             putSTA$NRTTwoNameIndx4$I (0)
             putSTA$NRTTwoNameIndx5$I (0)
             putSTA$NRTTwoNameIndx6$I (0)
             putSTA$NRTTwoNameIndx7$I (0)
             putSTA$NRTTwoNameIndx8$I (0)
            }            
         putSTA$PlotNRT$I (0)
        } # end if ilex[1] == ERASE
     else                                   # PLOT NRT ALL
        putSTA$PlotNRT$I ($ALL)
    } # end if ilex[3] == ALL

 if (ilex[3] == $lex$NAMED$)
    {
     call NRT_Named(STA$Pointer,iwords,ilex)
    } # end if it is a NAMED order

return
end     # end of subroutine Pl_NRTs


Subroutine NRT_Named(STA$Pointer,    # input 
                     iwords,         # input - number of words in order
                     ilex)           # input - order
########################################################
#$%
#$% Purpose:   NRT_Named processes the ERASE/PLOT NRT
#$%            NAMED orders
#$%
#$% Called By: PL_NRTs
#$%
#$% Calls:     Search_NRT   SMOVHN   SMOVV   ECHOH
#$%
#$% Tables:    STA
#$%
#$% Date:      December 1992
#$%
#$% Author:    Susan Miller
#$%
########################################################
BBCommon

BBDeclare  (STA$Nrtsinglename$C, NRT$Pointer)                       # MJC 8/1/2000 (E2145)
# parameters
integer    STA$Pointer, iwords
literal    ilex [iwords]
# functions
integer    lcomp
integer    I_SWITCH_1                                               # MJC 4/21/2000
literal    CSTRIP8                                                  # MJC 4/21/2000
# local variables
integer    STA$PlotNRT$I, len, valid_name, index,  NRTs_plotted
integer    name1_result, name2_result, found_match, kk
character  msg[ARB]

 len = 0
 name1_result = 0
 name2_result = 0
 found_match = $no

 if (ilex[1] == $lex$ERASE$)        # if it is an ERASE order
    {
     STA$PlotNRT$I = xSTA$PlotNRT$I
     if (STA$PlotNRT$I == 0)        # has no plotted NRTs for this view
        {
         call smovv(" No NRTs to erase for this view.  ",msg,len)
        }            
     else if ((STA$PlotNRT$I > 0)&(STA$PlotNRT$I < 9)) # double name NRTs saved
        {
         for (NRTs_plotted = STA$PlotNRT$I; NRTs_plotted > 0;
              NRTs_plotted = NRTs_plotted - 1)
            {
             switch (NRTs_plotted)
                {
                 case 1: index = xSTA$NRTTwoNameIndx1$I 
                 case 2: index = xSTA$NRTTwoNameIndx2$I
                 case 3: index = xSTA$NRTTwoNameIndx3$I
                 case 4: index = xSTA$NRTTwoNameIndx4$I 
                 case 5: index = xSTA$NRTTwoNameIndx5$I 
                 case 6: index = xSTA$NRTTwoNameIndx6$I 
                 case 7: index = xSTA$NRTTwoNameIndx7$I 
                 case 8: index = xSTA$NRTTwoNameIndx8$I
                } # end of case statement
             NRT$Pointer$TO index
             name1_result = (lcomp(xNRT$Name1$C,ilex[4]))
             # if name1 doesn't match, try the next index
             if (name1_result != 0)  next
             else # it does match the name to delete
                {
                 if (iwords == 5)
                    {
                     name2_result = (lcomp(xNRT$Name2$C,ilex[5]))
                     if (name2_result != 0) next
                    }
                 found_match = $yes
                 break
                }
            } # end of for loop through NRTs_plotted
         if (found_match == $yes)
            {
             call Switch_NRT_index (STA$Pointer, NRTs_plotted)
             putSTA$PlotNRT$I (STA$PlotNRT$I - 1)
            }
        } # end if two name NRTs plotted
     else if (STA$PlotNRT$I == 9)       # then a single name was saved
        {
         # requested name was not the saved name so send an error message
         if (iwords == 4) 
            {
             if (ilex[4] != xSTA$NRTSingleName$C)
                {
                 call smovhn(ilex[4],$$MaxLit,msg,len)
                 call smovv(" does not match the saved name for this view.  ",
                              msg,len)
                 call smovv("Order ignored.  ",msg,len)
                } # end if name entered doesn't match saved name
             else # it does saved name matches entered name
                {
                 putSTA$PlotNRT$I (0)
                 kk = 0; call smovv ("        ", STA$NRTSingleName$C, kk)
                 putSTA$NRTSingleName$C
                 return # to Pl_NRTs
                } # end if saved name matches entered name
            } # end if a single name was entered to erase
         if (iwords == 5)
            {
             call smovhn(ilex[4],$$MaxLit,msg,len)
             call smovv(" ",msg,len)
             call smovhn(ilex[5],$$MaxLit,msg,len)
             call smovv(" does not match the saved name for this view.  ",
                         msg,len)
             call smovv("Order ignored.  ",msg,len)
            } # end if two names entered to erase
        } # end if single name saved
     else if (STA$PlotNRT$I == 10)
        {
         call smovhn(ilex[4],$$MaxLit,msg,len)
         call smovv(" ",msg,len)
         if (iwords == 5)
            {
             call smovhn(ilex[5],$$MaxLit,msg,len)
             call smovv(" ",msg,len)
            }
         call smovv("cannot be erased because the command ",msg,len)
         call smovv("PLOT NRT ALL was used.",msg,len)
         call smovr(msg,len)
         call smovv("Order ignored.  ",msg,len)
        }
     call echoh(msg,len)
     call echor
     return # to Pl_NRTs
    }
 # it is a PLOT order
 else 
    {
     # PLOT NRT NAMED <track-name>  
     if (iwords == 4)           
        {
         NRTs_plotted = 0
         call Search_NRT(STA$Pointer,ilex,iwords,  #input
                         valid_name,index,NRTs_plotted) #output
         if (valid_name == $yes)
            {
             putSTA$PlotNRT$I ($SINGLE)
             putSTA$NRTSingleName$C (ilex[4])
            }
         else # not found in NRT table, or not found for that view
            return # to Pl_NRTs
        } # end if it is a single name order
     # PLOT NRT NAMED <track-name> <track-name-b>
     else if (iwords == 5)
        {
         NRTs_plotted = xSTA$PlotNRT$I
         call Search_NRT(STA$Pointer,ilex,iwords,         #input
                               valid_name,index,NRTs_plotted)   #output
         putSTA$PlotNRT$I (NRTs_plotted)
         switch (NRTs_plotted)
            {
             case 1: putSTA$NRTTwoNameIndx1$I (index)
             case 2: putSTA$NRTTwoNameIndx2$I (index)
             case 3: putSTA$NRTTwoNameIndx3$I (index)
             case 4: putSTA$NRTTwoNameIndx4$I (index)
             case 5: putSTA$NRTTwoNameIndx5$I (index)
             case 6: putSTA$NRTTwoNameIndx6$I (index)
             case 7: putSTA$NRTTwoNameIndx7$I (index)
             case 8: putSTA$NRTTwoNameIndx8$I (index)
            } # end of case statement             
        } # end if it is a two name order
    } # end if it is a PLOT order

return 
end # of subroutine NRT_Named


Subroutine Pl_Wide_Tracks(ista,         # Input - pointer to STA Table
                          nargs,        # Input - total number of input argument
                          args)         # Input - array of input argument
############################################################
#$%
#$% Purpose:   Process the PLOT WIDE AREA SURVEILLANCE TRACKS
#$%            order.
#$%
#$% Called By: PL_PLOT
#$%
#$% Calls:     echoi   echov   echor   echohn   igbyte
#$%
#$% Tables:    STA    SSR    SOS    HFD    SWD    VUE   UNT
#$%
#$% Date:      December 1992
#$%
#$% Author:    K. Chang
#$%
############################################################
BBcommon

BBDeclare  (SSR$Pointer, SSR$Tracknumber$I,
            SSR$Dettype$I, SSR$Reporteeview$I,
            STA$TRK$Index, STA$TRK$detectdataindx$I,
            STA$TRK$tracknumber$I, STA$TRK$tracktype$I,
            STA$TRK$trackview$I,
            VUE$Pointer, VUE$Trackcode$C,
            HFD$Pointer, UNT$Pointer,
            SWD$Pointer, SOS$Pointer)                   # MJC 8/1/2000 (E2145)
literal   CSTRIP                                        # MJC 4/21/2000
integer   ISTA, IGBYTE                                  # MJC 4/21/2000
integer*4 nargs
literal   args[ARB]
character TrkType, TrkSide
integer   TrkTbl_indx, detect_indx, detect_type, TrkSeqN
integer   invalid, input_view, iside, sta$pointer
integer*4 kview, kk, ctoi

sta$Pointer$To ista
kview = Xsta$View$i

if (kview < $FirstBlue$View)       # if control, then get the specified view
  {
   if (args[5] == $lex$blue$ | args[5] == $lex$orange$)
     input_view = args[6]
   else
     input_view = args[7]

   if (args[5] == $lex$blue$ | args[6] == $lex$blue$)     
     {
      kview = input_view + $FirstBlue$View - 1
      if (kview < $FirstBlue$View | kview > $LastBlue$View)
        {
         call echoi (input_view)
         call echov  (" is not a valid view number for blue.")
         call echor
         return
        }
     }
   else                           
     {
      kview = input_view + $FirstOrange$View - 1
      if (kview < $FirstOrange$View | kview > $LastOrange$View)
        {
         call echoi (input_view)
         call echov  (" is not a valid view number for orange.")
         call echor
         return
        }
     }
  }

#$% Get type of detection to be plot
if      (args[2] == $lex$SURVSAT$)                detect_type = $Survsat$PlotCode
else if (args[2] == $lex$HFDF$)                   detect_type = $HFDF$PlotCode
else if (args[2] == $lex$SWABS$)                  detect_type = $Swabs$PlotCode
else if (args[2] == $lex$SOSUS$)                  detect_type = $Sosus$PlotCode

#-----------------------------------------------------------------------
#$% process PLOT [SURVSAT|HFDF|SOSUS|SWABS] TRACK <NR>

if (args[4] == $Lex$Track$)               # Extract field from the <track-no>
  {
   TrkType = igbyte(args[5],2)
   TrkSide = igbyte(args[5],1)
   kk = 3
   TrkSeqN = ctoi(%%ref(args[5]),kk)                 # DEW 11/99 (E2172)

  if (args[2] == $lex$SURVSAT$)                 # Plot SURVSAT Track
    {
     invalid = YES

     #$% Check if the input track is valid
     if (TrkType == $LETE | TrkType == $LETA | TrkType == $LETU | TrkType == $LETS)
       {
        for (SSR$Pointer$First; SSR$Pointer$Valid; SSR$Pointer$Next)
           {
            SSR$TrackNumber$I = xSSR$TrackNumber$I
            if (TrkSeqN != SSR$TrackNumber$I)  # Check for the correct number
              next

            SSR$DetType$I = xSSR$DetType$I

            #$% Check for correct match of the second letter of track
            if      (TrkType == $LETE & SSR$DetType$I != $Null$Code)              next
            else if (TrkType == $LETA & SSR$DetType$I != $Air$Code)               next
            else if (TrkType == $LETS & SSR$DetType$I != $Surface$Code)           next
            else if (TrkType == $LETU & SSR$DetType$I != $Sub$Code)               next

            #$% Check for correct match of the first letter of track
            VUE$Pointer$To (xSSR$ReporteeView$I)
            VUE$TrackCode$C = xVUE$TrackCode$C
            if (igbyte(VUE$TrackCode$C, 1) != TrkSide)                            next

            invalid = NO
            break
           }

        if (invalid == NO)       # Does track belongs to this station's view
          {
           invalid = YES
           SSR$ReporteeView$I = xSSR$ReporteeView$I
           if (SSR$ReporteeView$I == kview)
             invalid = NO
          }
       } 

     if (invalid == NO)
       detect_indx = SSR$Pointer$Index

    } # args[2] == $lex$SURVSAT$

  else if (args[2] == $lex$HFDF$)                  # Plot HFDF Track
    {
     invalid = YES

     if (TrkType == $LetH)
       {
        if ((kview >= $FirstBlue$View &
             kview <= $LastBlue$View) &
            TrkSide == $LetB)                invalid = NO
        if ((kview >= $FirstOrange$View &
             kview <= $LastOrange$View) &
            TrkSide == $LetO)                invalid = NO
       }

     #$% Check if the input track is valid
     if (invalid == NO)
       {
        for (HFD$Pointer$First; HFD$Pointer$Valid; HFD$Pointer$Next)
           if (TrkSeqN == xHFD$SequenceNmbr$I)     # If track sequence number match
             {                                     # then break
              invalid = NO
              break
             }

        if (invalid == NO)       # Does track belongs to this station's view
          {
           invalid = YES
           if (xHFD$Detector1$I != 0)
             {
              unt$Pointer$To (xHFD$Detector1$I)
              if (kview == xUNT$View$I)
                invalid = NO
             }

           if (xHFD$ElpsExists$I != $no & xHFD$Detector2$I != 0 & invalid)
             {
              unt$Pointer$To (xHFD$Detector2$I)
              if (kview == xUNT$View$I)
                invalid = NO
             }
          }
       }

     if (invalid == NO)
        detect_indx = HFD$Pointer$Index

    }    # args[2] == $lex$HFDF$

  else if (args[2] == $lex$Swabs$)                 # Plot SWABS Track
    {
     invalid = YES       

     #$% Check if the input track is valid
     if ((TrkType == $LETT) & (TrkSide == $LETB | TrkSide == $LETO))
       {
        if (TrkSide == $LetB)           iside = $Blue$Code
        if (TrkSide == $LetO)           iside = $Orange$Code

        for (SWD$Pointer$First; SWD$Pointer$Valid; SWD$Pointer$Next)
           if (TrkSeqN == xSWD$SequenceNmbr$I &     # If track sequence number match
               iside   == xSWD$DetectorSide$I)      # then break
             {
              invalid = NO
              break
             }

        if (invalid == NO)        # Does track belongs to the SWABs view
          {
           invalid = YES
           if ((TrkSide == $LETB & kview == SWABS$B_View) |
               (TrkSide == $LETO & kview == SWABS$O_View))
             invalid = NO
          }
       }

     if (invalid == NO)
       detect_indx = SWD$Pointer$Index

    }    # args[2] == $lex$SWABS$

  else                                             # Plot SOSUS Track
    {
     invalid = YES

     #$% Check if the input track is valid
     if (TrkType == $LETZ & TrkSide == $LETB)
       {
        for (SOS$Pointer$First; SOS$Pointer$Valid; SOS$Pointer$Next)
           if (TrkSeqN == xSOS$SequenceNmbr$I)     # If track sequence number match
             {                                     # then break
              invalid = NO
              break
             }

        if (invalid == NO)        # Does track belongs to the SOSUS view
          {
           invalid = YES
           if (kview == SOSUS$View)
             invalid = NO
          }
       }

     if (invalid == NO)
       detect_indx = SOS$Pointer$Index

    } # args[2] == $lex$SOSUS$

   if (invalid == YES)
     {
      call echohn (args[5], 5)
      call echov  (" is either not a valid track number or")
      call echov  (" not belongs to the correct view.")
      call echor
      return
     }
   else
     {
      TrkTbl_Indx = 0           

      for (STA$TRK$Index = 1; STA$TRK$Index$ok; STA$TRK$Index = STA$TRK$Index + 1)
         {
          STA$TRK$DetectDataIndx$I = xSTA$TRK$DetectDataIndx$I
          STA$TRK$TrackNumber$I    = xSTA$TRK$TrackNumber$I
          STA$TRK$TrackType$I      = xSTA$TRK$TrackType$I
          STA$TRK$TrackView$I      = xSTA$TRK$TrackView$I

          #$% If same track is reenter, then break
          if (STA$TRK$DetectDataIndx$I == detect_indx &
              STA$TRK$TrackNumber$I == TrkSeqN &
              STA$TRK$TrackType$I == detect_type &
              STA$TRK$TrackView$I == kview)
            {
            putSTA$TRK$PlotTrk$I        (YES)
            break
            }

          #$% Save the index of an empty slot for later use.
          if (STA$TRK$TrackNumber$I == 0 & 
              STA$TRK$DetectDataIndx$I == 0 &
              TrkTbl_Indx == 0)
             TrkTbl_Indx = STA$TRK$Index
         }

      if (TrkTbl_Indx == 0 & STA$TRK$Index$Ok == $no)
        {
         call echohn (args[5], 5)
         call echov  (" can't be plot, track sub-table is full.")
         call echor
         return
        }
      else if (TrkTbl_Indx != 0 & STA$TRK$Index$OK == $no)
        {
         STA$TRK$Index = TrkTbl_Indx
         putSTA$TRK$TrackType$I      (detect_type)
         putSTA$TRK$TrackNumber$I    (TrkSeqN)
         putSTA$TRK$DetectDataIndx$I (detect_indx)
         putSTA$TRK$TrackView$I      (kview)
         putSTA$TRK$PlotTrk$I        (YES)

         #$% Clear out the indicator for PLOT ALL of the specified detected type 
         if      (args[2] == $lex$SURVSAT$)           putSTA$PlotAllSurvSat$I (0)
         else if (args[2] == $lex$HFDF$)              putSTA$PlotAllHFDF$I (0)
         else if (args[2] == $lex$SWABS$)             putSTA$PlotAllSwabs$I (0)
         else if (args[2] == $lex$SOSUS$)             putSTA$PlotAllSosus$I (0)
        }
     }
  } # end if args[4] = $Lex$Track$

#-----------------------------------------------------------------------
#$% process PLOT [SURVSAT|HFDF|SOSUS|SWABS] ALL

else                                        # if args[4] == $Lex$All$
  {
   if (args[2] == $lex$SURVSAT$)            # Plot all SURVSAT tracks
     putSTA$PlotAllSurvSat$i (kview)
   else if (args[2] == $lex$HFDF$)          # Plot all HFDF tracks
     putSTA$PlotAllHFDF$i (kview)
   else if (args[2] == $lex$SWABS$)         # Plot all SWABS tracks
     {
      if (kview == SWABS$B_View | kview == SWABS$O_View)
        putSTA$PlotAllSwabs$i (kview)
      else
        return
     }
   else                                     # Plot all SOSUS tracks
     {
      if (kview == SOSUS$View)
        putSTA$PlotAllSosus$i (kview)
      else
        return
     }

   #$% Clear out all track entry of the specified detect type from the 
   #$% STA$TRK subtable since all the tracks of the detect type will be plot.
   for (STA$TRK$Index = 1; STA$TRK$Index$Ok; STA$TRK$Index = STA$TRK$Index + 1)
      {
       STA$TRK$TrackType$I = xSTA$TRK$TrackType$I
       if (STA$TRK$TrackType$I == detect_type)
         {
          putSTA$TRK$TrackNumber$I (0)
          putSTA$TRK$DetectDataIndx$I (0)
          putSTA$TRK$TrackView$I (0)
         }
      }

   #$% Reset flag to plot the specified tracks if "ERASE ALL" was previously enter.
   if      (detect_type == $Survsat$PlotCode)     putSTA$PlotSurvSatTrk$I (YES)
   else if (detect_type == $HFDF$PlotCode)        putSTA$PlotHFDFTrk$I (YES)
   else if (detect_type == $Swabs$PlotCode)       putSTA$PlotSwabsTrk$I (YES)
   else                                           putSTA$PlotSosusTrk$I (YES)

  } # end if args[4] = $Lex$All$

return
end



Subroutine Erase_Wide_Tracks(ista,         # Input - pointer to STA Table
                             nargs,        # Input - total number of input argument
                             args)         # Input - array of input argument
############################################################
#$%
#$% Purpose:   Process the ERASE WIDE AREA SURVEILLANCE TRACKS
#$%            order.
#$%
#$% Called By: PL_PLOT
#$%
#$% Calls:     igbyte   echoi   echov   echor   echohn
#$%
#$% Tables:    STA   VUE   SSR   SOS   HFD   SWD
#$%
#$% Date:      December 1992
#$%
#$% Author:    K. Chang
#$%
############################################################

BBcommon

BBDeclare  (VUE$Pointer, VUE$Trackcode$C,
            STA$TRK$Index, STA$TRK$tracknumber$I,
            STA$TRK$tracktype$I, STA$TRK$trackview$I,
            SSR$Pointer, SSR$Dettype$I,
            SWD$Pointer, SWD$Detectorside$I)                # MJC 8/1/2000 (E2145)
integer ISTA, IGBYTE                                        # MJC 4/20/2000
literal CSTRIP                                              # MJC 4/20/2000
integer*4       sta$pointer, nargs
literal         args[ARB]
character       TrkType, TrkSide
integer         detect_type, TrkSeqN, invalid, hfd_flg
integer*4       kview, kk, ctoi

sta$Pointer$To ista
kview = Xsta$View$i

#$% get type of detection
if      (args[2] == $lex$SURVSAT$)              detect_type = $Survsat$PlotCode
else if (args[2] == $lex$HFDF$)                 detect_type = $HFDF$PlotCode
else if (args[2] == $lex$SWABS$)                detect_type = $Swabs$PlotCode
else if (args[2] == $lex$SOSUS$)                detect_type = $Sosus$PlotCode

#-----------------------------------------------------------------------
#$% process ERASE [SURVSAT|HFDF|SOSUS|SWABS] TRACK <NR>

if (args[4] == $Lex$Track$)               # Extract field from the <track-no>
  {
   TrkType = igbyte(args[5],2)
   TrkSide = igbyte(args[5],1)
   kk = 3
   TrkSeqN = ctoi(%%ref(args[5]),kk)                 # DEW 11/99 (E2172)

   invalid = YES

   #$% Check for correct track code (the first two letters of track)
   if (args[2] == $lex$SURVSAT$ & (TrkType == $LETE | TrkType == $LETA |
                                   TrkType == $LETS | TrkType == $LETU))
     {
     for (VUE$Pointer$First; VUE$Pointer$Valid; VUE$Pointer$Next)
        {
         VUE$TrackCode$C = xVUE$TrackCode$C

         #$% Does the SURVSAT track belongs to this station ?
         if (igbyte(VUE$TrackCode$C, 1) == TrkSide &
             (kview == $Neutral$View | kview == VUE$Pointer$Index))
           {
            invalid = NO
            break
           }
        }
     }
   else if (args[2] == $lex$HFDF$ & TrkType == $LETH &
            (TrkSide == $LETB | TrkSide == $LETO))
       invalid = NO
   else if (args[2] == $lex$SWABS$ & TrkType == $LETT)
     {
     if ((TrkSide == $LETB & (kview == SWABS$B_View | kview == $Neutral$View)) | 
         (TrkSide == $LETO & (kview == SWABS$O_View | kview == $Neutral$View)))
       invalid = NO
     }
   else if (TrkType == $LETZ)
     {
     if (TrkSide == $LETB & (kview == Sosus$View | kview == $Neutral$View))
       invalid = NO
     } 

   if (invalid == YES)
     {
      call echohn (args[5], 5)
      call echov  (" is either not a valid track number or")
      call echov  (" not belongs to the correct view.")
      call echor      
      return
     }

   hfd_flg = no  # This flag is a special case for HFDF track which has 2 detectors

   #$% Search STA$TRK sub-table for the match track, then clear out the slot entry
   for (STA$TRK$Index = 1; STA$TRK$Index$ok; STA$TRK$Index = STA$TRK$Index + 1)
      {
       Sta$Trk$TrackNumber$I = xSTA$Trk$TrackNumber$I
       Sta$Trk$TrackType$I   = xSTA$Trk$TrackType$I
       Sta$Trk$TrackView$I   = xSTA$Trk$TrackView$I

       if (detect_type != Sta$Trk$TrackType$I)         next
       if (TrkSeqN != Sta$Trk$TrackNumber$I)           next

       #$% Deeper search of the SURVSAT track since the track number can be same
       if (args[2] == $lex$SURVSAT$)
         {
          SSR$Pointer$To (xSTA$Trk$DetectDataIndx$I)
          SSR$DetType$I = xSSR$DetType$I

          if ((SSR$DetType$I == $Null$Code & TrkType != $LETE) |
              (SSR$DetType$I == $Air$Code & TrkType != $LETA) |
              (SSR$DetType$I == $Surface$Code & TrkType != $LETS) |
              (SSR$DetType$I == $Sub$Code & TrkType != $LETU))
            next

          VUE$Pointer$To (xSSR$ReporteeView$I)
          VUE$TrackCode$c = xVUE$TrackCode$c

          if (igbyte(VUE$TrackCode$c, 1) != TrkSide)
            next
         }
       else if (args[2] == $lex$HFDF$)
         {
          if (TrkSide == $LETB & (Sta$Trk$TrackView$I < $FirstBlue$View | 
                                  Sta$Trk$TrackView$I > $LastBlue$View))
            next
          if (TrkSide == $LETO & (Sta$Trk$TrackView$I < $FirstOrange$View |
                                  Sta$Trk$TrackView$I > $LastOrange$View))
            next

          #$% There may be a second entry with the same track but different view
          #$% Delete both entries of a HFDF track with a same track number if 
          #$%  station is control.
          if (kview == $Neutral$View & hfd_flg == no)
            {
             putSTA$Trk$TrackNumber$I (0)
             putSTA$Trk$DetectDataIndx$I (0)
             putSTA$Trk$TrackView$I (0)
             hfd_flg = yes
             next
            }
          else if (kview != $Neutral$View & kview != xSTA$TRK$TrackView$i)
             next
         }
       else if (args[2] == $lex$SWABS$)
         {
          SWD$Pointer$To (xSTA$Trk$DetectDataIndx$I)
          SWD$DetectorSide$I = xSWD$DetectorSide$I

          if ((SWD$DetectorSide$I == $blue$code & TrkSide != $LETB) |
              (SWD$DetectorSide$I == $orange$code & TrkSide != $LETO))
            next
         }

       break

      } # end of looping STA$TRK sub-table      

   if (Sta$Trk$Index$Ok == $no & hfd_flg == no)
     {
      call echohn (args[5], 5)
      call echov  (" is not found.")
      call echor
      call echov  ("Try this command 'ERASE XXXXX DETECTION ALL'")
      call echor      
     }
   else if (Sta$Trk$Index$Ok)
     {
      putSTA$Trk$TrackNumber$I (0)
      putSTA$Trk$DetectDataIndx$I (0)
      putSTA$Trk$TrackView$I (0)
     }

  } # end if args[4] = $Lex$Track$

#-----------------------------------------------------------------------
#$% process ERASE [SURVSAT|HFDF|SOSUS|SWABS] ALL

else                                        # if args[4] == $Lex$All$
  {
   if (args[2] == $lex$SURVSAT$)            # Erase all SURVSAT tracks
      putSTA$PlotAllSurvSat$i (0)
   else if (args[2] == $lex$HFDF$)          # Erase all HFDF tracks
      putSTA$PlotAllHFDF$i (0)
   else if (args[2] == $lex$SWABS$)         # Erase all SWABS tracks
      {
      if (kview < $FirstBlue$View)
        putSTA$PlotAllSwabs$i (0)
      else if (kview == SWABS$B_View | kview == SWABS$O_View)
        putSTA$PlotAllSwabs$i (0)
      else
        return
      }
   else                                     # Erase all SOSUS tracks
      {
      if (kview < $FirstBlue$View)
        putSTA$PlotAllSosus$i (0)
      else if (kview == SOSUS$View)
        putSTA$PlotAllSosus$i (0)
      else
        return
      }

   #$% Clear out all track entry of the specified detect type from the 
   #$% STA$TRK subtable.
   for (STA$TRK$Index = 1; STA$TRK$Index$Ok; STA$TRK$Index = STA$TRK$Index + 1)
      {
       STA$TRK$TrackType$I = xSTA$TRK$TrackType$I
       if (STA$TRK$TrackType$I == detect_type)
         {
          putSTA$TRK$TrackNumber$I (0)
          putSTA$TRK$DetectDataIndx$I (0)
          putSTA$TRK$TrackView$I (0)
         }
      }

  } # end if args[4] = $Lex$All$

return
end


subroutine display_dealist (STA$Pointer)
######################################################################
#$%
#$%  Purpose: Display_DEAlist displays the list of emitters chosen to
#$%           be suppressed from a particular station's ESM status board.
#$%
#$%  Called By: Suppress_emit
#$%             Unsuppress_emit
#$%
#$%  Calls:   echo..
#$%
#$%  Tables:  STA
#$%
#$%  Date:    April 1, 1993
#$%
#$%  Author:  Brent Burkhalter
#$%
######################################################################
BBCommon

BBDeclare  (STA$Deanum$I, STA$Pointer, STA$DEA$Index)       # MJC 8/1/2000 (E2145)
literal  CSTRIP8                                            # MJC 4/20/2000

  call echov ("Suppressed Emitter List: ")
  STA$DEAnum$I = xSTA$DEAnum$I
  if (STA$DEAnum$I == 0)
    call echov("<NONE>")
  else
    for (STA$DEA$Index = 1; STA$DEA$Index <= STA$DEAnum$I; 
         STA$DEA$Index = STA$DEA$Index + 1)
      {
       call echohn (xSTA$DEA$Name$C, $$MaxLit)
       call echov   (" ")
      }

  call echor

return
end


subroutine Suppress_Emit (ista,     # in - the STA table index
                          iwords,   # in - number of words in the command
                          ilex)     # in - entered command arguments
#################################################################################
#$%
#$%  Purpose: Suppress_emit inserts the specified emitter names into the
#$%           "emitters not to be displayed" list.  The list is used to 
#$%           eliminate selected emitters from the ESM astab display.  The list 
#$%           of suppressed emitters is shown upon completion of the request.
#$%
#$%  Called By: pl_exeord
#$%
#$%  Calls:   display_dealist
#$%
#$%  Tables:  STA       RAD
#$%
#$%  Date:    April 1, 1993
#$%
#$%  Author:  Brent Burkhalter
#$%
#################################################################################
BBCommon

BBDeclare  (STA$Pointer, STA$Deanum$I, STA$DEA$Index,
            RAD$Pointer, RAD$Type$C)                    # MJC 8/1/2000 (E2145)
literal  CSTRIP8                                        # MJC 4/20/2000
literal  ilex[30], name
integer  ista, iwords, found, i, j, iptr, litcmp, found_rad

  STA$Pointer$To ista

  for (i = 2; i <= iwords; i = i + 1)     # up to 8 possible names at a time for a
    {                                     # total of 10 names on the "suppressed" list
     found_rad = $no
     found = $no
     iptr = 0
     STA$DEAnum$I = xSTA$DEAnum$I

     if (STA$DEAnum$I < STA$DEA$Slots)         # if there is room
       {
        for (STA$DEA$Index = 1; STA$DEA$Index <= STA$DEAnum$I; 
                                STA$DEA$Index = STA$DEA$Index + 1)
          {
           j = litcmp (ilex[i], xSTA$DEA$Name$C)  # compare name to list
           if (j == 0)
             {                                  # already in list
              found = $yes
              break
             }
           else if (j < 0)                      # less than current list name
             {
              iptr = STA$DEA$Index
              break                             # found the place 
             }
          }

        if (found == $no)                         # if not already in the suppressed list
          {
           found_rad = $no
           for (RAD$Pointer$first; RAD$Pointer$OK; RAD$Pointer$Next) # search RAD table
             {
              RAD$Type$c = XRAD$Type$c
              if (RAD$Type$c == ilex[i])
                {
                 found_rad = $yes
                 break
                }
             }

           if (found_rad == $yes)
             {
              if (iptr == 0)
                iptr = STA$DEAnum$I + 1
              else
                for (j = STA$DEAnum$I; j >= iptr; j = j - 1)  # move remainer of
                  {                                           # list down
                   STA$DEA$Index = j
                   name = xSTA$DEA$Name$C
                   STA$DEA$Index = j + 1
                   putSTA$DEA$Name$C (name)
                  }

              STA$DEA$Index = iptr                          # insert radar name
              putSTA$DEA$Name$C (ilex[i])
              putSTA$DEAnum$I (STA$DEAnum$I + 1)
             }
           else     # the name was not found in the RAD table
             {
              call echohn (ilex[i], $$MaxLit)
              call echov  (" was not found in the Radar Characteristics")
              call echor
             }
          }         # end of if not already in the suppress list
       }            # end of if there is any free slots in the DEA subtable
     else  # (STA$DEAnum$I => STA$DEA$Slots)     # no more room in suppressed list
       {
        call echov  ("Maximum number of emiters already suppressed - ")
        call echohn (ilex[i], $$MaxLit)
        call echov  (" not added to the list ")
        call echor
       }
    }               # end of loop through command arguments

  call display_dealist (STA$Pointer)
  
return
end


subroutine Unsuppress_Emit (ista,     # in - the STA table index
                            iwords,   # in - number of words in the command
                            ilex)     # in - entered command arguments
#################################################################################
#$%
#$%  Purpose: Unsuppress_emit deletes specified emitter names from the 
#$%           "emitters not to be displayed" list (DEA subtable).  The player 
#$%           is shown the list of suppressed emitters upon completion of the 
#$%           request.
#$%
#$%  Calls:   echo..
#$%           display_dealist
#$%
#$%  Tables:  STA
#$%
#$%  Date:    April 1, 1993
#$%
#$%  Author:  Brent Burkhalter
#$%
#################################################################################
BBCommon

BBDeclare  (STA$Pointer, STA$DEA$Index, STA$Deanum$I)       # MJC 8/1/2000 (E2145)
literal  ilex[30], name
integer  ista, iwords, found, i, j
literal  CSTRIP8

  STA$Pointer$To ista

  if (ilex[2] == $NULL)          # clear list with nulls
    {
     for (STA$DEA$Index = 1; STA$DEA$Index <= STA$DEA$Slots; 
                             STA$DEA$Index = STA$DEA$Index + 1)
        putSTA$DEA$Name$C  ($NULL)
     putSTA$DEAnum$I (0)

     call echov ("Suppressed emitter list cleared")
    }
  else
    {
     for (i = 2; i <= iwords; i = i + 1)  # for each emitter (up to 7)
       {
        found = $no
        STA$DEAnum$I = xSTA$DEAnum$I
        for (STA$DEA$Index = 1; STA$DEA$Index <= STA$DEAnum$I;
                                STA$DEA$Index = STA$DEA$Index + 1)
          {
           if (xSTA$DEA$Name$C == ilex[i])        # if a name match
             {
              found = $yes
              for (j = STA$DEA$Index + 1; j <= STA$DEAnum$I; j = j + 1)
                {
                 STA$DEA$Index = j                # delete name, bring the 
                 name = xSTA$DEA$Name$C           # rest of the list up
                 STA$DEA$Index = j - 1
                 putSTA$DEA$Name$C  (name)
                }
              STA$DEA$Index = STA$DEAnum$I
              putSTA$DEA$Name$C ($NULL)           # clear last entry
              break
             }
          }

        if (found == $no)
          {
           call echov  ("Emitter ")  
           call echohn (ilex[i], $$MaxLit)
           call echov  (" not found in list.")  
          }
        else 
          {
           STA$DEAnum$I = xSTA$DEAnum$I - 1
           putSTA$DEAnum$I
          }
       }        # end of loop through command entries
    }

  call echor
  call display_dealist (STA$Pointer)

return
end



Subroutine Display_Unit_Information (STA$Pointer, UNT$Pointer)
#########################################################################
#$%
#$% Purpose:    Display_Unit_Information prints out the DISPLAY UNIT
#$%             information.
#$%
#$% Called By:  PL_Disply_Unit
#$%             PL_Disply_ALSP_Unit
#$%
#$% Calls:      Echo..
#$%             FGTask
#$%             WHSide
#$%
#$% Tables:     STA     UNT     ACC     AML     TRP     SHC     BML
#$%             CMC
#$%
#$% Date:       January 1994
#$%
#$% Author:     Moved from PL_Disply_Unit.
#$%
#$% Modified:   Carol Kropp - 2/95 (E1356)
#$%             Added class and launching platform info for cruise
#$%             missiles.
#$%
#$%             John McCormick - 1/98 (E1912)
#$%             Added time when sinking platform will be sunk.
#$%
#$%
#$%             Jim Allen - 6/03 (E2344)
#$%             Display noisc id from unt entry intead of unt$pointer$index
#$%
#$%             Jim Allen - 6/03 (E2348)
#$%             Add sconum to otg line
#$%
#########################################################################
BBcommon

BBDeclare  (UNT$Hierarchyid$I, UNT$View$I,
            UNT$Type$I, UNT$Launchindx$I,
            UNT$FullName$V, unt$flag$v, unt$SCONUM$v,
            unt$hulltype$v, unt$hullnumber$i,
            unt$nosicid$i, unt$otgcode$i,
            UNT2$Pointer, UNT3$Pointer)
BBDeclare  (AML$Pointer, TRP$Pointer,
            SHC$Pointer, SHC$FullName$V,
            BML$Pointer,
            CMC$Pointer, ACC$Pointer)             # MJC 8/1/2000 (E2145)
literal  CSTRIP8                                  # MJC 4/20/2000
integer  GAME_DTG                                 # MJC 4/20/2000
integer  STA$Pointer, UNT$Pointer
literal  task_num
integer  iside, m2len
VMSchar  VSTRIP*ARB, msg2*100

  call echov ("Information for ")
  call echohn (xUNT$Name$C, $$MaxLit)

  UNT$FullName$V = xUNT$FullName$V
  if (UNT$FullName$V > " ")
    {
    call echov(" (")
    call echovt (UNT$FullName$V)
    call echov(")")
    }

  call echov(" -- ")
 
  UNT$HierarchyId$i = xUNT$HierarchyId$i       # get task hierarchy id
  call fgtask (UNT$HierarchyId$i,task_num)
  call echohn (task_num,$$MaxLit)
 
  UNT$View$I = xUNT$View$I                     # get view
  call echov (" (")       
  call whside (UNT$View$i,iside)
  if (iside == $neutral$code)
    call echov ("N")
  else if (iside == $blue$code)
    {
     call echov ("B")
     call echoi (UNT$View$i-$firstblue$view+1)
    }
  else
    {
     call echov ("O")
     call echoi (UNT$View$i-$firstorange$view+1)
    }
  call echov (")  ")

  #----------------------------------------
  # New OTG info            dew 11/2000
  m2len = 0
  msg2 = ""
  
  unt$nosicid$i     = Xunt$nosicid$i
  unt$flag$v        = Xunt$flag$v
  unt$hulltype$v    = Xunt$hulltype$v 
  unt$SCONUM$v      = Xunt$SCONUM$v 
  unt$hullnumber$i  = Xunt$hullnumber$i
  unt$otgcode$i     = Xunt$otgcode$i

  if (unt$nosicid$i != 0)
    {
    call vmovv ("  Nosic ID: ",     msg2, m2len)
    call vmoviz(unt$nosicid$i,4,    msg2, m2len)
    }

  if (unt$Flag$V > " ")
    {
    call vmovv ("  Flag: ",         msg2, m2len)
    call vmovV (unt$Flag$V,         msg2, m2len)
    }

  if (unt$SCONUM$V > " ")
    {
    call vmovv ("  SCONUM: ",       msg2, m2len)
    call vmovV (unt$SCONUM$V,       msg2, m2len)
    }

  if (unt$HullType$V > " ")
    {
    call vmovv ("  Hull: ",         msg2, m2len)
    call vmovVT(unt$HullType$V,     msg2, m2len)
    if (unt$hullnumber$i > 0)
        call vmovi(unt$hullnumber$i,msg2, m2len)
    }

  if (unt$otgcode$i != 0)
    {
    call vmovv ("  Report type: ",  msg2, m2len)

    if      (UNT$OtgCode$I == $NAV$otg_code   ) call vmovv ("NAV   ", msg2, m2len)
    else if (UNT$OtgCode$I == $NAVNP$otg_code ) call vmovv ("NAVNP ", msg2, m2len)   
    else if (UNT$OtgCode$I == $NAVNRU$otg_code) call vmovv ("NAVNRU", msg2, m2len) 
    else if (UNT$OtgCode$I == $OTH$otg_code   ) call vmovv ("OTH   ", msg2, m2len) 
    else if (UNT$OtgCode$I == $OTHNP$otg_code ) call vmovv ("OTHNP ", msg2, m2len) 
    else if (UNT$OtgCode$I == $STS$otg_code   ) call vmovv ("STS   ", msg2, m2len) 
    else if (UNT$OtgCode$I == $STSNP$otg_code ) call vmovv ("STSNP ", msg2, m2len) 
    else if (UNT$OtgCode$I == $MER$otg_code   ) call vmovv ("MER   ", msg2, m2len) 
    else if (UNT$OtgCode$I == $FSH$otg_code   ) call vmovv ("FSH   ", msg2, m2len) 
    else if (UNT$OtgCode$I == $TOM$otg_code   ) call vmovv ("TOM   ", msg2, m2len) 
    else if (UNT$OtgCode$I == $OBG$otg_code   ) call vmovv ("OBG   ", msg2, m2len) 
    else if (UNT$OtgCode$I == $RTH$otg_code   ) call vmovv ("RTH   ", msg2, m2len) 
    else                                        call vmovv ("UNK   ", msg2, m2len)
    }

  # msg2 displayed below...
  #---------------------------------------- 

  UNT$Type$i = xUNT$Type$i                     # get class|type and, if a/c or boat, owner
  if (UNT$Type$i == $Air$Code)   # unit is an a/c
    {
     call echov ("Type:  ")
     ACC$Pointer = xUNT$AccPntr$i
     call echohn (xACC$Type$c,$$MaxLit)

     call echov ("  Owner:  ")
     if (xUNT$GhostedUnit$I == $yes)
       {
        call echov ("Ghosted Unit - track sharing ")
        if (Xunt$ALSPShared$i == $yes)  call echov ("ON")
        else                            call echov ("OFF")
       }  
     else
       {
        UNT2$Pointer$To  (xUNT$LaunchIndx$I)   # who a/c will bingo to

        AML$Pointer$to xUNT$AMLindx$i          # unit which launched it,
        UNT3$Pointer$to xAML$OwnerIndx$i       # since a handover changes
                                               # unt$launchindx, but not
                                               # the aml$ownerindx

        if (unt2$pointer$ok)
            call echohn (xUNT2$Name$c,$$MaxLit)
        else
            call echov ("None")

        if (UNT2$Pointer != UNT3$Pointer)
          {
           call echov ("  Launched from:  ")
           call echohn (xUNT3$Name$c,$$MaxLit)
          }
       }         # end of if unit is RESA owned
    }            # end of if unit is an aircraft
  else if (xUNT$SuperType$i == $Torpedo$SuperCode)  # is it a torp
    {                                               # clk 8/4/93 - bug fix
     call echov ("Class:  ")
     TRP$Pointer = xUNT$TRPPntr$I
     call echohn (xTRP$Name$C, $$MaxLit)
    }
  else if (UNT$Type$i == $Surface$Code |  # unit is a surface
           UNT$Type$i == $Sub$Code)       # platform or a sub
    {
     call echov ("Class: ")
     SHC$Pointer = xUNT$ShcPntr$i
     call echohn (xSHC$Type$c,$$MaxLit)

     SHC$FullName$V = xSHC$FullName$V
     if (SHC$FullName$V > " ")
        {
        call echov(" (")
        call echovt (SHC$FullName$V)
        call echov(")")
        }

     if (xUNT$SuperType$i == $SmallBoat$SuperCode)  # unit is a boat
       {
        call echov ("  Owner:  ")
        if (xUNT$GhostedUnit$I == $yes)
          {
           call echov ("Ghosted Unit - track sharing ")
           if (Xunt$ALSPShared$i == $yes)  call echov ("ON")
           else                            call echov ("OFF")
          }  
        else   # the boat is a RESA owned entity
          {
           BML$Pointer$to xUNT$BMLindx$i
           UNT2$Pointer$to xBML$OwnerIndx$i
           call echohn (xUNT2$Name$c,$$MaxLit)
          }
       }   # end of it the unit is a boat

     else
       {
        if (xUNT$GhostedUnit$I == $yes)
           {
            call echov ("  Owner:  ")
            call echov ("Ghosted Unit - track sharing ")
            if (Xunt$ALSPShared$i == $yes)  call echov ("ON")
            else                            call echov ("OFF")
           }  
           
       }
    
     if (xUNT$Status$I == $Sinking$Code)   # jhm 1/98 (E1912)
       {
        call echov ("  Will sink at ");
        call echoiz (Game_DTG(xUNT$TimeSunk$F), 6);
        call echov ("Z");
       }
    }     # end of if unit if surface or subsurface
  else if (UNT$Type$I == $CruiseMissile$Code)    # clk 2/95 (E1356)
    {
     call echov ("Class:  ")
     CMC$Pointer = xUNT$CMCPntr$I
     call echohn (xCMC$Type$C, $$MaxLit)

     call echov ("  From:  ")
     if (xUNT$GhostedUnit$I == $yes)
       call echov ("Ghosted Unit")
     else
       {
        UNT$LaunchIndx$I = xUNT$LaunchIndx$I
        UNT2$Pointer$To  (UNT$LaunchIndx$I)
        if (UNT2$Pointer$Ok)
          call echohn (xUNT2$Name$c,$$MaxLit)
        else
          call echov ("Unknown")
       }     # end of if non-ghosted CM
    }     # end of if unit is a CM
  else  if (UNT$Type$i == $ShoreBase$Code)   # unit is a shorebase
    {
     if (xUNT$GhostedUnit$I == $yes)
       {
        call echov ("Ghosted Unit - track sharing ")
        if (Xunt$ALSPShared$i == $yes)  call echov ("ON")
        else                            call echov ("OFF")
       }  
    }

  call echor

  if (m2len > 0)
    {
    call echov (msg2[1:m2len])
    call echor
    }

# Display control information about unit
if (XSTA$View$I == $Neutral$View)
{
    call echov ("NOSINK is ")
    if ( Xunt$NeverSink$i == YES) call echov ("ON")
    else                          call echov ("OFF")

    call echov ("   NODETECT is ")
    if ( Xunt$NeverDetect$i == YES) call echov ("ON")
    else                           call echov ("OFF")

    call echor
}

return
end

Subroutine Display_Ground_Information (STA$Pointer, AGD$Pointer)
#########################################################################
#$%
#$% Purpose:    Display_Ground_Information prints out the ground
#$%             information.
#$%
#$% Called By:
#$%             PL_Disply_ALSP_Unit
#$%
#$% Calls:      Echo..
#$%             FGTask
#$%             WHSide
#$%
#$% Tables:     STA     AGD
#$%
#$% Date:       August 2003
#$%
#$% Author:     James O. Allen   (E2363)
#$%
#$%
#########################################################################
BBcommon

literal  CSTRIP8
integer  GAME_DTG
integer  STA$Pointer, AGD$Pointer
literal  task_num
integer  iside
VMSchar  VSTRIP*ARB
VMSchar  Ground_class_to_Char*ARB, Ground_size_to_char*ARB
VMSchar  ClassV*ARB, sizeV*ARB

  call echov ("Information for ")
  call echohn (xAGD$Name$C, $$MaxLit)

  call echov(" -- ")
 
  iside = XAGD$Side$i
  call echov ("(")       
  if (iside == $neutral$code)   call echov ("N")
  else if (iside == $blue$code) call echov ("B")
  else                          call echov ("O")

  call echov (") ")

  classV = Ground_class_to_Char (Xagd$ALSPClass$I)
  call echovt (classV)
  call echov (" ")

  sizeV = Ground_size_to_Char (Xagd$ALSPSize$I)
  call echovt (sizeV)
  call echov (" ")

  call echor

return
end

Subroutine Display_Minefield_Information (STA$Pointer, MFD$Pointer)
#########################################################################
#$%
#$% Purpose:    Display_Minefield_Information prints out the minefield
#$%             information.
#$%
#$% Called By:
#$%             PL_Disply_ALSP_Unit
#$%
#$% Calls:      Echo..
#$%             FGTask
#$%             WHSide
#$%
#$% Tables:     STA     MFD
#$%
#$% Date:       March 2007
#$%
#$% Author:     James O. Allen 
#$%
#$%
#########################################################################
BBcommon

literal  CSTRIP8
integer  GAME_DTG
BBDeclare (STA$Pointer, MFD$Pointer, BOM$Pointer)
literal  task_num
integer  iside
VMSchar  VSTRIP*ARB

  call echov ("Information for minefield ")
  call echohn (xMFD$Name$C, $$MaxLit)

  call echov(" -- ")
 
  iside = XMFD$Side$i
  call echov ("(")       
  if (iside == $neutral$code)   call echov ("N")
  else if (iside == $blue$code) call echov ("B")
  else                          call echov ("O")
  call echov (") ")
  call echov(" -- ")

  bom$pointer$to Xmfd$BOMindx$i
  call echov ("Mine Type ")
  call echohn (xBOM$Name$C, $$MaxLit)

  if (Xmfd$GhostedUnit$i == $yes)
  {
      call echov(" -- ")
      call echov("Ghosted ")
  }

  call echor

return
end

Subroutine Display_SweepArea_Information (STA$Pointer, SWP$Pointer)
#########################################################################
#$%
#$% Purpose:    Display_SweepArea_Information prints out the sweeparea
#$%             information.
#$%
#$% Called By:
#$%             PL_Disply_ALSP_Unit
#$%
#$% Calls:      Echo..
#$%             FGTask
#$%             WHSide
#$%
#$% Tables:     STA     MFD
#$%
#$% Date:       June 2011
#$%
#$% Author:     James O. Allen 
#$%
#$%
#########################################################################
BBcommon

literal  CSTRIP8
integer  GAME_DTG
BBDeclare (STA$Pointer, SWP$Pointer, BOM$Pointer)
literal  task_num
integer  iside
VMSchar  VSTRIP*ARB

  call echov ("Information for SweepArea ")
  call echohn (xSWP$Name$C, $$MaxLit)

  call echov(" -- ")
 
  iside = XSWP$Side$i
  call echov ("(")       
  if (iside == $neutral$code)   call echov ("N")
  else if (iside == $blue$code) call echov ("B")
  else                          call echov ("O")
  call echov (") ")
  call echov(" -- ")

  if (Xswp$GhostedUnit$i == $yes)
  {
      call echov(" -- ")
      call echov("Ghosted ")
  }

  call echor

return
end


Subroutine PL_Disply_ALSP (nord, STA$Pointer, nargs, args) 
#########################################################################
#$%
#$% Purpose:    PL_Disply_ALSP processes the DISPLAY ALSP ... commands.
#$%
#$% Called By:  PL_Disply
#$%
#$% Calls:      Display_Unit_Information
#$%             Echo..
#$%             Pl_Disply_ALSP_Stats
#$%
#$% Tables:     STA     UNT
#$%
#$% Date:       January 1994
#$%
#$% Author:     Carol L. Kropp
#$%
#########################################################################
BBcommon

BBDeclare  (UNT$Pointer, UNT$Alspid$I, UNT$Name$C)  # MJC 8/1/2000 (E2145)
BBDeclare  (AGD$pointer,AGD$ALSPid$i)               # JOA UFL03 (E2363)
BBDeclare  (MFD$Pointer)
BBDeclare  (SWP$Pointer)
literal      CSTRIP8                                # MJC 4/20/2000
integer*4    nord, sta$pointer, nargs
literal      args[ARB]
literal  unit_name
integer  unit_alsp_id
integer find_agd_slot, find_agd_name
integer find_mfd_slot, find_mfd_name
integer find_swp_slot, find_swp_name

# args[1] = DISPLAY    args[2] = ALSP    args[3] = ID      args[4] = unit name
#                                        args[3] = UNIT    args[4] = id number
#                                        args[3] = STATISTICS

if (args[3] == $lex$ID$)           # DISPLAY ALSP ID command
{
	unit_name = args[4]
    for (UNT$Pointer$First; UNT$Pointer$OK; UNT$Pointer$Next)
    {
        UNT$Name$C = xUNT$Name$C
        if (UNT$Name$C == unit_name)
        {
			UNT$ALSPid$I = xUNT$ALSPid$I
            if (UNT$ALSPid$I != 0)
            {
               call echohn (UNT$Name$C, $$MaxLit)
               call echov  (": ALSP ID = ")
               call echoi  (xUNT$ALSPid$I)
            }
            else
            {
               call echohn (UNT$Name$C, $$MaxLit)
               call echov  (" is not registered in an ALSP confederation")
            }

            call echor
            break
        }      # end of unit name match
     }      # end of loop through the unit table
     if (!(UNT$Pointer$OK)) 
     {
         agd$pointer$to find_agd_name(unit_name)
         if (agd$pointer$valid)
         {
               agd$alspid$i = Xagd$alspid$i
               if (agd$alspid$i != 0)
               {
                   call echov ("ALSP ID: ")
                   call echoi (xAGD$ALSPid$I)
                   call echov (" ")
        
                   call Display_Ground_Information (STA$Pointer, AGD$Pointer)
               }
         }      # end of ALSP Name match
     }
     if (!(AGD$Pointer$VALID) & !(UNT$Pointer$OK))
     {
         mfd$pointer$to find_mfd_name(unit_name)
         if (mfd$pointer$valid)
         {
               call echov ("ALSP ID: ")
               call echoi (xMFD$ALSPid$I)
               call echov (" ")
    
               call Display_Minefield_Information (STA$Pointer, MFD$Pointer)
          }      # end of ALSP ID match
     }
     if (!(AGD$Pointer$VALID) & !(UNT$Pointer$VALID) & !(MFD$Pointer$OK))
     {
         swp$pointer$to find_swp_name(unit_name)
         if (swp$pointer$valid)
         {
               call echov ("ALSP ID: ")
               call echoi (xSWP$ALSPid$I)
               call echov (" ")
    
               call Display_SweepArea_Information (STA$Pointer, SWP$Pointer)
         }      # end of ALSP ID match
     }
     if (!(AGD$Pointer$VALID) & !(UNT$Pointer$OK) & !(MFD$Pointer$OK) & !(SWP$Pointer$VALID))
     {
        call echov ("No such unit with Name ")
        call echohn (unit_name)
        call echor
     }


    }      # end of DISPLAY ALSP ID command
  else if (args[3] == $lex$UNIT$)    # DISPLAY ALSP UNIT command
    {
     unit_alsp_id = args [4]

     for (UNT$Pointer$First; UNT$Pointer$OK; UNT$Pointer$Next)
       {
        UNT$ALSPid$I = xUNT$ALSPid$I
        if (UNT$ALSPid$I == unit_alsp_id)
          {
           call echov ("ALSP ID: ")
           call echoi (UNT$ALSPid$I)
           call echov ("  ")

           call Display_Unit_Information (STA$Pointer, UNT$Pointer)
           break
          }      # end of ALSP ID match
       }      # end of loop through the unit table
     if (!(UNT$Pointer$OK))             # JOA UFL03 E2363   now check ground radar sites
       {
         agd$pointer$to find_agd_slot(unit_alsp_id,$NO)
         if (agd$pointer$valid)
            {
               agd$alspid$i = Xagd$alspid$i
               if (agd$alspid$i != 0)
               {
                   call echov ("ALSP ID: ")
                   call echoi (xAGD$ALSPid$I)
                   call echov (" ")
        
                   call Display_Ground_Information (STA$Pointer, AGD$Pointer)
               }
               else
               {
                   agd$pointer = 0          # Invalid
               }
             }      # end of ALSP ID match
       }
     if (!(AGD$Pointer$VALID) & !(UNT$Pointer$OK))
       {
         mfd$pointer$to find_mfd_slot(unit_alsp_id)
         if (mfd$pointer$valid)
            {
               call echov ("ALSP ID: ")
               call echoi (xMFD$ALSPid$I)
               call echov (" ")
    
               call Display_Minefield_Information (STA$Pointer, MFD$Pointer)
             }      # end of ALSP ID match
       }
     if (!(AGD$Pointer$VALID) & !(UNT$Pointer$VALID) & !(MFD$Pointer$OK))
       {
         swp$pointer$to find_swp_slot(unit_alsp_id)
         if (swp$pointer$valid)
            {
               call echov ("ALSP ID: ")
               call echoi (unit_alsp_id)
               call echov (" ")
    
               call Display_SweepArea_Information (STA$Pointer, SWP$Pointer)
             }      # end of ALSP ID match
       }
     if (!(AGD$Pointer$VALID) & !(UNT$Pointer$OK) & !(MFD$Pointer$OK) & !(SWP$Pointer$VALID))
       {
        call echov ("No such unit with ALSP ID ")
        call echoi (unit_alsp_id)
        call echor
       }
    }      # end of DISPLAY ALSP UNIT command

  else if (args[3] == $lex$STATISTICS$)    # DISPLAY ALSP UNIT command
    {
     call Pl_Disply_ALSP_Stats
    }      # end of DISPLAY ALSP STATISTICS command

return
end           # end of PL_Disply_ALSP_Unit

