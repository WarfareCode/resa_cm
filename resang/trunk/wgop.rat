####    File:   WGOP.rat

#####   version 3.1  dated-  7apr81  
#####   version 3.0  dated- 22dec80

#$%
#$% Modifications:
#$%    2/15/91  trs  modified sui$ch$frequency$i to sui$ch$frequency$f
#$%

### KHC 4/93 (E1075)
### Processing of the FOR <addressee> [ ORDERS | SENSORS ] commands
### moved to station program.  The following routines were moved to
### a new file (wsorders.rat):  OORDER, XORDER_GUNS, XORDER_SENSORS,
### SORDER, and XORDER.  Also, EXPORD was relocated to lbcommn.rat.

include "ascii.inc"         
include "bbctl.inc"         
include "bbcode.inc"         
include "bbaml.inc"                     # jb - for subr. xorder 5/14/87
include "bbbml.inc"         
include "bbasw.inc"         
include "bbboy.inc"                     # jb                    9/10/87
include "bbbar.inc"                     # jb                    9/15/87
include "bbdeq.inc"         
include "bbcjc.inc"         
include "bbsui.inc"         
include "bbshc.inc"         
include "bbiff.inc"                     # cml                   3/21/91
include "bbirc.inc"                     # clf                   1/26/93
include "bbjag.inc"                     # clk 5/97 (E1791) - cancel JTMD attack
include "bbjam.inc"         
include "bbpat.inc"         
include "bbrad.inc"         
include "bbtor.inc"         
include "bbord.inc"         
include "bbsqd.inc"         
include "bbsta.inc"         
include "bbunt.inc"         
include "bbvue.inc"         
include "bbwet.inc"         
include "bbpim.inc"         
include "bbswb.inc"                 # 3/15/91 clk & smm
include "bbdam.inc"                 # clk 11/94 - CLEAR DAMAGE (entry) command
include "bbnam.inc"                 # clk 11/94 - CLEAR DAMAGE (entry) command
include "bbdac.inc"                 # SMM 4/96 (E1581) - clearing BDA w/ CLEAR DAMAGE
include "bbdss.inc"                 # SMM 4/96 (E1581) - clearing BDA w/ CLEAR DAMAGE
include "bbrte.inc"         
include "bbrto.inc"         
include "orders.inc"         
include "plplay.inc"         
include "hscmd.inc"         
include "stationmsg.inc"             # joa 12/97 (E1852)

#define ($DEBUGS,#$$Debug$Control) # ntrace on SAVORD
#define ($DEBUGA,#$$Debug$Control) # trace on ADDORD
#define ($DEBUGP,$$Debug$Control) # trace on wgordt ($dump,   lbit=0)
#define ($DEBUGR,$$Debug$Control) # trace on rmord ($rm & rm2,lbit=1&2)
#define ($DEBUGC,#$$Debug$Control) # trace on canord ($can,    lbit=3)
#define ($DEBUGE,$$Debug$Control) # trace on exeord ($exe,    lbit=4)
#define ($DEBUGT,#$$Debug$Control) # general trace of all processing routines
define ($DEBUGS,#)
define ($DEBUGA,#)
define ($DEBUGT,#)
define ($DEBUGP,)
define ($DEBUGD,#)
define ($DEBUGR,#)
define ($DEBUGC,)
define ($DEBUGE,)
define ($DEBUGV,)       # Skip/Trace CSF_INSERTER
#define ($DEBUG,#)
define(trace$wgordp$dump,istrip(trace$wgordp,0,M1bits))
define(trace$wgordp$rm,  istrip(trace$wgordp,1,M1bits))
define(trace$wgordp$rm2, istrip(trace$wgordp,2,M1bits))
define(trace$wgordp$can, istrip(trace$wgordp,3,M1bits))
define(trace$wgordp$exe, istrip(trace$wgordp,4,M1bits))
define(trace$wgordp$get, istrip(trace$wgordp,5,M1bits))


undefine read
undefine write
undefine err

define (BBimplicit, IMPLICIT NONE)  # jb  E2145     5/24/00


subroutine wgordp (Top)                   # order processing 
                    # Top is YES if this is the Primary Call to Ord Proc
########################################################
#$%
#$% Purpose:   WGORDP provides executive control
#$%            over the order processing routines.
#$%
#$% Called By: RESYNC     WARCYC
#$%            WGHALT
#$%
#$% Calls:     DELORD     GETORD_STATION     SAVORD
#$%            BLDORD     REVORD     WGORDX
#$%            COMRED     NOROG      COMNED
#$%            WGORDT
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Alex Vagus - 2/97 (H1059)
#$%            Commented out loop (see below) and changed
#$%            call to savord to send in the station pointer.
#$%
#$%            James Allen - 12/97 (E1852)
#$%            Added the StationMsgCommon block so that
#$%            order error messages are sent to the
#$%            issuing station.  The STA table index was
#$%            added the to argument list for bldord and revord.
#$%
#$%            James Allen - 12/97 (E1852)
#$%            Removed call to csf_inserter - csf/rsm is
#$%            no longer usable and the csf/rsm INP & MSG
#$%            subtables of the VUE table were dropped.
#$%
#$%            DEW/SMM - 6/99 (E2100)
#$%            Reset StationMsgWithinOrderProcessing to $no
#$%            when Gane$WasPaused.
########################################################
BBcommon
StationMsgCommon

literal hold[$order$array$size]
integer top,
        ista,iview,kview,ilen,id, STA$Pointer # jb E2145   5/24/00

StationMsgWithinOrderProcessing = $YES  # Order Processing begins - joa 12/97 (E1852)

if (top == $YES)                        # is this the first time this cycle
   {
    order$minute = Game$Minute          # yes......
    call delord                         # delete orders to being deleted units
    call reset_route_loop_flag
   }
else if (Game$WasPaused == $yes) 
   {
    StationMsgWithinOrderProcessing = $NO # DEW/SMM 6/99 (E2100)
    return
   }
else
   {
    order$Minute = Game$Minute + 1      # no (set up for next cycle review)
   }

hold[1] = order$minute

$DEBUGV call dbreak($no)

#______________________________________________________________________________
#       Process STA Input

for (sta$pointer$first; sta$Pointer$valid; sta$pointer$next)    # for each STA
   {
    if (Xsta$PlayerOn$i == NO) next

    iview = Xsta$View$i

    ista = STA$Pointer$Index

    repeat                              # get all orders till no more
       {
        call getord_station (sta$pointer,ilen,hold[2])  # get STA input Que
        if (ilen == 0) break                    # until no more

        if (execution$mode != review$mode)
           {
            call savord (sta$pointer,id,ilen,hold)    # save the order on disk
                                                      #  (return id#)
                                                      # view was replaced by STA$Pointer 
                                                      # av 2/97 (H1059)
            kview = iview
            call bldord (kview,ista,ilen,hold)    # build the order into ORD
           }                                    #  table or execute now
        else
           {
            call revord (iview,ista,ilen,hold)       # process REVIEW orders
           }

       }                                # loop for more from station

   }                                    # end of loop for each station

#______________________________________________________________________________
#       Process the rest of required Stuff (if we are/were not PAUSED)

if (Game$WasPaused == $No)
    {
    if (execution$mode == review$mode)
        {
        call wgordx                     # process orders from history
        }

    if (game$minute >= order$minute)
       {
        call comred                     # check for current orders if COM done
        call norog                      # output "no roger" messages....
        call comned                     # generate COM for those needed
       }
    
    call wgordt                         # process orders from table
    }

StationMsgWithinOrderProcessing = $NO  # Order Processing end - joa 12/97 (E1852)

return
end



subroutine norog                        # "no roger" message to originator 

########################################################
#$%
#$% Purpose:   NOROG generates a "no roger" message
#$%            to be output to the originator.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     RMORD      SEND
#$%
#$% Tables:    ORD        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

#
#   Generated Message
#
#       XXXXX did not roger xxxxxxx order sent via ckt 99
#       XXXXX can not send via ckt 99 ==> FOR xxxxx xxxxxxxxxx
#

literal CSTRIP8              # jb E2145 (cstrip8) 5/24/00
LitCharEquiv(msg1,13)
LitCharEquiv(msg2,14)
Integer ORD$Pointer,ORD$View$I,ORD$Status$I,ORD$AddIndx$I, # jb E2145 5/24/00
        UNT$Pointer, UNT2$Pointer                          # jb E2145 5/24/00

data msg1C /" "," "," ","so-so","did","not","roger","LEX",
            "order","sent","via","ckt"," "/

define ($1$addressee$, 4)
define ($1$order$,     8)
define ($1$circuit$,  13)

data msg2C/" "," "," ","so-so","can","not","send","via","ckt"," ",
                                "==>","For","so-so","LEX"/

define ($2$sender$,    4)
define ($2$circuit$,  10)
define ($2$addressee$,13)
define ($2$order$,    14)

#******

$DEBUGT call echov ("<norog:")

for (ord$pointer$first; still_ok (ord) ; )
   {
    #$% get view
    ord$view$i = xord$view$i

    $DEBUGT ord$id$i = xord$id$i
    ord$status$i = xord$status$i

    #$% if status is being deleted
    if (ord$status$i == $BeingDeleted$code)
       {
        $DEBUGT call echov ("D=")
        $DEBUGT call echoi (ord$id$i)
        $DEBUGT call echo ($colon)

        #$% call to remove order
        call rmord (ord$pointer)        # remove order
        next
       }

    #$% if didn't roger and can't send
    if (ord$status$i != $DidntRoger$code &
        ord$status$i != $CantSend$code    )
       {
        ord$pointer$next
        next
       }

    #$% get ADD index, if ADD index is valid
    ord$ADDIndx$i = xord$ADDIndx$i
    if (ord$ADDIndx$i != 0)
       {
        #$% set unit pointer to ADD index and set message to unit name
        unt$pointer$to ord$ADDIndx$i
        msg1[$1$addressee$] = xunt$name$c
        msg2[$2$addressee$] = msg1[$1$addressee$]
       }
    else
       {
        #$% set message to addressee
        msg1[$1$addressee$] = xord$addressee$c
        msg2[$2$addressee$] = msg1[$1$addressee$]
       }

    #$% exit unless status is didn't roger or can't send
    if (ord$status$i == $DidntRoger$code)
       {
        $DEBUGT call echov ("R=")

        #$% get first message and circuit
        msg1[$1$order$]   = xord$w01$c
        msg1[$1$circuit$] = xord$Circuit$i

        #$% send message that didn't roger
        call send_lex (ord$view$i,13,msg1)  # Didn't Roger ....
       }
    else
       {
        $DEBUGT call echov ("S=")

        #$% set message to unit name of sender
        msg2[$2$order$]   = xord$w01$c
        msg2[$2$circuit$] = xord$Circuit$i
        unt2$pointer$to xord$OriginatorIndx$i
        msg2[$2$sender$] = xunt2$name$c

        call send_lex (ord$view$i,14,msg2)  # Can't Send ....
       }
    $DEBUGT call echoi (ord$id$i)
    $DEBUGT call echo ($colon)
    call rmord (ord$pointer)            # remove order
   }
$DEBUGT call echo ($GREAT)

return
end



subroutine savord (sta$pointer,id,ilen,iinp)  # save orders to disk 
               #    I           I  I    L     # return order id

########################################################
#$%
#$% Purpose:   SAVORD saves orders on disk and
#$%            returns order identification
#$%            number.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Alex Vagus - 2/97 (H1059)
#$%            Change the first argument from the view
#$%            to the station pointer, so that both
#$%            view and station number can be saved.
#$%
#$%            Jim Allen - 8/04
#$%            Eliminate adding view information to define route order
#$%            This is now done in pga/prescript
########################################################

BBcommon

literal iinp[$order$array$size], side, view_number,
        CMD$ELM$word$c
integer iview,      # av 2/97 (H1059)
        istation, id, cmd$elm$index,  # jb E2145  5/24/00
        STA$Pointer,ilen # jb E2145 (Ilen an unused arg?) 5/24/00

$DEBUGS String msg "SAVORD ID=     , ORD     "
CMD$Record$Definition
CMD$ZERO

# extract & store the view and station number - av 2/97 (H1059)
iview = xSTA$View$I
putCMD$View$I  (iview)
istation = STA$Pointer$Index
putCMD$StationNumber$I  (istation)

for (cmd$elm$index=1; cmd$elm$index<=$ord$Len+1; cmd$elm$index=cmd$elm$index+1)
{
     PUTcmd$elm$word$c (iinp[cmd$elm$index])
}

#$% set ID to next order
id = next$order$id

write ($lfc$orders,rec = id) cmd$record    # put to history......

#$% increment order counter
next$order$id = next$order$id + 1

# zero record indicates EOF
cmd$zero 
#$% write the new orders file to record
id = next$order$id
write ($lfc$orders,REC=id) cmd$Record
call flush($lfc$orders)				# Write immediately to disk

$DEBUGS klen = 10; call smoviz(int(id),4,msg,klen)
$DEBUGS klen = 20; call smoviz((int(iinp[3])),4,msg,klen)
$DEBUGS call send_ (iview,0,klen,msg)    #        1/10/91

return
end



 subroutine hisord (id,iview,ista,len,iinp)   # get orders from disk 

########################################################
#$%
#$% Purpose:   HISORD gets orders from the disk when
#$%            running in the review mode.
#$%
#$% Called By: WGORDX
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            The station table index (ista) added
#$%            as an output argument, so error messages
#$%            are sent to the originating station.
#$%
########################################################
 BBcommon       #    I  I     I   L

 cmd$Record$Definition

 literal iinp[$order$array$size],   CSTRIP8 # jb E2145  5/24/00
 integer len,iview,id,ista, CMD$ELM$Index   # jb E2145  5/24/00

 #$% clear view
 iview = 0

 #$% if ID is greater than last order to execute, return
 if (id > last$order$to$execute) return

 read ($lfc$orders, rec=id, err=8010) Cmd$record

 #$% set length
 iview = xCmd$view$i

 ista = xCMD$StationNumber$I    # joa - 12/97 (E1852)

 for (cmd$elm$index = 1; cmd$elm$index <= $order$array$size;
                         cmd$elm$index=cmd$elm$index+1)
    {
    iinp[cmd$elm$index] = Xcmd$elm$word$c 
    }

 len = $ord$len

8010 continue

return
end



subroutine bldord (iview,ista,ilen,iinp)  # build the order into ORD table 
                 #  I     I    I  I    L     # return order id

########################################################
#$%
#$% Purpose:   BLDORD builds the order into the ORD
#$%            table if required, else it passes it
#$%            on for execution.
#$%
#$% Called By: WGORDP   WGORDX
#$%
#$% Calls:     EXEORD   EXPORD     SEND
#$%            ADDORD
#$%
#$% Tables:    ORD        VUE
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            Added the station table index to the
#$%            argument list so that the info can be
#$%            stored in the ORD table.
#$%
#$%            James Allen - 12/97 (E1833)
#$%            Added the "not for" processing to handle
#$%            wildcards in the addressee fields.
#$%
#$%            DEW/SMM 6/99 (E2100)
#$%            Moved setting of StationMsgIndx outside of
#$%            execute the order if statement, so that if
#$%            the order is built into the ORD table or an
#$%            message is sent, the correct station number
#$%            is saved. 
########################################################

 BBcommon
 StationMsgCommon

 Literal iinp[$order$array$size],       # order from player
         lex[$order$array$size],
         iaddr,     CSTRIP8,                        # jb E2145 5/24/00
         rteName
 integer flga,                          # flag for collective groups
         cnta,                          # count of addressees
         stka[$max$TaskGroup]           # stack of addressees
 integer icnt, okord, fndrte
 integer GetNotForFlags,  NotFor,  NotForOffset,
         mask, x_now, In_Launch / $no /
 Integer n,ista, ISNUMBER, UNT2$Pointer        # jb E2145 5/24/00                        
 Integer k,iview,idnum,id,ilen,iptr,nord,kview,klen,   # jb E2145 5/24/00
         VUE$Pointer,VUE$EmbarkIndx$I,VUE$Circuit$I,rview
 Integer rteindx, in_route / $no /
 Integer in_modifyRoute / $no /

 BBDeclare (rte$pointer, rte2$pointer, rto$pointer)
 Character msg[ARB]

$DEBUGT call echov ("<BLDORD:")

iaddr = 0
rview = iview
if (iview == $Neutral$view) iview = 0    # set up control as wildcard view

StationMsgIndx = ista      # Originating station of order DEW/SMM 6/99 (E2100)

#______________________________________________________________________
# build the order into ORD table or else execute it
#
# We can execute it now if:
#   - it is a single line command (not n of m),
#   - No delay time specified,
#   - No addressee (not FOR someone)

x_now = $no

if ($ord$cnt   == 1 & 
    $ord$Start == 0 & 
    ($ord$num < FOR$order$lo | $ord$num > FOR$order$hi))
    x_now = $yes

if (x_now == $yes) 
    {
    call set_Task_Address (NO)
    id = next$order$id
    iptr = 0            # avoid call w/constant         4/7/87
    call exeord (iview,                 # process execution
                 iaddr,                 #iview = view index (in)
                 iptr,                  #iaddr = addressee name (in)
                 id,                    #iptr = addressee pointer (in)
                 int($ord$num),         #id = order id (in)
                 ilen-6,                #$ord$num = order number (in)
                 iinp[8])               #ilen-6 = args length (in)
                                        #iinp[8] = args (in)

    return
    }

#------------------------------------------------------------
# Now, we know it needs to go into the ORD table or RTE/RTO table for 
# execution sooner or later.
# Or, we need to expand the order for each addressee
# included in the FOR clause.  This is where we replicate
# the order, once for each actual UNT to get it.
# We record a differnet UNT$Pointer with each copy of the 
# order.
# 
# Exception -- Flight Plans should not have the UNT reference 
# stored.  There is a problem when a CANCEL LAUNCH immediately
# preceeds a LAUNCH script.  
#
# Description of Problem:
#   When the flight does not previously exist, The CANCEL Nop's 
#   and the flight plan goes in with a null UNT index.
#   When the plan is changed, and the flight is still on the 
#   deck... the idea is to cancel the old and enter a new launch.
#   ALL of the commands are going into ORD with the flight plan 
#   lines assigned to the unt of the previous launch.  Because 
#   the CANCEL is not having a chance to execute.  
#                                                   DEW

nord = $ord$num
kview = iview
call expord (kview,$ord$addr,cnta,stka,flga,nord)# explode addressees

klen = 0
if (cnta == 0 & $ord$cnt == 1 ) # no addee ? FLGA       4/29/87
   {
    if (FLGA > 4)   
        {
#       call wgoerr (iview,iaddr,nord,nargs,args,"Not enabled yet.")
        # don't have the right arguments to pass....  dew
        }  # jb    don't translate $lex$....$ 4/18/87
    else 
        {
        if($isNumeric($ord$addr)) call smoviz(int($ord$addr),4,msg,klen)
        else                      call smovhn ($ord$addr,$$MaxLit,msg,klen)

        Call SMOVV(" is an unknown addressee!",msg,klen)

        call send_ (iview,0,klen,msg)        # 33 vice 30        1/10/91
        }
    return
   }

if (flga < 4)   #  jb Provide for ALLMISSION order, in which    4/15/87
 {              #  jb case FLGA was set by EXPORD to MSNcod +8
  if ($ord$cnt != 1) cnta = 1      # force launch/commtext commands to
 }      # go to only first addressee.. but NOT in case of ALLMISSION

#--------------------------------------------------
# Do he have a launch command...
# Is this line 1 of N where N > 2 and Launch or Scramble

if ($ord$seq == 1)
    {
    if ($ord$cnt >  2                  &
        ($ord$Num == LAUNCH$order    |      # this is a launch 
         $ord$Num == LAUNCHC$order   |      # of any kind ?
         $ord$Num == LAUNCHBoat$order ) )
        {
        in_launch = $Yes
        }
    else
        {
        in_launch = $No
        }
    }    

#--------------------------------------------------
# Do he have a define route command...
# Is this line 1 of N where N >= 2 and define route

if ($ord$seq == 1)
    {
    if ($ord$cnt >=  2                  &
        $ord$Num == DEFINEROUTE$order)
        {
        in_route = $Yes
        call bldrte (rview,ista,ilen+1,iinp,rteindx)
        }
    else
        {
        in_route = $No
        }
    }    

#--------------------------------------------------
# Do he have a modify route command...
# Is this line 1 of N where N >= 2 and define route

if ($ord$seq == 1)
    {
    if ($ord$cnt >=  2                  &
        $ord$Num == MODIFYROUTE$order)
        {
        in_modifyroute = $Yes
        call ochrte (rview,ista,ilen+1,iinp,rteindx,rto$pointer)
        }
    else
        {
        in_modifyroute = $No
        }
    }    

#--------------------------------------------------
# Is this a line from a flight plan?
# (are in lines 3...n and the LAUNCH command was just entered...)

if (in_launch == $yes &
    $ord$seq  >  2    &
    $ord$cnt  >  2    &
    cnta      == 1     )
    {
    # Clear the unt pointer
    stka[1] = 0
    }

if (in_launch == $yes & $ord$seq > 1)
{
    # Check for reference to route
    if ($ord$num == PROCEEDROUTE$order)
    {
        rteName = iinp(7+3)
        rteindx = fndrte(rteName)
        if (rteindx == 0)
        {
            klen = 0
            call smovv ("Launch plan has route ",msg, klen)
            call smovhn (rteName, $$MaxLit, msg, klen)
            call smovv (" that is not defined.",msg, klen)
            call smovv (" Execute route order deleted.", msg, klen)
            call send_ (iview,0,klen,msg)
            return
        }
        else
        {
            icnt = $ord$cnt - $ord$seq
            rte2$pointer$to rteindx
            rte$pointer = rte2$pointer
            okord = $yes
            call nested_route_check (rte$pointer, rte2$pointer, icnt, iview, okord) 
            if (okord == $no) return
        }
    }
}
#--------------------------------------------------

if (iview <= $Neutral$view) vue$pointer$first
else                        vue$pointer$to iview

vue$circuit$i = Xvue$circuit$i
vue$embarkindx$i = Xvue$embarkindx$i

if (vue$embarkindx$i > unt$slots)       # not embarked
   {
    klen = 0
    Call smovv("Sorry, You are not embarked anywhere!!!",msg,klen)
    call send_ (iview,0,klen,msg)          # display error
    return
   }

if (in_route == $yes)
    {
        if (rteindx != 0 & $ord$seq > 1)
        {
            call addrte (rteindx,rview,ista,ilen+1,iinp)
            if ($ord$seq == $ord$cnt)        # Last sub-order
            {
                if (rto$used > rto$size)   # Table overflow
                {
                    rte$pointer$to rteindx
                    rto$used = Xrte$RTOPntr$i - rto$base
                    PUTrte$Name$c( 0 )      # Make slot available
                    rte$used = rte$used - rte$entry
                }
            }
        }                    
    }
else if (in_modifyroute == $yes)
    {
        if (rteindx != 0 & $ord$seq > 1)
        {
            call modifyrte (rteindx,rto$pointer,rview,ista,ilen+1,iinp)
        }                    
    }
else
    {
    #$% for each entry
    for (k = 1; k <= cnta; k = k + 1)
       {
        if ($ord$seq == 1)        # Only check first order in plan - joa 12/97 (E1833)
          {
           call unit_notfor_offset (stka[k], NotForOffset) # Get unit notfor offset
           if (NotForOffset != $Clear$NotFor)         # Not set
             {
              mask = 0
              $setbit (mask, NotForOffset)           # Create notfor mask
              NotFor = GetNotForFlags(nord) & mask   # Set not for result
              if (NotFor != 0)                       # There is an addresseee restriction
                {
                 call NotFor_errmsg (iview, NotForOffset)
                 unt2$pointer = stka[k]
                 lex[1] = Xunt2$name$c               # addressee
                 lex[2] = iinp[3+1]                  # time
                 lex[3] = iinp[2+1]                  # code
                 if (iinp[6+1] != 1)
                    lex[3] = -(lex[3])
                 klen = iinp[1+1]-6 + 3
                 for (n=4; n <= klen; n=n+1)
                   { lex[n] = iinp[n+4] }
    
                 #$% call to send the order to the player terminal
                 call send_lex (iview,Klen,lex)
                 next
                }
             }
          }
    
        #$% set ID number to next plan order ID and increment counter
        idnum = next$planorder$id
        next$planorder$id = next$planorder$id + 1
    
        #$% call to add order into ORD table
        call addord (iview,ista,$ord$addr,stka[k],vue$circuit$i,
                     vue$embarkindx$i,idnum,ilen,iinp)
       }
    }
$DEBUGT call echov (":BLDORD>")
$DEBUGT call echor

return
end



subroutine fndord (id,ord$pointer)              # find order # id 
                #   I  I                        # return the pointer
########################################################
#$%
#$% Purpose:   FNDORD finds the order which has the
#$%            given order ID number and returns the
#$%            ORD pointer.
#$%
#$% Called By: KILORD     CANORD     EXEORD
#$%            OMESSG     OCANCL
#$%
#$% Calls:     None
#$%
#$% Tables:    ORD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

Integer    ID, ORD$Pointer      # jb  E2145 5/24/00

#$% for each order number entry
for (ord$pointer$first; still_ok (ORD) ; ord$pointer$next)
   {
    #$% if order ID is same, return
    if (xord$id$i == id) return
   }

#$% clear order pointer
ord$pointer = 0

return
end



subroutine fndordByname (name,ordpntr)           # find order by name 
                #   I  I                        # return the pointer
########################################################
#$%
#$% Purpose:   FNDORD finds the order which has the
#$%            given addressee and returns the
#$%            ORD pointer.
#$%
#$% Called By: infltmisn
#$%
#$% Calls:     None
#$%
#$% Tables:    ORD
#$%
#$% Date:      Aug 09
#$%
#$% Author:    James Allen
#$%
########################################################
BBcommon

literal    name, cstrip8
Integer    ORD$Pointer, ordpntr

#$% for each order number entry
for (ord$pointer$first; still_ok (ORD) ; ord$pointer$next)
{
    #$% if order ID is same, return
    if (xord$addressee$c == name)
    {
        ordpntr = ord$pointer
        return
    }
}

#$% clear order pointer
ordpntr = 0

return
end



subroutine kilord (idlo,idhi)                   # find order # id 
                #   I    I                      # return the pointer

########################################################
#$%
#$% Purpose:   KILORD deletes the orders with order
#$%            ID number in the range from idlo
#$%            to idhi.
#$%
#$% Called By: OLAUNC
#$%
#$% Calls:     FNDORD     RMORD
#$%
#$% Tables:    ORD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

Integer id, idlo, idhi, ORD$Pointer   # jb  E2145 5/24/00

$DEBUGT call echov ("<kilord:")
$DEBUGT call echoi (idlo)
$DEBUGT call echo ($minus)
$DEBUGT call echoi (idhi)

#$% for each ID entry
for (id = idhi; id >= idlo; id = id - 1)
   {
    #$% call to find order ID
    call fndord (id,ord$pointer)

    #$% if ORD pointer valid, call to remove order
    if (ord$pointer == 0) next

    PUTord$Status$i ($BeingDeleted$code)
   }

$DEBUGT call echo ($GREAT)

return
end



subroutine delord                       # remove all orders to deleteed UNTs 

########################################################
#$%
#$% Purpose:   DELORD marks orders "to-be-deleted",
#$%            if the addressee is being deleted.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT        ORD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

integer              gone[unt$slots]
Integer indx,                                   # jb  E2145 5/24/00
        UNT$Pointer,UNT$Status$I,               # jb  E2145 5/24/00
        ORD$Pointer,ORD$AddIndx$I,ORD$Status$I  # jb  E2145 5/24/00
 
common /scratch$pad/ gone

$DEBUGd call echov ("<delord")

#$% clear index
indx = 0
#$% for each unit entry
for (unt$pointer$first; unt$pointer$valid; unt$pointer$next)
   {
    #$% increment index counter
    indx = indx + 1

    #$% get unit status
    unt$Status$i = Xunt$Status$i
    #$% if slot not in use or being deleted set gone to YES
    if (Xunt$InUse$i  == $no              |
        unt$Status$i == $BeingDeleted$code) gone[indx] = $yes
    #$% else set gone to NO
    else                                     gone[indx] = $no
   }

#$% for each order entry
for (ord$pointer$first; still_OK (ORD) ; ord$pointer$next)
   {
    #$% if status not executable, get next entry
    if (Xord$Status$i != $Executable$code) next

    #$% get add index, if add index is zero, get next
    ord$Addindx$i = Xord$Addindx$i
    if (ord$AddIndx$i == 0) next

    #$% if not gone, get next entry
    if (gone[ord$AddIndx$i] == $no) next

    #$% set status to being deleted and save
    ord$Status$i = $BeingDeleted$code
    PUTord$Status$i

    $DEBUGd call echov (": id=")
    $DEBUGd call echoi (Xord$Id$i)
    $DEBUGd call echov (" unt=")
    $DEBUGd call echoi (ord$AddIndx$i)
   }

$DEBUGd call echo ($GREAT)

return
end



subroutine canord (unt$pointer,id)      # remove all orders to specified UNT 
BBcommon          # I          I        # except for order ID

########################################################
#$%
#$% Purpose:   CANORD removes all orders to
#$%            specified units.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FNDORD     RMORD
#$%
#$% Tables:    ORD        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  SMM 6/94 PER #E1236 sends message for cancelling
#$%            an attack order 
#$%
#$%            James Allen - 2/96 (E1467)
#$%            Added new CANCEL FUEL order (ship refueling).
#$%ordlo
########################################################

literal cname,iname, ORD$Addressee$C,  CSTRIP8            # jb  E2145 5/24/00
integer id,ixcan,idlast,indx,                             # jb  E2145 5/24/00
        UNT$View$I,                                       # jb  E2145 5/24/00
        UNT$Pointer,UNT$PimIndx$I,UNT$AswIndx$I,          # jb  E2145 5/24/00
        ORD$Pointer,ORD$Sequence$I,ORD$Count$I,ORD$ID$I,  # jb  E2145 5/24/00
        ORD$Start$I,ORD$Code$I,ORD$UP$I,                  # jb  E2145 5/24/00
        PIM$Pointer, ASW$Pointer                          # jb  E2145 5/24/00
integer kk
integer         order_time    # clk 11/93 - to replace iminut, for vts
integer         ords[500],icnt,k,ordlo,ordhi
character msg[ARB]

common /scratch$pad/ ords,iname,cname,icnt,k,ordlo,ordhi

$DEBUGC ixcan = trace$wgordp$can
$DEBUGC if (ixcan == $yes)
$DEBUGC    {
$DEBUGC     call echor
$DEBUGC     call echov ("<canord:")
$DEBUGC    }

iname = Xunt$name$c                     # unt name
kk = 0; call smovv ("        ",cname, kk)           # collective name
if (xunt$leader$i == $yes) cname = Xunt$ForceName$c

#______________________________________________________________________
# if this unit is on an ORBIT (PIM)... remove the PIM           # 12/6/83

unt$PimIndx$i = Xunt$PimIndx$i 
if (unt$PimIndx$i != 0)
   {
    pim$pointer$to unt$PimIndx$i
    PUTunt$PimIndx$i (0)
    pim$zero
    PUTpim$modified$i ($YES)
   }


#______________________________________________________________________

#$% initialize flags
icnt = 0
idlast = id
order_time = order$minute
indx = unt$pointer$index

#$% call to find order
call fndord (id,ord$pointer)
if (ord$pointer != 0)                               # if current order
   {
    ord$sequence$i = Xord$sequence$i
    ord$Count$i = Xord$Count$i

    if (ord$sequence$i != ord$count$i)              # determine current
        idlast = id + ord$count$i - ord$sequence$i  # plan size

    $DEBUGC if (ixcan == $yes)
    $DEBUGC    {
    $DEBUGC     call echov (" id=")
    $DEBUGC     call echoi (id)
    $DEBUGC     call echo ($minus)
    $DEBUGC     call echoi (idlast)
    $DEBUGC    }

    #$% get starting time
    order_time = Xord$Start$i
   }

for (ord$pointer$first; still_ok (ord); ord$pointer$next)   # for all orders
   {
    #$% if not executable, get next entry
    if (xord$status$i != $Executable$code) next

    ord$id$i = xord$id$i

    if (ord$id$i >= id & ord$id$i <= idlast) next       # save current plan

    #$% get addressee
    ord$addressee$c = xord$addressee$c
    if (ord$addressee$c != iname &
        ord$addressee$c != cname &
        Xord$addIndx$i  != indx   ) next

    ord$sequence$i = Xord$sequence$i
    ord$Count$i = Xord$Count$i
    ord$Up$i = Xord$Up$i

    if (ord$sequence$i > 1 &
        ord$Up$i == $no     ) next

    #$% get order start
    ord$Start$i = Xord$Start$i
    if (ord$Start$i > order_time) next

    #$% get order code
    if (ord$Start$i == order_time & ord$id$i > id) next             # 18MAR82

    ord$code$i = Xord$code$i
    if ((ord$code$i == ATTACK$Order) & # if this is an attack order, send msg
        (id == -1)) # make sure this call is from bingo command SMM 7/13/94 
        {
         kk = 0
         call smovhn (Xunt$name$c,$$MaxLit,msg,kk)
         call smovv(" discontinuing attack.  ",msg,kk)
         call send_ (unt$view$i,0,kk,msg)

         putORD$NbrofTracks$I ($no)
         putORD$Status$I ($BeingDeleted$code)
        }

    if (ord$code$i != BARRIER$order  &
        ord$code$i != CAPSTATION$order &    # clk 3/92
        ord$code$i != RECONN$order   &
        ord$code$i != REFUEL$order   &
        ord$code$i != FUEL$order     &          # joa 2/96 (E1467)
        ord$code$i != LAND$order     &
        ord$code$i != PROCEED$order  &
        ord$code$i != STATION$order  &
        ord$code$i != PERFORM$order  &      # clk 11/96 (E1600)
    #$% set order ID low and high
        Xord$Up$i == $no             ) next

    ordlo = ord$id$i
    #$% for each order entry
    ordhi = ordlo + ord$Count$i - ord$Sequence$i

        #$% increment counter
    for (k = ordlo; k <= ordhi; k=k+1)
       {
        icnt = icnt + 1
        ords[icnt] = k
       }
   }

$DEBUGC if (ixcan == $yes)
$DEBUGC    {
$DEBUGC     call echov (" Xid=")
$DEBUGC     call echoi (id)
$DEBUGC     call echo ($minus)
$DEBUGC     call echoi (idlast)
$DEBUGC    }

while (icnt > 0)                        # remove in reverse order
   {
    k = ords[icnt]
    #$% call find order
    icnt = icnt - 1

    #$% if zero, get next
    call fndord (k,ord$pointer)

    #$% call to remove order
    if (ord$pointer == 0) next

    PUTord$Status$i ($BeingDeleted$code)
   }

$DEBUGC if (ixcan == $yes)
$DEBUGC    {
$DEBUGC     call echo ($great)
$DEBUGC    }

return
end



subroutine rmord (ord$pointer)                  # remove the order pointed to 

########################################################
#$%
#$% Purpose:   RMORD removes the order that
#$%            is pointed to.
#$%
#$% Called By: NOROG      KILORD     CANORD
#$%            WGORDT     OMESSG     OCANCL
#$%
#$% Calls:     None
#$%
#$% Tables:    ORD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon           # I

Integer k,I1,I2,ilen,irng,ihi,  ORD$Pointer   # jb E2145  5/24/00

$DEBUGR ixrm = trace$wgordp$rm
$DEBUGR if (ixrm == $yes)
$DEBUGR    {
$DEBUGR     call echor
$DEBUGR     call echov ("<rmord :")
$DEBUGR     call echoi (ord$pointer)
$DEBUGR    }

#$% if pointer not OK, return
if (! ord$pointer$ok) return

$DEBUGR if (ixrm == $yes)
$DEBUGR    {
$DEBUGR     call echov (" Id=")
$DEBUGR     call echoi (xord$id$i)
$DEBUGR     if (trace$wgordp$rm2 == $yes) call trace
$DEBUGR    }

#$% set order length
ilen = ord$entry
ihi  = ord$pointer + ilen

#$% set order range
irng = ord$last - ihi + 1

#$% for each order entry
for (k = 0; k <= irng; k = k + 1)
   {
    #$% increment entry
    i1 = ord$pointer + k
    i2 = ihi + k

    ibb[i1] = ibb[i2]
   }

#$% set last order to last minus length
ord$used = ord$used - ilen

return
end



subroutine wgordx                               # process orders from history 

########################################################
#$%
#$% Purpose:   WGORDX processes orders from the
#$%            history file for the review mode.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     HISORD     SEND       BLDORD
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            Added the station table index to the
#$%            hisord and bldord calls.
#$%
########################################################
BBcommon

literal hold[$order$array$size],lex[23]
integer flag, klen,
        k,id,iview,ilen,ista, nord   # jb E2145  5/24/00

String msg1 "The order history file is processed.    "
data flag/-1/

#$% if next order to execute is greater, return
if (next$order$to$execute > last$order$to$execute) return

#$% if next order to execute is less than two, set to two
if (next$order$to$execute < 2) next$order$to$execute = 2

#$% if flag is negative 2, return
if (flag == -2) return

repeat
   {
    #$% set ID
    id = next$order$to$execute

    #$% call to get orders from the disk
    call hisord (id,iview,ista,ilen,hold)

    #$% if view not valid
    if (iview == 0)
       {
        #$% for each view entry
        for (k = $first$view; k <= $last$view; k=k+1)
           {
            #$% call to send message
            call send_ (k,0,40,msg1)
           }
        #$% set flag negative
        flag = -2
        return
       }

    #$% if time of order is greater than game time, break
    if (hold[1] > game$minute) break

    else
       {
        nord = hold[3]
        if (nord == END$order            |
            nord == REVIEWPAUSE$order    |
            nord == REVIEWCONTINUE$order |
            nord == REVIEWFAST$order     |
            nord == REVIEWNORMAL$order   |
            nord == REVIEWEND$order       )
           {
            continue                            # don't execute it
           }
        else
           {
            lex[1] = hold[4+1]                  # addressee
            lex[2] = hold[3+1]                  # time
            lex[3] = hold[2+1]                  # code
            if (hold[6+1] != 1) lex[3] = -(lex[3])
            klen = hold[1+1]-6 + 3
            for (k=4; k <= klen; k=k+1)
               {
                lex[k] = hold[k+4]
               }

            #$% call to send the order to the player terminal
            call send_lex (iview,Klen,lex)

            #$% call to build order
            call bldord (iview,ista,ilen,hold)
           }

        #$% increment next order to execute counter,
        #$% and set next order ID
        next$order$to$execute = next$order$to$execute + 1
        next$order$id = next$order$to$execute
       }
   }

return
end


subroutine wgordt                               # process orders from table 

########################################################
#$%
#$% Purpose:   WGORDT processes orders from
#$%            the ORD table.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     EXEORD     RMORD
#$%
#$% Tables:    ORD        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            Added the StationMsgCommon for storing
#$%            data on the originating station of the cmd.
#$%
########################################################

BBcommon
StationMsgCommon

literal  hold[$order$array$size], ORD$Addressee$C, CSTRIP8  # jb E2145  5/24/00
Integer ixcnt,ixlen,idlast,ixdump,game_dtg,
        ORD$Pointer,ORD$Sequence$I,ORD$Count$I,ORD$ID$I,ORD$Start$I, # jb E2145
        ORD$Code$I,ORD$AddIndx$I,ORD$COMindx$I,ORD$OriginatorIndx$I, # jb E2145
        ORD$Circuit$I,ORD$UP$I,ORD$NbrARGS$I,ORD$Unit$I,ORD$Phase$I, # jb E2145
        ORD$View$I,ORD$Status$I, ORD$WRD$Index, # jb  E2145     5/24/00
        ORD$STAindx$I, UNT$Pointer,             # jb  E2145     5/24/00
        ORD$DTGStart$I, ORD$PAT$I, 
        ORD$TimeToDepart$I
real    Time_Avail, Time_needed, eta
VMSchar msg*120
integer msg_len,isnumber     #jhm 6/12/2001
integer n                    # (E2245) jhm ufl01 

$DEBUGP  Literal xmsg[40]
$DEBUGT call echov ("<wgordt:")

$DEBUGP ixcnt = 0
$DEBUGP ixlen = 0
$DEBUGP xmsg[1] = 0
$DEBUGP xmsg[2] = 0
$DEBUGP xmsg[3] = 0

idlast = -1
ord$pointer$first

repeat
   {
99  if (! ord$pointer$ok) break         # any orders to process?

	current_ord$pointer = ord$pointer	# Save current ord$pointer for debug purposes.

    $DEBUGP if (ord$used < 0)   # check for error symptom
    $DEBUGP    {
    $DEBUGP     call echor
    $DEBUGP     call echo ($bell)
    $DEBUGP     call echov ("Orders Wipeout...  Indx=") # jb E2144  5/24/00
    $DEBUGP     call echoi (ixcnt+1)
    $DEBUGP     call echor
    $DEBUGP
    $DEBUGP     if (trace$wgordp != 0) call ddebug
    $DEBUGP
    $DEBUGP     if (ord$used < 0) ord$used = 0
    $DEBUGP    }

1   ord$Sequence$i = Xord$Sequence$i
    ord$Count$i    = Xord$Count$i
2   ord$Up$i       = Xord$Up$i
3   ord$ID$i       = Xord$ID$i
4   ord$Start$i    = Xord$Start$i
5   ord$Code$i     = Xord$Code$i
    ord$PAT$i      = Xord$PAT$i
    ord$DTGStart$i = Xord$DTGStart$i

    ord$Addressee$c= Xord$Addressee$c
    ord$AddIndx$i  = Xord$AddIndx$i
    ord$COMIndx$i  = Xord$COMIndx$i
    ord$Circuit$i  = Xord$Circuit$i
    ord$Status$i   = Xord$Status$i
    ord$OriginatorIndx$i = Xord$OriginatorIndx$i
    ord$TimeToDepart$i   = Xord$TimeToDepart$i

    $DEBUGP ixdump = trace$wgordp$dump
    $DEBUGP
    $DEBUGP ixcnt = ixcnt + 1
    $DEBUGP
    $DEBUGP
    $DEBUGP if (ixdump == $yes)
    $DEBUGP    {
    $DEBUGP     if (ixlen != 0) call send_lex ($Neutral$view,ixlen,xmsg)
    $DEBUGP
    $DEBUGP     xmsg[ 4] = 'ODump'
    $DEBUGP     xmsg[ 5] = ixcnt
    $DEBUGP     xmsg[ 6] = 'Id:'
    $DEBUGP     xmsg[ 7] = ord$ID$i
    $DEBUGP     xmsg[ 8] = ord$Sequence$i
    $DEBUGP     xmsg[ 9] = 'of'
    $DEBUGP     xmsg[10] = ord$Count$i
    $DEBUGP     xmsg[11] = 'Stat:'
    $DEBUGP     xmsg[12] = ord$Status$i
    $DEBUGP     xmsg[13] = 'nord:'
    $DEBUGP     xmsg[14] = ord$Code$i
    $DEBUGP     xmsg[15] = 'FOR'
    $DEBUGP     xmsg[16] = ord$Addressee$c
    $DEBUGP     xmsg[17] = Xord$w01$c
    $DEBUGP     xmsg[18] = 'time'
    $DEBUGP     xmsg[19] = ord$Start$i
    $DEBUGP     xmsg[20] = 'Org:'
    $DEBUGP     xmsg[21] = ord$OriginatorIndx$i
    $DEBUGP     xmsg[22] = 'Add:'
    $DEBUGP     xmsg[23] = ord$AddIndx$i
    $DEBUGP     xmsg[24] = 'COM:'
    $DEBUGP     xmsg[25] = ord$COMIndx$i
    $DEBUGP     xmsg[26] = 'Ckt:'
    $DEBUGP     xmsg[27] = ord$Circuit$i
    $DEBUGP     xmsg[28] = 'Up:'
    $DEBUGP     xmsg[29] = ord$Up$i
    $DEBUGP     ixlen = 29
    $DEBUGP    }

6   if (ord$sequence$i > 1 &                    # sequential order and
        ord$Up$i == $NO     )                   # not up yet
       {
7       if ((idlast+1) == ord$id$i)             # if prior order still present
           {                                    # yes ... do not process
8           idlast = ord$id$i                   #   save the id
            ord$pointer$next                    #   point to next
            next                                #   loop again
           }

9       if (ord$DtgStart$i == $no)
            {
            ord$start$i = ord$start$i+Order$Minute  # update time relative
            PUTord$start$i                          # to current time
            }

10      ord$Up$i = $yes                         # flag order as up, to allow
        PUTord$Up$i                             # start=start+G$M only once
       }

11  idlast = ord$id$i                           #   save the id

    if (ord$status$i != $Executable$code)       # is it executable ?
       {                                        # no  ... do not process
        ord$pointer$next                        #   point to next
        next                                    #   loop again
       }

16  ord$AddIndx$i = Xord$AddIndx$i
    if (ord$AddIndx$i == 0) unt$pointer = 0
    else                    unt$pointer$to ord$AddIndx$i

17  for (ord$wrd$index = 1; 
         ord$wrd$index <= ord$wrd$slots; 
         ord$wrd$index = ord$wrd$index + 1)
        {
        hold[ord$wrd$index] = xord$wrd$$c
        }

## Zero out all args above legitimate argument pass (E2245) JHM 8/24/2001 UFL01
##   ord$wrd$slots macro defined as xORD$Nbrargs$I
 
  for (n=ord$wrd$slots+1;n<=$order$array$size;n=n+1)
     hold(n)=0.0
 

#--------------------------------------------------
# The following test (#12 below) is to see if it is time to dispatch 
# this order....
# Either the explicit time has come, or it is a LAUNCH command of some 
# kind.  This testing has been expanded to include commands that can
# be COMPLETED at a given PAT or TOT time. 
# (PAT and TOT have identicle meaning here)
# If the ORD$PAT$I field is YES, it was requested for this order to
# start execution at the "right" time.  
# Now, we need to determine if it is the "right" time. 
#
#                                                 DEW (E2206) Sep-2000

115 if (ord$pat$i == $yes &                     # DEW (E2206) Sep-2000
        ORD$TimeToDepart$I == $no)
        {
        # Call someone with this order, and see if we can start it yet...
        # If so, set TimeToDepart to $YES       # DEW        

        Time_avail = ord$start$i - game$minute

        call Estimate_Time_Needed (ord$pointer,    # (In) Order to analyze
                                   Time_Needed)    # (out) minutes required to complete

        #------------------------------
        # Do we need to start yet...

        if (Time_Needed >= Time_Avail)
            {
            # We could look at how much time... 
            # If it cannot actually get there on time, or should have 
            # started a long time ago...
            # We could generate a message to that effect.
            # Maybe later...                DEW 9/2000

            # If time_needed >= 999999.0, there was a problem with 
            # the command...  make a different message. (or no message)

            if (time_needed >= 999999.0)
                {
                # No message
                }
            else if ( (Time_Needed - Time_Avail) > 2) 
                {
                StationMsgIndx = xORD$STAIndx$i

                # What do we say?....
                msg = ""
                msg_len = 0

                call vmov  ($return,                     msg, msg_len)
                call vmovv ("Arriving ",                 msg, msg_len)
                call vmovi (int(Time_Needed-Time_Avail), msg, msg_len)
                call vmovv (" min late.",                msg, msg_len)
                call vmovv (" ETA ",                     msg, msg_len)
                eta = game$time + time_needed
                call vmoviz(Game_DTG(eta),6,             msg, msg_len)
                
                ORD$View$I      = xORD$View$I
                ORD$Addressee$c = xORD$Addressee$c
                Ord$Code$i      = xOrd$Code$i

                call wgo_lex (ORD$View$I,ORD$Addressee$c,Ord$Code$i,
                              ord$wrd$slots,hold, msg[1:msg_len])
                }

            # This flag makes sure we don't come inside here again.

            ORD$TimeToDepart$I = $Yes
            putORD$TimeToDepart$I
            }
        }

#--------------------------------------------------

# E2274 JOA UFL02 - Launch boat commented out because TIME delay ignored.
#             TimeToDepart flag means launch now
#118 if (ord$code$i  == LAUNCH$order |           # this is a launch 
#        ord$code$i  == LAUNCHC$order)  #   |          # of any kind ?
#        ord$code$i  == LAUNCHBoat$order )
#        {
#        ORD$TimeToDepart$I = $Yes
#        }

119 if (ord$code$i  == CANCEL$order   &         # this is a cancel launch
          ( hold[2] == $lex$LAUNCH$ |           # of any kind ?
            hold[2] == $lex$SCRAMBLE$) )
        {
        ORD$TimeToDepart$I = $Yes
        }

12  if (ord$start$i > game$minute   &           # is it time yet ?  
        ORD$TimeToDepart$I == $No        )
       {                                        # no  ... do not process
13      ord$pointer$next                        #   point to next
        next                                    #   loop again
       }

14  ORD$NbrArgs$I   = XORD$NbrArgs$I
    ORD$Start$I     = XORD$Start$I
    ORD$Addressee$C = XORD$Addressee$C
    ORD$Id$I        = XORD$Id$I
    ORD$Unit$I      = XORD$Unit$I
    ORD$Code$I      = XORD$Code$I
    ORD$STAIndx$I   = XORD$STAIndx$I     # joa 12/97 (E1852)
    ORD$View$I      = XORD$View$I
    ORD$Phase$I     = XORD$Phase$I
    ORD$Sequence$I  = XORD$Sequence$I
    ORD$Count$I     = XORD$Count$I

    StationMsgIndx = ORD$STAIndx$i        # joa 12/97 (E1852)

    $DEBUGT call echov ("id=")
    $DEBUGT call echoi (ord$id$i)
    $DEBUGT call echo ($colon)

    $DEBUGP if (ixdump == $yes)
    $DEBUGP    {
    $DEBUGP     ixlen = ixlen + 1; xmsg[ixlen] = $lex$execute$
    $DEBUGP    }



18  if ($isnumeric(ord$addressee$c)) 
         call set_Task_Address (YES)
    else                                        
         call set_Task_Address (NO)

19  call exeord (_                              # process execution
                 ord$view$i,                    # pass view index
                 ord$addressee$c,               # pass addressee name
                 unt$pointer,                   # pass addressee pointer
                 ord$id$i,                      # pass order id
                 ord$code$i,                    # pass order number
                 ord$wrd$slots,                 # pass args length
                 hold)                          # pass args

20  if (! ord$pointer$ok) break                 # any orders left to process?
21  if (ord$id$i == xord$id$i)                  # is same order still there ?
       {                                        # Yes.....
22      ord$phase$i = xord$phase$i
        $DEBUGP if (ixdump == $yes)
        $DEBUGP    {
        $DEBUGP     ixlen = ixlen + 1; xmsg[ixlen] = 'Phase'
        $DEBUGP     ixlen = ixlen + 1; xmsg[ixlen] = ord$phase$i
        $DEBUGP    }
23      if (ord$phase$i == 0)                   #   check if to be removed
           {                                    # yes ....
            $DEBUGP if (ixdump == $yes)
            $DEBUGP    {
            $DEBUGP     ixlen = ixlen + 1; xmsg[ixlen] = $lex$delete$
            $DEBUGP    }
24          call rmord (ord$pointer)            #    delete it (pack table)
            idlast = -1                         #    allow next order
25          next                                #    loop again
           }
26      idlast = ord$id$i                       # save the id
        ord$pointer$next                        # dont remove it, skip over
27      next
       }
    # order has been removed.... (and table packed) loop again
28  idlast = -1                                 # allow next order
   }
$DEBUGP if (ixdump == $yes)
$DEBUGP    {
$DEBUGP     if (ixlen != 0) call send_lex ($Neutral$view,ixlen,xmsg)
$DEBUGP     ixlen = 0
$DEBUGP    }
$DEBUGT call echo ($GREAT)

current_ord$pointer = 0		# zero means no longer in order processing from ord table

return
end



subroutine revord (_                            # execute REVIEW orders 
                   iview,   # I                 # pass view index
                   ista,    # I                 # Originating station index
                   ilen,    # I                 # pass length of the order
                   hold)    # L                 # pass order msg data

########################################################
#$%
#$% Purpose:   REVORD filters out orders not
#$%            allowed in review mode.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     SMOV       SEND       EXEORD
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            Added the station table index of the
#$%            originator of the command - so error
#$%            messages are sent to that station only.
#$%
########################################################
 BBcommon
 StationMsgCommon

 literal hold[$order$array$size],iaddr # jb IADDR for EXEORD call  
 integer ilen, iview, ista,
         klen, id, iptr, nord, iflag   # jb  E2145 5/24/00

 character msg[200]

#string sorry "Sorry, REVIEW mode only allows the following:     
#                  COPY, CANCEL XMARK, CLASSIFY, DEFINE, END, 
#                  ENVELOPE, LABEL, LOB, MARK, ORDERS, PLACE, 
#                  PLOT, REVIEW, SAVE, TIME or UNMARK. "

$DEBUGT call echov ("<REVORD=")

nord = hold[3]

     #$% determine review orders, and initialize flags
     if (nord == COPY$order          ) iflag = $yes
else if (nord == CANCELX$order       ) iflag = $yes
else if (nord == CLASSIFY$order      ) iflag = $yes
else if (hold[8] == $lex$DEFINE$     )
   {
    if      (hold[9] == $lex$TIME$   ) iflag = $yes
    else if (hold[9] == $lex$LARGE$  ) iflag = $yes
#    else if (hold[9] == $lex$BOTTLE$ ) iflag = $yes    ##tpa 6/5/85
    else                               iflag = $no
   }
else if (nord == END$order           ) iflag = $yes
else if (nord == ENVELOPE$order      ) iflag = $yes
else if (nord == LABEL$order         ) iflag = $yes
else if (nord == LOB$order           ) iflag = $yes
else if (nord == MARKTRACK$order     ) iflag = $yes
else if (nord == MARKBEARING$order   ) iflag = $yes

# khc - 4/93 (E1075) - ORDERS commands moved to station program.
#else if (nord == ORDERS$order        ) iflag = $yes

else if (nord == PLACE$order         ) iflag = $yes
else if (nord == PLOT$order          ) iflag = $yes
else if (nord == REVIEWPAUSE$order   ) iflag = $yes
else if (nord == REVIEWCONTINUE$order) iflag = $yes
else if (nord == REVIEWFAST$order    ) iflag = $yes
else if (nord == REVIEWNORMAL$order  ) iflag = $yes
else if (nord == REVIEWEND$order     ) iflag = $yes
else if (nord == SAVE$order          ) iflag = $yes
else if (nord == TIME$order          ) iflag = $yes
else if (nord == UNMARK$order        ) iflag = $yes
else                                   iflag = $no

if (iflag == $no)                               # not allowed during review
   {
    klen = 0
    #$% call to move message data
    call smovv ("Sorry, REVIEW mode only allows the following: ",msg,klen)
    call smov ($tab,msg,klen)
    call smov (6,msg,klen)
    call smov ($return,msg,klen)
    call smovv ("COPY, CANCEL XMARK, CLASSIFY, DEFINE, END, ",msg,klen)
    call smovv ("ENVELOPE, GO, LABEL, LOB, MARK, ",msg,klen)
    call smovv ("PAUSE, PLACE, PLOT, SET, SAVE, TIME or UNMARK.",msg,klen)
    call send_(iview,0,klen,msg)
   }
else                                            # execute now
   {
    call set_Task_Address (NO)

    StationMsgIndx = ista      # Originating station - joa 12/97 (E1852)

    id   = 0            # avoid call w/constant         4/7/87
    iptr = 0            # avoid call w/constant         4/7/87
    iaddr = 0.          # avoid call w/constant         4/7/87
    call exeord (_                              # process execution
                 iview,                         # pass view index
                 iaddr,                         # pass addressee name
                 iptr,                          # pass addressee pointer
                 id,                            # pass order id
                 nord,                          # pass order number
                 ilen-7,                        # pass args length
                 hold[8])                       # pass args
   }
$DEBUGT call echov (":REVORD>")

return
end



subroutine exeord (_                            # execute order now 
                   iview,        # I            # pass view index
                   iaddr,        # L            # pass addressee name
                   unt2$pointer, # I            # pass addressee pointer
                   id,           # I            # pass order id
                   nord,         # I            # pass order number
                   nargs,        # I            # pass args length
                   args)         # L            # pass args

########################################################
#$%
#$% Purpose:   EXEORD performs final addressee
#$%            validation and disburses orders
#$%            to appropriate routines.
#$%
#$% Called By: WGORDT   BLDORD  REVORD
#$%
#$% Calls:     EXPORD     SEND       FNDORD
#$%            WGOERR     CANORD     OCANCL
#$%            ODETAC     ODROP      ODEFIN
#$%            OEND       OHANDO     (OORDER-moved to station program)
#$%            ORELOC     ORBTO      OXCIR
#$%            OCLIFY     OCOPY      ODESIG
#$%            OENVEL     OLABEL     OLOB
#$%            OMARKU     OMESSG     OPLOT
#$%            OPSSAT     OCOMM      OEXECU
#$%            OCIRKT     OEMBRK     OREPRT
#$%            OACTIV     OBLIP      OSUBCS
#$%            OEMCON     OFIRE      OJAM
#$%            OLAUNC     OLOAD      OMISSN
#$%            OMODE      ORECAL     OASSAT
#$%            OWEAPO     OTAKE      OALTIT
#$%            ODEPTH     OREFUL     OSPEED
#$%            OSURF      OBARR      OBINGO
#$%            OCOURS     OCOVER     ORECON
#$%            OPROCE     OSEARC     OSTAT1
#$%            OPAIR      OSPLIT     OATTACK
#$%            OIFF
#$%
#$% Tables:    UNT        ORD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Susan Miller 
#$%            Allow ghosted a/c units with a mission of AEW,  8/95 (E1454)
#$%            AIRTANKER or STTANKER to be chopped to another  9/95 (E1453)
#$%            view.
#$%
#$%            James Allen - 2/96 (E1467)
#$%            Added new FOR <addressee> CONSUMPTION [ OFF | ON ].
#$%            Added new FOR <addressee> PREDICT [ WHEN ... | FUEL ...].
#$%            Added new FOR <addressee> FUEL ... .
#$%
#$%            James Allen - 3/96 (E1563)
#$%            If an a/c is bingoing, don't let a motion
#$%            command cancel it.
#$%
#$%            Carol Kropp - 5/96 (E1467)
#$%            When a surface unit is being refueled, do not
#$%            allow motion commands.
#$%
#$%            Susan Miller - 1/97 (E1732)
#$%            Added call to OIFF
#$%
#$%            Susan Miller - 5/97 (E1633)
#$%            If a unit is performing fltops, don't allow
#$%            a maneuver order to be processed.
#$%
#$%            Carol Kropp - 9/97 (E1892)
#$%            Added call to update the game rate registered
#$%            with ALSP.
#$%
#$%            James Allen - 12/97 (E1832)
#$%            The command restrictions were increased
#$%            so when processing orders the order id 
#$%            was added to the argument list of a number
#$%            of maneuver related command subroutines.
#$%
#$%            James Allen - 12/97 (E1824)
#$%            Removed handling of SetEMI$Order code,
#$%            the commands were dropped with verion 6.3.
#$%
#$%            Susan Miller - 7/98 (E2013)
#$%            Added calls oreplen to handle new order names
#$%            for old orders.
#$%
#$%            James Allen - 8/98 (E2040)
#$%            Ignore orders for units marked for deletion
#$%
#$%            James Allen - 7/03 (E2350)
#$%            Add call to formation order 
#$%
########################################################
 BBcommon

 literal args[$order$array$size],  CSTRIP8, # jb E2145  5/24/00
         iaddr
 LitCharEquiv(mexe,12)

 integer iview, id, nord, nargs,
        jj,kklen,ixexe,loop,match,idummy,IS_TASK_ADDRESS, # jb E2145 5/24/00
        UNT$Pointer,UNT$Status$I,                        # jb E2145  5/24/00
        UNT2$Pointer, ORD$Pointer, ISNUMBER              # jb E2145  5/24/00 

 integer flga,                          # flag for collective groups
         cnta,                          # count of addressees
         stka[$Max$TaskGroup],          # stack of addressees
         upnt                           # holder for the unt$pointer

 integer Game_DTG
 Character msg[ARB]
 integer UNT$Mission$I, UNT$Type$I, shared_mission
 logical maneuver_order      # joa 12/97 (E1832)

EXTERNAL IS_TASK_ADDRESS, ISNUMBER     #  jb E2145    5/24/00

Data mexeC/" "," "," ","XXXXX","LEX","order","Id="," ","Nord="," ","For","XXXXX"/

$DEBUGT call echov ("<EXEORD=")
$DEBUGT call echoi (id)

$DEBUGE ixexe = trace$wgordp$exe
$DEBUGE if (ixexe == $yes)
$DEBUGE    {
$DEBUGE     mexe[5] = args[1]
$DEBUGE     mexe[8] = id
$DEBUGE     mexe[10] = nord
$DEBUGE    }

#find the addressee(s)

if (iaddr == 0 | unt2$pointer != 0)
   {
    cnta = 1
    stka[1] = unt2$pointer
   }
else
   {
    call expord (iview,iaddr,cnta,stka,FLGA,nord) # explode addressees
   }

#$% if view is less than one, set view to one
if (iview <= 0) iview = 1
kklen = 0
if (cnta == 0)                          # no addressee ????
   {
    if (flga > 4)       
            {}            # jb Don't translate ALLMISSION..   5/18/87 
    else if ($isNumeric(iaddr))   
             call smoviz(int(iaddr),4,msg,kklen)
    else                     
             call smovhn (iaddr,$$MaxLit,msg,kklen)
    Call SMOVV(" is an unknown addressee!!!",msg,kklen)
    call send_ (iview,0,kklen,msg)          # display error

    #$% call to find order
    call fndord (id,ord$pointer)
    if (ord$pointer == 0) return

    #$% clear order phase (so it will be deleted)
    PUTord$phase$i (0)
    return
   }

#$% for each entry
for (loop=1; loop <= cnta; loop = loop+1)
   {
    unt$pointer = stka[loop]
    upnt = unt$pointer

    $DEBUGE if (ixexe == $yes)
    $DEBUGE    {
    $DEBUGE     if (unt$pointer != 0) mexe[12] = xunt$name$c
    $DEBUGE     else                  mexe[12] = 'sys'
    $DEBUGE    }

    # do some order validation?

    #$% if unit pointer is valid
    if (unt$pointer != 0)
       {
        #$% get unit status
        UNT$Status$I  = xUNT$Status$I                # joa 8/98 (E2040)
        if (UNT$Status$I == $BeingDeleted$Code &     # prevent order proc
            args[1] != $lex$Repair$)                 # on being deleted unit
          next

        unt$Type$I = Xunt$Type$I                        

        #$% if awaiting launch (Boat or Air)
        if (unt$Status$I == $AwaitingLaunch$code &
            Xunt$TimeLaunched$f > Game$Time)          
            {
            if (( unt$Type$I == $Air$Code & nord != Load$order) | # allow reload
                  Xunt$SuperType$i == $Smallboat$SuperCode)
                {
                jj = 0 
                call smovhn  (Xunt$Name$c,$$MaxLit,msg,jj)
                Call SMOVV(" awaiting launch, cannot accept orders until ",msg,jj)
                call smoviz (Game_DTG(Xunt$TimeLaunched$f), 6,msg,jj)
                call send_ (iview,0,jj,msg)    ## jj vice 56    1/10/91

# khc - 4/93 (E1075) - ORDERS commands moved to station program.
#                if (nord != ORDERS$order) next

                next
                }
            }

        if (unt$Type$I   == $Surface$Code &
            unt$Status$I == $ReadyToRecover$code )
            {
            jj = 0
            call smovhn (Xunt$Name$c,$$MaxLit,msg,jj)
            Call SMOVV(" awaiting recovery, cannot accept orders.",msg,jj)
            call send_ (iview,0,jj,msg) # 48 vice 45    1/10/91

# khc - 4/93 (E1075) - ORDERS commands moved to station program.
#            if (nord != ORDERS$order) next

            next
            }

        if (xUNT$GhostedUnit$I == $yes)     # don't process orders for ghosts
          {                                 # clk 6/92
           UNT$Mission$I = xUNT$Mission$I

           shared_mission = $NO
           if ((UNT$Mission$I == $AEW$Code) |       # does it have the 
               (UNT$Mission$I == $AirTanker$Code) | # right mission?
               (UNT$Mission$I == $STtanker$Code))
                shared_mission = $YES

           # Ghosted units may not accept orders except..
           if ((nord != CHOP$Order)     |
               (nord != ENTEROTG$Order) |
               (UNT$Type$I != $Air$Code))
             {
              jj = 0
              call smovhn (xUNT$Name$C, $$MaxLit, msg, jj)
              call smovv  (" is a ghosted unit and cannot accept orders.", msg, jj)
              call send_   (iview, 0, jj, msg)
              next
             }
           # send a different msg if a/c without AEW, AIRTANKER, or
           # STTANKER mission SMM 9/95
           else if (UNT$Type$I == $Air$Code) # it is an a/c
             {
              if ((shared_mission == $YES) &    # shared mission
                  (xUNT$ALSPShared$I == $NO))
                {
                 if (UNT$Mission$I == $AEW$Code) 
                   {
                    jj = 0
                    call smovhn (xUNT$Name$C, $$MaxLit, msg, jj)
                    call smovv (" is not ", msg, jj)
                    call smovv  ("a shared ghosted AEW aircraft type", msg, jj) 
                    call smovv  (" and cannot accept orders.", msg, jj)
                    call send_   (iview, 0, jj, msg)
                    next
                   }
                  # else doesn't need to br ALSPShared if airtanker or sttanker
                } # end if unit has shared mission and is not alsp shared
              else if (shared_mission == $NO)
                {
                 jj = 0
                 call smovhn (xUNT$Name$C, $$MaxLit, msg, jj)
                 call smovv (" does not have a shared mission", msg, jj)
                 call smovv (" and cannot accept orders.", msg, jj)
                 call send_   (iview, 0, jj, msg)
                 next
                }
             } # end if it is an a/c 
          }         # end of check for ghosted unit

       } # end if for a specific UNT

    #### SYSTEM CONTROL ORDERS ##############################################

    #$% determine system control orders and initialize flags
    match = $yes
         if (nord == ALSP$order          ) call oalsp (nord,iview,nargs,args)
    else if (nord == CANCEL$order        ) call ocancl(nord,id,upnt,iview,nargs,
                                                       args,iaddr)
    else if (nord == CLEAR$order         ) call oclear (nargs,args)
    else if (nord == CREATE$order        ) call ocreate(nord,upnt,nargs,args)
    else if (nord == DEFEND$order        ) call odefend_unit(upnt,args)
    else if (nord == DELETEUNIT$order    ) call odelunt (nord,iview,nargs,args)
    else if (nord == DETACH$order        ) call odetac(nord,id,upnt,nargs,args)
    else if (nord == DROP$order          ) call odrop (nord,iview,nargs,args)
    else if (nord == DEFINE$order        ) call odefin(nord,iview,nargs,args)
    else if (nord == DEFINEDUCTING$order ) call odefin(nord,iview,nargs,args)
    else if (nord == DEFINETIME$order    ) call odefin(nord,iview,nargs,args)
    else if (nord == DEFINELARGE$order   ) call odefin(nord,iview,nargs,args)
    else if (nord == END$order           ) call oend  (nord,iview,nargs,args)
    else if (nord == HANDOVER$order      ) call ohando(nord,upnt,nargs,args)
    else if (nord == HANDOVERBARRIER$order) call ohando(nord,upnt,nargs,args)
    else if (nord == SCUTTLE$order)        call oscuttle(nord,upnt,nargs,args)
    else if (nord == CHOP$order          ) call ohando(nord,upnt,nargs,args)  # SMM 7/98 (E1976)
    else if (nord == INFORM$order        ) call oinfrm(nord,upnt,nargs,args)
    else if (nord == INTELL$order        ) call ointell (id,iview)
    else if (nord == MESSAGE$order       ) call omessg  (id,iview)
    else if (nord == DefinePIM$order     ) call opim    (id,iview)
    else if (nord == ModifyPIM$order     ) call oChPim(nord,iview,nargs,args)
    else if (nord == DefineLanding$order ) call oLanding (nord,iview,nargs,args) # dew 11/22/89
    else if (nord == MarkROUTE$order   )   call omarkRTE (nord,iview,nargs,args)
    else if (nord == DeleteROUTE$order   ) call delRTE (nord,iview,nargs,args)
    else if (nord == DefineSPA$order     ) call oSPA (nord,iview,nargs,args) # clk 10/1/91
    else if (nord == DeleteSPA$order     ) call oSPA (nord,iview,nargs,args)
    else if (nord == MineField$order     ) call ominefield(nord,nargs,args,id)
    else if (nord == ORBIT$order         ) call oOrbit(nord,upnt,nargs,args)
    else if (nord == CONSUMPTION$order   ) call oFuelState(nord,upnt,nargs,args)    # joa 2/96 (E1467)
    else if (nord == ProcessIFF$order    ) call oIFF(id,upnt,nargs,args,iview) #(E1732)

# khc - 4/93 (E1075) - ORDERS and SENSOR commands are now processed by the station program.
#    else if (nord == ORDERS$order        ) call oorder(nord,upnt,iview,iaddr,nargs,args)

    else if (nord == RELOCATE$order      ) call oreloc(nord,iview,nargs,args)
    else if (nord == REPLENISH$order     ) call oreplen(nord,upnt,nargs,args)
    else if (nord == RIPPLE$order        ) call oripple(upnt,nargs,args)
    else if (nord == SETSPEED$order      ) call oreplen(nord,upnt,nargs,args)
    else if (nord == SETSTATUS$order     ) call oreplen(nord,upnt,nargs,args)
    else if (nord == CHARGE$order        ) call oreplen(nord,upnt,nargs,args)
    else if (nord == ADD$order           ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == CHANGE$order        ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == CLOSE$order         ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == DAMAGE$order        ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == DISABLE$order       ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == REPAIR$order        ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == REPLENISHTO$order   ) call oreplen(nord,upnt,nargs,args)   # SMM 7/98 (E2013)
    else if (nord == LOCK$order          ) call olock (nord,iview,nargs,args) # E2273
    else if (nord == REVIEWPAUSE$order   ) call opause (nord,iview,nargs,args)
    else if (nord == REVIEWCONTINUE$order) call opause (nord,iview,nargs,args)
    else if (nord == REVIEWFAST$order    ) REVIEW$Fast = args[3]
    else if (nord == REVIEWNORMAL$order  ) REVIEW$Fast = 0
    else if (nord == REVIEWEND$order     ) continue
    else if (nord == SAVE$order          ) save$request = $yes
    else if (nord == SET$order           ) call oset (nord,iview,nargs,args)
    else if (nord == TIME$order          ) call set_game_rate(args[1],args[2]) 
    # added 6/27/90
    else match = $no

    if (match == $yes)
       {
        $DEBUGE if (ixexe == $yes)
        $DEBUGE    {
        $DEBUGE     mexe[4] = 'SYS:'
        $DEBUGE     call send_lex (iview,12,mexe)
        $DEBUGE    }

        next
       }

    #### PLOT/DISPLAY ORDERS ################################################

    #$% determine plot/display orders and initialize flags

    # Note:  Most of the following commands are now executed at STATION
    #        This means that the commands now numbered in the 9XX range
    #        could be removed from here, along with the O_____ routines that
    #        processed them.                            DEW 18-Sep-91

    match = $yes
         if (nord == COPY$order       ) call ocopy  (nord,iview,nargs,args)
    else if (nord == CLASSIFY$order &   # jb (no addressee)     5/28/87 
                     unt2$pointer == 0) call oclify (nord,iview,nargs,args)
    else if (nord == DESIGNATE$order  ) call odesig (nord,iview,nargs,args)
    else if (nord == EnterOTG$order   ) call oenter_otg (nord,iview,nargs,args)
    else if (nord == EnterAir$order   ) call oenter_air (nord,iview,nargs,args)
    else if (nord == EnterBoat$order  ) call oenter_boat (nord,iview,nargs,args)
    else if (nord == TEXT$order       ) continue # just to remove from table
    else if (nord == PREDICT$order    ) call PL_predict (nord, upnt, nargs, args)  # joa 2/96 (E1467)
    else match = $no

    if (match == $yes)
       {
        $DEBUGE if (ixexe == $yes)
        $DEBUGE    {
        $DEBUGE     mexe[4] = 'PLOT:'
        $DEBUGE     call send_lex (iview,12,mexe)
        $DEBUGE    }

        next
       }

    #### OTHER #############################################################

    #$% determine other orders and initialize flags
    match = $yes
         if (nord == COMMTEXT$order   ) call ocomm (id,iview,nargs,args)
    else if (nord == EXECUTE$order    ) call oexecu (iview,id,upnt)
    else if (nord == CIRCUIT$order    ) call ocirkt (nord,iview,nargs,args)
    else if (nord == EMBARK$order     ) call oembrk (nord,iview,nargs,args)
    else if (nord == REPORT$order     ) call oreprt (iview,upnt,nargs,args)
    else if (nord == ALERT$order      ) call oalert (iview,upnt,nargs,args)
    else if (nord == USE$order        ) call oUsePl (iview,upnt,nargs,args)
    else if (nord == ISAR$order &       # jb ('FOR' order)      6/1/87 
         unt2$pointer$VALID) call oISAR(nord,iview,nargs,args,unt2$pointer)
    else match = $no

    if (match == $yes)
       {
        $DEBUGE if (ixexe == $yes)
        $DEBUGE    {
        $DEBUGE     mexe[4] = 'OTH:'
        $DEBUGE     call send_lex (iview,12,mexe)
        $DEBUGE    }

        next
       }

    #### EQUIPMENT ORDERS ##################################################

    #$% determine equipment orders and initialize flags
    match = $yes
         if (nord == ACTIVATE$order     ) call oactiv(nord,upnt,nargs,args)
    else if (nord == ACTIVATEASMD$order ) call oactiv(nord,upnt,nargs,args)
    else if (nord == ACTIVATESONAR$order) call oactiv(nord,upnt,nargs,args)
    else if (nord == ACTIVATEJAMMER$order) call oactiv(nord,upnt,nargs,args)
    else if (nord == ActivateJTMDGroundSensor$Order) call oactiv(nord,upnt,nargs,args)
    else if (nord == ActivateJTMDAirSensor$Order)    call oactiv(nord,upnt,nargs,args)
    else if (nord == Archive$order      ) call oarchive (args) # SMM 7/99 (E2056)
    else if (nord == BLIP$order         ) call oblip (nord,upnt,nargs,args)
                    # call to odeploy replaces call to osubcs, 5/90, reh
    else if (nord == DEPLOY$order       ) call odeploy(nord,id,upnt,nargs,args)
    else if (nord == EMCON$order        ) call oemcon(upnt,nargs,args)
    else if (nord == FIRECRUISE$order   ) call ofire (nord,id,upnt,nargs,args)
    else if (nord == FIRETORPEDOES$order) call ofire (nord,id,upnt,nargs,args)
    else if (nord == FIRING$order       ) call ocommenc(nord,id,upnt,nargs,args)
    else if (nord == SWEEPING$order     ) call osweep(nord,id,upnt,nargs,args)
    else if (nord == JAM$order          ) call ojam  (nord,upnt,nargs,args)
    else if (nord == LAUNCH$order       ) call olaunc(nord,id,upnt)
    else if (nord == LAUNCHC$order      ) call olaunc(nord,id,upnt)
    else if (nord == LAUNCHboat$order   ) call olaunch_boat (nord,id,upnt)
    else if (nord == LOAD$order         ) call oload (nord,id,upnt)
    else if (nord == MAST$order         ) call osubcs(nord,upnt,nargs,args)
    else if (nord == MISSION$order      ) call omissn(nord,upnt,nargs,args)
    else if (nord == MISSIONAMPHIB$order) call omissn(nord,upnt,nargs,args)
    else if (nord == MISSIONAIR$order   ) call omissn(nord,upnt,nargs,args)
    else if (nord == MODE$order         ) call omode (nord,upnt,nargs,args)
    else if (nord == CEASEJam$order     ) call ojam  (nord,upnt,nargs,args)
    else if (nord == PING$order         ) call oactiv(nord,upnt,nargs,args)
    else if (nord == EXTENDPING$order   ) call oactiv(nord,upnt,nargs,args)
    else if (nord == PINGDISPLAY$order  ) call oping (nord,upnt,nargs,args)
    else if (nord == PINGSET$order      ) call oping (nord,upnt,nargs,args)
    else if (nord == RECALL$order       ) call orecal(nord,upnt,nargs,args)
    else if (nord == RECOVER$order      ) call orecov(nord,id,upnt,nargs,args)
    else if (nord == ReportC2$order     ) call oreport_c2
    else if (nord == RETRIEVE$order     ) call osubcs(nord,upnt,nargs,args)
    else if (nord == SELECT$order       ) call oselct(nord,upnt,nargs,args)
    else if (nord == SILENCE$order      ) call oactiv(nord,upnt,nargs,args)
    else if (nord == SILENCEASMD$order  ) call oactiv(nord,upnt,nargs,args)
    else if (nord == SILENCESONAR$order ) call oactiv(nord,upnt,nargs,args)
    else if (nord == SilenceJTMDGroundSensor$Order) call oactiv(nord,upnt,nargs,args)
    else if (nord == SilenceJTMDAirSensor$Order)    call oactiv(nord,upnt,nargs,args)
    else if (nord == SURVSAT$order      ) call oassat(nord,upnt,nargs,args)
    else if (nord == WEAPONS$order      ) call oweapo(nord,upnt,nargs,args)
    else if (nord == SPLITOFF$order     ) call osplit(nord,upnt,nargs,args,0,0,0)
    else if (nord == ZOOM$order         ) call ozoom (nord,upnt,nargs,args)
    else if (nord == LOOK$order         ) call olook (nord,upnt,nargs,args)
    else if (nord == SCAN$order         ) call oscan (nord,upnt,nargs,args)
    else if (nord == ABIL$order         ) call oabil (nord,upnt,nargs,args)
    else if (nord == TAKEUSINGSAM$order ) call otake  (nord,id,upnt,nargs,args)
    else match = $no

    if (match == $yes)
       {
        $DEBUGE if (ixexe == $yes)
        $DEBUGE    {
        $DEBUGE     mexe[4] = 'EQ:'
        $DEBUGE     call send_lex (iview,12,mexe)
        $DEBUGE    }

        next
       }

    #### POSTURE/MANEUVER ORDERS Check #####################################

    # don't allow units doing flight ops to be given a
    # maneuver order  SMM 5/97 (E1633)

    unt$Status$I = xUNT$Status$I    # jhm 4/99 (E2071) awaiting launch test    
    if ( ((Level$FltOps >= 2) & (unt$Status$I == $Fltops$code)) | 
                        (unt$Status$I == $AwaitingLaunch$Code)) # jhm 4/99
        {
         if (maneuver_order(nord))   # joa 12/97 (E1832)
            {
             jj = 0 
             call smovhn (xUNT$Name$C, $$MaxLit, msg, jj)
             call smovv  (" cannot act on Maneuver orders", msg, jj)
             call smovv  (" during flight operations.  ", msg, jj)
             call smovv  ("Use CANCEL RECOVER order.  ", msg, jj)
             call send_   (iview, 0, jj, msg)  
             next
            }
        } # end if ((Level$FltOps >= 2) & (xUNT$Status$I == $Fltops$code))

    if (maneuver_order(nord)  |         # joa 12/97 (E1852)
        nord == ALTITUDE$order|         # posture
        nord == DEPTH$order   |
        nord == SPEED$order   |
        nord == SURFACE$order |
        nord == COURSE$order  |
        nord == REPEAT$order  |
        nord == COURSENOSPEED$order  )
       {
        continue
       }
    else if (nord != ALLMISSION$Order)  #                       4/26/87
       {
#       call wgoerr (iview,iaddr,nord,nargs,args,"Not enabled yet.")
        jj = 0
        Call SMOVV("Dropped an order not implemented for WARGAMe.",msg,jj)
        call send_ (iview,0,jj,msg)             ## jb           4/28/86
        next
       }


    #### POSTURE ORDERS ####################################################

    #$% if type is shorebase
    unt$type$i = xunt$type$i 
    unt$Status$i = xunt$Status$i 
    if ((unt$type$i == $ShoreBase$code & nord != TAKE$order) |   # SMM (E1997) 
        (unt$type$i == $surface$code & (unt$Status$i == $DeadInWater$Code |
         unt$Status$i == $UnderTow$Code | unt$status$i == $Sinking$Code)))
       {
        if (IS_TASK_ADDRESS(idummy) != YES)     # don't give error if 
            {                                   # order was for Task group
            jj = 0 
            call smovhn (Xunt$Name$c,$$MaxLit,msg,jj)
            Call SMOVV(" cannot act on Maneuver orders",msg,jj)
            call send_ (iview,0,jj,msg)    # 38 vice 35        1/10/91
            }

        next
       }

    #$% determine posture orders and initialize flags
    match = $yes
         if (nord == ALTITUDE$order   ) call oaltit (nord,upnt,nargs,args)
    else if (nord == DEPTH$order      ) call odepth (nord,upnt,nargs,args)
    else if (nord == REFUEL$order     ) call oreful (nord,upnt,nargs,args,id)
    else if (nord == REFUELPOS$order  ) call oreful (nord,upnt,nargs,args,id)
    else if (nord == FUEL$order       ) call ofuel  (nord,upnt,nargs,args,id)      # joa 2/96 (E1467)
    else if (nord == SPEED$order      ) call ospeed (nord,upnt,nargs,args,id)      # joa 8/98 (E2021)
    else if (nord == SURFACE$order    ) call osurf (nord,upnt,nargs,args)
    else if (nord == HIDE$order       ) call ohide  (nord,id,upnt,nargs,args)         # KHC 6/92
    else match = $no

    if (match == $yes)
       {
        $DEBUGE if (ixexe == $yes)
        $DEBUGE    {
        $DEBUGE     mexe[4] = 'POS:'
        $DEBUGE     call send_lex (iview,12,mexe)
        $DEBUGE    }

        next
       }

    #### MANEUVER ORDERS ###################################################

    #$% determine maneuver orders and initialize flags
    match = $yes
         if (nord == BARRIER$order    ) call obarr  (nord,id,upnt)
    else if (nord == BINGO$order      ) call obingo (nord,upnt,nargs,args)
    else if (nord == MOOR$order       ) call omoor  (nord,upnt,nargs,args,id)
    else if (nord == TOW$order        ) call otow   (nord,upnt,nargs,args,id)
    else if (nord == COURSE$order     ) call ocours (nord,id,upnt,nargs,args)
    else if (nord == COURSENOSPEED$order) call ocours (nord,id,upnt,nargs,args)
    else if (nord == TAKE$order       ) call otake  (nord,id,upnt,nargs,args)
    else if (nord == COVER$order      ) call ocover (nord,id,upnt,nargs,args)
    else if (nord == RECONN$order     ) call orecon (nord,upnt,nargs,args,id)
    else if (nord == PROCEED$order    ) call oproce (nord,upnt,nargs,args,id)
    else if (nord == PROCEEDROUTE$order)call oroute (nord,upnt,nargs,args,id)
    else if (nord == RESUME$order     ) call oresume (nord,upnt,nargs,args,id)
    else if (nord == REPEAT$order     ) call orepeat (nord,upnt,nargs,args,id)
    else if (nord == CAPSTATION$order ) call ocap (nord,upnt,nargs,args,id)
    else if (nord == LAND$order       ) call oland  (nord,upnt,nargs,args,id)
    else if (nord == PERFORM$order & Order$Minute <= Game$Minute )
                                        call omASW  (nord,upnt,nargs,args,id)
    else if (nord == SEARCH$order     ) call osearc (iview,id,upnt)
    else if (nord == STATION$order    ) call ostati (nord,upnt,nargs,args,id)
    else if (nord == FORMATION$order  ) call oformation (nord,iview,upnt,nargs,args,id)
    else if (nord == PAIR$order       ) call opair  (nord,upnt,nargs,args,id)
    else if (nord == STRIKE$order     ) call opair  (nord,upnt,nargs,args,id)  # joa 12/97 (E1832)
    else if (nord == ATTACK$order     ) call oattack(nord,upnt,nargs,args,id)
    else match = $no

    if (match == $yes)
       {
        $DEBUGE if (ixexe == $yes)
        $DEBUGE    {
        $DEBUGE     mexe[4] = 'MAN:'
        $DEBUGE     call send_lex (iview,12,mexe)
        $DEBUGE    }

        next
       }

    ########################################################################

    $DEBUGE if (ixexe == $yes)
    $DEBUGE    {
    $DEBUGE     mexe[4] = 'NOP:'
    $DEBUGE     call send_lex (iview,12,mexe)
    $DEBUGE    }
   }                                    # end loop of all addressees

$DEBUGT call echo ($GREAT)

return
end

 

subroutine set_task_address (istat)

########################################################
#$%
#$% Purpose:   SET_TASK_ADDRESS is used to indicate if a 
#$%            task address is being used in the order
#$%             
#$% Called By: 
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JULY 83
#$%
#$% Author:    Dane Wills
#$%
########################################################
IMPLICIT NONE                  # jb  E2145     5/24/00

integer         task_stat
common  /tadd/  task_stat
Integer istat # jb  E2145     5/24/00

task_stat = istat

return
end

 

integer function is_task_address (istat)

########################################################
#$%
#$% Purpose:   IS_TASK_ADDRESS 
#$%            is used by the order execution routines to control
#$%            the generation of error messages.
#$%             
#$% Called By: 
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      JULY 83
#$%
#$% Author:    Dane Wills
#$%ine exeord
########################################################
IMPLICIT NONE                  # jb  E2145     5/24/00

integer         task_stat
common  /tadd/  task_stat
Integer istat

istat = task_stat
is_task_address = task_stat

return
end

 

subroutine wgoerr (iview,iaddr,nord,nargs,args,text) 

########################################################
#$%
#$% Purpose:   WGOERR generates an order error
#$%            message composed of LEX codes
#$%            and message text.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal         args[$order$array$size],iaddr
integer*4       nargs,nord,iview,kk
VMSchar*(*)     text                    # this can be any quoted string  1/94 DEW
VMSchar*ARB     msg
kk = 0; call smovv ("*Error: ", msg, kk); call smovvt (text, msg, kk)

call wgo_lex (iview,iaddr,nord,nargs,args,msg[1:kk])

return
end


subroutine wgo_lex (iview,iaddr,nord,nargs,args,text) 

########################################################
#$%
#$% Purpose:   WGOERR generates an order error
#$%            message composed of LEX codes
#$%            and message text.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon        #   I     L     I    I     L    ".." 

literal   mess[40],args[$order$array$size],iaddr
integer*4            I,L,M, M1, M2,
            nargs,nord,iview        # jb    5/12/98

vaxcharacter*(*)    text               # this can be any quoted string  1/94 DEW

vaxcharacter*8 txt
literal        txt_l
equivalence (txt, txt_l)
data txt/"<TXT>   "/
      
mess[1] = iaddr
mess[2] = 0
mess[3] = nord

L = 3
for (i = 1; i <= nargs; i=i+1)
   {
    L = L + 1
    mess[L] = args[i]
   }

#$% set length of message
L = L + 1; mess[L] = txt_l

for (I = 1; I <= len(text); I = I + 8)
   {
    L = L + 1

    mess[L] = $BLANKLIT # Make sure it is blank
    M = 0
    M1 = I                # As I varies from 1, 9, 17...
    M2 = M1 + 7           #     (M1,M2) varies: (1,8), (9,16), (17,24), ...
    M2 = min(len(text), M2)
    call smovv(text[M1:M2], mess[L], M)
   }

call send_lex (iview,L,mess)        # echo the order....

return
end


subroutine oinfrm (nord,unt$pointer,nargs,args) 

########################################################
#$%
#$% Purpose:   OINFRM processes INFORM commands 
#$%            to tell the player of some event completion.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal  args[$order$array$size], UNT$Name$C, CSTRIP8   # jb E2145  5/24/00
integer  nord, nargs,       # jb note: nord an unused argument..
         ilen, iview, itxt, UNT$Pointer                 # jb E2145  5/24/00
character       msg[ARB]

ilen = 0

unt$name$c = Xunt$name$c
iview      = Xunt$view$i

call smovhn (unt$name$c,$$MaxLit,msg,ilen)
call smovv  (": ",msg,ilen)

itxt = (nargs-1) * 8

call smovh (args[2],itxt,msg,ilen)

call send_ (iview,0,ilen,msg)

return
end


subroutine orecov (nord,id,unt$pointer,nargs,args) 

########################################################
#$%
#$% Purpose:   ORECOV sets status of a CV to FLTOPS, i.e. starts
#$%            motion to turn into the wind.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      DEC 83
#$%
#$% Author:    Dane Wills
#$%
#$% Modified:  James Allen - 12/97 (E1370)
#$%            Added the order id to the argument list
#$%            for the call to clear_maneuver_all.
#$%
########################################################
BBcommon

literal   args[$order$array$size], name, CSTRIP8    # jb D2145  5/24/00
integer   nord, nargs, id,
        kview, idummy, IS_TASK_ADDRESS,             # jb D2145  5/24/00
        UNT$Pointer                                 # jb D2145  5/24/00
EXTERNAL               IS_TASK_ADDRESS              # jb D2145  5/24/00

if (xUNT$Status$I != $Sinking$Code)
    {
    if (Xunt$AirCapable$i == $YES)
        {
        call clear_maneuver_all (nord, id, xUNT$View$I, UNT$Pointer)
        PUTunt$status$i ($Fltops$code)
        PUTunt$RecoverOrd$i ($YES)  #<<<>>>For FltOps level 3???    7/23/86 
        }
    else if (IS_TASK_ADDRESS(idummy) != YES)        # don't give error if 
        {                                           # order was for Task group
        kview = Xunt$view$i
        name  = Xunt$Name$c

        call wgoerr (kview,name,nord,nargs,args,
                     "Not an Aircraft capable ship.")
        }
    }

return
end

subroutine opause (nord,iview,nargs,args) 

########################################################
#$%
#$% Purpose:   OPAUSE processes PAUSE and GO commands 
#$%            and generates a message to the CSF Controller.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     Notify_CSF
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 82
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 9/97 (E1892)
#$%            Added call to update the game rate registered
#$%            with ALSP when the wargame is paused/running.
#$%
########################################################
BBcommon

literal         args[$order$array$size]
integer         nord, iview, nargs,  kk 

character       msg[80]

kk = 0

if (nord == REVIEWPAUSE$order   ) 
    {
    Game$Pause = $yes

    # register the current game rate - clk 9/97 (E1892)
    if (ALSP$Active != $no)
      call alsp_register_rate (0.0)

    if (nargs >= 2)
        {
        if (args[2] == $lex$REFRESH$)
            {
            refresh$request = $YES

            call smovv (", REFRESH",msg,kk)
            }
        else if (args[2] == $lex$LOCK$)
            {
            lock$station = $YES

            call smovv (", LOCK",msg,kk)
            }
        }
    else 
        {
        refresh$request = $no
        lock$station    = $no

        call smovv (", NOLOCK",msg,kk)
        }
    }
else if (nord == REVIEWCONTINUE$order) 
    {
    Game$Pause      = $no
    Refresh$Request = $no
    Lock$Station    = $no

    # register the current game rate - clk 9/97 (E1892)
    if (ALSP$Active != $no)
      call alsp_register_rate (game$rate)
    }

call smov (EOS,msg,kk)

call Notify_CSF ("NOTICE",msg)

return
end

subroutine olock (nord,iview,nargs,args) 

########################################################
#$%
#$% Purpose:   OLOCK processes LOCK and UNLOCK commands. 
#$%            LOCK keeps playeer stations from entering BB orders.
#$%            (E2273)
#$%            
#$% Called By: EXEORD
#$%
#$% Tables:    None
#$%
#$% Date:      Aug 02
#$%
#$% Author:    James O. Allen
#$%
########################################################
BBcommon

literal         args[$order$array$size]
integer         nord, iview, nargs,  kk 

character       msg[80]

kk = 0

if (args[1] == $lex$LOCK$) 
{
    lock$station = $YES
}
else if (args[1] == $lex$UNLOCK$) 
{
    Lock$Station    = $no
}

return
end


subroutine omessg (id,iview)                    # order id 

########################################################
#$%
#$% Purpose:   OMESSG processes message commands
#$%            and generates display messages.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     IPBYTE     FNDORD     RMORD
#$%            SEND
#$%
#$% Tables:    ORD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            Added StationMsgCommon and related processing
#$%            so messages are sent to the whole view.
#$%
########################################################

BBcommon          # I   I
StationMsgCommon

literal text[$order$array$size,8], CSTRIP8  # jb E2145  5/24/00
integer iview,nview,tosta,icnt,tlen[8],
        k,klen,m,id,lenh,Lid,mid,           # jb E2145  5/24/00
        ORD$Pointer,ORD$WRD$Index           # jb E2145  5/24/00
integer sta$pointer
integer loview, hiview
literal w2
String msgH "Message, From:                "
String nogo "Can not send message to                "

$DEBUGT call echov ("<omessg:")

#                   1              2                   3
#{514,BAQ      }  MESSAGE (to) [ CONTROL |
#                                VIEW (own)  |
#                                STATION (number) <station-number> ];
#
#{514,AQ       }  MESSAGE (to) [ BLUE (view number) <view>  [ | <view> ] |
#                                ORANGE (view number) <view> [ | <view> ] |
#                                ALL];

call fndord (id,ord$pointer)            # get the original order (from table)

loview = 1
hiview = 1
tosta = 0

if (ord$pointer != 0)                   # if order there....
   {
    w2 = Xord$W02$C
    if (w2 == $lex$CONTROL$)
    {
        loview = 1
        hiview = 1
    }
    else if (w2 == $lex$VIEW$)
    {
        loview = iview
        hiview = iview
    }
    else if (w2 == $lex$STATION$)
    {
        loview = iview
        hiview = iview
        tosta  = Xord$W03$c 

        # Check for valid station number
        if (tosta > (default$stations + extra$stations))
        {
            klen = 25
            Call SMOVv("Station ",nogo,klen)
            call smovi (tosta,nogo,klen)
            call send_ (iview,0,klen,nogo)
            return
        }
        sta$pointer$to tosta
        # Check that station belongs to view or contol, or control sending
        if (Xsta$view$i != iview & iview != 1 & Xsta$view$i != 1)
        {
            klen = 25
            Call SMOVv("Station ",nogo,klen)
            call smovi (tosta,nogo,klen)
            call send_ (iview,0,klen,nogo)
            return
        }
    }
    else if (w2 == $lex$BLUE$)
    {
        loview = xord$w03$c + $firstblue$view - 1
        hiview = loview
        if (loview > $lastblue$view)
        {
            klen = 25
            Call SMOVv("BLUE ",nogo,klen)
            call smovi (Xord$w03$c,nogo,klen)
            call send_ (iview,0,klen,nogo)
            return
        }
        if (Xord$NbrArgs$i > 3)
        {
          hiview = xord$w04$c + $firstblue$view - 1
          if (hiview > $lastblue$view | hiview < loview)
          {
            klen = 25
            Call SMOVv("BLUE ",nogo,klen)
            call smovi (Xord$w04$c,nogo,klen)
            call send_ (iview,0,klen,nogo)
            return
          }
        }
    }
    else if (w2 == $lex$ORANGE$)
    {
        loview = xord$w03$c + $firstorange$view - 1
        hiview = loview
        if (loview > $lastorange$view)
        {
            klen = 25
            Call SMOVv("ORANGE ",nogo,klen)
            call smovi (Xord$w03$c,nogo,klen)
            call send_ (iview,0,klen,nogo)
            return
        }
        if (Xord$NbrArgs$i > 3)
        {
          hiview = xord$w04$c + $firstorange$view - 1
          if (hiview > $lastorange$view | hiview < loview)
          {
            klen = 25
            Call SMOVv("ORANGE ",nogo,klen)
            call smovi (Xord$w04$c,nogo,klen)
            call send_ (iview,0,klen,nogo)
            return
          }
        }
    }
    else if (w2 == $lex$ALL$)
    {
        loview = 1
        hiview = $lastorange$view 
    }

    icnt = Xord$count$i - 1             # get number of lines of text
    Lid = icnt + id

    for (mid = id+1; mid <= Lid; mid = mid + 1)         # loop for text
       {
        call fndord (mid,ord$pointer)
        if (ord$pointer == 0) next      # can't find order (table been full)

        tlen[mid-id] = ord$wrd$slots

        for (ord$wrd$index=1;ord$wrd$index <= ord$wrd$slots;
             ord$wrd$index = ord$wrd$index+1)
             text[ord$wrd$index,mid-id] = xord$wrd$$c
       }
   }

lenh = 15
if (iview == $Neutral$view)               # set up senders name
   {
    Call SMOVv("Control ",msgH,lenh)

    Call SMOVv(" Station ",msgH,lenh)
    call smovi(StationMsgIndx,msgh,lenh)

   }
else if (iview <= $lastblue$view)
   {
    Call SMOVv("Blue ",msgH,lenh)
    call smovi(iview-$firstblue$view+1,msgh,lenh)

    Call SMOVv(" Station ",msgH,lenh)
    call smovi(StationMsgIndx,msgh,lenh)
   }
else
   {
    Call SMOVv("Orange ",msgH,lenh)
    call smovi(iview-$firstOrange$view+1,msgh,lenh)

    Call SMOVv(" Station ",msgH,lenh)
    call smovi(StationMsgIndx,msgh,lenh)
   }

if (tosta == 0)
{
    StationMsgIndx = 0                  # Illegal station causes msg to view
}
else
{
    StationMsgIndx = tosta
}

for (nview = loview; nview <= hiview; nview = nview + 1)
{
    call send_ (nview,0,lenh,msgh)

    do m = 1, icnt
    {
        call send_ (nview,0,8*(tlen[m]),text[1,m])
    }
}
$DEBUGT call echo ($GREAT)

return
end



subroutine oend (nord,   # I                       # order number 
                 iview,  # I                       # given view
                 nargs,  # I                       # number of arguments
                 args)   # L                       # array of arguments

########################################################
#$%
#$% Purpose:   OEND processes end commands.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal args[$order$array$size]
Integer nord, iview, nargs

#$% if side order finished, set autologout to YES
if (game$designation == 0 & args[2] == $lex$yes$) auto$logout = $yes

#$% set halt request to true
halt$request = $true

return
end



subroutine ocirkt (nord,  # I                      # order number 
                   iview, # I                      # given view
                   nargs, # I                      # number of arguments
                   args)  # L                      # array of arguments
########################################################
#$%
#$% Purpose:   OCIRKT processes circuit commands
#$%            and generates display messages.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SMOVH      SMOVI      SEND
#$%
#$% Tables:    VUE
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal args[$order$array$size]
integer nord,iview,nargs,
        VUE$Pointer,VUE$Circuit$I,      # jb E2145  5/24/00
        klen,ickt,kckt, PAT$Pointer     # jb E2145  5/24/00
Character msg1[ARB]
#
#          Generated messages:
#
#          Cannot use circuit nn, still on nn/
#          Switching to circuit nn from nn.../
#          ..../....1..../....2..../....3..../

#$% if view is less than CONTROL, set view point first
if (iview <= $Neutral$view) vue$pointer$first
#$% else set view pointer to view
else                      vue$pointer$to iview

#$% get view circuit
kckt = xvue$circuit$i
ickt = args[2]

if (ickt == 0)
   {
    #$% clear circuit
    vue$circuit$i = 0
   }
else
   {
    #$% set view circuit
    vue$circuit$i = kckt

    #$% for each path entry
    for (pat$pointer$first; Still_OK (PAT) ; pat$pointer$next)
       {
        #$% if not circuit path, get next
        if (ickt != xpat$circuit$i) next

        #$% set view circuit
        vue$circuit$i = ickt
        break
       }
   }

#          Cannot use circuit nn, still on nn/
#          Switching to circuit nn from nn.../

#$% set length
klen = 0
if (vue$circuit$i != ickt)
   {
    #$% call to move message
    call smovv ("Cannot use circuit ",msg1,klen)
    call smovi (ickt,msg1,klen)
    call smovv (", still on ",msg1,klen)
   }
else
   {
    #$% call to move message
    call smovv ("Switching to circuit ",msg1,klen)
    call smovi (ickt,msg1,klen)
    call smovv (" from ",msg1,klen)
   }
call smovi (kckt,msg1,klen)
call send_ (iview,0,klen,msg1)

#$% save view circuit
PUTvue$circuit$i

return
end



subroutine oembrk (nord,   # I                     # order number 
                   kview,  # I                     # given view
                   nargs,  # I                     # number of arguments
                   args)   # L                     # array of arguments

########################################################
#$%
#$% Purpose:   OEMBRK processes embark commands
#$%            and generates display messages.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     EXPORD     SMOVH      SMOVHN
#$%            SMOV       SEND       WHVIEW
#$%
#$% Tables:    VUE        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal args[$order$array$size],  CSTRIP8  # jb E2145   5/24/00
literal kplat, iplat, iaddr
integer nord,iview,nargs, kview,
        indx,kindx,klen, UNT$Pointer,      # jb  E2145   5/24/00
        VUE$Pointer,VUE$EmbarkIndx$I       # jb  E2145   5/24/00

integer stka[$Max$TaskGroup],cnta,flga
character msg1[ARB]

data iaddr/0/

#
#          Generated messages:
#
#          Cannot embark on XXXXX, still on XXXXX
#$% get embark index
#          Embarking on XXXXX from XXXXX
#          ..../....1..../....2..../....3..../

iview = kview

if (nargs > 2)
    {
    call whview (iview,args[3])
    if (iview == 0)
        {
        call wgoerr (kview,iaddr,nord,nargs,args,"Invalid View.")
        return
        }
    }
#$% if view is less than CONTROL (not a valid view), go to first entry
#$% in the vue table
if (iview <= $Neutral$view) vue$pointer$first
#$% else set view pointer to view indicated
else                      vue$pointer$to iview

vue$EmbarkIndx$i = xvue$EmbarkIndx$i

#$% get platform and index values
iplat = args[2]
kindx = Xvue$EmbarkIndx$i

#$% if index value is zero (for all)
if (kindx == 0)
   {
    #$% set platform to indicate "ALL"
    kplat = 'ALL'
   }
#$% else if index is greater than number of units
else if (kindx > unt$slots)
   {
    #$% set platform ti indicate "NoOne"
    kplat = 'NoOne'
   }
else
   {
    #$% else set unit pointer to the index number
    unt$pointer$to kindx
    #$% and get the name of the unit (platform)
    kplat = Xunt$name$c
   }

#$% if view is less than CONTROL (not a valid view), set kview to zero
if (iview <= $Neutral$view) kview = 0
#$% else (if valid view) match kview to iview
else                      kview = iview
call expord (kview,               # generate list of addressees
               iplat,               # given addressee
               cnta,                # return count of receipents
               stka,                # array of unit pointers
               flga,                # flag (y/n) if collective nam
               0)                   # order number
#$% get unit pointer
unt$pointer = stka[1]
#$% if unit pointer valid
if (unt$pointer != 0)
   {
    #$% set local index to index matching the unit
    indx = unt$pointer$index
    #$% and get platform name
    iplat = xunt$name$c
    #$% emabrked index to match unit
    vue$EmbarkIndx$i = indx
   }
#$% else if embarked on all platforms
else if (iplat == 'ALL')
   {
    #$% set appropriate values to indicate "ALL"
    cnta = 1
    indx = 0
    vue$EmbarkIndx$i = 0
   }
else
   {
    cnta = 0
    indx = 0
   }
#          Cannot embark on XXXXX, still on XXXXX.
#          Embarking on XXXXX from XXXXX.
klen = 0
if (cnta == 0)
   {
    call smovv ("Cannot embark on ",msg1,klen)
    call smovhn (iplat,$$MaxLit,msg1,klen)
    call smovv (", still on ",msg1,klen)
   }
else
   {
    call smovv ("Embarking on ",msg1,klen)
    call smovhn (iplat,$$MaxLit,msg1,klen)
    call smovv (" from ",msg1,klen)
   }
call smovh (kplat,$$MaxLit,msg1,klen)
call smov ($period,msg1,klen)
call send_ (iview,0,klen,msg1)    # klen vice numeral    1/10/91

PUTvue$EmbarkIndx$i

return
end



subroutine whview (iview,ilex)          # determine view index from: 

####################################################################
#$%
#$%
#$%   Purpose: whview determines view index number for CONTROL,
#$%            BLUE and ORANGE.
#$%
#$%   Called By: OEMBRK
#$%
#$%   Calls: None
#$%
#$%   Tables: None
#$%
#$%   Date: April 1982
#$%
#$%   Author: Dana Wills
#$%
####################################################################
bbcommon                                

literal ilex[2]                         # ..... 0 if err
Integer iview       # jb E2145  5/24/00

#$% if CONTROL view, then index is one
if      (ilex[1] == $lex$Control$)
    {
    iview = 1
    }
#$% else if BLUE view, then index is table index plus view #
else if (ilex[1] == $lex$BLUE$)
    {
    iview = ilex[2] + $FirstBlue$View - 1

    #$% if index is greater than largest BLUE view #, make index zero (error)
    if (iview > $LastBlue$View) iview = 0
    }
#$% else if ORANGE view, then index is table index plus view #
else if (ilex[1] == $lex$ORANGE$)
    {
    iview = ilex[2] + $FirstOrange$View - 1

    #$% if index is greater than largest ORANGE view #, make index zero (error)
    if (iview > $LastOrange$View) iview = 0
    }
#$% else if there is an error, make index zero
else
    {
    iview = 0
    }

return
end



subroutine odetac(nord,    # I                      # detach/attach from/to 
                  id,      # I
                  oldunt,  # I                 # collective group
                  nargs,   # I
                  args)    # L

########################################################
#$%
#$% Purpose:   ODETAC processes commands to attach
#$%            or detach units from or to collective
#$%            groups.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     XDETAC     SEND       XATTAC
#$%
#$% Tables:    UNT        
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1370)
#$%            Added the order id to the argument list
#$%            for call to clear_maneuver_all.
#$%
########################################################
BBcommon

literal args[$order$array$size],igrp,
        UNT$ForceName$C, CSTRIP8        # jb E2145  5/24/00
LitCharEquiv(msg1,10)
LitCharEquiv(msg2,7)
REAL*4  UNT$GuideRange$F                # jb E2145  5/24/00 
integer nord,iview,nargs,oldunt,newunt,
        id,indx, UNT2$Pointer,          # jb E2145  5/24/00 
        UNT$Pointer,UNT$Leader$I,UNT$GuideIndx$i # jb 5/12/98

data msg1C/"","","","xxxxx","is","new"," leader ","of","group","xxxxx"/
data msg2C/"","","","xxxxx","can't","join","xxxxx"/

#$% call to detach unit
call xdetac(oldunt,newunt)

#$% if new unit
if (newunt != 0)
   {
    #$% set unit pointer, get name, leader, force and view
    unt$pointer = newunt
    msg1[4] = Xunt$Name$C
    msg1[7] = $lex$Leader$
    msg1[10] = Xunt$ForceName$C
    iview =  Xunt$View$I
    #$% call to display message
    call send_lex (iview,10,msg1)
   }

#$% if need to attach
if (args[1] == $lex$ATTACH$)
   {
    #$% set unit pointer to old unit pointer
    unt$pointer = oldunt

    #$% get and save unit name
    msg1[4] = Xunt$Name$C
    msg1[7] = args[3]
    msg1[10] = args[2]

    #$% set group and view
    igrp = args[2]
    iview =  Xunt$View$I

    #$% clear index
    indx = 0                                    # find leader of group

    #$% for each unit entry
    for (unt2$pointer$first; unt2$pointer$valid; unt2$pointer$next)
       {
       #$% if unit is not same view or force name is not
       #$% group name or no leader, get next
        if (Xunt2$view$i != iview    |
            Xunt2$ForceName$C != igrp|
            Xunt2$Leader$i != $Yes    ) next

        #$% set index
        indx = unt2$pointer$index
        break
       }

    if (args[3] == $lex$MEMBER$) # Must be a Leader (for a MEMBER to join)
       {
        if (indx == 0)                          # no leader found
           {
            #$% get and save unit name
            msg2[4] = Xunt$Name$C
            msg2[7] = args[2]

            #$% call to display that unit can't join in
            call send_lex (iview,7,msg2)
            return
           }

        call clear_maneuver_all (nord, id, xUNT$View$I, UNT$Pointer)

        unt$Leader$i = $no                      # insert as a member
        PUTunt$Leader$i

        #$% set force name to group
        unt$ForceName$C = igrp
        PUTunt$ForceName$C

        #$% set guide index
        unt$GuideIndx$i = indx
        PUTunt$GuideIndx$i

        #$% set guide range
        unt$GuideRange$f = 0.0            
        PUTunt$GuideRange$f               
       }
    else        # Else is joining as LEADER..
       {
        #$% set force name to group
        unt$ForceName$C = igrp
        PUTunt$ForceName$C

        #$% call to attach unit
        call xattac(unt$pointer,indx)   # (leader-to-be,old-leader-or-0)
       }

    #$% call to display view message
    call send_lex (iview,10,msg1)
   }

return
end        # End DETAC



subroutine xdetac(unt$pointer, # I  to-be-detached, detach unit from collective 
                  newunt)      # I  leader-assigned# group
########################################################
#$%
#$% Purpose:   XDETAC detaches a unit from the
#$%            collective group.
#$%
#$% Called By: ODETAC     REMOVE
#$%
#$% Calls:     XATTAC
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal  igrp,UNT$ForceName$C, CSTRIP8, CSTRIP             # jb E2145 5/24/00
Integer newunt,iview,indx,iSame,iJamm,iStrC,iCap,iAny,iSTnkr, # jb E2145 5/24/00
        UNT$Pointer,UNT$Leader$I,UNT$Mission$I,     # jb E2145 5/24/00
        UNT2$Pointer,UNT2$Leader$I,UNT2$Status$I,UNT2$Mission$I # jb E2145 5/00
 
#$% clear new unit
newunt = 0

#$% if unit pointer not OK, return
if (! unt$pointer$ok) return

if (Xunt$Type$i != $Air$Code) return            # Skip boats KR08 JOA

#$% get unit leader and force name
unt2$Leader$I = Xunt$Leader$I                   # save leader flag
igrp          = Xunt$ForceName$C

if (Xunt$atoid$c == 0)                          # If ato, mission# in forcename
{
    unt$ForceName$C = 0                             # remove from group
    PUTunt$ForceName$C
}

unt$Leader$I = $no                              # insure that not leader
PUTunt$Leader$I

 # If detachee was NOT leader, we're through--
IF (unt2$Leader$i == $NO) RETURN  #--but if he LED the flight, we need a
                                  #                             new leader.

#$% get view, mission, unit pointer index
iview         = Xunt$View$i
unt$mission$i = Xunt$mission$i
indx          = unt$pointer$index

#$% clear flags
iSame = 0
iJamm = 0
iStrC = 0
iCap  = 0
iAny  = 0
iSTnkr= 0               # jb (for New Strike-Tanker mission)    10/1/86

#$% for each unit entry
for (unt2$pointer$first; unt2$pointer$valid; unt2$pointer$next)
   {
    #$% if unit is not same view or force name is not group name, get next
    if (Xunt2$view$i != iview    |
        Xunt2$ForceName$C != igrp) next

    #$% get unit status
    unt2$status$i = Xunt2$status$i

    #$% if being deleted or sinking, get next
    if (unt2$status$i == $BeingDeleted$code) next
    if (unt2$status$i == $Sinking$code     )  next

    #$% get unit mission
    unt2$mission$i = Xunt2$mission$i

    #$% determine mission status and set flags
#    if (isame == 0 & unt2$mission$i == unt$mission$i  ) #      10/3/86
    if (unt2$mission$i == unt$mission$i) # No need to stay in   10/3/86
     {                          # this FOR loop if a flight     10/3/86
      isame = unt2$pointer      # member's mission matches      10/3/86
      BREAK                     # that of the former leader-jb- 10/3/86
     }

    if (ijamm == 0 & unt2$mission$i == $jam$code      ) ijamm = unt2$pointer
    if (istrc == 0 & unt2$mission$i == $strikecap$code) istrc = unt2$pointer
    if (icap  == 0 & (unt2$mission$i == $cap$code |
                      unt2$mission$i == $AirDefense$Code)) icap  = unt2$pointer
    if (iSTnkr== 0 & unt2$mission$i == $STtanker$code ) iSTnkr= unt2$pointer
    if (iany  == 0)                                     iany  = unt2$pointer
   }    # End of FOR loop thru unt2$pointer...

    ## ( Note that at this point, even if none of the 'favored' missions was
     #   found, IANY does has a value for use as a default..)

if      (isame != 0) iany  = isame      # (Highest preference)  10/3/86
else if (ijamm != 0) iany  = ijamm      # Order reversed and ELSE's " 
else if (istrc != 0) iany  = istrc      # added;  results in same   "
else if (icap  != 0) iany  = icap       # priorities, but with pos- "
else if (iSTnkr !=0) iany  = iSTnkr     # sibly fewer tests -jb- 10/3/86    

#$% set new unit to any
newunt = iany

#$% call to attach unit to collective group
call xattac (iany,indx)

return
end



subroutine xattac(unt$pointer,  # I  leader-to-be   # attach unit to collective 
                  indx)         # I  old-leader     # group

########################################################
#$%
#$% Purpose:   XATTAC attaches a unit to the
#$%            collective group.
#$%
#$% Called By: ODETAC     XDETAC
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

LITERAL UNT$ForceName$C, CSTRIP8                # jb E2145 5/24/00
REAL*4  UNT$OrderedLatitude$F,UNT$OrderedLongitude$F,UNT$OrderedCourse$F,
        UNT$GuideBearing$F,UNT$GuideRange$F,UNT$AttackBearing$F,
        UNT$AttackRange$F,                      # jb E2145 5/24/00
        UNT2$GuideBearing$F,UNT2$GuideRange$F   # jb E2145 5/24/00
Integer indx,nindx,                             # jb E2145 5/24/00
        UNT$Pointer,UNT$Leader$I,UNT$OrderedAltDepth$I,UNT$GuideTrue$I,
        UNT$AttackTrue$I,UNT$UseOrdSpeed$I,UNT$AssignedTarget$I,
        UNT$GuideIndx$I,UNT$AttackIndx$I,       # jb E2145 5/24/00
        UNT2$Pointer,UNT2$Leader$I,UNT2$GuideIndx$I # jb E2145 5/24/00
  
#$% if unit pointer not OK, return
if (! unt$pointer$ok) return                    # if some error

#$% set unit leader to YES and save
unt$leader$i = $yes
PUTunt$leader$i

if (indx == 0) RETURN # If no old leader, no a/c to lead per old orders

nindx          = unt$pointer$index
unt$pointer$to   nindx

#$% set unit and position pointers to old leader
unt2$pointer$to indx

# copy old leaders orders.....
#

unt$OrderedLatitude$f     = Xunt2$OrderedLatitude$f
PUTunt$OrderedLatitude$f
unt$OrderedLongitude$f    = Xunt2$OrderedLongitude$f
PUTunt$OrderedLongitude$f
unt$OrderedCourse$F       = Xunt2$OrderedCourse$F
PUTunt$OrderedCourse$F
unt$OrderedAltDepth$I     = Xunt2$OrderedAltDepth$I
PUTunt$OrderedAltDepth$I
unt$GuideBearing$F        = Xunt2$GuideBearing$F
PUTunt$GuideBearing$F
unt$GuideRange$F          = Xunt2$GuideRange$F
PUTunt$GuideRange$F
unt$GuideTrue$I           = Xunt2$GuideTrue$I
PUTunt$GuideTrue$I
unt$AttackBearing$F       = Xunt2$AttackBearing$F
PUTunt$AttackBearing$F
unt$AttackRange$F         = Xunt2$AttackRange$F
PUTunt$AttackRange$F
unt$AttackTrue$I          = Xunt2$AttackTrue$I
PUTunt$AttackTrue$I
unt$UseOrdSpeed$i         = Xunt2$UseOrdSpeed$i
PUTunt$UseOrdSpeed$i

unt$GuideIndx$I          = Xunt2$GuideIndx$I
PUTunt$GuideIndx$I
unt$AttackIndx$I         = Xunt2$AttackIndx$I
PUTunt$AttackIndx$I
unt$AssignedTarget$i      = Xunt2$AssignedTarget$i
PUTunt$AssignedTarget$i


# put old leader on guide to new--PROVIDED THAT unt2$leader is not "NO",
#  which will be true if the calling subroutine is XDETAC... jb 10/1/86

IF (Xunt2$Leader$i != $no)              # jb - "IF" inserted    10/1/86
 {
  unt2$Leader$i              = $no
  PUTunt2$Leader$i
  unt2$guideIndx$i          = nindx
  PUTunt2$guideIndx$i
  unt2$GuideBearing$F        = 0.0
  PUTunt2$GuideBearing$F
  unt2$GuideRange$F          = 0.0
  PUTunt2$GuideRange$F
 }

#re-assign station guides to members

#$% get force name
unt$ForceName$C = Xunt$ForceName$C

#$% for each unit entry
for (unt2$pointer$first; Still_OK (unt2) ; unt2$pointer$next)
   {
    if (xunt2$ForceName$C != unt$ForceName$C) next      # if not in group

    if (xunt2$leader$I != $no) next                     # if not a member

    if (Xunt2$guideIndx$i != indx) next        # if no guiding on old leader

    unt2$guideIndx$i = nindx                   # station on new leader
    PUTunt2$guideIndx$i
   }

return
end        # End  XATTAC




subroutine ocancl(nord,            # I              # cancel orders pending 
                  id,              # I              # Order id
                  unt$pointer,     # I              # unt pointer
                  iview,           # I              # given view
                  nargs,           # I
                  args,            # L
                  iaddr)           # L              # original addressee

########################################################
#$%
#$% Purpose:   OCANCL processes cancel commands to
#$%            cancel orders that are pending.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FLTREC     FNDORD     RMORD
#$%            SEND    boat_recover
#$%
#$% Tables:    ORD        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp 4/92:  Added cancel of CAP
#$%
#$%            Carol Kropp - 8/95 (E1465)
#$%            When CANCEL ALL was entered ATTACK commands
#$%            were cleared from the orders queue, but the
#$%            related fields were not.
#$%
#$%            Susan Miller - 10/95 (E1453)
#$%            Added cancel refuel command so that all the
#$%            flags would get reset.
#$%
#$%            James Allen - 3/96 (E1467)
#$%            Added cancel unrep and cancel fuel command
#$%            processing.
#$%
#$%            Carol Kropp - 2/97 (E1731)
#$%            CANCEL ALL will clear the DROP MINE flag.
#$%
#$%            Susan Miller - 5/97 (E1633)
#$%            Reset MarshallWarning flag when a CANCEL
#$%            BINGO or ALL command is processed.
#$%            Reset status to proceeding when canceling
#$%            RECOVER order.
#$%
#$%            Susan Miller - 7/97 (E1385)
#$%            Set UNT$TestIntercept$I to $no when the
#$%            assigned target is being cleared.
#$%
#$%            James Allen - 12/97 (E1370)
#$%            The order id was added the the argument
#$%            list for use in calls.
#$%            MOOR is not a multi-phase order, so moved
#$%            to unit ok section.  Also added "ALL" option
#$%            to tests.
#$%            Canceled message is not displayed if the
#$%            unit's view is not legal.
#$%            Canceled orders are marked for deletion
#$%            as processed rather than saving them in an
#$%            array for later deletion.
#$%            CANCEL ATTACH or CANCEL ALL causes attached
#$%            aircraft to detach.
#$%            Two counters displayed for orders in ord
#$%            table and unt flags, for expanded message
#$%            regarding number of orders canceled.
#$%            Do not delete current order.
#$%            Flags are not cleared unless appropriate
#$%            for the unit type.
#$%
#$%            Susan Miller - 7/98 (E1983)
#$%            When this routine is called via bingo or
#$%            clear_maneuver_all... the hasbarrier flag 
#$%            gets set to $no but the barrier still lives.
#$%            Instead, if barrier is passive or active,
#$%            send a will die if not handed-over msg
#$%            and leave hasbarrier flag set to $yes.
#$%
#$%
#$%            John McCormick - 12/98 (E2047)
#$%            Call to clear_maneuver_all from this 
#$%            subroutine commented out to prevent
#$%            recursive call under launch order condition.
#$%            Previous code not necessary but problematic.
#$%
#$%            Susan Miller - 4/99 (E1969)
#$%            Removed resetting of rulesofengagement.
#$%            Added clearing of new variable UNT$TakeUsingSAM$I
#$%
#$%            John McCormick - 7/99 (e2081) 
#$%            Prevented deletion of launches due to 
#$%            maneuver type order while pre-launch
#$%
#$%            John McCormick - 1/00 (e2176)
#$%            Allow cancellation of launches and associated plans.
#$%
########################################################
BBcommon

literal iaddr,args[$max$args],kadd, event_name, 
        ORD$w01$C,ORD$w02$C,CSTRIP8,                 # jb  E2145 5/24/00
        ORD$w03$C,ORD$w04$C,
        atoid, xatoid,
        unt2$ForceName$c
integer nord,iview,nargs,idrop, id,iminut,newunt,  # jb  E2145 5/24/00
        jcnt,mlen,icnt,indx,idlast,        # jb  E2145 5/24/00
        UNT$Pointer,UNT$Status$I,UNT$GuideIndx$I,UNT$AttackIndx$I,
        UNT$PimIndx$I,UNT$ASWindx$I,UNT$AssignedTarget$I, # jb E2145 5/24/00
        UNT2$Pointer,UNT2$Status$I,UNT2$MarshallStatus$I, # jb E2145 5/24/00
        UNT2$SuperType$I, UNT2$Type$I,                    # jb E2145 5/24/00   
        ORD$Pointer,ORD$ID$I,ORD$Count$I,ORD$Sequence$I,ORD$Code$I,
        ORD$Start$I, PIM$Pointer, ASW$Pointer, BOY$Pointer,
        BAR$Pointer,ISNUMBER, v_len,                      # jb  E2145 5/24/00
        icount, iseq, isave_ord, ord$NbrArgs$i

integer dummy1,dummy2
logical maneuver_order 
Integer litcmp          # joa E2210

           #          1         2         3         4         5        6
           # 12345678901234567890123456789012345678901234567890123456790123456789
integer BOY$Type$I          # SMM 7/98 (E1983)
integer warning_sent        # SMM 7/98 (E1983)
VMSchar vmsg*(ARB)
BBdeclare   (unt$name$c)

integer order_count,prev_count,prev_order  # JHM 4/99 (E2081)
integer inplan

order_count = 0               
prev_count = 0
prev_order = 0                             # JHM 4/99 (E2081)

mlen = 71
icnt = 0
jcnt = 0

if      (iaddr == 'ZIP') kadd = 0
else if (iaddr == 'ALL') kadd = -1
else                       kadd = iaddr

UNT$Name$C = iaddr

#$% initialize flags
idlast = id
iminut = order$minute
inplan = $NO

#$% Do not cancel current order/plan
call fndord (id,ord$pointer)
if (ord$pointer != 0)                               # if current order
   {
    ord$sequence$i = Xord$sequence$i
    ord$Count$i = Xord$Count$i

    if (ord$Count$i > 1) inplan = $YES

    if (ord$sequence$i != ord$count$i)              # determine current
        idlast = id + ord$count$i - ord$sequence$i  # plan size

    #$% get starting minute
    iminut = Xord$Start$i
   }

#$% for each order entry
for (ord$pointer$first; Still_OK (ord) ; ord$pointer$next)
{
    idrop = $no

    if (Kadd != xord$Addressee$c & Kadd != -1) next

    if (Xord$Status$i == $BeingDeleted$code)   next

    #$% if not executable, get next entry
    if (xord$status$i != $Executable$code) next

    ord$id$i = xord$id$i

    if (ord$id$i >= id & ord$id$i <= idlast) next       # save current plan
    if (ord$id$i > id) break  # only address previous orders... (lower id) DEW

    ord$NbrArgs$i  = Xord$NbrArgs$i
    ord$count$i    = Xord$count$i
    ord$sequence$i = xord$sequence$i
    ord$Code$i     = Xord$Code$i
    ord$w01$c      = Xord$w01$c
    ord$w02$c      = Xord$w02$c
    ord$w03$c      = Xord$w03$c
    ord$w04$c      = Xord$w04$c

    if (nord != CANCEL$order)            # Cancel order cancels current and pending
    {
                                        # e2081 code moved under != cancel block  JHM 1/00 (e2176)
        if(ord$code$i == Launch$Order | # start of JHM 4/99 (E2081)
           ord$code$i == LaunchC$Order)
        {                             # prevent deletion of launches due to 
            order_count = xOrd$Count$i   # maneuver type order while pre-launch      
            if (order_count > xOrd$Sequence$i) # set only if a launch plan
            {
              prev_order = Launch$Order
              prev_count = 1
            }
            next                            # skip
        } # end code = Launch$Order

         if (prev_order == Launch$Order)    #check for flight plan
         {
            ord$sequence$i = xOrd$Sequence$i
            if ((order_count != ord$sequence$i) & (prev_count < ord$sequence$i)) # jhm 4/99 check sequence to total, and increasing
            {
             prev_count = ord$sequence$i  # store new sequence number
             next                         # skip 
            }
            else     
            {
             prev_count = 0           # reinitialize
             order_count = 0
             prev_order = 0
             next
            }
        } #end of prev_order == Launch, end of JHM 4/99 (E2081)

        if (!maneuver_order(ord$code$i)) # Maneuver orders override all pending
        {                                #  maneuver orders
            if (ord$count$i == 1)        # Cancel all maneuver plans
            {
                #$% get order start
                ord$Start$i = Xord$Start$i
                if (ord$Start$i > iminut) next

                #$% get order code
                if (ord$Start$i == iminut & ord$id$i > id) next             # 18MAR82
            }
        }
    } # not cancel order

    if (args[2] == $lex$ALL$)
    {
        idrop = $yes
		if (ord$Code$i == Scramble$order | ord$Code$i == Launch$order)
		{
			ATOid = 0
        	if (ord$NbrArgs$i >= 7)
            	if (xord$w06$c == $lex$ATOID$) ATOid = xord$w07$c

        	if (ord$NbrArgs$i >= 9)
            	if (xord$w08$c == $lex$ATOID$) ATOid = xord$w09$c
 			if (ATOid != 0)
			{
				idrop = $no
                v_len = 0
                call vmovv ("ATO missions not canceled.  Cancel individually.",vmsg,v_len)
                call send_v(iview,vmsg[1:v_len]) 
			}
		}
    }
    else if (args[2] == $lex$SEARCH$)
    {
        #$% if code is text, message, commtext, launch or
        #$% load order, get next
        if (ord$Code$i == Text$order        |
            ord$Code$i == Message$order     |
            ord$Code$i == Commtext$order    |
            ord$Code$i == Launch$order      |
            ord$Code$i == LaunchC$order     |
            ord$Code$i == LaunchBoat$order  |
            ord$Code$i == Load$order         ) next

        if (ord$count$i == 1) next              # if count is one, get next

        idrop = $yes
    }
    else if (args[2] == ord$w01$c) idrop = $yes

    if (idrop == $no) next                      # if no drop, get next

    atoid = 0   # from ORD tbl of SCRAMBLE command          # dew 10/6/00
    xatoid = 0  # from body of cancel scramble command

    if (ord$w01$c == $lex$LAUNCH$  |            # if first word is launch
        ord$w01$c == $lex$SCRAMBLE$)            # (or scramble)
    {
        if (Xord$Unit$i != 0)
        {
            UNT2$Pointer$To Xord$Unit$i             # get unit order

            unt2$Status$i         = Xunt2$Status$i
            unt2$MarshallStatus$i = Xunt2$MarshallStatus$i 
    
            if (unt2$Status$i != $OnGuide$Code & 
                unt2$Status$i != $AwaitingLaunch$code) next

            unt2$SuperType$i      = Xunt2$SuperType$i              # DEW 5/1/90

            if (unt2$SuperType$i != $SmallBoat$SuperCode )         # DEW 5/1/90
            {
                if (unt2$MarshallStatus$i != $AwaitLaunch$code &
                    unt2$MarshallStatus$i != $Launching$code  )   next
            }

        } # ord$unit$i not zero                

        if (ord$w01$c == $lex$launch$)            # dew 10/6/00
        {
            if (ord$w02$c == $lex$boat$ )         # DEW 5/1/90
                event_name = xORD$w05$c
            else
                event_name = xORD$w04$c
        }
        if (ord$w01$c == $lex$scramble$)
            event_name = xORD$w05$c

        # ATO ID ?
        if (nargs >= 5)                     # JOA 6/04
            if (args[4] == $lex$atoid$) xATOid = args[5]

        if (ord$NbrArgs$i >= 7)
            if (xord$w06$c == $lex$ATOID$) ATOid = xord$w07$c

        if (ord$NbrArgs$i >= 9)
            if (xord$w08$c == $lex$ATOID$) ATOid = xord$w09$c
 
        if      (args[2] == $lex$all$) continue
        else if (args[3] == 'ALL'  ) continue
        else if (args[3] != event_name) next
        else if (xATOid  != ATOid     ) next        # dew 10/6/00

    } # end screening cancel launch 

    if (ord$w01$c == $lex$FIRE$)              # if fire cruise order
    {
        if (ord$w04$c == $lex$CRUISE$)
        {
            if (ord$NbrArgs$i >= 10)
            {
                event_name = xORD$w10$c
        
                if (args[2] == $lex$fire$   &
                    args[3] == $lex$cruise$ &
                    (args[4] == event_name | args[4] == 'ALL')) continue
                else
                    next
            }    
        } # end screening cancel fire cruise 
    }

    if (Xord$Start$i > iminut)                   # Pending order
    {
        if (ord$sequence$i == ord$count$i)      # Count plan, not orders in plan
            icnt = icnt + 1
    }
    else
        jcnt = jcnt + 1                         # Current order

    if (ord$w01$c == $lex$LAUNCH$  |            # if first word is launch
        ord$w01$c == $lex$SCRAMBLE$)
    {
        if (Xord$unit$i != 0)
        {
            if (Xunt2$SuperType$i == $SmallBoat$SuperCode )
                call boat_recover (Unt2$Pointer) # return boat to platform
            else 
                call fltrec (Unt2$Pointer) # return aircraft to platform

            if (ord$w01$c == $lex$SCRAMBLE$) 
            {
                putUNT2$Leader$i ($no)
                UNT2$ForceName$C = 0
                putUNT2$ForceName$C 
            }
        }
        PUTord$Status$i ($BeingDeleted$code)    # call to remove order
        # now... delete rest of launch plan
        iseq = xORD$Sequence$i
        icount = Xord$count$i

        isave_ord = ord$pointer
        for (ord$pointer$next; Still_OK (ord) ; ord$pointer$next)
        {
            if (iseq + 1 != xORD$Sequence$i |   # JOA E2318 Change & to |
                icount   != Xord$count$i     ) break

            isave_ord = ord$pointer
            PUTord$Status$i ($BeingDeleted$code)    # flag to remove order
            iseq = iseq + 1
            icnt = icnt + 1
        }

        ord$pointer = isave_ord

    }
 
    if (unt$pointer$ok)
    {
        if (ord$w01$c == $lex$TOW$)  #jb - if Cancelled order is TOW  5/31/89
        {
            UNT$Status$i     = xUNT$Status$i    # Info                         
            UNT$GuideIndx$i  = xUNT$GuideIndx$i   # about                      
            UNT$AttackIndx$i = xUNT$AttackIndx$i    # the TUG-ging vessel
            unt2$pointer$TO (UNT$GuideIndx$I) # Point to BOAT UNDER TOW
    
                #$% Is UNT already towing boat?  Is boat's pointer inbounds?
            if( UNT$Status$i == $TOWING$Code  &  unt2$pointer$ok &  
                Xunt2$SuperType$i == $SmallBoat$SuperCode ) # Is boat flagged?
            {
              putUNT2$Status$i    ($Proceeding$Code)
              putUNT2$GuideIndx$i    ($NO)
              putUNT2$orderedSPEED$F (0.0)
              putUNT2$AttackIndx$i   ($NO)
              putUNT2$LastManeuverOrderCode$i (NO$order)
            }
            else if(unt2$pointer$OK & Xunt2$GuideIndx$i == UNT$Pointer$Index &
                Xunt2$SuperType$i == $SmallBoat$SuperCode ) # Is boat flagged?
            {
              putUNT2$GuideIndx$i    ($NO)
            }
            
            putUNT$orderedSPEED$F (0.0)
            putUNT$GuideIndx$i    ($NO)
            putUNT$AttackIndx$i   ($NO)
            putUNT2$LastManeuverOrderCode$i (NO$order)
            if(UNT$Status$i != $Sinking$Code &    #    jb \/        \/ 8/18/89
              unt$status$i !=$DeadInWater$Code & unt$status$i !=$UnderTow$Code)
                    putUNT$Status$i ($Proceeding$Code)
        } # End if Canceled order is TOW..        jb  5/31/89
    
        if (ord$w01$c == $lex$BARRIER$)     # if order is BARRIER   9/22/87
        {
            UNT$PIMindx$i = xUNT$PIMindx$i  # jb                    9/23/87
            if(UNT$PIMindx$i != $NO)        # jb                    9/22/87
            {                              
              PIM$Pointer$TO (UNT$PIMindx$i) # jb                   9/22/87
              if(PIM$Pointer$VALID) PIM$ZERO # jb                   9/22/87
              putUNT$PIMindx$i ($NO)         # jb                   9/22/87
              putUNT$LastManeuverOrderCode$i (NO$order)
            }
        }

        if (ord$w01$c == $lex$PERFORM$)     # if order is PERFORM   6/21/90
        {
            UNT$ASWindx$i = xUNT$ASWindx$i  # jb                    6/21/90
            if(UNT$ASWindx$i != $NO)        # jb                    6/21/90
            {                              
              ASW$Pointer$TO (UNT$ASWindx$i) # jb                   6/21/90
              if(ASW$Pointer$VALID) ASW$ZERO # jb                   6/21/90
              putUNT$ASWindx$i ($NO)         # jb                   6/21/90
              putUNT$LastManeuverOrderCode$i (NO$order)
            }
        }
    
        else if (ord$w01$c == $lex$LAND$ | ord$w01$c == $lex$WITHDRAW$)
        {
            if (Xunt$Mission$i == $AMPHIB$code)
            {
              putUNT$Mission$I ($NoneAssigned$Code)
              putUNT$OrderedLatitude$F  ($pi)
              putUNT$OrderedLongitude$F (0.0)
              PUTUNT$MotionFlags$I (0)                # clear any route/ALZ being used
              putUNT$LastManeuverOrderCode$i (NO$order)
            }
        }
    } # end unt$pointer$ok

    PUTord$Status$i ($BeingDeleted$code)    # call to remove order
}    # END FOR (ORD$pointer$first...

if (unt$pointer$ok)                             # if unit pointer OK
   {
    if (maneuver_order (nord))              # Any maneuver order overrides
    {                                       # automatic reaction to attack
        PUTunt$ReactFlag$i ($NO)

        unt$status$i = Xunt$Status$i
        if(UNT$Status$I !=$Sinking$Code & UNT$Status$I != $UnderTow$Code &
           UNT$Status$I !=$DeadinWater$Code)
            putUNT$STATUS$I ($PROCEEDING$CODE)
        if (inplan == $NO)                       # Not Within plan
        {
            PUTunt$RTEIndx$i (0)
        }
    }

    unt$name$c = xunt$name$c                    # save name

    if (args[2] == $lex$TAKE$ |    # set ROE if attacked
        args[2] == $lex$ATTACK$ | args[2] == $lex$ALL$) # SMM 3/93 added cancel attack
       {                        # clk 3/92 added cancel pair
       if (xUNT$AssignedTarget$I != 0) # if not assigned a target, unit
          {                             # is not taking or paired    clk 4/92
           if (xUNT$UseGuns$I != $no)   # clk 1/93
             {
              UNT$AssignedTarget$I = xUNT$AssignedTarget$I  # get the assigned TAKE target
              UNT$AttackIndx$I = xUNT$AttackIndx$I          # get the target attack index
              call deassign_guns (UNT$Pointer, UNT$AssignedTarget$I, $Take$Guncode, $Fired$Guncode)
              if (UNT$AssignedTarget$I != UNT$AttackIndx$I)
                call deassign_guns (UNT$Pointer, UNT$AttackIndx$I, $Take$Guncode, $Fired$Guncode)
             }

           call Clear_BTT_Info (UNT$Pointer)   # clk 7/95 (E1419)
           putUNT$LastManeuverOrderCode$i (NO$order)

# SMM 4/99 (E1969) don't change ROE on a take  PUTunt$RulesOfEngage$i  ($IfAttacked$code) 
           PUTunt$AssignedTarget$i (0)             # cleGame$Timear assigned target 
           putUNT$TestIntercept$I ($NO)            # SMM 7/97 (E1385)
           PUTunt$AttackIndx$i     (0)             # clear attack index and save
           PUTunt$coverflag$i      (0) # clear cover flag <<<RG>>>> 9/18/85
           if (args[2] == $lex$ATTACK$)
             {
              putUNT$MultipleTarget$I (0)    # SMM 3/93 - reset flags
              putUNT$AttackedTarget$I (0)    
             }
           if (xUNT$AssignedCap$I != $no)  # if the aircraft is assigned to CAP
             { # return to CAP station  SMM 5/93
              call Proc_CAP(UNT$Pointer,dummy1,dummy2)
             }
           if (xUNT$TakeUsingSAM$I == $YES)
              {
               putUNT$TakeUsingSam$I ($NO)      # SMM 4/99 (E1969)
              }
           jcnt = jcnt + 1                      # increment counter
          }
       }

    if (args[2] == $lex$ATTACH$ | args[2] == $lex$ALL$) # joa 12/97 (E1370)
       {
        # Cancel attach
        if (litcmp(Xunt$ForceName$c,  0) == 0 & Xunt$Leader$i == $NO)
            {
            call xdetac(unt$pointer, # I  to-be-detached, detach unit from collective 
                        newunt)      # I  leader-assigned# group
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                     # increment counter
            }
       }

    if (args[2] == $lex$COVER$ | args[2] == $lex$ALL$) ###<<<RG>>>>  9/18/85
       {
        if (Xunt$CoverFlag$i != 0)
            {
            PUTunt$AssignedTarget$i (0)             # clear assigned target 
            PUTunt$AttackIndx$i     (0)             # clear attack index
            PUTunt$coverflag$i      (0)             # clear cover flag.
            putUNT$TestIntercept$I ($NO)            # SMM 7/97 (E1385)
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                         # increment counter
            }
       }

    if (args[2] == $lex$UNREP$ |          # joa 3/96 (E1467)
        args[2] == $lex$FUEL$  |          # cancel unrep or
        args[2] == $lex$ALL$)             # cancel fuel
      {
        if(xUNT$Status$i == $ReturningToBase$Code |
           Xunt$status$i == $InPort$code)
            {
            PutUNT$Status$i    ($Proceeding$Code)
            putUNT$GuideIndx$I ($NO)                # delete guide
            putUNT$TimePortArrival$F (0.0)
            }
       putUNT$LastManeuverOrderCode$i (NO$order)
       if (xUNT$HosesAllocatedFlag$I == $YES)
         {
          UNT2$Pointer$To (xUNT$GuideIndx$I)
          UNT2$Type$I = xUNT2$Type$I             # Set sGame$Timetatus
          if (UNT2$Type$I == $ShoreBase$Code)    # based on
             putUNT$Status$I ($InPort$Code)      # supplier type
          else if (UNT2$Type$I == $Surface$Code |
                   UNT2$Type$I == $SurfaceWithAC$Code)
             putUNT$Status$i ($Proceeding$Code)

          call free_fuel_transfer_equip (UNT$Pointer)
          jcnt = jcnt + 1                     # increment counter
         }   # end of if refueling hoses are allocated
      }   # end of if cancel unrep or cancel fuel

    if (args[2] == $lex$bingo$ | args[2] == $lex$ALL$)     # Cancel BINGO
       {
        if (Xunt$status$i == $ReturningToBase$code)
            {
            jcnt = jcnt + 1                         # increment counter
            }
        PUTunt$Status$i ($Proceeding$code)      #       10/24/85    
        if (XUNT$TYPE$I == $AIR$CODE &          # JOA UFL02 - Don't cancel launch
           Xunt$MarshallStatus$i == $Recovering$Code)
              PUTunt$MarshallStatus$i ($inflight$code)
        putUNT$MarshallWarning$I ($no)          # SMM 5/97 (E1633)
        putUNT$LastManeuverOrderCode$i (NO$order)

        PUTunt$GuideIndx$i   ($NO)              #       10/24/85
        PUTunt$guiderange$f  (0.)               #       10/24/85
        PUTunt$AssignedTarget$i (0)             # Remove target assignment
        PUTunt$AttackIndx$i     (0)             # Remove attack/refuel intercept
        PUTunt$ALZindx$i     (0)
        PUTunt$PLNIndex$i    (0)
        PUTunt$RangeToNext$f (20000.)           #       10/24/85
        putUNT$UseOrdSpeed$I ($no)              # clk 3/23/94
        PUTunt$OrderedLatitude$f($pi)           # Remove ordered position
        PUTunt$TailChaseOverride$i ($No)
        PUTunt$LaunchOrdId$i    (0)             # 

        if (Xunt$HasBarrier$i != $NO)
        {
# SMM 7/98 (E1983) don't clear hasbarrier flag 
#            PUTunt$HasBarrier$i ($NO)
            warning_sent = $no # SMM 6/98 (E1983)
            indx = UNT$Pointer$Index
            for (boy$pointer$first; boy$pointer$ok; boy$pointer$next)
            {
                if (xBOY$OwnerIndx$i     != indx |
                    xBOY$KillTime$F <=Game$Time ) NEXT 

                BOY$Type$I = xBOY$Type$I    # SMM 6/98 (E1983)
                # if act. or pass. send a handover or die msg SMM 6/98 (E1983)
                if (warning_sent == $no &           # only send warning once
                    args[2] != $lex$bingo$ &  # don't send warning if cancel bingo order
                    (BOY$Type$I == $ActiveBarrier$Code |
                     BOY$Type$I == $PassiveBarrier$Code))
                  {
                   v_len = 0
                   call vmovhn(xUNT$Name$C,$$MaxLit,vmsg,v_len)
                   call vmovv (" must handover barriers or ",vmsg,v_len)
                   call vmovv (" lose them.",vmsg,v_len)
                   call send_v(iview,vmsg[1:v_len]) 
                   warning_sent = $yes
                  }

                if (BOY$Type$i !=$CHAFF$code) NEXT    # jb vice RBOC 2/4/91

                putBOY$KillTime$F (Game$Time)
                BAR$Pointer$TO    (BOY$Pointer$Index)
                putBAR$FALLING$i  ($YES)
                BREAK
            }
        }
       }        # End if cancel BINGO..

    if (args[2] == $lex$MOOR$ | args[2] == $lex$ALL$)     # joa 12/97 (E1370)
       {
        if(xUNT$Status$i == $ReturningToBase$Code |
           Xunt$status$i == $InPort$code)
            {
            PutUNT$Status$i    ($Proceeding$Code)
            PutUNT$GuideIndx$i ($NO)
            PutUNT$OrderedSpeed$F (0.0)
            putUNT$TimePortArrival$F (0.0)
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                     # increment counter
            }
       }

    if (args[2] == $lex$RECONN$ | args[2] == $lex$ALL$)
       {
        if (Xunt$Mission$i == $RECONN$CODE)
            {
            # the mission assigned to the unit will remain RECONN
            putUNT$Status$I ($PROCEEDING$CODE)
            putUNT$AttackIndx$I ($NO)
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                     # increment counter
            }
       }

    if (args[2] == $lex$RECOVER$ | args[2] == $lex$ALL$) # jb 11/3/86
       {
        if (Xunt$RecoverOrd$i != $NO)
            {
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                     # increment counter
            }
        PUTunt$RecoverOrd$i ($NO) # clr flag for FltOps Lvl 3 11/3/86
        putUNT$Status$I ($Proceeding$Code)      # SMM 5/97 (E1633)
       }

    if (args[2] == $lex$PROCEED$ | args[2] == $lex$ALL$)  # SMM 11/25/92
       {
        if (Xunt$OrderedLatitude$f != $PI)
            {
            PUTunt$OrderedLatitude$f ($pi)
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                     # increment counter
            }
       }

    if (args[2] == $lex$ORBIT$ | args[2] == $lex$ALL$)    # SMM 1/25/93
       {
        UNT$PIMindx$i = xUNT$PIMindx$i  # get the PIM table index
        if(UNT$PIMindx$i != $NO)
         {                              
          PIM$Pointer$TO (UNT$PIMindx$i) # point to it 
          if(PIM$Pointer$VALID) PIM$ZERO # if it is a valid pointer
          putUNT$PIMindx$i ($NO)         # zero out indx into PIM table
          putPIM$Modified$I ($yes)       # since the PIM$Zero clears the modified flag
          putUNT$LastManeuverOrderCode$i (NO$order)
          jcnt = jcnt + 1                   # increment counter
         }
       }

    if (args[2] == $lex$STATION$ | args[2] == $lex$ALL$)  # SMM 11/27/92
       {
        if (Xunt$GuideIndx$i != $NO)
            {
            putUNT$GuideIndx$I ($NO)                # delete guide
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                         # increment counter
            }
       }

    if (args[2] == $lex$CAP$ | args[2] == $lex$ALL$)   # clk 4/92
      { # cancel CAP assignment:  FOR xxxxx CANCEL [ CAP | ALL ]
       if (xUNT$AssignedCap$I != $no)  # if the aircraft is assigned to CAP
         {
          putUNT$AssignedCap$I  ($no)  # zero out the CAP associated fields
          putUNT$CapAltitude$I  ($no)
          putUNT$CapRange$I     ($no)
          putUNT$CapLatitude$F  ($no)
          putUNT$CapLongitude$F ($no)
          putUNT$Status$I       ($Proceeding$Code)

          putUNT$MultipleTarget$I (0)    # SMM 6/6/94 - reset flags
          putUNT$AttackedTarget$I (0)    
          putUNT$LastManeuverOrderCode$i (NO$order)
          jcnt = jcnt + 1                   # increment counter
         }
      }

    if (args[2] == $lex$HIDE$ | args[2] == $lex$ALL$)
      {
       if (Xunt$HideStatus$i != $NoHideStatus)
            {
            putUNT$LastManeuverOrderCode$i (NO$order)
            jcnt = jcnt + 1                     # increment counter
            }
       putUnt$HideStatus$I ($NoHideStatus)      # cancel hiding
       putUnt$HideSiteIndx$I (0)                # reset the Hide Site index
      }

    if (args[2] == $lex$STRIKE$ | args[2] == $lex$ALL$)
      {                                 # clk 4/95 (E1355) 
       putUNT$DroppingMineFlag$I ($no)  # clk 2/97 (E1731)
                                        # cancel DROP MINE
       if (xUNT$AssignedTarget$I == UNT$Engaging$Position)
         {
          call Clear_BTT_Info (UNT$Pointer)   # clk 7/95 (E1419)
          putUNT$OrderedLatitude$F  ($pi)
          putUNT$OrderedLongitude$F (0.0)
          putUNT$AssignedTarget$I   (0)
          putUNT$TestIntercept$I    ($NO)     # SMM 7/97 (E1385)
          putUNT$TargetType$I       (0)
          putUNT$AGDIndex$I         (0)
          putUNT$LastManeuverOrderCode$i (NO$order)
          jcnt = jcnt + 1                       # increment counter
         }   # end of if unit is engaging a posit
      }   # end of if CANCEL [ALL | STRIKE]

    if (args[2] == $lex$REFUEL$ | args[2] == $lex$ALL$)  # SMM 10/95 (E1453)
      {                                 
       if (XUNT$Status$I == $ACREFUEL$CODE)
        {
         putUNT$Status$I ($PROCEEDING$CODE)
         putUNT$AttackIndx$I ($NO)
         putUNT$RefuelAmount$I (0)
         putUNT$ALSPRefuelStatus$I (0)
         putUNT$LastManeuverOrderCode$i (NO$order)

         jcnt = jcnt + 1                     # increment counter
        }
      }

    if (args[2] == $lex$ALL$)  
    {
       putUNT$LastManeuverOrderCode$i (NO$order)
       putUNT$MarshallWarning$I ($no)          # SMM 5/97 (E1633)
       if (iview != -1) putUNT$RTEIndx$I (0)   # tmb 8/18/17
    }

   }   # end of if unit pointer is valid

if (iview != -1)                                # joa - 12/97 (E1370)
    {
    v_len = 0
    if ($isnumeric(UNT$Name$C))  call vmoviz (int(UNT$Name$C),4,vmsg,v_len)
    else                         call vmovhn (UNT$Name$C,$$MaxLit,vmsg,v_len)

    call vmovv (" ",vmsg,v_len)
    Call vmovi (icnt,vmsg,v_len)                    # Orders canceled - joa 12/97 (E1370)
    call vmovv (" pending orders canceled.  ",vmsg,v_len)
    Call vmovi (jcnt,vmsg,v_len)                    # Orders cleared 
    call vmovv (" current orders cleared.",vmsg,v_len)
    
    call send_v (iview,vmsg[1:v_len])           # 'orders were canceled'
    }

return
end        # End OCANCL  msg




subroutine odefin(nord,  # I                      # define values 
                  iview, # I                      # given view
                  nargs, # I                      # number of arguments
                  args)  # L                      # array of arguments

########################################################
#$%
#$% Purpose:   ODEFIN defines values for each
#$%            view from define command.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     XDEFIN
#$%
#$% Tables:    None
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

literal args[$order$array$size],ilex[30]
integer nord,iview,nargs,
        i, istat, ilen      # jb E2145  5/24/00

call xdefin (nargs,args,istat)

if (istat != $no)
   {
    ilex[1] = 0
    ilex[2] = 0
    ilex[3] = nord
    for (i=1; i <= nargs; i=i+1) ilex[i+3] = args[i]

    ilen = nargs+4
    ilex[ilen] = %4H****

    if (istat == $yes)
       {
        ilen = ilen + 1; ilex[ilen] = 'BAD'
        ilen = ilen + 1; ilex[ilen] = 'VALUE'
       }
    else # if (istat == $yes + $yes)
       {
        ilen = ilen + 1; ilex[ilen] = $lex$unknown$
        ilen = ilen + 1; ilex[ilen] = 'CMD'
       }

    #$% call to send rejection message
    call send_lex (iview,ilen,ilex)
   }

return
end

define($no$vue,)
define($no$wet,)
define($no$unt,)

include "wixdefin.rin"         
include "wixprint.rin"         



subroutine ocopy (nord,   # I                     # copy messages 
                  iview,  # I                     # given view
                  nargs,  # I                     # number of arguments
                  args)   # L                     # array of arguments

########################################################
#$%
#$% Purpose:   OCOPY processes copy command to flag
#$%            CONTROL for a copy of blue or orange
#$%            messages.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND       IPBYTE
#$%
#$% Tables:    VUE
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon
StationMsgCommon

literal args[$order$array$size]
integer nord,iview,nargs, k, loop,  # jb E2145  5/24/00
        VUE$Pointer, VUE$Copy$I     # jb E2145  5/24/00
BBDeclare (sta$pointer)

character msg[ARB]
integer klen

String msgb "Cannot copy BLUE X"
String msgo "Cannot copy ORANGE X"

$DEBUGT call echov ("<ocopy:")

sta$pointer$to StationMsgIndx

if (args[2] == $lex$All$)                       # COPY ALL
   {
    PUTsta$copy$i ($yes)            # Make copy control station oriented

#    #$% for each drop entry
#    for (loop = $firstblue$view;loop <= $last$view; loop = loop+1)
#       {
#        #$% set VUE pointer and store
#        vue$pointer$to loop
#        vue$copy$i = $yes
#        putvue$copy$i
#       }

   }
else if (args[2] == $lex$off$)                  # COPY OFF
   {
    PUTsta$copy$i ($no)
#    #$% for each entry
#    for (loop = $first$view;loop <= $last$view; loop = loop+1)
#       {
#        #$% set VUE pointer, set copy to NO and store
#        vue$pointer$to loop
#        vue$copy$i = $no
#        putvue$copy$i
#       }
   }
else
   {
     klen = 0
     Call SMOVV("COPY BLUE and COPY ORANGE orders disabled.",msg,klen)
     call send_ (iview,0,klen,msg)        # 
#    if (args[2] == $lex$blue$)                  # COPY BLUE n
#       {
#        k = args[3] + $firstblue$view - 1
#        call ipbyte (msgb,18,args[3]+$dig0)
#        if (k > $lastblue$view)
#           {
#            #$% call to display rejection message
#            call send_ (iview,0,18,msgb)
#           }
#        else
#           {
#            #$% set copy to YES and store
#            vue$pointer$to k
#            vue$copy$i = $yes
#            putvue$copy$i
#           }
#       }
#    else                                        # COPY ORANGE n
#       {
#        k = args[3] + $firstorange$view - 1
#        call ipbyte (msgo,20,args[3]+$dig0)
#        if (k > $lastorange$view)
#           {
#            #$% call to display rejection message
#            call send_ (iview,0,20,msgo)
#           }
#        else
#           {
#            #$% set copy to YES and store
#            vue$pointer$to k
#            vue$copy$i = $yes
#            putvue$copy$i
#           }
#       }
#
   }

$DEBUGT call echo ($GREAT)

return
end


subroutine getord_station (sta$pointer,ilen,iinp)       # get orders from STA 

########################################################
#$%
#$% Purpose:   GETORD_STATION gets orders from STATION 
#$%            input queue.
#$%
#$% Called By: WGORDP
#$%
#$% Calls:     ECHOH      ECHOI      ECHOR
#$%
#$% Tables:    VUE
#$%
#$% Date:      FEB 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
 BBcommon          # I    I    L        # return ilen = 0 if no input

 literal iinp[$order$array$size-1],  CSTRIP8      # jb E2145  5/24/00       
 REAL*4  rval                                     # jb E2145  5/24/00
 Integer i,k,ilen,iview, ISNUMBER,                # jb E2145  5/24/00
         STA$Pointer,STA$InpRead$I,STA$InpWrite$I, # jb E2145  5/24/00
         STA$INP$index                            # jb E2145  5/24/00
 EXTERNAL  ISNUMBER                               # jb E2145  5/24/00

 for (i=1; i<=$order$array$size-1; i=i+1) iinp[i] = 0    

 ilen = 0

 #$% get input read and input write
 STA$inpread$i  = xSTA$inpread$i
 STA$inpwrite$i = xSTA$inpwrite$i

 #$% if input read is write, return
 if (STA$inpread$i == STA$inpwrite$i) return

 #$% set input index
 STA$inp$index = STA$inpread$i

 #$% set length
 ilen = xSTA$inp$word$C

 $DEBUGT call echov ("<GETORD:v=")
 $DEBUGT call echoi (iview)
 $DEBUGT call echo ($colon)
 $DEBUGT call echoi (ilen)

 if (ilen < 6 | ilen > $order$array$size-1)           # test for invalid info in queue 
    {
     STA$inpread$i = STA$inpwrite$i  # set read index to write index
     putSTA$inpread$i                # store it
     ilen = 0

     call echov ("ERROR-- Order Length Invalid. Clearing Queue! View=")
     call echoi (iview)
     call echor
     return                          # exit
    }

 for(i=1; i<=ilen; i=i+1)            # loop for the given length
   {
    iinp[i] = xSTA$inp$word$C        # get the text of the message

    STA$inp$index = STA$inp$index + 1
    if(STA$inp$index > STA$inp$slots) STA$inp$index = 1
   }

 #$% set input read to index and store it
 STA$inpread$i = STA$inp$index
 putSTA$inpread$i

if (trace$wgordp$get != NO)
    {
    call echor
    call echov ("GETORD_Station, STA=")
    call echoi (sta$pointer$index)
    call echov (", nargs=")
    call echoi (ilen)
    call echov (", args=")

    for (k=1; k <= ilen; k=k+1)
        {
        if (k > 1) call echov (',')

        rval = iinp[k]
        if ($isnumeric(iinp[k])) call echof (rval,1)
        else                     call echohn (iinp[k],8)
        }
    }
#if (iinp[3] == ALLMISSION$order)       # jb <<<>>> recognition..
#    iinp[26] = ALLMISSION$order        # 4/8/87; deactivate 4/21/87

return
end



#$% directs action based on the "deploy" command
subroutine odeploy(nord,id,upnt,nargs,args)
BBCommon

literal     args [ $order$array$size ]
integer*4   nord,id,upnt,nargs

if ( args [ 2 ] == $Lex$CounterMeasure$ )
    {
    call Deploy_CtrMeasure (nord,id,upnt,nargs,args)
    }
else
    {
    call osubcs(nord,upnt,nargs,args)
    }
return
end

subroutine oreport_c2
##############################################################################
#$%
#$% Purpose:   OReport_C2 processes the REPORT HISTORY DATA command, calling
#$%            the routines which create the WPC C2 Simulated MissRep System
#$%            data files.
#$%
#$% Called By: Exeord
#$%            WarCyc
#$%
#$% Calls:     Report_C2_Air_Destroyed
#$%            Report_C2_Air_Ground_Data
#$%            Report_C2_Flight_Hist_Data
#$%
#$% Tables:    None
#$%
#$% Date:      Oct. 1994
#$%
#$% Author:    Carol L. Kropp
#$%
##############################################################################
BBCommon

##Integer ReportC2Data        # jb E2145  5/24/00

#  call Report_C2_Air_Destroyed
#  call Report_C2_Air_Ground_Data
  call Report_C2_Flight_Hist_Data

  ReportC2Data = $no        # reset flag

return
end


subroutine oclear (nargs, args)
##############################################################################
#$%
#$% Purpose:   OClear processes the CLEAR ... commands
#$%            Initially, there is only the CLEAR DAMAGE (entry for unit)...
#$%
#$% Called By: Exeord
#$%
#$% Calls:     smov..            <lbsmov.rat>
#$%            send
#$%            convert_to_gm     <lbtime.rat>
#$%            clear_BDA_entry
#$%
#$% Tables:    DAM     NAM     UNT
#$%
#$% Date:      Nov. 1994
#$%
#$% Author:    Carol L. Kropp
#$%
#$% Modified:  Susan Miller 4/96 (E1581)
#$%            Added clearing of BDA info (argument 5 of the command).
#$%
##############################################################################
BBCommon

literal  args[20],  CSTRIP8     # jb E2145  5/24/00
integer  nargs, litcmp

# args[1] = $lex$Clear$
# args[2] = $lex$Damage$
# args[3] = literal name
# args[4] = integer zulu time | $lex$All$
# args[5] = $lex$Yes$ | $lex$No$               # SMM 4/96 (E1581) clear BDA info

integer  msg_len
Character msg[ARB]

literal  unit_name
real  game_minute
integer  NAM$Pointer, nam_table_index
integer  DAM$Pointer, DAM$NameIndx$I
real     DAM$Time$F
integer  nbr_cleared
integer  BDA_minute

  if (args[2] == $lex$Damage$)   # if the CLEAR DAMAGE (entry) command
    {
     msg_len = 0
     unit_name = args[3]

     # locate the unit name in the NAM table
     nam_table_index = 0
     for (NAM$Pointer$First; NAM$Pointer$Valid; NAM$Pointer$Next)
       {
        if (litcmp(xNAM$Name$C, unit_name)== 0)  # if the unit name located
          {
           nam_table_index = NAM$Pointer$Index
           break
          }
       }

     if (nam_table_index > 0)   # if the name was found
       {
        nbr_cleared = 0
        if (args[4] == $lex$All$)
          {
           for (DAM$Pointer$First; DAM$Pointer$Valid; DAM$Pointer$Next)
             {
              DAM$NameIndx$I = xDAM$NameIndx$I
              if (DAM$NameIndx$I == nam_table_index)
                {
                 DAM$Zero
                 nbr_cleared = nbr_cleared + 1
                }   # end of if name index matches
             }   # end of loop through the DAM table
          }
        else   # clear a specific time entry
          {
           call Convert_to_gm (INT(args[4]), game_minute)
           for (DAM$Pointer$First; DAM$Pointer$Valid; DAM$Pointer$Next)
             {
              DAM$NameIndx$I = xDAM$NameIndx$I
              if (DAM$NameIndx$I == nam_table_index)
                {
                 DAM$Time$F = xDAM$Time$F
                 if (DAM$Time$F == game_minute)
                   {
                    DAM$Zero
                    nbr_cleared = nbr_cleared + 1
                   }   # end of if time matches
                }   # end of if name index matches
             }   # end of loop through the DAM table
          }   # end of if clear ALL, else specific time

        if (nbr_cleared == 0)
          {
           call smovv  ("Cannot clear DAMAGE entries for ", msg, msg_len)
           call smovhn (unit_name, $$MaxLit, msg, msg_len)
           call smovv  (" - no entries located.", msg, msg_len)
          }
        else
          {
           call smovi  (nbr_cleared, msg, msg_len)
           if (nbr_cleared == 1)
             call smovv  (" DAMAGE entry for ", msg, msg_len)
           else
             call smovv  (" DAMAGE entries for ", msg, msg_len)
           call smovhn (unit_name, $$MaxLit, msg, msg_len)
           call smovv  (" cleared.", msg, msg_len)
          }
       }   # end of if name was located in the NAM table
     else
       {
        call smovv  ("Cannot clear DAMAGE entries for ", msg, msg_len)
        call smovhn (unit_name, $$MaxLit, msg, msg_len)
        call smovv  (" - name not located.", msg, msg_len)
       }

     call send_   ($Neutral$View, 0, msg_len, msg)

     if (args[5] == $lex$Yes$)   # if BDA entries are to be cleared
       {
        if (args[4] == $lex$All$)   # if all entries
          BDA_minute = 0
        else                        # only entries at a specific time
         {
          call Convert_to_gm (INT(args[4]), game_minute)
          BDA_minute = game_minute
         }         
         call clear_BDA_entry (unit_name,BDA_minute)
       }   # end of if BDA entries are to be cleared
    }   # end of if CLEAR DAMAGE (entry) command

return
end


subroutine clear_BDA_entry (target_name, minute_destroyed)
##############################################################################
#$%
#$% Purpose:   To clear the associated BDA information.
#$%
#$% Called By: OClear
#$%
#$% Calls:     smov..            <lbsmov.rat>
#$%            send
#$%
#$% Tables:    DAC  DSS
#$%
#$% Date:      April 1996
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Carol Kropp - 11/96 (E1689)
#$%            Removed clearing the DAC slot and set the the resurrected
#$%            and c2reported flags.  Also removed using Remove_TBL_slot
#$%            which incorrectly move too many bytes (relocating BML
#$%            table data into the DSS area) and did not handle the
#$%            split nature of the DSS table. Blue uses DSS entries
#$%            1..(MaxDSSslots$Per$View-1) and Orange uses entries
#$%            MaxDSSslots$Per$View..DSS$Slots.
#$%
##############################################################################
BBCommon

literal  target_name,  CSTRIP8     # jb E2145  5/24/00
integer  minute_destroyed, litcmp

integer  number_found
integer  DAC$Pointer
integer  DSS3$Pointer   # outer loop control to locate unit entries
integer  DSS$Pointer    # loop control to move entries for filling
integer  DSS2$Pointer   # the space cleared
integer  last_dss_ptr

integer  msg_len
Character msg[ARB]

  number_found = 0

  # we don't know what the unit is so we need to loop through the
  # DAC (Air destroyed table) and the DSS (Damaged ships,subs,shore table)
  
  # loop through DAC table first
  for (DAC$Pointer$First;DAC$Pointer$Valid;DAC$Pointer$Next)
    {
     if (litcmp(xDAC$SideNumber$C, target_name) == 0)
       {
        if (((minute_destroyed != 0) & 
            (INT(xDAC$TimeDestroyed$F) == minute_destroyed)) |
            (minute_destroyed == 0))
          {
           number_found = number_found + 1

           putDAC$Resurrected$I  ($yes)    # if destruction was already
           if (xDAC$C2Reported$I == $yes)  # reported, report resurrection
             putDAC$C2Reported$I ($no)     # else, don't ever report DAC   
                                           # information
          }
       }   # end if there is a name match
    }   # end of for loop through DAC table

  if (number_found == 0)  # if it was in the DAC try the DSS table
    {
     for (DSS3$Pointer$First; DSS3$Pointer$OK; DSS3$Pointer$Next)
        {
         if (litcmp(xDSS3$Name$C, target_name) == 0)
           {
            if ((INT(xDSS3$TimeDamaged$F) == minute_destroyed) |
                (minute_destroyed == 0)                  )
              {
               number_found = number_found + 1
               DSS3$ZERO
              }   # end of if the time matches or all entries for unit are to be cleared
           }   # end if name match
        }   # end of for loop through DSS table
    }   # end if no DAC entries were found

  if (number_found != 0)
    {
     msg_len = 0
     call smovi  (number_found, msg, msg_len)
     if (number_found == 1)
        call smovv  (" BDA entry for ", msg, msg_len)
     else
        call smovv  (" BDA entries for ", msg, msg_len)
     call smovhn (target_name, $$MaxLit, msg, msg_len)
     call smovv  (" cleared.  ", msg, msg_len)
     call send_   ($Neutral$View, 0, msg_len, msg)
    }   # end of if DAC/DSS entries were located matching the name

return
end


Subroutine GoFromPause      # Process Go order only. Temporary until orders
                            #  processed each cycle.
#$%
#$% Modified:  James Allen - 12/97 (E1852)
#$%            Added the station table index to the
#$%            bldord and revord calls.
#$%
BBcommon

literal hold[$order$array$size]
Integer STA$pointer, iview,kview,ista,ilen,id   # jb E2145  5/24/00


hold[1] = order$minute

#______________________________________________________________________________
#       Process STA Input

for (sta$pointer$first; sta$Pointer$valid; sta$pointer$next)    # for each STA
   {
    if (Xsta$PlayerOn$i == NO) next

    iview = Xsta$View$i
    ista = STA$Pointer$Index   # joa 12/97 (E1852)

    repeat                              # get all orders till no more
       {
        call getord_station (sta$pointer,ilen,hold[2])  # get STA input Que
        if (ilen == 0) break                    # until no more

        if (execution$mode != review$mode)
           {
            call savord (STA$Pointer,id,ilen,hold)    # save the order on disk
                                                      #  (return id#)
            kview = iview
            call bldord (kview,ista,ilen,hold)     # build the order into ORD
           }                                          #  table or execute now
        else
           {
            call revord (iview,ista,ilen,hold)        # process REVIEW orders
           }

       }                                # loop for more from station

   }                                    # end of loop for each station

#______________________________________________________________________________

return
end


integer function GetNotForFlags (nord)
##############################################################################
#$%
#$% Purpose:   Get not for flags for order - allows wildcards to be entered
#$%            for the addressee fields.
#$%
#$% Called By: bldord, ocancl
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$% Date:      December 1997 (E1833)
#$%
#$% Author:    Jim Allen
#$%
##############################################################################

integer  nord

integer  NotForDone
integer  ordnum
integer  NotForFlags[0:For$order$hi]

data NotForDone/0/

  if (NotForDone == 0)            # First time thru
    {                               # Initialize notfor flags for each order
     NotForDone = 1
     for (ordnum = For$order$lo; ordnum <= For$order$hi; ordnum = ordnum + 1)
       {
        call parse_get_notfor (ordnum, notforflags[ordnum])
       }
    }

  GetNotForFlags = notforflags[nord]

return
end



subroutine NotFor_ErrMsg (iview, NotForOffset)
##############################################################################
#$%
#$% Purpose:   Builds and send the appropriate error messages when units
#$%            are given orders by wildcard which should not receive them.
#$%
#$% Called By: bldord, ocancl
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$% Date:      December 1997 (E1833)
#$%
#$% Author:    Jim Allen
#$%
##############################################################################

integer   iview, NotForOffset,I_SWITCH_1    # jb E2145  5/24/00
integer   klen
character msg[ARB]

  klen = 0
  switch (NotForOffset)
    {
     case $Not$Aircraft:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("aircraft.", msg, klen)
       }
     case $Not$Surface:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("ships.", msg, klen)
       }
     case $Not$Submarine:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("submarines.", msg, klen)
       }
     case $Not$ShoreBase:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("bases.", msg, klen)
       }
     case $Not$SmallBoat:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("boats.", msg, klen)
       }
     case $Not$GroundUnit:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("ground units.", msg, klen)
       }
     case $Not$AircraftMnvr:
       {
        call smovv ("Following order cannot override ", msg, klen)
        call smovv ("aircraft in critical maneuver.", msg, klen)
       }
     case $Not$CruiseMissileMnvr:
       {
        call smovv ("Following order cannot override ", msg, klen)
        call smovv ("missile in critical maneuver.", msg, klen)
       }
     case $Not$SmallBoatMnvr:
       {
        call smovv ("Following order cannot override ", msg, klen)
        call smovv ("boat in critical maneuver.", msg, klen)
       }
     case $Not$GhostedUnit:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("ghosted units.", msg, klen)
       }
     case $Not$SurfaceMnvr:
       {
        call smovv ("Following order cannot override ", msg, klen)
        call smovv ("ship in critical maneuver.", msg, klen)
       }
     case $Not$Torpedo:
       {
       call smovv ("Following order is inappropriate for ", msg, klen)
       call smovv ("torpedos.", msg, klen)
       }
     case $Not$SubmarineMnvr:
       {
        call smovv ("Following order cannot override submarine ", msg, klen)
        call smovv ("in critical maneuver.", msg, klen)
       }
     case $Not$TorpedoMnvr:
       {
        call smovv ("Following order cannot override torpedo ", msg, klen)
        call smovv ("in critical maneuver.", msg, klen)
       }
     case $Not$CruiseMissile:
       {
       call smovv ("Following order is inappropriate for ", msg, klen)
       call smovv ("missiles.", msg, klen)
       }
     default:
       {
        call smovv ("Following order is inappropriate for ", msg, klen)
        call smovv ("unit type or status:",msg,klen)
       }
    }

  call send_ (iview,0,klen,msg)          # display error

return
end

subroutine oenter_otg (nord,iview,nargs,args) 

########################################################
#$%
#$% Purpose:   OENTRE_OTG processes ENTER OTG commands to
#$%            record OTH Gold Information into the BB.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      NOV 2000
#$%
#$% Author:    Dane Wills
#$%
#$% Modified:  James O. Allen 6/03 E2348
#$%            Add optional SCONUM clause 
#$%            Remove SHC$nosicid and flag
#------------------------------------------------------------
#                           Notes
# Syntax:
#
#    ENTER OTG (info for) <name> 
#         [ | ID (nosic) <number> ]
#         [ | FLAG (code) <flag>  ] 
#         [ | REPORT (as) <name>  ] 
#                        # [ [ NAV | OTH | STS ] [ | NP ]
#                        #  | NAVNRU | MER | FSH 
#                        #  | ROTHR  | TOM | OBG 
#                        # ] ]
#         [ | TYPE <name> (number) <number> ]
#         [ | SCONUM [ | <name6> ] ]
#         [ | NAMED <full-name> ]
#
# This command can be entered for any UNT, AML, BML, or 
# any specific equipment characteristics.
#
# Values for all fields are not applicable to all tables.
#
#  Table   Nosic ID    Flag    Report  Type/Hull   Name
#  =====   ========    ====    =====   =========   ====
#   UNT     Yes         Yes     Yes     Yes         Yes
#   AML     Yes         Yes     Yes     No          No
#   BML     Yes         Yes     Yes     No          No 
#   Base    Yes         Yes     Yes     N/A         Yes
#   SHC     No          No      No      No          Yes
#   ACC     No          No      No      No          Yes
#   EQ      No          No      No      No          Yes
#
#############################################################

BBcommon

literal     args[$order$array$size], CSTRIP8, Name

integer     nord, nargs, mlen, iview, matches, narg,
            Named[30], M_Tbl[30], M_Ptr[30], kk, ipnt,
            inc, jj, msave, $$tbl

# All of the (positive) tables have a FullName
data        Named / $$UNT,-$$AML,-$$BML, $$SHC, $$ACC, 
                    $$RAD, $$ESM, $$IRC, $$SUI, $$JAM,
                    $$CJC, $$IFF, $$GND, $$MC,  $$TOR, 
                    $$BOM, $$COB, $$NAV, $$SON, $$SOB,
                    $$TRP, $$CTM, $$CHF, $$CMC, 0,
                    0,     0,     0,     0,     0     /

VMSchar     msg*ARB

BBdeclare  (tbl$pointer, TBL$FullName$V, 
            UNT$Pointer, UNT$Flag$V, UNT$HullType$V,
            UNT$SCONUM$V,
            UNT$OtgCode$I, UNT$NosicId$I, UNT$HullNumber$I,
            AML$Pointer, AML$NosicId$i, BML$Pointer, BML$NosicId$i,
            SHC$Pointer, ACC$Pointer)

integer stka[$Max$TaskGroup],cnta,flga,kview
logical verify_NosicId_uniqueness
integer nosicidold
integer get_NosicId
data flga/0/                                # Not a collective name

name = args[3]
kview = 0                                   # Wildcard view
matches = 0
for (ipnt = 1; Named[ipnt] != 0; ipnt=ipnt + 1)
    {
    $$tbl = abs(named[ipnt])

    if ($$tbl == $$UNT)
        {
        call expord (kview,name,cnta,stka,flga,nord)# explode addressees
        if (cnta >= 1)
            tbl$pointer = stka[1]
        else
            tbl$pointer = 0
        }
    else
        {
        call tblfind ($$tbl, name, tbl$pointer)
        }

    if (tbl$pointer != 0) 
        {
        matches = matches + 1
        M_Tbl[matches] = named[ipnt]
        M_Ptr[matches] = tbl$pointer
        }
    }

mlen = 0
msg = ""
call vmovv  ("Problem with OTG info for ", msg, mlen)
call vmovhn (name, $$MaxLit, msg, mlen)
call vmovv  (": ", msg, mlen)
msave = mlen 

if (matches == 0)
    {
    # never matched any RESA name

    call vmovv ("Not found.", msg, mlen)
    call send_v (iview,msg[1:mlen])

    return
    }
else if (matches > 1)
    {
    # matched multiple RESA Names
    # Perfectly valid to match UNT & AML, or
    # UNT & BML, or UNT & SHC, or (?)


    }

msave = mlen 

UNT$NosicId$I   = -1
UNT$OtgCode$I   = 99
UNT$HullNumber$I= 0
Unt$Flag$V      = ""
Unt$HullType$V  = ""
Unt$SCONUM$V    = "@@@@@@"
TBL$FullName$V  = ""

for (narg = 4; narg <= nargs; narg = narg + inc)
    {
    inc = 2     # Default increment

    if (args[narg] == $lex$ID$)
        {
        UNT$NosicId$I = args[narg+1]
        if (UNT$NosicId$i < 0 | UNT$NosicId$i > 9999)
            {
            call vmovv ("NOSIC ID out of range (0-9999)", msg, mlen)
            call send_v (iview,msg[1:mlen])
            return
            }
        }

    else if (args[narg] == $lex$FLAG$)
        {
        kk = 0
        call vmovh (args[narg+1], $$MaxLit, UNT$Flag$V, kk)
        }

    else if (args[narg] == $lex$REPORT$)
        {
        if      (args[narg+1] == 'NAV') UNT$OtgCode$I = $NAV$otg_code   
        else if (args[narg+1] == 'NAVNP') UNT$OtgCode$I = $NAVNP$otg_code   
        else if (args[narg+1] == 'NAVNRU') UNT$OtgCode$I = $NAVNRU$otg_code
        else if (args[narg+1] == 'OTH') UNT$OtgCode$I = $OTH$otg_code   
        else if (args[narg+1] == 'OTHNP') UNT$OtgCode$I = $OTHNP$otg_code 
        else if (args[narg+1] == 'STS') UNT$OtgCode$I = $STS$otg_code   
        else if (args[narg+1] == 'STSNP') UNT$OtgCode$I = $STSNP$otg_code 
        else if (args[narg+1] == 'MER') UNT$OtgCode$I = $MER$otg_code   
        else if (args[narg+1] == 'FSH') UNT$OtgCode$I = $FSH$otg_code   
        else if (args[narg+1] == 'TOM') UNT$OtgCode$I = $TOM$otg_code   
        else if (args[narg+1] == 'OBG') UNT$OtgCode$I = $OBG$otg_code   
        else if (args[narg+1] == 'RTH') UNT$OtgCode$I = $RTH$otg_code   
        else if (args[narg+1] == 'UNK') UNT$OtgCode$I = $UNK$otg_code   
        else 
            {
            call vmovv ("Report code '",        msg, mlen)
            call vmovhn(args[narg+1], $$maxLit, msg, mlen)
            call vmovv ("' is not: NAV OTH STS MER FSH TOM OBG RTH UNK. ",msg, mlen)
            }
        } 

    else if (args[narg] == $lex$TYPE$)
        {
        inc = 3
        kk = 0
        call vmovh (args[narg+1], $$MaxLit, UNT$HullType$V, kk)
        UNT$HullNumber$I  = args[narg+2]
        }

    else if (args[narg] == $lex$SCONUM$)
        {
        if (narg == nargs) inc = 1
        else
            {
            if (args[narg+1] == $lex$NAMED$ |
                args[narg+1] == $lex$ID$    |
                args[narg+1] == $lex$FLAG$  |
                args[narg+1] == $lex$REPORT$|
                args[narg+1] == $lex$TYPE$  ) inc = 1
            }
        if (inc == 1)
            {
            kk = 0
            call vmovv ("      ",  UNT$SCONUM$V, kk)
            }
        else
            {         
            kk = 0
            call vmovh (args[narg+1], 6, UNT$SCONUM$V, kk)
            }
        }

    else if (args[narg] == $lex$NAMED$)
        {
        inc = 4
        kk = 0
        jj = (nargs - narg) * 8
        call vmovh (args[narg+1], jj, TBL$FullName$V, kk)
        }
    } # end for all args

#------------------------------------------------------------    

for (kk = 1; kk <= matches; kk=kk+1)
    {
    $$tbl       = abs(M_Tbl[kk])
    tbl$pointer = M_Ptr[kk]
    
    if (UNT$NosicId$I >= 0)             # joa rsoi14 - allow nosic id change
        {
        if ($$tbl == $$UNT)
            {
            UNT$Pointer = tbl$pointer 
            nosicidold = Xunt$NosicId$i
            putUNT$NosicId$i( 0 )
            call free_nosicid (nosicidold)
            if (!verify_NosicId_uniqueness (UNT$Nosicid$i))
                {
                PUTUNT$NosicId$i( nosicidold )
                call set_nosicid (nosicidold)
                call vmovv ("NOSIC ID not unique", msg, mlen)
                }
            else
                {
                call set_nosicid (unt$Nosicid$i)
                putUNT$NosicId$i
                }
            }
        else if ($$tbl == $$AML)
            {
            AML$Pointer = tbl$pointer 
            nosicidold = XAML$NosicId$i
            putAML$NosicId$i( 0 )
            call free_nosicid (nosicidold)
            if (!verify_NosicId_uniqueness (UNT$Nosicid$i))
                {
                PUTAML$NosicId$i( nosicidold )
                call set_nosicid (nosicidold)
                call vmovv ("NOSIC ID not unique", msg, mlen)
                }
            else         
                {
                call set_nosicid (unt$Nosicid$i)
                putAML$NosicId$i (UNT$NosicId$I)
                }
            }
        else if ($$tbl == $$BML)
            {
            BML$Pointer = tbl$pointer 
            nosicidold = XBML$NosicId$i
            putBML$NosicId$i( 0 )
            call free_nosicid (nosicidold)
            if (!verify_NosicId_uniqueness (UNT$Nosicid$i))
                {
                PUTBML$NosicId$i( nosicidold )
                call set_nosicid (nosicidold)
                call vmovv ("NOSIC ID not unique", msg, mlen)
                }
            else
                {
                call set_nosicid (unt$Nosicid$i)
                putBML$NosicId$i (UNT$NosicId$I)
                }
            }
        else if (kk == 1)           # Output error on first table only
            {
            call vmovv  ("NOSIC Id is n/a. ", msg, mlen)
            }
        } # end if Nosic Id

    if (UNT$NosicId$I < 0)             # id not specified - get nosicid if 0
        {
        if ($$tbl == $$UNT)
            {
            UNT$Pointer = tbl$pointer 
            unt$nosicid$i = Xunt$NosicId$i
            if (unt$NosicId$i == 0)
                {
                unt$NosicId$i = get_NosicId()
                if (unt$Nosicid$i == 0)         # No available nosicid
                    call vmovv ("NOSIC ID not available", msg, mlen)
                else
                    PUTunt$NosicId$i
                }
            }
        else if ($$tbl == $$AML)
            {
            AML$Pointer = tbl$pointer 
            aml$nosicid$i = XAML$NosicId$i
            if (aml$NosicId$i == 0)
                {
                aml$NosicId$i = get_NosicId()
                if (unt$Nosicid$i == 0)         # No available nosicid
                    call vmovv ("NOSIC ID not available", msg, mlen)
                else
                    PUTaml$NosicId$i
                }
            }
        else if ($$tbl == $$BML)
            {
            BML$Pointer = tbl$pointer 
            BML$NosicId$i = XBML$NosicId$i
            if (bml$NosicId$i == 0)
                {
                bml$NosicId$i = get_NosicId()
                if (bml$Nosicid$i == 0)         # No available nosicid
                    call vmovv ("NOSIC ID not available", msg, mlen)
                else
                    PUTbml$NosicId$i
                }
            }
        } # end if Nosic Id not set

    if (unt$Flag$v != " ")
        {
        if ($$tbl == $$UNT)
            {
            UNT$Pointer = tbl$pointer 
            putUNT$Flag$V (Unt$Flag$V)
            }
        else if ($$tbl == $$AML)
            {
            AML$Pointer = tbl$pointer 
            putAML$Flag$V (Unt$Flag$V)
            }
        else if ($$tbl == $$BML)
            {
            BML$Pointer = tbl$pointer 
            putBML$Flag$V (Unt$Flag$V)
            }
        else if (kk == 1)
            {
            call vmovv  ("Flag is n/a. ", msg, mlen)
            }
        }

    if (UNT$OtgCode$I != 99)        # 99 is unused value 
        {
        if ($$tbl == $$UNT)
            {
            UNT$Pointer = tbl$pointer 
            putUNT$OtgCode$i
            }
        else if ($$tbl == $$AML)
            {
            AML$Pointer = tbl$pointer 
            putAML$OtgCode$i (UNT$OtgCode$I)
            }
        else if ($$tbl == $$BML)
            {
            BML$Pointer = tbl$pointer 
            putBML$OtgCode$i (UNT$OtgCode$I)
            }
        else if (kk == 1)
            {
            call vmovv  ("Report code is n/a. ", msg, mlen)
            }
        }

    if (Unt$HullType$v != " ")
        {
        if ($$tbl == $$UNT)
            {
            UNT$Pointer = tbl$pointer 
            putUNT$HullType$V 
            putUNT$HullNumber$I 
            }
        else if (kk == 1)
            {
            call vmovv  ("Type is n/a. ", msg, mlen)
            }
        }

    if (tbl$FullName$V != " ")
        {
        if (M_Tbl[kk] > 0)
            {
            PUTtbl$FullName$V 
            }
        else if (kk == 1)
            {
            call vmovv  ("Name is n/a. ", msg, mlen)
            }
        }
    if (unt$SCONUM$v != "@@@@@@")
        {
        if ($$tbl == $$UNT)
            {
            UNT$Pointer = tbl$pointer 
            putUNT$SCONUM$V (Unt$SCONUM$V)
            }
        else if (kk == 1)
            {
            call vmovv  ("SCONUM is n/a. ", msg, mlen)
            }
        }
    } # end for tbl loop

#------------------------------------------------------------

if (mlen != msave)
    {
    # had any problems?

    call send_v (iview,msg[1:mlen])
    }

return
end


subroutine oenter_air (nord,iview,nargs,args)
########################################################
#$%
#$% Purpose:   OENTER_AIR processes ENTER AIR commands at
#$%            simulation execution time
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     
#$%
#$% Tables:    AML
#$%
#$% Date:      AUG 2001
#$%
#$% Author:    James Allen
#$%
#------------------------------------------------------------
#                           Notes
# Syntax:
#          1    2                                 3
#        ENTER AIR (maint log side number id) <side-id>
#                                         ( seq) <number>               (4)
#                                         (quantity) <number>           (5)
#                                         (of) <aircraft-type>          (6)
#                                         (base name) <force-name>      (7)
#                                         (time flown) <minutes>        (8)
#                                         (up time) <minutes>           (9)
#                                         (squadron_name) <force-name> (10)
#                                         (default mission) 
#                                         [ | [ AD        | AEW    | AI 
#                                             | AIRTANKER | ALFT   | AMPHIBIOUS 
#                                             | ASW       | BAI    | CAP 
#                                             | CAS       | DECOY  | ESCORT 
#                                             | EW        | FY     | JAMMER 
#                                             | MP        | OCA    | RECONN 
#                                             | RELAY     | RESCUE | SEARCH 
#                                             | SM        | STRCAP | STRIKE 
#                                             | STTANKER  | SURCAP | SURVEILLANCE 
#                                             | SW        | TASMO  | TEW
#                                             | WW ] ];                (11)
#
#
#############################################################

BBcommon

literal     args[$order$array$size], name

integer     nord, nargs, mlen, iview, narg, k, kk

integer     squadron_index, default_mission, it_is_Dup

VMSchar     msg*ARB
VMSchar     VSTRIP*ARB

 integer ILEN, nadded,
         ACC$Pointer,
         UNT$Pointer,
         AML$Pointer,
         AML$Status$I,
         AML$Sqdindx$I,
         AML$Accpntr$I,
         AML$Ownerindx$I,
         AML$Defaultmission$I
 literal AML$Timeflown$F,    
         AML$Timelaunch$F,   
         AML$Timemaint$F,    
         AML$Sidenumber$C,   
         ACC$Type$C,         
         CSTRIP8             
integer  get_nosicid
BBDeclare (AML$NosicId$i)

for(ACC$POINTER$FIRST;ACC$POINTER$OK;ACC$POINTER$NEXT)
{
    ACC$TYPE$C = XACC$TYPE$C

    if(ACC$TYPE$C == args[6])
    {
        AML$ACCPNTR$I = ACC$POINTER
        break
    }
}

if (!acc$pointer$ok)
{
    mlen = 0
    msg = ""
    call vmovhn (args[6], $$MaxLit, msg, mlen)
    call vmovv  (" aircraft type not found. ENTER AIR order rejected.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT)
{
    if(XUNT$NAME$C == args[7])
    {
        AML$OWNERINDX$I = UNT$POINTER$INDEX

        break
    }
}

if (!unt$pointer$ok)
{
    mlen = 0
    msg = ""
    call vmovhn (args[6], $$MaxLit, msg, mlen)
    call vmovv  (" base not found. ENTER AIR order rejected.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

call enterSquadron (args[10], squadron_index)
if (squadron_index == 0)
{                          # then there was an error
    mlen = 0
    msg = ""
    call vmovhn (args[10], $$MaxLit, msg, mlen)
    call vmovv  (" squadron not entered. SQD table full.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

if (nargs >= 11)
{
   call Lex_to_Mission_Code (args[11], default_mission)
   if (default_mission == -1)
     default_mission = $NoneAssigned$Code
}
else
   default_mission = $NoneAssigned$Code

nadded = 0
#$% for each aml entry                                                         
for (k=0; k<args[5]; k=k+1)                     #loop thru # of aml entries
{
    #$% initialize line length and name
    ilen = 0
    kk = 0; call smovv ("        ", name, kk)
    #$% move data to output buffer 
    call smovhn (args[3],2,name,ilen)               #pack side number id and
    call smoviz (int(args[4])+k,3,name,ilen)        # seq number

    call check_force_name ( name, it_is_Dup )

    if ( it_is_dup == $YES )                 
    {
        mlen = 0
        msg = ""
        call vmovhn (name, $$MaxLit, msg, mlen)
        call vmovv  (" side number duplicates the name of an existing Force.", msg, mlen)

        call send_v (iview,msg[1:mlen])

        next                        # do not add this side-number
    }

    call check_aml_name ( name, it_is_Dup )

    if ( it_is_dup == $YES )               
    {
        mlen = 0
        msg = ""
        call vmovhn (name, $$MaxLit, msg, mlen)
        call vmovv  (" side number duplicates the name of an aircraft.", msg, mlen)

        call send_v (iview,msg[1:mlen])

        next                        # do not add this side-number
    }

    call check_bml_name ( name, it_is_Dup )        

    if ( it_is_dup == $YES )
    {
        mlen = 0
        msg = ""
        call vmovhn (name, $$MaxLit, msg, mlen)
        call vmovv  (" side number duplicates the name of a boat.", msg, mlen)

        call send_v (iview,msg[1:mlen])

        next                        # do not add this side-number
    }

    aml$pointer = aml$last + 1
    if (!aml$pointer$valid)
    {
        mlen = 0
        msg = ""
        call vmovhn (name, $$MaxLit, msg, mlen)
        call vmovv  (" side number not entered. AML table full.", msg, mlen)

        call send_v (iview,msg[1:mlen])

        return
    }
    aml$used = aml$pointer$index * aml$entry

    nadded = nadded + 1
    if (nadded == 1)
        call Check_AC_DEQ (UNT$pointer, ACC$pointer)     # add as needed

    PUTaml$sidenumber$C (name)                  #put new entry in table
    PUTaml$timeflown$f (args[8])
    PUTaml$timelaunch$f (args[9])
    PUTaml$sqdindx$i (squadron_index)
    PUTaml$defaultmission$i (default_mission)
    PUTAML$ACCPNTR$I    
    aml$TimeMaint$f = 1.E35
    PUTaml$TimeMaint$f     
    PUTAML$OWNERINDX$I
    PUTAML$STATUS$I ($ONDECK$CODE)
    aml$NosicId$i = get_nosicid()
    PUTaml$NosicId$i
    # Default OTG info
    putAML$Flag$V (XUnt$Flag$V)             # Use base flag
    putAML$OTGcode$i($NAVNRU$otg_code)

    aml$pointer$next
}

return
end

subroutine check_aml_name ( name, it_is_Dup )

#########################################################
#$%
#$% Purpose:   CHECK_AML_NAME looks for a matching name 
#$%
#$% Called By: oenter_air
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      Aug 2001
#$%
#$% Author:    James Allen
#$%
#########################################################

BBcommon

BBdeclare (aml$pointer)
integer it_is_dup
literal name, cstrip8

it_is_dup = $NO

for (aml$pointer$first; aml$pointer$ok; aml$pointer$next)
{
    if ( name == Xaml$SideNumber$c )
    {
        it_is_dup = $YES
        break
    }
}

end

subroutine check_bml_name ( name, it_is_Dup )

#########################################################
#$%
#$% Purpose:   CHECK_BML_NAME looks for a matching name 
#$%
#$% Called By: oenter_air
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      Aug 2001
#$%
#$% Author:    James Allen
#$%
#########################################################

BBcommon

BBdeclare (bml$pointer)
integer it_is_dup
literal name, cstrip8

it_is_dup = $NO

for (bml$pointer$first; bml$pointer$ok; bml$pointer$next)
{
    if ( name == Xbml$name$c )
    {
        it_is_dup = $YES
        break
    }
}

end

subroutine check_force_name ( name, it_is_Dup )

#########################################################
#$%
#$% Purpose:   CHECK_FORCE_NAME looks for a matching name 
#$%
#$% Called By: oenter_air
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      AUG 2001
#$%
#$% Author:    James Allen
#$%
#########################################################

BBcommon

BBDeclare (unt$pointer)
integer it_is_dup
literal name, cstrip8

it_is_dup = $NO

for (unt$pointer$first; unt$pointer$ok; unt$pointer$next)
{
    if (Xunt$name$c == name)
    {
        it_is_dup = $YES
        break
    }
}

end



subroutine enterSquadron (squadron_name, index)
###############################################################
#$%
#$% Purpose:   enterSquadron lookup squadron name.
#$%            If not found, it will be added unless table exceeded
#$%
#$% Called By: oenter_air
#$%
#$% Calls:     echo..
#$%            
#$% Tables:    SQD
#$%
#$% Date:      Aug 2001
#$%
#$% Author:    James Allen
#$%
###############################################################
BBcommon

literal  squadron_name, cstrip8
integer  index
BBDeclare (sqd$pointer)

index = 0           # Means failed to find or add squadron

# Locate squadron
for (sqd$pointer$first; sqd$pointer$ok; sqd$pointer$next)
{
    if (squadron_name == XSQD$SquadronName$C)
    {
        index = sqd$pointer$index
        return
    }
}

# If squadron not located, add if room
if (sqd$pointer$valid) 
{
      PUTSQD$SquadronName$C (squadron_name)
      index = sqd$pointer$index
      sqd$pointer$next
      sqd$last$to sqd$pointer
}

return
end     # end enterSquadron



subroutine oenter_boat (nord,iview,nargs,args)

 #######################################################
 #$%
 #$% Purpose:   oenter_boat loads in the BOAT Main-
 #$%            tenance Log data.
 #$%
 #$% Called By: exeord
 #$%
 #$% Calls:     ECHOH      ECHOI      ECHOR
 #$%
 #$% Tables:    BML        SHC        UNT
 #$%
 #$% Date:      Sep 01
 #$%                                        (jb)
 #$% Author:    James Allen
 #$%    
 #######################################################

 BBcommon

literal     args[$order$array$size], name

integer     nord, nargs, mlen, iview, narg

integer     it_is_Dup

VMSchar     msg*ARB
VMSchar     VSTRIP*ARB

 integer   UNT$Pointer,                     
           BML$Pointer,                     
           BML$Shcpntr$I,                   
           BML$Ownerindx$I,                 
           BML$Status$I,                
           SHC$Pointer,                 
           SHC$Smallboat$I             
 real      SHC$Fuelrate$F,
           SHC$Onepctfuel$F
 literal   CSTRIP8,
           BML$Name$C, SHC$Type$C
integer get_NosicId
BBDeclare (BML$NosicId$i)

#            1    2        3                  4                    5
#{433,AFQ} ENTER BOAT <force-name> (class) <class> (for base) <force-name>;

name = args[3]

for(SHC$POINTER$FIRST;SHC$POINTER$OK;SHC$POINTER$NEXT)
{
    if (XSHC$SmallBoat$i != $YES)    NEXT

    if(XSHC$TYPE$C == args[4])
    {
        BML$SHCPNTR$I = SHC$POINTER
        break
    }
}

if (!shc$pointer$ok)
{
    mlen = 0
    msg = ""
    call vmovhn (args[4], $$MaxLit, msg, mlen)
    call vmovv  (" ship class not found. ENTER BOAT order rejected.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT)
{
    if(XUNT$NAME$C == args[5])
    {
        BML$OWNERINDX$I = UNT$POINTER$INDEX
        break
    }
}

if (!unt$pointer$ok)
{
    mlen = 0
    msg = ""
    call vmovhn (args[5], $$MaxLit, msg, mlen)
    call vmovv  (" base not found. ENTER BOAT order rejected.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

call check_aml_name ( name, it_is_Dup )

if ( it_is_dup == $YES )               
{
    mlen = 0
    msg = ""
    call vmovhn (name, $$MaxLit, msg, mlen)
    call vmovv  (" boat name duplicates the name of an aircraft.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

call check_bml_name ( name, it_is_Dup )        

if ( it_is_dup == $YES )
{
    mlen = 0
    msg = ""
    call vmovhn (name, $$MaxLit, msg, mlen)
    call vmovv  (" boat name duplicates the name of a boat.", msg, mlen)

    call send_v (iview,msg[1:mlen])
    return
}

bml$pointer = bml$last + 1
if (!bml$pointer$valid)
{
    mlen = 0
    msg = ""
    call vmovhn (name, $$MaxLit, msg, mlen)
    call vmovv  (" boat not entered. BML table full.", msg, mlen)

    call send_v (iview,msg[1:mlen])

    return
}

bml$used = bml$pointer$index * bml$entry

PUTBML$NAME$C (name)

PUTBML$SHCPNTR$I

PUTBML$OWNERINDX$I

#$% initialize the BML chain for this unit:
PUTBML$NextBML$i (Xunt$BMLindx$i)
PUTunt$BMLindx$i (BML$Pointer$index) 

PUTunt$BoatRestricted$i ($NO)     # be capable of handling boats

PUTBML$STATUS$I ($ONDECK$CODE)

PutBML$DamageMultiplier$i (1) 

# Default OTG info
bml$NosicId$i = get_nosicid()
PUTbml$NosicId$i
putBML$Flag$V (XUnt$Flag$V)
putBML$OTGcode$i($NAVNRU$otg_code)

return
end



subroutine odelunt (nord,iview,nargs,args)

########################################################
#$%
#$% Purpose:   odelunt marks a unit for deletion.  
#$%            
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     
#$%
#$% Tables:    None
#$%
#$% Date:      AUG 2001
#$%
#$% Author:    James Allen
#$%
#------------------------------------------------------------
#                           Notes
# Syntax:
#
#    DELETE UNIT (named) <force-name>; 
#
#############################################################

BBcommon

VMSchar     msg*ARB
integer     mlen, nord, iview, nargs
literal     name,args[$order$array$size]

BBdeclare (UNT$Pointer)

name = args[3]
mlen = 0
msg = ""

call untfnd (iview, name, unt$pointer)

if (unt$pointer$ok)
{
    if (Xunt$GhostedDISUnit$i == $yes) # joa 10/01  (E2240)
    {
        PUTunt$DISDeleteSent$i ($yes)      # This allows unit removed from UNT
    }
 
    if (XUNT$Type$I == $Air$code)
    {
        call fltrec(unt$pointer)
    }
    else if (XUNT$SuperType$I == $SmallBoat$Supercode)
    {
        call boat_recover(unt$pointer)
    }

    PUTUNT$Status$i ($BeingDeleted$code)

    call vmovhn (name, $$MaxLit, msg, mlen)
    call vmovv  (" unit marked for deletion.", msg, mlen)
}
else
{
    call vmovhn (name, $$MaxLit, msg, mlen)
    call vmovv  (" not deleted. Unit not found.", msg, mlen)
}

call send_v (iview,msg[1:mlen])

return
end



logical function verify_NosicId_uniqueness (NosicID)

########################################################
#$%
#$% Purpose:   verify_NosicId_uniqueness searches UNT, AML, BML   
#$%            to see if given nosicid is in use. (E2275)
#$%
#$% Called By: oenter_otg
#$%
#$% Calls:     
#$%
#$% Tables:    UNT, AML, BML
#$%
#$% Date:      July 2002
#$%
#$% Author:    James Allen
#$%
#############################################################

BBcommon

integer NosicId

BBdeclare (UNT$Pointer)
BBdeclare (AML$Pointer)
BBdeclare (BML$Pointer)

verify_NosicId_uniqueness = $TRUE
if (NosicId == 0)                           # Zero means not used
    return

for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT)
{
    if (Xunt$NosicId$i == NosicId)
    {
        verify_NosicId_uniqueness = $FALSE
        return
    }
}

for(AML$POINTER$FIRST;AML$POINTER$OK;AML$POINTER$NEXT)
{
    if (XAML$NosicId$i == NosicId)
    {
        verify_NosicId_uniqueness = $FALSE
        return
    }
}

for(BML$POINTER$FIRST;BML$POINTER$OK;BML$POINTER$NEXT)
{
    if (Xbml$NosicId$i == NosicId)
    {
        verify_NosicId_uniqueness = $False
        return
    }
}

return
end



define (nosicidCommon,
 byte NosicIdInUse[0:$Hi_UNT$NOSICid$I]
 common/nosicid/nosicidInUse
)

integer function get_NosicId()

########################################################
#$%
#$% Purpose:   Get unique noscid
#$%
#$% Called By: chop_ghosted_airsupport
#$%
#$% Calls:     
#$%
#$% Tables:    UNT, AML, BML
#$%
#$% Date:      Feb. 2008
#$%
#$% Author:    James Allen
#$%
#############################################################

BBcommon

NosicidCommon

integer i
integer nosicId
integer firstTime
integer free_nosicid

BBdeclare (UNT$Pointer)
BBdeclare (AML$Pointer)
BBdeclare (BML$Pointer)

data firstTime/1/       # First time through routine init nosicids in use


if (firstTime == 1)
{
    firstTime = 0
    for (i=1; i<=$Hi_UNT$NOSICid$I; i=i+1)
    {
        nosicIdInUse[i] = $NO
    }
    
    for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT)
    {
        nosicId = Xunt$NosicId$i
        if (NosicId > 0) 
        {
            nosicIdInUse[NosicId] = $YES
        }
    }
    
    for(AML$POINTER$FIRST;AML$POINTER$OK;AML$POINTER$NEXT)
    {
        nosicId = Xaml$NosicId$i
        if (NosicId > 0) 
        {
            nosicIdInUse[NosicId] = $YES
        }
    }
    
    for(BML$POINTER$FIRST;BML$POINTER$OK;BML$POINTER$NEXT)
    {
        nosicId = Xbml$NosicId$i
        if (NosicId > 0) 
        {
            nosicIdInUse[NosicId] = $YES
        }
    }
}

nosicId = 0
for (i=1; i<=$Hi_UNT$NOSICid$I; i=i+1)
{
    if (nosicIdInUse[i] == $NO)
    {
        nosicId = i
        nosicIdInUse[NosicId] = $YES
        break
    }
}

return (nosicId)

end

subroutine free_nosicid (nosicId)
integer nosicId
nosicidCommon

NosicIdInUse[nosicId] = $NO
return 

end

subroutine set_nosicid (nosicId)
integer nosicId
nosicidCommon

NosicIdInUse[nosicId] = $YES
return 

end


Subroutine reset_route_loop_flag
########################################################
#$%
#$% Purpose:   Resets route loop flag for all units
#$%
#$% Called By: wgordp
#$%
#$% Calls:     
#$%
#$% Tables:    UNT
#$%
#$% Date:      September 2005
#$%
#$% Author:    James Allen
#$%
#############################################################

BBcommon

BBdeclare (UNT$Pointer)

for (unt$pointer$first; unt$pointer$ok; unt$pointer$next)
{
    PUTunt$RouteLoopFlag$i( 0 )
}

return
end

subroutine set_game_rate(time_or_ratio,value)
########################################################
#$%
#$% Purpose:   Sets game ratio in a manner that can be invoked
#$%    by order processor and ALSP
#$%
#$% Called By: wgop and alsp parser
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      April 2015
#$%
#$% Author:    Jay Braun
#$%
#############################################################

BBcommon

literal time_or_ratio, value

if (time_or_ratio == $lex$TIME$)
{
    game$rate = 60. / value
}
else    # RATIO
{
    game$rate = real(value)
}

#Minimum game rate is historically 0.15
if (game$rate < 0.15)
   game$rate = 0.15

time$spec = time$step * $Seconds$per$Minute / game$rate

# register the current game rate - clk 9/97 (E1892)
if (ALSP$Active != $no & Game$Pause != $yes)
    call alsp_register_rate (game$rate)

return
end
