## PTTOP.RAT

include "ascii.inc"         
include "bbctl.inc"         
include "bbcode.inc"         
include "bbsta.inc"         
include "ptmain.inc"         
include "ptcolor.inc"
include "ptgraph.inc"         
include "bbbar.inc"         
include "bbbmk.inc"         
include "bbcor.inc"         
include "bblin.inc"             # jb POLYGONs, LINE/sequences    11/14/89
include "bbmfd.inc"         
include "bbmrk.inc"         
include "bbnuc.inc"         
include "bbown.inc"         
include "bbpim.inc"         
include "bbplc.inc"         
include "bbrmt.inc"         
include "bbrvu.inc"         
include "bbsat.inc"         
include "bbser.inc"         
include "bbshc.inc"         
include "bbsop.inc"         
include "bbswp.inc"         
include "bbtrk.inc"         
include "bbunt.inc"                   # jb Replaces DUP  4/5/89
include "bbwet.inc"         
include "bbrte.inc"             # reh, routes, 11/21/89
include "bbrto.inc"         
include "bbalz.inc"             # reh, landing zones, 11/29/89
include "bbprt.inc"             # reh, plot routes, 11/21/89
include "bbdeq.inc"             # 
include "bbrad.inc"             # 
include "bbsui.inc"             # 
include "bbler.inc"             # LIDAR regions 2/91 SMM/CLK
include "bbswb.inc"             # SWABS regions 3/91 SMM/CLK
include "bbspa.inc"             # Submarine Patrol Area information - clk 10/91
include "bbpsp.inc"             # plotted SPA information - clk 10/91
include "bbird.inc"             
include "bbnrt.inc"             # SMM 12/92 PER #E1101
include "bbhfd.inc"             # Plot wide area surveillance tracks - khc 12/92
include "bbssr.inc"             # PER E1066 - khc 12/92
include "bbswd.inc"             #             khc 12/92
include "bbsos.inc"             #             khc 12/92
include "bbagd.inc"             # clk 9/95 (E1456) - Plotting "Ghosts" Ground Data
include "bbmc.inc"              # clk 9/95 (E1456) - Plotting "Ghosts" Ground Data
include "alsp.inc"              # clk 9/95 (E1456) - Plotting "Ghosts" Ground Data
include "elevation.inc"         # joa 11/95 (E1422) - Terrain
include "bbl16.inc"             # clk 12/95 (E1469) - JTIDS / L-16 Track Data
include "bblcl.inc"             # clk 12/95 (E1469) - JTIDS / L-16 Track Data
include "bbbom.inc"             # clk 1/97  (E1731) - Persistent Effect Munitions Plotting
include "bbpem.inc"             # clk 1/97  (E1731) - Persistent Effect Munitions Plotting
include "bbnam.inc"             # clk 3/97  (E1781) - retasking id's
include "bbssc.inc"             # clk 3/99  (E2064)
include "plplay.inc"         

define $STA$EF$PlotWakeUp        101    # request to cycle PLOT 
define (BBImplicit, Implicit NONE)                  # MJC 5/31/2K (E2145)
define ($$$Air ,1)
define ($$$Sub ,2)
define ($$$Surf,3)
define ($$$Land,4)              # added 1/91, for plotting and erasing bases
define ($$$Boat,5)              # added 8/91, for plotting and erasing boats
define ($$$Site,6)              # added 7/92, for plotting and erasing sites
define ($$$Miss,7)      # added 1/94, for plotting SAM missiles
define ($$$Vehicle,8)
define ($$$Max_Type,8)
# Note: Ground types are handled separately - clk 9/95

define ($$$Enemy,1)
define ($$$Friendly,2)
define ($$$Neutral,3)
define ($$$Unknown,4)
define ($$$Max_Side,4)

define ($$$Orange,1)
define ($$$Blue,2)

define($MinTorp_PlotSpeed,5.0)

define  (Select_Common,                         ## for use in SELECT_SET
    integer     select_mask[$$$Max_Type,$$$Max_Side]
    integer     ntds_symbol[$$$Max_Type,$$$Max_Side]
    common      /sel_com/       select_mask, ntds_symbol
    )

define  (Select_Common_data,                    ## for use in SELECT_SET
    data        ntds_symbol [$$$Air ,$$$Enemy   ] /$NTDS$Enemy$Air    /
    data        ntds_symbol [$$$Air ,$$$Friendly] /$NTDS$Friendly$Air /
    data        ntds_symbol [$$$Air ,$$$Neutral ] /$NTDS$Unknown$Air  /
    data        ntds_symbol [$$$Air ,$$$Unknown ] /$NTDS$Unknown$Air  /
    data        ntds_symbol [$$$Sub ,$$$Enemy   ] /$NTDS$Enemy$Sub    /
    data        ntds_symbol [$$$Sub ,$$$Friendly] /$NTDS$Friendly$Sub /
    data        ntds_symbol [$$$Sub ,$$$Neutral ] /$NTDS$Unknown$Sub  /
    data        ntds_symbol [$$$Sub ,$$$Unknown ] /$NTDS$Unknown$Sub  /
    data        ntds_symbol [$$$Surf,$$$Enemy   ] /$NTDS$Enemy$Surf   /
    data        ntds_symbol [$$$Surf,$$$Friendly] /$NTDS$Friendly$Surf/
    data        ntds_symbol [$$$Surf,$$$Neutral ] /$NTDS$Unknown$Surf /
    data        ntds_symbol [$$$Surf,$$$Unknown ] /$NTDS$Unknown$Surf /
    data        ntds_symbol [$$$Boat,$$$Enemy   ] /$NTDS$Enemy$Surf   /
    data        ntds_symbol [$$$Boat,$$$Friendly] /$NTDS$Friendly$Surf/
    data        ntds_symbol [$$$Boat,$$$Neutral ] /$NTDS$Unknown$Surf /
    data        ntds_symbol [$$$Boat,$$$Unknown ] /$NTDS$Unknown$Surf /
    data        ntds_symbol [$$$Land,$$$Enemy   ] /$NTDS$Base         /
    data        ntds_symbol [$$$Land,$$$Friendly] /$NTDS$Base         /
    data        ntds_symbol [$$$Land,$$$Neutral ] /$NTDS$Base         /
    data        ntds_symbol [$$$Land,$$$Unknown ] /$NTDS$Base         /
    data        ntds_symbol [$$$Site,$$$Enemy   ] /$NTDS$Site         /
    data        ntds_symbol [$$$Site,$$$Friendly] /$NTDS$Site         /
    data        ntds_symbol [$$$Site,$$$Neutral ] /$NTDS$Site         /
    data        ntds_symbol [$$$Site,$$$Unknown ] /$NTDS$Site         /
    data        ntds_symbol [$$$Miss,$$$Enemy   ] /$NTDS$Missile      /
    data        ntds_symbol [$$$Miss,$$$Friendly] /$NTDS$Missile      /
    data        ntds_symbol [$$$Miss,$$$Neutral]  /$NTDS$Missile      /
    data        ntds_symbol [$$$Miss,$$$Unknown]  /$NTDS$Missile      /
    data        ntds_symbol [$$$Vehicle,$$$Enemy   ] /$NTDS$Ground_box/
    data        ntds_symbol [$$$Vehicle,$$$Friendly] /$NTDS$Ground_box/
    data        ntds_symbol [$$$Vehicle,$$$Neutral]  /$NTDS$Ground_box/
    data        ntds_symbol [$$$Vehicle,$$$Unknown]  /$NTDS$Ground_box/
    )



Subroutine Plot_RECTANGLEs (STA$Pointer)                         #receive view

 ##########################################################
 #$%
 #$% Purpose:   PLOT_RECTANGLES collects RECTANGLE data for
 #$%            display to the APPRORRIATE STATIONS....
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_RECTANGLES
 #$%
 #$% Tables:    PLC
 #$%
 #$% Date:      July 1987
 #$%
 #$% Author:    Joe Bryant
 #$%
 #########################################################

BBcommon
PLOTcommon

integer         BINCK, COLOR

integer ISTA,
        KORIENT,
        LENGTH,
        KWIDTH,                          # MJC 5/31/2K (E2145)
        ipoly_type #SMM 4/2014

BBDeclare  (STA$Pointer,
            PLC$Pointer,
            PLC$Latitude$F,
            PLC$Longitude$F)            # MJC 5/31/2K (E2145)

real    FLAT,
        FLON                            # MJC 5/31/2K (E2145)

ista  = STA$Pointer$Index

#COLOR = $Color$CIRCLE
COLOR = $Color$BAR$chaff                        # jb            7/8/87

for (PLC$Pointer$First; PLC$Pointer$Valid; PLC$Pointer$Next)
    {
    if (xPLC$Type$I    != $RECTANGLE$Code) NEXT # jb moved up   7/7/87
  
    if (xPLC$Station$I != ista) NEXT # jb, per 7/23/90 request  7/23/90

    PLC$Latitude$F  = xPLC$Latitude$F          #get latitude
    PLC$Longitude$F = xPLC$Longitude$F         #get longitude

    if (BINCK(PLC$Latitude$F, PLC$Longitude$F) == NO) NEXT

    fLAT = PLC$Latitude$F               # RADIANS
    fLON = PLC$Longitude$F              # RADIANS

    LENGTH  = xPLC$Radius$I                     # jb    7/6/87
    Korient = xPLC$Orient$I                     # jb    7/6/87
    Kwidth  = xPLC$Width$I                      # jb    7/6/87

    if (LENGTH == 0) LENGTH = 2                 # jb    7/6/87
    if (Kwidth == 0) Kwidth = 1                 # jb    7/6/87

    ipoly_type = $Poly$Solid$Code
    call Draw_RECTANGLE(fLAT,fLON,Length,Korient,Kwidth,COLOR,ipoly_type) #7/6/87
                                    #                         ^- is the type
                                    #                       of polygon...
    }

return
end



Subroutine Plot_ELLIPSEs (STA$Pointer)                         #receive view

 ##########################################################
 #$%
 #$% Purpose:   PLOT_ELLIPSES collects ELLIPSE data for
 #$%            display to the APPROPRIATE STATIONS....
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_RECTANGLE
 #$%
 #$% Tables:    PLC       RMT
 #$%
 #$% Date:      August 1991
 #$%
 #$% Author:    Cynthia Leaf
 #$%
 ##########################################################

BBcommon
PLOTcommon

integer         BINCK, COLOR
integer*2       Radius

integer ISTA,
        LENGTH,
        KORIENT,
        KWIDTH                      # MJC 5/31/2K (E2145)

BBDeclare  (STA$Pointer,
            PLC$Pointer,
            RMT$Pointer)            # MJC 5/31/2K (E2145)

real FLAT,FLON                      # MJC 5/31/2K (E2145)

ista  = STA$Pointer$Index

for (PLC$Pointer$First; PLC$Pointer$Ok; PLC$Pointer$Next)
   {
    #$% check station index
    if (xPLC$Station$I != ista) next

    #$% check type of mark
    if (xPLC$Type$I == $BistaticEllipse$Code)
      {
       #$% get RMT index
       RMT$Pointer$to (xPLC$Reference$i)

       if (xRMT$LastDetType$i == $Bistatic$Type)
         {
          fLat = xRMT$ApparentLat$F          #get latitude
          fLon = xRMT$ApparentLon$F          #get longitude
      
          if (BINCK(fLat,fLon) != NO)   # plot this ellipse
            {
             LENGTH  = xRMT$EllipseMinorAxis$i       # get minor axis
             Korient = xRMT$EllipseOrientation$i     # get orientation
             Kwidth  = xRMT$EllipseMajorAxis$i       # get major axis
      
             if (LENGTH == 0) LENGTH = 1
             if (Kwidth == 0) Kwidth = 2
      
             #$% determine color of ellipse
             if (xRMT$DetectionType$i == $ActiveNonVisual$Code)
               COLOR = $Color$Off_White     # clk 1/94 (E1096) vice: $color$obj$neutral
             else
               COLOR = $Color$lob$sonar
      
             if (LENGTH != Kwidth)     # draw an ellipse
               call Draw_RECTANGLE(fLAT,fLON,Length,Korient,Kwidth,COLOR,0)
                                               #                         ^- is the
                                               #                type of polygon...
             else            # draw a circle
               {
                Radius = LENGTH/2
                call Draw_Circle_c(fLAT,fLON,Radius,Color, $Poly$Solid$Code)
               }
            }
         }
       else
         PLC$ZERO
      }
   }

return
end


Subroutine Getsta (ista,sta$pointer,iview,megname,ifd)

##########################################################
 #$%
 #$% Purpose:   GETSTA 
 #$%            
 #$%
 #$% Called By: PLOT
 #$%
 #$% Calls:     TYPERR    ENDR4
 #$%            SMOVHN              SMOV
 #$%
 #$% Tables:  STA  
 #$%            
 #$% Date:      MAY 83
 #$%
 #$% Author:    ADAMOS T
 #$%
 ##########################################################

BBcommon
integer             ista, i, ctoi
character           megname[10]
#external            plot$_INVSTANUM,
#                    plot$_INVVIEW

VaxCharacter*64     Args[3], Params
Integer*4           Arg_Len[3]  

integer II,
        IFD,
        IVIEW                   # MJC 5/31/2K (E2145)
BBDeclare  (STA$Pointer,
            STA$Geodisp$C)          # MJC 5/31/2K (E2145)
literal CSTRIP8                 # MJC 5/31/2K (E2145)

call read_arguments (3, Args, Arg_Len, Params) # read the command line

if (args[1] != " ")                             # dew 9/16/91
    {
    i = 1 
    ista = ctoi (%%ref(args[1]),i)
    }

STA$Pointer$to ista                             # setup STA$POINTER

if (! sta$pointer$valid)                        # ok? 
    {
    ista = 0
    call echoV ("Invalid Station Number")
    call echor
    call endr4                              # close files and terminate program
    call exit (2)
    }

iview = Xsta$View$i                             # setup IVIEW

if (iview < $First$View | iview > $Last$View)
    {
    #$% generate network error message
    call echoV ("Invalid Station View")
    call echor
    #$% close files and terminates program
    call endr4
    call exit (2)
    }

STA$GeoDisp$C = xSTA$GeoDisp$C                  # setup MEGNAME
ii  = 0
if (args[2] != " ")                             # dew 9/16/91
    {
    call smovvn (args[2], megname,ii)
    }
else
    {
    call smovhn (STA$GeoDisp$C,8, megname,ii)
    }
call smov   (EOS,             megname,ii)

ifd = 0


end



Subroutine Plot_Up (IX_sta, nmap, iside)                #main control

##########################################################
 #$%
 #$% Purpose:   PLOT_UP determines the plot generation
 #$%            subroutines to be executed for the re-
 #$%            quired display.
 #$%
 #$% Called By: PLOT
 #$%
 #$% Calls:     BINSET          SMOVIZ          DRAW_CENTER_C
 #$%            PLOT_BASES      PLOT_TRUE       PLOT_OWN
 #$%            PLOT_ESM_SONAR  PLOT_SOSUS      Plot_RECTANGLES
 #$%            PLOT_CIRCLES    PLOT_GRID       PLOT_XMARK      
 #$%            PLOT_SONAR      DRAW_DONE       PLOT_ReMoTe
 #$%            PLOT_MRKWB      PLOT_ENVELOPES  PLOT_LIDAR
 #$%            Plot_SPAs       PLOT_HIDE_SITE  Plot_NRTs
 #$%            Plot_ALSP_Ground_Data
 #$%
 #$% Tables:    STA
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Carol Kropp - 12/92  (E1036)
 #$%            Added entry Plot_Up_Copy_Entry for when a
 #$%            control station is plotting another's geo.
 #$%            Modifications permit the control station to
 #$%            relocate the center as well as change the
 #$%            radius of the display.  If control is plotting
 #$%            another station's geo - the center location
 #$%            and radius of plot are stored in the control
 #$%            station's STA slot.
 #$%
 #$%            Susan Miller 5/95 (E1405)
 #$%            PIMs were not plotting because the conditional
 #$%            statement was checking that STA$PlotFriendly$I &
 #$%            STA$PlotFriendlySurf$I were 1 when they were greater
 #$%            than 1.
 #$%
 #$%            Jim Allen - 12/97 (E1825)
 #$%            Added plot tech control label.
 #$%
 #$%            Jim Allen - 2/98 (E1864)
 #$%            To improve efficiency changed PlotPIM to
 #$%            PlotPIMIndx and added the cruise missile
 #$%            mission plotting.
 #$%
###########################################################

BBcommon
PLOTcommon

integer I_COPY_ENTRY_CALLED,
        IX_STA,
        NMAP,
        ISTATION_HOLD,
        ICONTROL_STAT,
        LEN,
        ISIDE,
        KK,
        KKK,
        IVIEW,
        ISTA                        # MJC 5/31/2K (E2145)

BBDeclare  (STA$Pointer,
			STA$Side$I,
            STA$View$I,
            STA$Symbology$I,
            STA$Latitude$F,
            STA$Longitude$F,
            STA$Plotradius$I,
            STA$Label$I,
            STA$Plotchaff$I,
            STA$Plotsonobuoy$I,
            STA$Plotpimindx$I,
            STA$Plancmuntindx$I,
            STA$Satindx$I,
            RVU$Pointer,
            UNT$Pointer)            # MJC 5/31/2K (E2145)

literal CSTRIP                      # MJC 5/31/2K (E2145)


real*4          LAT,                    ## latitude for center plot
                LON                     ## longitude for center plot
integer         Game_DTG,               ## function to produce Day Time Group
		Game_DTGs,
                RADIUS,                 ## current radius of plot
                MAP                     ## Flag if map should be drawn

character       buf[30], Day_Nite[30]

string          TIME[20] "000000"                       

i_copy_entry_called = $no       # clk 12/92 - (E1036)
repeat                          # added entry point so that the     # E2143 dew 10/99
  {                             # control's station STA index is known
   break
   entry Plot_Up_Copy_Entry (IX_sta, nmap, iside, icontrol_stat)
   i_copy_entry_called = $yes
  }

STA$Pointer$To ix_sta

if (! sta$pointer$valid) return

STA$View$I = xSTA$View$I                ## extract current view
STA$Side$I = xSTA$Side$I                ## extract station logon side

if (nmap != NO) 
    {
    MAP = YES                           ## if new map requested
    }
else
    {
    MAP = NO
    }

if (Xsta$PlotRivers$i     != NO) $setbit(MAP,$Map$Rivers)
if (Xsta$PlotBoundaries$i != NO) $setbit(MAP,$Map$Boundaries)
if (Xsta$PlotTerrain$i    != NO) $setbit(MAP,$Map$Terrain)

STA$Symbology$I = xSTA$Symbology$I      # joa 7/96 (E1602)
call MVBITS (STA$Symbology$I, 0, $Symbology$NumBits,
             MAP, $Symbology$BasePos)

if (i_copy_entry_called == $no)
  {
   STA$Latitude$F   = xSTA$Latitude$F           ## get center latitude
   STA$Longitude$F  = xSTA$Longitude$F          ## get center longitude
   STA$PlotRadius$I = max(1,xSTA$PlotRadius$I)  ## get plot radius
  }
else          # clk 12/92 (E1036) - If a control station is plotting
  {           # another's geo, then get the center & radius from the
   istation_hold = STA$Pointer                    # control STA slot
   STA$Pointer$To  (icontrol_stat)
   STA$Latitude$F   = xSTA$CopyLatitude$F           ## get center latitude
   STA$Longitude$F  = xSTA$CopyLongitude$F          ## get center longitude
   STA$PlotRadius$I = max(1,xSTA$CopyPlotRadius$I)  ## get plot radius
   STA$Pointer = istation_hold
  }

RADIUS = STA$PlotRadius$I

call Binset (_                          ## set display bin parameters
             STA$Latitude$F,            ## pass center latitude
             STA$Longitude$F,           ## pass center longitude
             STA$PlotRadius$I)          ## pass plot radius

call Select_Set (STA$Pointer)

LAT = STA$Latitude$F * 180 /$PI         ## convert latitude and longitude
LON = STA$Longitude$F * 180 /$PI        ## to degrees

len=0
Call smoviz (Game_DTGs(game$time), 8, TIME, len)      ## get Day Time Group
call smovv ('z (', TIME, len)
Call smovi (int(imin),               TIME, len)      ## game minute
call smovv (') ', TIME, len)

call Draw_CENTER_C (LAT, LON, MAP, RADIUS, TIME)  ## output new map

call Day_Nite_Time (STA$Latitude$F, STA$Longitude$F, Day_Nite)  ## tpa 7/26/83

call Draw_TEXT_C ($Line$DayNite, Day_Nite, $Color$Text) ## tpa 7/26/83

#______________________________________________________________________
#

if (iside == YES)
    {
    kk = 0
    if (STA$View$i < $FirstBlue$view)
        {
        if (xSTA$TechControlFlag$I == $yes)     # joa - 12/97 (E1825)
            call smovv ("TECH CONTROL",buf,kk)
        else if (sta$Side$i == $Control$code)
	            call smovv ("CONTROL",buf,kk)
		else
	            call smovv ("NEUTRAL",buf,kk)
        }
    else 
        {
        if (STA$View$i < $FirstOrange$view)
            {
            call smovv ("BLUE",buf,kk)
            kkk = sta$view$i - $FirstBlue$view + 1
            }
        else
            {
            call smovv ("ORANGE",buf,kk)
            kkk = sta$view$i - $FirstOrange$view + 1
            }
        call smovi (kkk,buf,kk)
        }
    
    call smov (EOS,buf,kk)
    
    call Draw_text_c ($line$view, buf, $color$text)
    }

#______________________________________________________________________

call cg_clear                           ## Clear char grid for declutter
RVU$Pointer$To  STA$View$I              ## for the view specified
ctkcd = xRVU$TrackCode$C                ## get track code for view

STA$Label$I = xSTA$Label$I
iview       = xSTA$View$I
ista        = ix_sta

call Plot_Bases (iview,Sta$Pointer,xSTA$PlotGhostGroundBase$I)
call Plot_hide_sites (iview,Sta$Pointer)

if (STA$Side$I == $Control$code) 
    {
    call Plot_True (STA$Pointer)

    call Plot_MrkWB (iview, ista, STA$Pointer)

    STA$PlotChaff$I    = xSTA$PlotChaff$I
    STA$PlotSonobuoy$I = xSTA$PlotSonobuoy$I

    if (STA$PlotSonobuoy$I == YES | STA$PlotChaff$I == YES)
        {
        call Plot_All_Barrier (STA$View$I,STA$PlotChaff$I,STA$PlotSonobuoy$I) 
        }
    }
else
    {
    call Plot_Own (iview, STA$Label$I, STA$pointer)

    call Plot_Remote (iview, STA$Label$I, STA$pointer)

    if (xSTA$PlotEoir$I == YES) 
        call Plot_EOIR (iview, STA$Label$I, STA$pointer)

#    if (xSTA$Envelopes$I == YES) 
#        call Plot_Envelopes (iview, xSTA$EnvelopeSource$I, xSTA$EnvRadius$I)

    call Plot_MrkWB (iview, ista, STA$Pointer)

    if (xSTA$PlotSonar$I != $NO | xSTA$PlotESM$I != $NO | xSTA$EERnum$i != 0
        | xSta$PlotESMJam$I != $NO)  # JFR 7/26/94 - plot only esm due to jammers
        call Plot_Esm_Sonar (STA$Pointer)       # (alternative NOT $yes!) 

    STA$PlotChaff$I = xSTA$PlotChaff$I
    if (STA$PlotChaff$I == YES)
        {
        call Plot_Chaff_Barrier (STA$View$I)
        }

    STA$PlotSonobuoy$I = xSTA$PlotSonobuoy$I
    if (STA$PlotSonobuoy$I == YES)  
        {
        call Plot_Sonob_Barrier (STA$View$I)
        }
    }

if (xSTA$PlotMineFields$I == YES | Xsta$PlotGhostMinefield$I == $YES)
    call Plot_Minefields (sta$pointer)   # 6/89

if (Xsta$PlotGhostSweepArea$I == $YES)
    call Plot_SweepAreas (sta$pointer)

call Plot_RadarCoverages (sta$pointer)

if (xSTA$PlotSonarReg$I == YES) call Plot_Sonar_reg ## plot sonar env regions

if (xSTA$PlotLIDAR$I == YES) call Plot_LIDAR  ## plot LIDAR regions

if (xSTA$PlotSWABS$I == YES) call Plot_SWABS (sta$pointer)     # 3/7/91

if (xSTA$PlotLINES$I == YES)             # jb                        11/14/89
    {
    call Plot_LINEseq (STA$Pointer)     ## plot POLYGONS / LINEseq.  11/14/89
    }

if (STA$View$I <= $LastBlue$View & xSTA$PlotSosus$I == YES)
    call Plot_Sosus 

STA$PlotPimIndx$i = xSTA$PlotPimIndx$i    # PIM index is stored vice
if (STA$PlotPIMINdx$i != 0)               # the PIM name - joa 2/98 (E1864)
    {
    unt$pointer$to STA$PlotPimIndx$i 
    call Plot_Pim_Lines (STA$Pointer, unt$pointer)   ## plot pim LINES
    }

STA$PlanCMUNTIndx$i = XSTA$PlanCMUNTIndx$i   # added the CM mission
if (STA$PlanCMUNTIndx$i != 0)                # planning - joa 2/98 (E1864)
    {
    unt$pointer$to STA$PlanCMUNTIndx$i
    call Plot_Pim_Lines (STA$Pointer, unt$pointer)   ## plot plan cm pim LINES
    }

# SMM 5/95 PIMs were not plotting because these values were greater than 1.
if (xSTA$PlotFriendly$I != NO | xSTA$PlotFriendlySurf$I != NO)
    {
    call Plot_Pim_Marks(iview,STA$Label$I,STA$Pointer) ## plot pim position
    }

call Plot_RECTANGLES(STA$Pointer)       ## plot for (BLUE + CONTROL)

call Plot_ELLIPSES(STA$Pointer)         ## plot ellipses

call Plot_Circles(STA$Pointer)          ## plot circle to station

call Plot_Xmarks (STA$Pointer)          ## plot x-mark to station

call Plot_Grids (STA$Pointer)           ## plot grids

putSTA$RothrNewOrder$i ($yes)
call Plot_Rothr (STA$Pointer)           ## plot rothr

call Plot_Routes ( STA$Pointer )

call Plot_SPAs ( STA$Pointer )          # clk 10/91

call Plot_LandingZones ( STA$Pointer )

call Plot_NRTs (iview, ista) # SMM 12/92  PER #E1101

call Plot_ALSP_Ground_Data (STA$Pointer)    # clk 9/95 (E1456)

if (Nuclear$capable == YES)             ## nuclear capable scenario   4/29/85
    {
    call Plot_Nuclear (STA$Pointer)     ## plot blast and circle

    call delay (5000)                   ## delay 5 seconds

    #No longer exists
    #call set_bkgrnd($NO)
    }

STA$SatIndx$I = xSTA$SatIndx$I

if (STA$SatIndx$I > 0) call Plot_Survsat(STA$Pointer)  ## plot survsat

#-------------------------------------------------------------------------
# khc 12/92 - PER E1066
# Plot [SURVSAT | HFDF | SWABS | SOSUS] DETECTION [ALL (tracks) | TRACK <track-no>]

if (xSTA$PlotAllSurvSat$I > 0 & xSTA$PlotSurvSatTrk$I == YES)           # Plot SurvSat ALL
  call Pl_All_SurvSat_Trk(sta$pointer)

if (xSTA$PlotAllHFDF$I > 0 & xSTA$PlotHFDFTrk$I == YES)                 # Plot HFDF ALL
  call Pl_All_HFDF_Trk(sta$pointer)

if (xSTA$PlotAllSwabs$I > 0 & xSTA$PlotSwabsTrk$I == YES)               # Plot Swabs ALL
  call Pl_All_Swabs_Trk(sta$pointer)

if (xSTA$PlotAllSosus$I > 0 & xSTA$PlotSosusTrk$I == YES)               # Plot Sosus ALL
  call Pl_All_Sosus_Trk(sta$pointer)

call Pl_WideAreaSurv_Trk(sta$pointer) # Plot SurvSat, HFDF, Swabs, and Sosus Tracks


call Plot_Persistent_Munitions (STA$Pointer)  # clk 1/97 (E1731)
#-------------------------------------------------------------------------

call Draw_Done

return
end



Subroutine Plot_True (STA$Pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_TRUE displays objects for Control.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     SMOV    SMOVH           DRAW_UNIT_C
 #$%
 #$% Tables:    UNT        
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Carol Kropp - 1/94
 #$%            Added Station Ability to PLOT/ERASE ghosted
 #$%            units (ALSP/DIS).
 #$%
 #$%            Jonathan Richardson - 5/21/94 (E1064/E1435)
 #$%            Plot cruise missiles in a different color.
 #$%
 #$%            Carol Kropp - 9/95 (E1456)
 #$%            Extended the PLOT/ERASE ability for ghosts.
 #$%
 ##########################################################


BBcommon
PLOTcommon
Select_Common
Select_Common_Data

integer         COLOR,                          ## color of synbol
                SELECT_dup,                     ## check unit to be plotted
                DRAW_UNIT_C,
                BINCK,                          ## check unit within lat lon
                TYPE
integer*4       SPEED

real*4          LAT,                            ## latitude of unit
                LON,                            ## longitude of unit
                LENGTH,                         ## NTDS speed vector length
                BEARING,                        ## NTDS speed vector heading
                COURSE
character       NAME1[20],                      ## unit name
                NAME2[ARB]                      ## unit name 2

integer ISTA,
        ID,
        IDUMMY,
        ITYPE,
        ISIDE,
        NTDS,
        ISINK,
        NN,
        N2,
        ISTAT,
        INFO                                     # MJC 5/31/2K (E2145)

integer X1,
        X2,
        X3                                       # MJC 5/31/2K (E2145)

literal CSTRIP8                                  # MJC 5/31/2K (E2145)

BBDeclare  (STA$Plotspeedair$I,
            STA$Pointer,
            STA$Plotspeedship$I,
            STA$Plotghostair$I,
            STA$Plotghostsubsurface$I,
            STA$Plotghostsurface$I,
            STA$Plotmissileobject$I,
            STA$Label$I,
			STA$PlotLabelDeclutter$I,
            UNT$Pointer,
            UNT$Status$I,
            UNT$Ghostedunit$I,
            UNT$Type$I,
            UNT$Truelatitude$F,
            UNT$Truelongitude$F,
            UNT$Truespeed$F,
            UNT2$Pointer,
            tbl$Pointer)                         # MJC 5/31/2K (E2145)

STA$plotspeedair$i  = xSTA$plotspeedair$i
STA$plotspeedship$i = xSTA$plotspeedship$i

STA$PlotGhostAir$I        = xSTA$PlotGhostAir$I           # clk 9/95 (E1456)
STA$PlotGhostSubsurface$I = xSTA$PlotGhostSubsurface$I    # clk 9/95 (E1456)
STA$PlotGhostSurface$I    = xSTA$PlotGhostSurface$I       # clk 9/95 (E1456)

STA$PlotMissileObject$I = xSTA$PlotMissileObject$I 

ista = STA$Pointer

STA$Label$I = xSTA$Label$I
STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I

for (UNT$Pointer$First; UNT$Pointer$Valid; UNT$Pointer$Next)  
    {
    if (XUNT$InUse$I == $NO) next 

    ID         = UNT$Pointer$Index                      ## unit identification
    UNT$Status$I = xUNT$Status$I                ## get unit status

    if (UNT$Status$I == $AcAwaitingLaunch$Code) next 

    if(UNT$Status$I == $BeingDeleted$Code)
        {
        next
        }

    UNT$GhostedUnit$I = xUNT$GhostedUnit$I
    if (UNT$GhostedUnit$I == $yes)          # clk 1/94
      {                                     # allows option plotting of ghosts
       UNT$Type$I = xUNT$Type$I             # check to see if station wants this type
       if ((STA$PlotGhostAir$I == $yes & (UNT$Type$I == $Air$Code |
                                          UNT$Type$I == $CruiseMissile$Code)) |
           (STA$PlotGhostSubsurface$I == $yes & UNT$Type$I == $Sub$Code)      |
       (STA$PlotGhostSubsurface$I == $yes & xUNT$SuperType$i == $Torpedo$SuperCode)      |
           (STA$PlotGhostSurface$I == $yes & UNT$Type$I == $Surface$Code)     )
         idummy = SELECT_dup (UNT$Pointer,itype,iside,COLOR)
       else
         next
      }
    else if (SELECT_dup(UNT$Pointer,itype,iside,COLOR) == NO) #should unit be ploted
        next

    UNT$TrueLatitude$F  = xUNT$TrueLatitude$F   ## extract unit latitude
    UNT$TrueLongitude$F = xUNT$TrueLongitude$F  ## and longitude

    if (BINCK (UNT$TrueLatitude$F, UNT$TrueLongitude$F) == NO) next 

    # (E1064/E1435) color of cruise missiles are different - JFR 5/21/94
    if (xUNT$Type$I == $CruiseMissile$Code)
       COLOR = $Color$CruiseMissile

    NTDS       = NTDS_Symbol[itype,iside]               ## symbol type
    LAT        = UNT$TrueLatitude$F  * 180/ $PI         ## convert to degrees
    LON        = UNT$TrueLongitude$F * 180/ $PI    
    COURSE     = xUNT$TrueCourse$F   * 180/ $PI         ## conv crs to deg
    SPEED      = xUNT$TrueSpeed$F                       ## conv flt to int
    TYPE       = xUNT$Type$I 

    isink = NO

    if (UNT$Status$I == $Sinking$Code | UNT$Status$I == $BeingDeleted$Code)
        {
        if (iside == $$$Orange) COLOR = $color$obj$sink$O
        else                    COLOR = $color$obj$sink$B

        isink = YES
        }

    if (STA$Label$I == YES)                     ## if labels are requested
        {
        nn = 0

        if (isink == YES)  call smovv ('!',NAME1, nn)    ## set code for blink

        call smovhn (xUNT$Name$C, $$MaxLit, NAME1, nn)
        call smov  (EOS,            NAME1, nn)

        n2 = 0
        if (UNT$GhostedUnit$I == $yes)               
            call smovv  ("GHOST-",NAME2,n2) 
           
        call Get_Characteristic_Pointer (UNT$Pointer, TBL$Pointer)
	if (TBL$Pointer == 0) next			# Avoid 0 pointrer
        call smovhn (xTBL$Name$C, $$MaxLit, name2, n2)
        call smov   (EOS,NAME2,n2)    

        }
    else                                        ## no labels
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                      NAME2, COLOR, COURSE,
                      SPEED, TYPE, x1, 
                      x2, x3, 
                      INFO)

    if (istat == NO) continue
    else if (STA$plotspeedair$i == YES & itype == $$$Air)
      {
       BEARING = xUNT$TrueCourse$F * 180/ $PI      #convert radians to degrees
       LENGTH  = 40.0 * int(xUNT$TrueSpeed$F / 200 + 0.5)
       call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
      }
    else if ((STA$plotspeedship$i == YES & itype != $$$Air) &
             (itype != $$$Miss))    # and not an advanced SAM  SMM 2/94
      {
       BEARING = xUNT$TrueCourse$F * 180/ $PI       #convert radians to degrees
#       LENGTH  = 40.0 * int(xUNT$TrueSpeed$F / 7 + 0.5) commented 12/90,reh

        #$% set speed "vectors" for torpedos in circle search, 12/90
        if (xUNT$SuperType$i == $Torpedo$SuperCode)
            {
            UNT$TrueSpeed$F = xUNT$TrueSpeed$F 
            if (UNT$TrueSpeed$F > 0.0 &
                UNT$TrueSpeed$F < $MinTorp_PlotSpeed)
                {
                SPEED = $MinTorp_PlotSpeed
                }
            }

       LENGTH  = 40.0 * Speed / 7.0 + 0.5
       call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
      }

     # if this is a SAM and it has an assigned target that is not
     # being deleted, then draw a pairing line
     if ((xUNT$Type$I == $SAMissile$Code) & 
         (xUNT$AssignedTarget$I != 0))
        {
         # get the assigned target
         UNT2$Pointer$To xUNT$AssignedTarget$I

         # as long as the target is not being deleted
         # draw the pairing line
         if (xUNT2$Status$I != $BeingDeleted$Code)
             call Draw_SAM_pairing_line(UNT$Pointer,UNT2$Pointer,
                                        LAT,LON)        # SMM 3/28/95
        }

    } # end of loop through UNT table

return
end # Plot_True 




Integer Function SELECT_dup (UNT$Pointer,itype,iside,icolor)

##########################################################
 #$%
 #$% Purpose:   SELECT_DUP Validates if unit should be
 #$%            plotted on display.
 #$%
 #$% Called By: PLOT_TRUE
 #$%
 #$% Calls:     
 #$%
 #$% Tables:    UNT       
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Susan Miller 1/94 added SAM
 ##########################################################

BBcommon
Select_common

integer ITYPE,
        ISIDE,
        ICOLOR                              # MJC 6/1/2K (E2145)
BBDeclare  (UNT$Type$I,
            UNT$Pointer,
            SHC$Pointer,
            UNT$Supertype$I,
            UNT$View$I)                     # MJC 6/1/2K (E2145)

SELECT_DUP = NO

UNT$Type$I = xUNT$Type$I 

if (UNT$Type$I == $Shorebase$Code) return

if      (UNT$Type$I == $Air$Code          | 
         UNT$Type$I == $CruiseMissile$Code)             itype = $$$Air

else if (UNT$Type$i == $Sub$Code)                       itype = $$$Sub

else if (UNT$Type$I == $Surface$Code)
{
    Shc$pointer = Xunt$SHCPntr$i
 
    if (Xshc$domain$i == $LandOp$code)                  itype = $$$Vehicle
    else                                                itype = $$$Surf
}

else if (UNT$Type$I == $SAMissile$Code)                 itype = $$$MISS

else                                                    return

UNT$SuperType$I = xUNT$SuperType$I 
if (UNT$SuperType$I == $SmallBoat$SuperCode )           itype = $$$Boat

UNT$View$I = xUNT$View$I 

if      (UNT$View$I == $Neutral$View )
    {
    iside  = $$$Neutral
    icolor = $Color$Obj$Neutral
    }
else if (UNT$View$I <= $LastBlue$View)
    {
    iside = $$$Blue
    icolor = $Color$Obj$Blue
    }    
else
    {
    iside = $$$Orange
    icolor = $Color$Obj$Orange
    }

return (select_mask[itype,iside])
end



Subroutine Plot_Own (iview, STA$Label$I, STA$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_OWN validates if unit should be plotted
 #$%
 #$% Called By: PLOT_ASSUMED
 #$%
 #$% Calls:     BINCK   SELECT_OWN     
 #$%
 #$% Tables:    OWN        UNT  STA
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Carol Kropp - 1/94
 #$%            Added Station Ability to PLOT/ERASE ghosted
 #$%            units (ALSP/DIS).
 #$%
 #$%            Jonathan Richardson - 5/21/94 (E1064/E1435)
 #$%            Plot cruise missiles in a different color.
 #$%
 #$%            Carol Kropp - 9/95 (E1456)
 #$%            Extended the PLOT/ERASE ability for ghosts.
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_Common

integer         COLOR,                          ## color of synbol
                SELECT_OWN,                     ## check unit to be plotted
                BINCK,                          ## check unit within lat lon
                DRAW_UNIT_C,
                iview,
                TYPE
integer*4       SPEED

real*4          LAT,                            ## latitude of unit
                LON,                            ## longitude of unit
                LENGTH,                         ## NTDS speed vector length
                COURSE,
                BEARING                         ## NTDS speed vector heading
character       NAME1[20],                      ## unit name
                NAME2[20]                       ## unit name 2

BBDeclare  (STA$Plotspeedair$I,
            STA$Pointer,
            STA$Plotspeedship$I,
            STA$Plotghostair$I,
            STA$Plotghostsubsurface$I,
            STA$Plotghostsurface$I,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)
BBDeclare  (OWN$Pointer,
            OWN$View$I,
            OWN$Status$I,
            OWN$Latitude$F,
            OWN$Longitude$F,
            OWN$Speed$I,
            TBL$Pointer,
            UNT$Ghostedunit$I,
            UNT$Type$I,
            UNT$Pointer,
            UNT2$Pointer)                   # MJC 6/1/2K (E2145)
integer ID,
        IDUMMY,
        ITYPE,
        ISIDE,
        NTDS,
        ISINK,
        N1,
        INFO,
        N2,
        ISTAT                               # MJC 6/1/2K (E2145)

literal CSTRIP8                             # MJC 6/1/2K (E2145)

integer X1,
        X2,
        X3                                  # MJC 6/1/2K (E2145)

STA$plotspeedair$i  = xSTA$plotspeedair$i
STA$plotspeedship$i = xSTA$plotspeedship$i

STA$PlotGhostAir$I        = xSTA$PlotGhostAir$I           # clk 9/95 (E1456)
STA$PlotGhostSubsurface$I = xSTA$PlotGhostSubsurface$I    # clk 9/95 (E1456)
STA$PlotGhostSurface$I    = xSTA$PlotGhostSurface$I       # clk 9/95 (E1456)
STA$PlotLabelDeclutter$I  = xSTA$PlotLabelDeclutter$I
for (OWN$Pointer$First; OWN$Pointer$Ok; OWN$Pointer$Next)
    {
    OWN$View$I = xOWN$View$I                    ## get units view

    if (OWN$View$I != iview)  next              ## if not same view 

    ID     = OWN$Pointer$Index + UNT$Slots      # UNT           7/8/86
    UNT$Pointer$To xOWN$Unit$I

    if(xUNT$Status$I == $BeingDeleted$Code)
        {
        next
        }

    OWN$Status$I = xOWN$Status$I                ## get unit status

    OWN$Latitude$F  = xOWN$Latitude$F
    OWN$Longitude$F = xOWN$Longitude$F

    if (BINCK (OWN$Latitude$F,OWN$Longitude$F) == NO) next

    UNT$GhostedUnit$I = xUNT$GhostedUnit$I
    if (UNT$GhostedUnit$I == $yes)          # clk 1/94
      {                                     # allows option plotting of ghosts
       UNT$Type$I = xUNT$Type$I             # check to see if station wants this type
       if ((STA$PlotGhostAir$I == $yes & UNT$Type$I == $Air$Code)        |
           (STA$PlotGhostSubsurface$I == $yes & UNT$Type$I == $Sub$Code) |
           (STA$PlotGhostSurface$I == $yes & UNT$Type$I == $Surface$Code))
         idummy = SELECT_OWN (OWN$Pointer,itype,iside,COLOR)
       else
         next
      }
    else if (SELECT_OWN (OWN$Pointer,itype,iside,COLOR) == NO) # unit be ploted
        next

    # (E1064/E1435) color of cruise missiles are different - JFR 5/21/94
    if (xOWN$Type$I == $CruiseMissile$Code)
       COLOR = $Color$CruiseMissile

    NTDS   = NTDS_Symbol[itype,iside]
    LAT    = OWN$Latitude$F  * 180/ $Pi 
    LON    = OWN$Longitude$F * 180/ $Pi
    COURSE = xOWN$Course$I 
    SPEED  = xOWN$Speed$I
    TYPE   = xOWN$Type$I

    isink = NO

    if (OWN$Status$I == $Sink$Status)
        {
        if (iside == $$$Orange) COLOR = $color$obj$sink$O
        else                    COLOR = $color$obj$sink$B

        isink = YES
        }

    if (STA$Label$I == $YES)                    ## if labels requested
        {
        n1 = 0

        if (isink == YES)  call smovv ('!',NAME1,n1) # insert code to make blink
    
        call smovhn(xUNT$Name$C,$$maxlit,NAME1,n1)  ## #insert name of unit
        call smov  (EOS,          NAME1,n1)    

        n2 = 0
        # if ghosted unit, fill name2
        if (UNT$GhostedUnit$I == $YES)
           {                
            call smovv("GHOST",NAME2,n2) 
            call smov (EOS,NAME2,n2)    
           }
        else
          {                
            call Get_Characteristic_Pointer (UNT$Pointer, TBL$Pointer)
            call smovhn (xTBL$Name$C, $$MaxLit, name2, n2)
            call smov   (EOS,NAME2,n2)    
           }
        }
    else
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                      NAME2, COLOR, COURSE,
                      SPEED, TYPE, x1, 
                      x2, x3, 
                      INFO)

    if (istat == NO) continue
    else if (STA$plotspeedair$i == YES & itype == $$$Air)
      {
       BEARING = xOWN$Course$I
       LENGTH  = 40.0 * int(xOWN$Speed$I / 200.0 + 0.5)
       call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
      }
    else if ((STA$plotspeedship$i == YES & itype != $$$Air) &
             (itype != $$$Miss))    # and not an advanced SAM  SMM 2/94
      {
       BEARING = xOWN$Course$I
#       LENGTH  = 40.0 * int(xOWN$Speed$I / 7 + 0.5) commented out 12/90,reh

        #$% set speed "vectors" for torpedos in circle search, 12/90
        if (xOWN$SuperType$i == $Torpedo$SuperCode)
            {
            OWN$Speed$i = xOWN$Speed$i 
            if (OWN$Speed$i > 0.0 &
                OWN$Speed$i < $MinTorp_PlotSpeed )
                {
                SPEED = $MinTorp_PlotSpeed
                }
            }

       LENGTH  = 40.0 * Speed / 7.0 + 0.5
       call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
      }

     # if this is a SAM and it has an assigned target that is not
     # being deleted, then draw a pairing line
     if ((xUNT$Type$I == $SAMissile$Code) & 
         (xUNT$AssignedTarget$I != 0))
        {
         # get the assigned target
         UNT2$Pointer$To xUNT$AssignedTarget$I

         # as long as the target is not being deleted
         # draw the pairing line
         if (xUNT2$Status$I != $BeingDeleted$Code)
             call Draw_SAM_pairing_line(UNT$Pointer,UNT2$Pointer,
                                        LAT, LON)       # SMM 3/28/95
        }
    }

return
end # Plot_Own



Subroutine Plot_Remote (iview, STA$Label$I, STA$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_REMOTE collects detection data and validates for 
 #$%            display to the specified view.
 #$%
 #$% Called By: PLOT_ASSUMED
 #$%
 #$% Calls:     BINCK   DRAW_UNIT_C
 #$%
 #$% Tables:    RMT     STA
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Jonathan Richardson - 5/21/94 (E1064/E1435)
 #$%            Plot cruise missiles in a different color.
 #$%
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_Common
$poly$styles

character       NAME1[20],
                NAME2[20]
integer         NTDS,
                COLOR,
                BINCK,
                label_id,
                DRAW_UNIT_C,
                SELECT_RMT,
                TYPE
integer*4       SPEED
real*4          LAT,
                LON,
                COURSE,
                LENGTH,                          ## NTDS speed vector length
                BEARING,                         ## NTDS speed vector heading
#                latitude,
#                longitude,
                hlat[arith(TRK$pos$slots,+,3)],
                hlon[arith(TRK$pos$slots,+,3)]
literal         a_track
VMSchar         ASTAB_Class*($$MaxName+1)

BBDeclare  (STA$Plotspeedair$I,
            STA$Pointer,
            STA$Plotspeedship$I,
            STA$Plottrackhistory$I,
            STA$Label$I,
			STA$PlotLabelDeclutter$I,
            RMT$Pointer,
            RMT$Lastdettime$F,
            RMT$Detectee$I,
            RMT$Detectiontype$I,
            RMT$Apparentlat$F,
            RMT$Apparentlon$F,
            RMT$Targetid$I,
            RMT$Detector$I,
            RMT$Acassignedto$I,
            RMT$Trkindx$I,
            RMT$Class$I)                                # MJC 6/1/2K (E2145)
BBDeclare  (UNT$Status$I,
            UNT$Pointer,
            TRK$Pointer,
            TRK$Nbrpoints$I,
            TRK$Firstpoint$I,
            TRK$POS$Index,
            OWN$Pointer,
            OWN$Mission$I,
            RVU$Pointer)                                # MJC 6/1/2K (E2145)
integer IVIEW,
        ILAST,
        ID,
        ITYPE,
        ISIDE,
        ISINK,
        N1,
        N2,
        ISTAT,
        INFO,
        GAME_TIME,
        INDX                                            # MJC 6/1/2K (E2145)
integer X1, X2, X3, poly_type
real    T2, G2                                          # MJC 6/1/2K (E2145)

STA$plotspeedair$i     = xSTA$plotspeedair$i
STA$plotspeedship$i    = xSTA$plotspeedship$i
STA$PlotTrackHistory$i = Xsta$plotTrackHistory$i 
STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

RVU$Pointer$To iview

RMT$Pointer$To xRVU$LastRmtIndx$I
ilast = RMT$Pointer

for (RMT$Pointer$To xRVU$FirstRmtIndx$I; RMT$Pointer<= ilast; RMT$Pointer$Next)
   {
    RMT$LastDetTime$F = xRMT$LastDetTime$F              # clk 11/96 (E1695)
    if (RMT$LastDetTime$F + Minutes$To$Old < imin)      # Don't plot tracks that are "old"...
      next                                              # tracks could still be on astab!

    ID     = RMT$Pointer$Index + OWN$Slots + UNT$Slots  # UNT   7/8/86
    RMT$Detectee$I = xRMT$Detectee$I            # jb - pairing  6/16/86
    UNT$Pointer$To RMT$Detectee$I               # jb - no "x"   6/16/86

    if(xUNT$Status$I == $BeingDeleted$Code)
        {
        next
        }

    RMT$DetectionType$I = xRMT$DetectionType$I

    if (RMT$DetectionType$I != $ActiveVisual$code    &
        RMT$DetectionType$I != $ActiveNonVisual$code ) next

    if(xrmt$ignore$i == $yes) next              # bearing dropped by CORMOD

    RMT$ApparentLat$F = xRMT$ApparentLat$F
    RMT$ApparentLon$F = xRMT$ApparentLon$F

    if (BINCK (RMT$ApparentLat$F,RMT$ApparentLon$F) == NO) next

    RMT$TargetId$I = xRMT$TargetId$I            ## get target ident
    RMT$Class$I    = xRMT$Class$I               ## get class

    if      (RMT$Class$I == $Sub$Code)     label_id = 'U'
    else if (RMT$Class$I == $Surface$Code) label_id = 'S'
    else if (RMT$Class$I == $Air$Code)     label_id = 'A'
    else                                   label_id = $blanki4
    

    if (SELECT_RMT (iview,RMT$Class$I,RMT$TargetId$I,itype,iside,COLOR) == NO) 
          next

    # (E1064/E1435) color of cruise missiles are different - JFR 5/21/94
    if (xUNT$Type$I == $CruiseMissile$Code)
       COLOR = $Color$CruiseMissile

    NTDS   = NTDS_Symbol[itype,iside]
    LAT    = RMT$ApparentLat$F * 180/ $PI       
    LON    = RMT$ApparentLon$F * 180/ $PI
    COURSE = xRMT$Course$I
    SPEED  = xRMT$Speed$I
    TYPE   = RMT$Class$I

    isink = NO

    UNT$Pointer$To RMT$Detectee$I ## 6/23/83 TPA 6/16/86 no "x" jb

    UNT$Status$I = xUNT$Status$I

    RMT$DetectionType$I = xRMT$DetecTiontype$I

    if (rmt$LastDetTime$f + Minutes$To$Yellow < imin)
        {
        COLOR = $Color$Obj$Fading
        }
#   else if (RMT$LastDetVisual$I == YES &                       ## tpa 11/4/83
    else if (Xrmt$LastDetType$i  == $Visual$Type &              ## DEW 2/1/91
             (UNT$Status$I       == $Sinking$Code      | 
              UNT$Status$I       == $BeingDeleted$Code))
        {
        if (iside == $$$Orange) COLOR = $color$obj$sink$O
        else                    COLOR = $color$obj$sink$B

        isink = YES
        }

    if (STA$Label$I == $YES)                    ## if labels requested
        {
        n1 = 0

        if (isink == YES)  call smovv ('!',NAME1,n1) # insert code to make blink
        call smovhn (a_track(ctkcd, label_id, xRMT$TrackNumber$I),
                     $$MaxLit,NAME1,n1)                     # DEW 11/99 (E2172)
        call smov  (EOS,NAME1,n1)    

        n2 = 0
        if (Track$Time$Tag == $ON)      # put up last detection time
            {
            call smoviz(Game_Time(rmt$LastDetTime$f),5,NAME2,n2)  # zulu time
            call smov  (EOS,                NAME2,n2)
            }
        else if (Track$Time$Tag == 2)   # random
            {
            call smovv ("00000",NAME2,n2)
            call smov  (EOS,                 NAME2,n2)
            }
        else                            # it's off, no time tags so put up class
            {
            call smovv (Astab_Class(RMT$Pointer),NAME2,n2) # Std Track Classification (E2183)
            call smov (EOS,                      NAME2,n2)    
            }
        }
    else
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    rmt$TRKindx$i = Xrmt$TRKindx$i

    istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                      NAME2, COLOR, COURSE,
                      SPEED, TYPE, x1, 
                      x2, x3, 
                      INFO)

    if (istat == NO) continue
    else if (STA$plotspeedair$i == YES & itype == $$$Air)
        {
        BEARING = xRMT$Course$I
        LENGTH  = 40.0 * int(xRMT$Speed$I / 200 + 0.5)
        call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
        }
    else if (STA$plotspeedship$i == YES & itype != $$$Air)
        {
        BEARING = xRMT$Course$I
        LENGTH  = 40.0 * int(xRMT$Speed$I / 7 + 0.5)
        call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
        }
    else if (STA$PlotTrackHistory$i == YES &
             rmt$TRKindx$i          != 0    )
        {
        trk$pointer$to rmt$TRKindx$i

        trk$NbrPoints$i  = Xtrk$NbrPoints$i
        trk$FirstPoint$i = Xtrk$FirstPoint$i

        indx = 0
        trk$pos$index = trk$FirstPoint$i

        repeat
            {
            indx = indx + 1
            hlat[indx] = Xtrk$pos$latitude$f * 180/ $PI         ## dew 1/13/84
            hlon[indx] = Xtrk$pos$longitude$f * 180/ $PI

            if (indx >= trk$NbrPoints$i) break

            trk$pos$index = trk$pos$index + 1
            if (trk$pos$index > trk$pos$slots) trk$pos$index = 1

            } # until (trk$pos$index == trk$FirstPoint$i)

        indx = indx + 1
        hlat[indx] = LAT
        hlon[indx] = LON

        ID = UNT$Pointer$Index
	poly_type = poly_line_style[$poly$History]
        call Draw_polygon_c (ID, hlat, hlon, -indx, COLOR, poly_type)
        }

#     if(itype == $$$Air)
    if(label_id == 'A' &        # jb - an airborne tgt to pair? 6/17/86
        level$AA > 1 & xSTA$PlotSonar$i !=$YES )       # jb >   9/19/90
     {
      RMT$acASSIGNEDto$I = xRMT$acASSIGNEDto$I  # jb - pairing  6/16/86
      if(RMT$acASSIGNEDto$I !=$NO & xRMT$CoverFlag$I ==$NO )
       {
        OWN$Pointer$TO (RMT$acASSIGNEDto$I)     #     pairing   8/19/86
        OWN$Mission$i = Xown$Mission$i          #        "      8/19/86
        if(OWN$Mission$i ==$Cap$Code | OWN$Mission$i ==$StrikeCap$Code |
           OWN$Mission$i == $SurveillanceCap$Code |     #       8/19/86
           OWN$Mission$I == $AirDefense$Code)           # clk 4/92
         {
          T2 = xOWN$Latitude$f  * 180./$PI      # jb - pairing  6/16/86
          G2 = xOWN$Longitude$f * 180./$PI      # jb - pairing  6/16/86

          RMT$Detector$I = xRMT$Detector$I      # jb - pairing  6/16/86

          call Draw_Line_C(LAT, LON, T2, G2, $color$obj$fading) #6/16/86
         }  # End if a/c has CAP-type mission..
       }  # End if track is assigned to an a/c  
     }  # End if track is airborne
   } #   End of loop thru RMT table

return
end



Integer Function SELECT_OWN (OWN$Pointer,itype,iside,icolor)

##########################################################
 #$%
 #$% Purpose:   SELECT_OWN Validates if unit should be
 #$%            plotted on display.
 #$%
 #$% Called By: PLOT_ASSUMED 
 #$%
 #$% Calls:     
 #$%
 #$% Tables:    OWN
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
Select_common

BBDeclare  (OWN$Type$I,
            OWN$Pointer,
            OWN$Supertype$I,
            OWN$View$I,
            UNT$Pointer,
            SHC$Pointer)

integer ITYPE,
        ISIDE,
        ICOLOR                                  # MJC 6/1/2K (E2145)

SELECT_OWN = NO

OWN$Type$I = xOWN$Type$I 

if      (own$TYPE$I == $Surface$CODE      )
{
    unt$pointer$to XOWN$Unit$i
    shc$pointer = Xunt$SHCPntr$i
    if (Xshc$domain$i == $LandOp$code)      itype = $$$Vehicle
    else                                    itype = $$$Surf
}
else if (OWN$Type$I == $Air$Code          ) itype = $$$Air
else if (OWN$Type$I == $CruiseMissile$Code) itype = $$$Air
else if (OWN$Type$i == $Sub$Code)           itype = $$$Sub
else if (OWN$Type$I == $SAMissile$Code)     itype = $$$MISS
else                                        return

Own$SuperType$I = xOwn$SuperType$I 
if (Own$SuperType$I == $SmallBoat$SuperCode ) itype = $$$Boat

OWN$View$I = xOWN$View$I 

if (OWN$View$I == $Neutral$View )
    {
    iside  = $$$Neutral
    icolor = $Color$Obj$Neutral
    }
else if (OWN$View$I <= $LastBlue$View)
    {
#    iside = $$$blue                # jb    8/15/91
    iside = $$$friendly
    icolor = $Color$Obj$Blue
    }    
else
    {
#    iside = $$$Orange                # jb    8/15/91
    iside = $$$friendly
    icolor = $Color$Obj$Orange
    }

return (select_mask[itype,iside])
end



Integer Function SELECT_RMT (iview, icat, id, itype, iside, icolor)

###########################################################
#$%
#$% Purpose:   SELECT_RMT determines display codes for
#$%            reported platforms.
#$%
#$% Called By: PLOT_REMOTE
#$%
#$% Calls:     None
#$%
#$% Tables:    RMT
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos
#$%
###########################################################

BBcommon
PLOTcommon
Select_common

integer ICAT,
        ITYPE,
        KSIDE,
        ID,
        ISIDE,
        ICOLOR,
        IVIEW                               # MJC 6/1/2K (E2145)

SELECT_RMT = NO

if      (icat == $ShoreBase$Code) return

     if (icat == $Air$Code )      itype = $$$Air
else if (icat == $Sub$code )      itype = $$$Sub
else                              itype = $$$Surf

kside = id

if (kside == $Enemy$Code)               # If enemy, set side and color
   {
   iside  = $$$Enemy
   icolor = $Color$Obj$Orange

   if (iview > $LastBlue$View)             #if seen by orange, reverse id's
        icolor = $color$obj$blue
   }
else if (kside == $Friendly$Code)       # If friendly, set side and color
   {
   iside  = $$$Friendly
   icolor = $Color$Obj$Blue

   if (iview > $LastBlue$View)             #if seen by orange, reverse color
        icolor = $color$obj$orange
   }
else if (kside == $Neutral$Code)   # clk 1/94 (E1096) - So that Neutral and Unknown
   {                               #                    are visually distinguishable
    iside  = $$$Neutral
    icolor = $Color$Obj$Neutral
   }
else                                    # Otherwise, it must be unknown
   {                                    # set side and color
   iside  = $$$Unknown
   icolor = $Color$Obj$Unknown
   }

return (select_mask[itype,iside])
end



Subroutine Plot_Bases (kview,STA$Pointer, plot_ghosts_flag)

##########################################################
 #$%
 #$% Purpose:   PLOT_BASE sets up plot data for all 
 #$%            shorebases that are to be plotted.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK   SMOVH   SMOV    DRAW_UNIT_C
 #$%            SELECT_BASES
 #$%
 #$% Tables:    STA     UNT
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Carol Kropp - 1/94
 #$%            Added Station Ability to PLOT/ERASE ghosted
 #$%            units (ALSP/DIS).
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_common

integer         plot_ghosts_flag

real*4          LAT, 
                LON,
                COURSE
integer         select_bases
integer*4       kview,kside,
                SPEED,TYPE,NTDS,
                itype,iside,istat,draw_unit_c,
                COLOR,
                BINCK
character       NAME1[20], NAME2[20]

BBDeclare  (UNT$Pointer,
            UNT$Ghostedunit$I,
            UNT$Truelatitude$F,
            UNT$Truelongitude$F,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)

integer IDUMMY,
        ID,
        INFO,
        NN                                      # MJC 6/1/2K (E2145)
integer X1, X2, X3                              # MJC 6/1/2K (E2145)
literal CSTRIP8                                 # MJC 6/1/2K (E2145)

if      (kview == $Neutral$View )   kside = $$$Neutral
else if (kview <= $LastBlue$View)   kside = $$$Blue
else                                kside = $$$Orange

STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
STA$Label$I = xSTA$Label$I

for (UNT$Pointer$First; UNT$Pointer$OK; UNT$Pointer$Next)  
    {                                           ## Search UNT table for
                                                ## all shorebases....

    UNT$GhostedUnit$I = xUNT$GhostedUnit$I
    if (UNT$GhostedUnit$I == $yes)          # clk 1/94
      {                                     # allows option plotting of ghosts
        if (plot_ghosts_flag == $no)
          next
        else
          {
           if (xUNT$Type$I == $Shorebase$Code)
             idummy = SELECT_bases(kside,UNT$Pointer,itype,iside,COLOR,NTDS)
           else next
          }
      }
    else if ( SELECT_bases(kside,UNT$Pointer,itype,iside,COLOR,NTDS) == NO ) next

    UNT$TrueLatitude$F  = xUNT$TrueLatitude$F   ## Get Lat/Long of base 
    UNT$TrueLongitude$F = xUNT$TrueLongitude$F

    if (BINCK (UNT$TrueLatitude$F, UNT$TrueLongitude$F) == NO) next

    ID     = UNT$Pointer$Index
    LAT    = UNT$TrueLatitude$F  * 180/$PI      ## Convert Lat to degrees
    LON    = UNT$TrueLongitude$F * 180/$PI      ## Convert Lon to degrees
    COURSE = 0.0
    SPEED  = 0
    TYPE   = xUNT$Type$I

    if (STA$Label$I == YES)
        {
        nn = 0                                  ## get name of base
        call smovhn (xUNT$Name$C,$$MaxLit,NAME1,nn)
        call smov  (EOS,          NAME1,nn)
    
        if (UNT$GhostedUnit$I == $YES)
          {                
           nn = 0
           call smovv ("GHOST", NAME2, nn)
           call smov  (EOS,     NAME2, nn)    
          }
        else
           NAME2[1] = EOS
        }
    else
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    istat = Draw_UNIT_C (NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                    NAME2, COLOR, COURSE,
                    SPEED, TYPE, x1, 
                    x2, x3, 
                    INFO)

    }                     

return
end



Integer Function SELECT_Bases (kside,UNT$Pointer,itype,iside,icolor,ntds)

#########################################################
#$%
#$% Purpose:    SELECT_Bases validates if a given base
#$%             should be plotted on the geo display.
#$%
#$% Called By:  PLOT_BASES
#$%
#$% Calls:      None
#$%
#$% Date:       JAN 1991
#$%
#$% Author:     C. Leaf
#$%
#########################################################

BBcommon
Select_common

integer*4 kside,
          itype,iside,icolor,ntds,
          UNT$Pointer

SELECT_Bases = NO

if (xUNT$Type$I != $Shorebase$Code) return

itype = $$$Land

if     (xUNT$View$I == $Neutral$View )
  {
   icolor = $Color$Obj$Neutral
   iside = $$$Neutral
  }
else if (xUNT$View$I <= $LastBlue$View)
  {
   icolor = $Color$Obj$Blue
   iside = $$$Blue

   if (kside == $$$Orange) iside = $$$Enemy
  }
else
  {
   icolor = $Color$Obj$Orange
   iside = $$$Orange

   if (kside == $$$Orange) iside = $$$Friendly
  }

ntds = $NTDS$Base

return (select_mask[itype,iside])
end




Subroutine Plot_All_Barrier (iview,ichaff,isonob)

##########################################################
 #$%
 #$% Purpose:   Chaff Barrires gets position of barriers for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_POLYGON_C
 #$%
 #$% Tables:    OWN        COR          BAR
 #$%
 #$% Date:      apr 17 84
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

real*4          LAT[COR$PT$Slots], LON[COR$PT$Slots]
integer         COLOR,
                BINCK

BBDeclare  (BAR$Pointer,
            BAR$Type$I,
            BAR$PT$Index,
            BAR$PT$lat$F,
            BAR$PT$lon$F)                               # MJC 6/1/2K (E2145)
integer ID,
        IVIEW,
        ICHAFF,
        ISONOB,
        ICNT                                            # MJC 6/1/2K (E2145)
integer poly_type #SMM 5/14 

for (BAR$Pointer$First; BAR$Pointer$Ok; BAR$Pointer$Next)
    {
    BAR$Type$I = xBAR$Type$I

    if (BAR$Type$I == $CHAFF$Code & ichaff == YES)      # jb 1/18/91
        {
        COLOR = $Color$Bar$Chaff
        }
    else if (BAR$Type$I != $CHAFF$Code & isonob == YES) # jb 1/18/91
        {
        COLOR = $Color$Bar$Sonar
        }
    else next

    icnt = 0                                    ## count points within BIN

    do BAR$Pt$Index = 1, BAR$PT$Slots           ## do for 4 points
        {
        BAR$Pt$Lat$F = xBAR$Pt$Lat$F
        BAR$Pt$Lon$F = xBAR$Pt$Lon$F

        icnt = icnt + BINCK (BAR$PT$Lat$F, BAR$PT$Lon$F) 

        LAT[BAR$Pt$Index] = BAR$Pt$Lat$F * 180/ $PI
        LON[BAR$Pt$Index] = BAR$Pt$Lon$F * 180/ $PI
        }                       

    if (icnt == NO) NEXT                        # no points within Plot Radius

    ID = 0

    # AV 9/94 (E1326):  Distinguish between chaff and sonobouy
    if (BAR$Type$I != $CHAFF$Code & isonob == YES) 
      {  
       # distinguish between pasive and active sonobouys  (E1326)
       if (BAR$Type$i == $PassiveBarrier$Code) 
         {
	  poly_type = poly_line_style[$Poly$Barrier] 
          call Draw_polygon_c (ID, LAT, LON, BAR$PT$Slots, COLOR, 
	       		      poly_type)
	 }
       else
         {
	  poly_type = poly_line_style[$Poly$ActBarrier]
          call Draw_polygon_c (ID, LAT, LON, BAR$PT$Slots, COLOR, 
	       		      poly_type)
	 }
      }
    else
      {
       poly_type = poly_line_style[$Poly$Barrier]
       call Draw_Polygon_c (ID, LAT, LON, BAR$PT$Slots, COLOR, 
       	    		   poly_type)
      }
    }

return
end


Subroutine Plot_Chaff_Barrier (iview)

##########################################################
 #$%
 #$% Purpose:   Chaff Barrires gets position of barriers for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_POLYGON_C
 #$%
 #$% Tables:    OWN        COR          BAR
 #$%
 #$% Date:      apr 17 84
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

real*4          LAT[COR$PT$Slots], LON[COR$PT$Slots]
real*4          cLAT[BAR$PT$Slots], cLON[BAR$PT$Slots]
integer         COLOR,
                BINCK

BBDeclare  (OWN$Pointer,
            OWN$Firstcorindx$I,
            COR$Nextindx$I,
            COR$Pointer,
            COR$Type$I,
            COR$PT$Index,
            COR$PT$lat$F,
            COR$PT$lon$F,
            BAR$Pointer,
            BAR$Type$I,
            BAR$CVU$Index,
            BAR$CVU$chaflg$I,
            BAR$PT$Index,
            BAR$PT$lat$F,
            BAR$PT$lon$F)                               # MJC 6/1/2K (E2145)
integer IVIEW,
        ICNT,
        ID                                              # MJC 6/1/2K (E2145)
integer poly_type  #SMM 5/14

COLOR = $Color$Bar$Chaff

for (OWN$Pointer$First; OWN$Pointer$Ok; OWN$Pointer$Next)
    {
    if (xOWN$View$I != iview)  next             # Get the right view

    OWN$FirstCorIndx$I = xOWN$FirstCorIndx$I

    COR$NextIndx$I     = OWN$FirstCorIndx$I

    while (COR$NextIndx$I != 0)
        {
        COR$Pointer$To COR$NextIndx$I           ## set to next point
        COR$NextIndx$I = xCOR$NextIndx$I

        COR$Type$I = xCOR$Type$I 

        if (COR$Type$I != $CHAFF$Code) next # jb  $CHAFF        1/18/91

        icnt = 0                                # count points within BIN

        do COR$Pt$Index = 1,COR$PT$Slots        #do for N points
            {
            COR$Pt$Lat$F = xCOR$Pt$Lat$F
            COR$Pt$Lon$F = xCOR$Pt$Lon$F

            icnt = icnt + BINCK (COR$pt$Lat$F, COR$pt$Lon$F) 

            LAT[COR$Pt$Index] = COR$Pt$Lat$F * 180/ $PI
            LON[COR$Pt$Index] = COR$Pt$Lon$F * 180/ $PI
            }                           

        if (icnt == NO) next                    # no points within Plot Radius

        ID = OWN$Pointer$Index + UNT$Slots      # UNT           7/8/86
	poly_type = poly_line_style[$poly$Barrier]
        call Draw_polygon_c (ID, LAT, LON, COR$PT$Slots, COLOR, 
	     		    poly_type)
        }
    }

## FOR OTHER CHAFF BARRIERS OUTSIDE OWN VIEW

for (BAR$Pointer$First; BAR$Pointer$Ok; BAR$Pointer$Next)
    {
    BAR$Type$I = xBAR$Type$I

    if (BAR$Type$I != $CHAFF$Code) NEXT  ## not chaff jb    1/18/91

    BAR$CVU$Index = iview                       ## set to station view

    BAR$CVU$ChaFlg$I = xBAR$CVU$ChaFlg$I

    if (BAR$CVU$ChaFlg$I == NO)   NEXT          ## view not to see chaff

    icnt = 0                                    ## count points within BIN

    do BAR$Pt$Index = 1, BAR$PT$Slots           ## do for 4 points
        {
        BAR$Pt$Lat$F = xBAR$Pt$Lat$F
        BAR$Pt$Lon$F = xBAR$Pt$Lon$F

        icnt = icnt + BINCK (BAR$PT$Lat$F, BAR$PT$Lon$F) 

        cLAT[BAR$Pt$Index] = BAR$Pt$Lat$F * 180/ $PI
        cLON[BAR$Pt$Index] = BAR$Pt$Lon$F * 180/ $PI
        }                       

    if (icnt == NO) NEXT                        # no points within Plot Radius

    ID = 0
    poly_type = poly_line_style[$Poly$Barrier]
    call Draw_Polygon_c (ID, cLAT, cLON, BAR$PT$Slots, COLOR, 
    	 		poly_type)
    }

return
end


Subroutine Plot_Sonob_Barrier (iview)

##########################################################
 #$%
 #$% Purpose:   SONOB barrier gets position of barriers for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_POLYGON_C
 #$%
 #$% Tables:    OWN        COR
 #$%
 #$% Date:      apr 84
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

real*4          LAT[COR$PT$Slots], LON[COR$PT$Slots]
integer         COLOR,
                BINCK

BBDeclare  (OWN$Pointer,
            OWN$Firstcorindx$I,
            COR$Nextindx$I,
            COR$Pointer,
            COR$Type$I,
            COR$PT$Index,
            COR$PT$lat$F,
            COR$PT$lon$F)                   # MJC 6/1/2K (E2145)
integer IVIEW,
        ICNT,
        ID,                                 # MJC 6/1/2K (E2145)
        poly_type 			    # SMM 5/14

COLOR = $Color$Bar$Sonar

for (OWN$Pointer$First; OWN$Pointer$Ok; OWN$Pointer$Next)
    {
    if (xOWN$View$I != iview)  next             # Get the right view

    OWN$FirstCorIndx$I = xOWN$FirstCorIndx$I

    COR$NextIndx$I     = OWN$FirstCorIndx$I

    while (COR$NextIndx$I != 0)
        {
        COR$Pointer$To COR$NextIndx$I           ## set to next point
        COR$NextIndx$I = xCOR$NextIndx$I

        COR$Type$I = xCOR$Type$I 

        if (COR$Type$I != $ActiveBarrier$Code &
            COR$Type$I != $PassiveBarrier$Code) next

        icnt = 0                                # count points within BIN

        do COR$Pt$Index = 1,COR$PT$Slots        #do for N points
            {
            COR$Pt$Lat$F = xCOR$Pt$Lat$F
            COR$Pt$Lon$F = xCOR$Pt$Lon$F

            icnt = icnt + BINCK (COR$pt$Lat$F, COR$pt$Lon$F) 

            LAT[COR$Pt$Index] = COR$Pt$Lat$F * 180/ $PI
            LON[COR$Pt$Index] = COR$Pt$Lon$F * 180/ $PI
            }                                   #end do for N points

        if (icnt == NO) next                    # no points within Plot Radius

        ID = OWN$Pointer$Index + UNT$Slots      # UNT           7/8/86
	poly_type = poly_line_style[$poly$Barrier]
#       call Draw_polygon_C (ID, LAT, LON, COR$PT$Slots, COLOR, poly_type)
        if (COR$Type$i == $PassiveBarrier$Code)        # 8/14/91  cml
	  {
	   poly_type = poly_line_style[$poly$Barrier]
           call Draw_polygon_c (ID, LAT, LON, COR$PT$Slots, COLOR, 
	   		        poly_type)
	  }
        else
	  {
	   poly_type = poly_line_style[$Poly$ActBarrier]
           call Draw_polygon_c (ID, LAT, LON, COR$PT$Slots, COLOR,
                                poly_type)
          }
	}
    }

return
end



Subroutine Plot_Sosus 

##########################################################
 #$%
 #$% Purpose:   PLOT_SOSUS gets position of SOSUS Regions
 #$%            for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    SOP
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

real*4          LAT[sop$ver$Slots], LON[sop$ver$Slots]
integer         COLOR,
                BINCK

BBDeclare  (SOP$Pointer,
            SOP$VER$Index,
            SOP$VER$latitude$F,
            SOP$VER$longitude$F)                        # MJC 6/1/2K (E2145)
integer ID,
        NPOINTS,
        ICNT                                            # MJC 6/1/2K (E2145)
integer poly_type #SMM 5/14

COLOR = $color$SOSUS                            #     1/7/87    

for (sop$Pointer$First; sop$Pointer$Ok; sop$Pointer$Next)
    {
    npoints = Xsop$NbrVertices$I        # number points 

    if (npoints == 0) next

    icnt = 0                            # count points within BIN

    #$% for each vertex entry
    for (Sop$Ver$Index = 1 ; Sop$Ver$Index <= npoints;
         Sop$Ver$Index = Sop$Ver$Index + 1)
        {
        Sop$Ver$Latitude$F  = XSop$Ver$Latitude$F
        Sop$Ver$Longitude$F = XSop$Ver$Longitude$F

        icnt = icnt + BINCK (sop$ver$Latitude$F, sop$ver$Longitude$F) 

        LAT[sop$ver$Index] = Sop$Ver$Latitude$F * 180/ $PI
        LON[sop$ver$Index] = Sop$Ver$Longitude$F * 180/ $PI
        }                                       #end loop for N points

    if (icnt == NO) next                        # no points within Plot Radius

    ID = 0
    poly_type = poly_line_style[$poly$SOSUS]
    call Draw_polygon_c (ID, LAT, LON, npoints, COLOR, poly_type)
    }

 return
 end



Subroutine Plot_SWABS (sta$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_SWABS gets position of SWABS Regions
 #$%            for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    SOP
 #$%
 #$% Date:      March 1, 1991
 #$%
 #$% Author:    Susan Miller and Carol Kropp
 #$%
 ##########################################################

BBcommon
PLOTcommon

real*4          LAT[swb$ver$Slots], LON[swb$ver$Slots]
integer         COLOR,
                BINCK

BBDeclare  (STA$View$I,
            STA$Pointer,
            SWB$Pointer,
            SWB$Side$I,
            SWB$VER$Index,
            SWB$VER$latitude$F,
            SWB$VER$longitude$F)                        # MJC 6/1/2K (E2145)
integer ISIDE,
        NPOINTS,
        ICNT,
        ITYPE,
        ID                                              # MJC 6/1/2K (E2145)

sta$view$i = Xsta$view$i    # get the station view

if      (sta$view$i < $FirstBlue$View)    iside = 0
else if (sta$view$i < $FirstOrange$View)  iside = $blue$code
else                                      iside = $orange$code

COLOR = $color$SWABS 

for (swb$Pointer$First; swb$Pointer$Ok; swb$Pointer$Next)
    {
    SWB$side$i = xSWB$side$I            # Side of ownership (Blue/Orange)

    if (SWB$side$i == 0) next

    if (iside != 0 &                    # CONTROL sees both sides
        iside != SWB$side$i) next       # else only same side

    npoints = Xswb$NbrVertices$I        # number points 

    if (npoints == 0) next

    icnt = 0                            # count points within BIN

    #$% for each vertex entry
    for (Swb$Ver$Index = 1 ; Swb$Ver$Index <= npoints;
         Swb$Ver$Index = Swb$Ver$Index + 1)
        {
        Swb$Ver$Latitude$F  = XSwb$Ver$Latitude$F
        Swb$Ver$Longitude$F = XSwb$Ver$Longitude$F

        icnt = icnt + BINCK (swb$ver$Latitude$F, swb$ver$Longitude$F) 

        LAT[swb$ver$Index] = Swb$Ver$Latitude$F * 180/ $PI
        LON[swb$ver$Index] = Swb$Ver$Longitude$F * 180/ $PI
        }                                       #end loop for N points

    if (icnt == NO) next                        # no points within Plot Radius

    if (SWB$side$i == $blue$code) itype = $Poly$B_SWABS
    else                          itype = $Poly$O_SWABS

    ID = $Poly$Solid$Code
    call Draw_polygon_c (ID, LAT, LON, npoints, COLOR, itype)
    }

 return
 end



Subroutine Plot_Sonar_reg

##########################################################
 #$%
 #$% Purpose:   PLOT_SONAR_REG gets position of SONAR Environment 
 #$%            Regions for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    SER
 #$%
 #$% Date:      June 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

real*4          LAT[SER$VER$Slots], LON[SER$VER$Slots]
integer         COLOR,
                BINCK

BBDeclare  (SER$Pointer,
            SER$VER$Index,
            SER$VER$latitude$F,
            SER$VER$longitude$F)                        # MJC 6/1/2K (E2145)
integer ID,
        KPOINTS,
        KCNT                                            # MJC 6/1/2K (E2145)
integer poly_type

COLOR = $Color$SonarEnv

for (SER$Pointer$First; SER$Pointer$Ok; SER$Pointer$Next)
    {
    kpoints = xSER$NbrVertices$I        # number points 

    if (kpoints == 0) next

    kcnt = 0                            # count points within BIN

    #$% for each vertex entry
    for (SER$VER$Index = 1 ; SER$VER$Index <= kpoints;
                             SER$VER$Index = SER$VER$Index + 1)
        {
        SER$VER$Latitude$F  = xSER$VER$Latitude$F
        SER$VER$Longitude$F = xSER$VER$Longitude$F

        kcnt = kcnt + BINCK (SER$VER$Latitude$F, SER$VER$Longitude$F) 

        LAT[SER$VER$Index] = SER$VER$Latitude$F  * 180/ $PI
        LON[SER$VER$Index] = SER$VER$Longitude$F * 180/ $PI
        }                                       #end loop for k points

    if (kcnt == NO) next                        # no points within Plot Radius

    ID = 0
    poly_type = poly_line_style[$poly$Sonar]
    call Draw_polygon_c (ID, LAT, LON, kpoints, COLOR, poly_type)
    }

 return
 end



Subroutine Plot_LIDAR

##########################################################
 #$%
 #$% Purpose:   PLOT_LIDAR gets position of LIDAR Environment 
 #$%            Regions for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    LER
 #$%
 #$% Date:      Feb 1991
 #$%
 #$% Author:    Susan Miller and Carol Kropp
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

real*4          LAT[LER$VER$Slots], LON[LER$VER$Slots]
integer         COLOR,
                BINCK

BBDeclare  (LER$Pointer,
            LER$VER$Index,
            LER$VER$latitude$F,
            LER$VER$longitude$F)                        # MJC 6/1/2K (E2145)
integer KPOINTS,
        KCNT,
        ID                                              # MJC 6/1/2K (E2145)
integer poly_type #SMM 5/14

COLOR = $Color$LIDAR

for (LER$Pointer$First; LER$Pointer$Ok; LER$Pointer$Next)
    {
    kpoints = xLER$NbrVertices$I        # number points 
    if (kpoints == 0) next

    kcnt = 0                            # count points within BIN

    #$% for each vertex entry
    for (LER$VER$Index = 1 ; LER$VER$Index <= kpoints;
                             LER$VER$Index = LER$VER$Index + 1)
        {
        LER$VER$Latitude$F  = xLER$VER$Latitude$F
        LER$VER$Longitude$F = xLER$VER$Longitude$F

        kcnt = kcnt + BINCK (LER$VER$Latitude$F, LER$VER$Longitude$F) 

        LAT[LER$VER$Index] = LER$VER$Latitude$F  * 180/ $PI
        LON[LER$VER$Index] = LER$VER$Longitude$F * 180/ $PI
        }                                       #end loop for k points

    if (kcnt == NO) next                        # no points within Plot Radius

    ID = 0
    poly_type = poly_line_style[$poly$LIDAR]
    call Draw_polygon_c (ID, LAT, LON, kpoints, COLOR, poly_type)
    }

 return
 end



Subroutine Plot_MineFields (sta$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_MineFields gets position of each Blue/Orange 
 #$%            minefield for display.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    MFD
 #$%
 #$% Date:      July 89
 #$%
 #$% Author:    D.E.Wills
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

literal     cstrip8
real*4      LAT[SER$VER$Slots], LON[SER$VER$Slots]
integer     COLOR,
            BINCK
character   NAME1[20], NAME2[20]

BBDeclare  (STA$View$I,
            STA$Pointer,
			STA$PlotLabelDeclutter$I,
            MFD$Pointer,
            MFD$Side$I,
            MFD$GhostedUnit$i,
            MFD$VER$Index,
            MFD$VER$latitude$F,
            MFD$VER$longitude$F,
            MFD$Targettype$I)                       # MJC 6/1/2K (E2145)
integer ISIDE,
        KPOINTS,
        kpoints_sign,
        KCNT,
        ITYPE,
        K,
        ID,                                      # MJC 6/1/2K (E2145)
	mark

sta$view$i = Xsta$view$i 
STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I
if      (sta$view$i < $FirstBlue$View)    iside = 0
else if (sta$view$i < $FirstOrange$View)  iside = $blue$code
else                                      iside = $orange$code

COLOR = $Color$MineField

name2[1] = EOS

for (MFD$Pointer$First; MFD$Pointer$Ok; MFD$Pointer$Next)
    {
    mfd$side$i = xMFD$Side$I            # Side of ownership (Blue/Orange)

    if (mfd$side$i == 0) next

    if (iside != 0 &                    # CONTROL sees both sides
        iside != mfd$side$i) next       # else only same side
        
    kpoints = xMFD$Points$I             # number of points 

    mfd$GhostedUnit$i = xMFD$GhostedUnit$i
    if (mfd$GhostedUnit$i == $yes)
    {
        if (Xsta$PlotGhostMinefield$I == $NO) next
        kpoints_sign = -1               # Don't close polygon
        k = 0
        call smovhn (Xmfd$Name$C,$$Maxlit,name1,k)
        call smov  (EOS,name1,k)
    }        
    else
    {
        kpoints_sign = 1                    # Close Polygon
        k = 0
        call smovi (Xmfd$sequence$i,name1,k)
        call smov  (EOS,name1,k)
    }
    kcnt = 0                            # count points within BIN

    #$% for each vertex entry
    for (MFD$VER$Index = 1 ; MFD$VER$Index <= kpoints;
         MFD$VER$Index = MFD$VER$Index + 1)
        {
        MFD$VER$Latitude$F  = xMFD$VER$Latitude$F
        MFD$VER$Longitude$F = xMFD$VER$Longitude$F

        kcnt = kcnt + BINCK (MFD$VER$Latitude$F, MFD$VER$Longitude$F) 

        LAT[MFD$VER$Index] = MFD$VER$Latitude$F  * 180/ $PI
        LON[MFD$VER$Index] = MFD$VER$Longitude$F * 180/ $PI
        }   #end loop for k points

    if (kcnt == NO) next        # no points within Plot Radius

    if (mfd$side$i == $blue$code) itype = poly_line_style[$Poly$B_MineField] 
    else                          itype = poly_line_style[$Poly$O_MineField]  

    MFD$TargetType$I = xMFD$TargetType$I
    if (MFD$TargetType$I == $ShipAndSub$Code)       # clk 3/93 (E1023)
      {
        k = 0
        call smovv ("ASW/", name2, k)
        call smovv ("ASUW",name2,k)
        call smov  (EOS, name2, k)
      }
    else if (MFD$TargetType$I == $Sub$Code)
      {
        k = 0
        call smovv ("ASW", name2, k)
        call smov  (EOS, name2, k)
      }
    else    # if (MFD$TargetType$I == $Ship$Code)
      {
        k = 0
        call smovv ("ASUW",name2,k)
        call smov  (EOS, name2, k)
      }
    mark =$ntds$xmark
    call draw_ntds_c (mark,
                    lat[1],lon[1],
                    color,
					STA$PlotLabelDeclutter$I,
                    name1,name2)

    ID = 0
    call Draw_polygon_c (ID, LAT, LON, kpoints*kpoints_sign, 
    	 		COLOR, itype)
    }

 return
 end



Subroutine Plot_SweepAreas (sta$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_SweepAreas gets position of each ghosted
 #$%            sweeparea for display. RESA sweeparea are displayed as routes.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    SWP
 #$%
 #$% Date:      March 2007
 #$%
 #$% Author:    James O. Allen
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

literal     cstrip8
real*4      LAT[SWP$VER$Slots], LON[SWP$VER$Slots]
integer     COLOR,
            BINCK
character   NAME1[20], NAME2[20]

BBDeclare  (STA$View$I,
            STA$Pointer,
			STA$PlotLabelDeclutter$I,
            SWP$Pointer,
            SWP$Side$I,
            SWP$GhostedUnit$i,
            SWP$VER$Index,
            SWP$VER$latitude$F,
            SWP$VER$longitude$F)
integer ISIDE,
        KPOINTS,
        kpoints_sign,
        KCNT,
        ITYPE,
        K,
        ID,                                      # MJC 6/1/2K (E2145)
	mark

sta$view$i = Xsta$view$i 

if      (sta$view$i < $FirstBlue$View)    iside = 0
else if (sta$view$i < $FirstOrange$View)  iside = $blue$code
else                                      iside = $orange$code

STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I

COLOR = $Color$SweepArea

name2[1] = EOS

for (SWP$Pointer$First; SWP$Pointer$Ok; SWP$Pointer$Next)
    {
    SWP$side$i = xSWP$Side$I            # Side of ownership (Blue/Orange)

    if (SWP$side$i == 0) next

    if (iside != 0 &                    # CONTROL sees both sides
        iside != SWP$side$i) next       # else only same side
        
    kpoints = xSWP$Points$I             # number of points 

    if (xSWP$GhostedUnit$i == $no) next

    kpoints_sign = -1               # Don't close polygon
    k = 0
    call smovhn (XSWP$Name$C,$$Maxlit,name1,k)
    call smov  (EOS,name1,k)

    kcnt = 0                            # count points within BIN
    #$% for each vertex entry
    for (SWP$VER$Index = 1 ; SWP$VER$Index <= kpoints;
         SWP$VER$Index = SWP$VER$Index + 1)
        {
        SWP$VER$Latitude$F  = xSWP$VER$Latitude$F
        SWP$VER$Longitude$F = xSWP$VER$Longitude$F

        kcnt = kcnt + BINCK (SWP$VER$Latitude$F, SWP$VER$Longitude$F) 

        LAT[SWP$VER$Index] = SWP$VER$Latitude$F  * 180/ $PI
        LON[SWP$VER$Index] = SWP$VER$Longitude$F * 180/ $PI
        }   #end loop for k points

    if (kcnt == NO) next        # no points within Plot Radius

    # Used for dash or solid polygon.  Use of minefield flags ok
    if (SWP$side$i == $blue$code) itype = poly_line_style[$Poly$B_MineField] 
    else                          itype = poly_line_style[$Poly$O_MineField]  
    mark = $ntds$xmark
    call draw_ntds_c (mark,
                    lat[1],lon[1],
                    color,
					STA$PlotLabelDeclutter$I,
                    name1,name2)

    ID = 0
    call Draw_polygon_c (ID, LAT, LON, kpoints*kpoints_sign, 
    	 		COLOR, itype)
    }

 return
 end



Subroutine Plot_RadarCoverages (sta$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_RadarCoverages draws envelope around host platform
 #$%            representing detection ranges in current environment
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK      DRAW_PLOYGON
 #$%
 #$% Tables:    STA
 #$%
 #$% Date:      February 2009
 #$%
 #$% Author:    James O. Allen
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

literal     cstrip8

BBDeclare  (STA$SEN$index, unt$pointer, sta$SENnum$i,
            STA$Pointer)
integer nV,
        color,
        ID

integer sta$SEN$Index2
integer poly_type #SMM 5/14

real rLat(180)                # Radar detection envelope lat array
real rLon(180)                # Radar detection envelope lat array

sta$SENnum$i = Xsta$SENnum$i

for (STA$SEN$index = 1; sta$SEN$index <= sta$SENnum$i;
     sta$SEN$Index = sta$SEN$index + 1)
{
    unt$pointer$to Xsta$SEN$UntIndx$i
    if (Xunt$status$i == $beingDeleted$code)
    {
        sta$SEN$index2 = sta$SENnum$i
        sta$SEN$Duplicate$sta2$sen
        sta$SENnum$i = sta$SENnum$i - 1
        PUTsta$SENnum$i
        next
    }

    call radarCoverageEnvelope(_
                                sta$pointer,
                                sta$SEN$index,
                                rLAT,             # Output
                                rLON,
                                nV,
                                color)

    id = 0
    poly_type = poly_line_style[$poly$GRID]
    call Draw_polygon_c (ID, rLAT, rLON, nV, COLOR, 
    	 		 poly_type)# outer circle
}

return
end



Subroutine Plot_Circles (STA$Pointer)                         #receive view

 ##########################################################
 #$%
 #$% Purpose:   PLOT_CIRCLES collects circle data for
 #$%            display to the specified station.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_CIRCLE_C
 #$%
 #$% Tables:    PLC
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon

integer         BINCK,
                RADIUS,
                COLOR
real*4          LAT,
                LON

BBDeclare  (STA$Pointer,
            PLC$Pointer,
            PLC$Latitude$F,
            PLC$Longitude$F)                        # MJC 6/1/2K (E2145)
integer ISTA                                        # MJC 6/1/2K (E2145)

ista  = STA$Pointer$Index

COLOR = $Color$CIRCLE

for (PLC$Pointer$First; PLC$Pointer$Valid; PLC$Pointer$Next) 
    {
    if (xPLC$Station$I != ista)         next    #if station not match
    if (xPLC$Type$I    != $Circle$Code) next

    PLC$Latitude$F  = xPLC$Latitude$F          #get latitude

    PLC$Longitude$F = xPLC$Longitude$F         #get longitude

    if (BINCK(PLC$Latitude$F, PLC$Longitude$F) == NO) next

    LAT = PLC$Latitude$F * 180/ $PI
    LON = PLC$Longitude$F * 180/ $PI

    RADIUS = xPLC$Radius$I

    if (RADIUS == 0) RADIUS = 1

    call Draw_Circle_c (LAT, LON, RADIUS, COLOR, $Poly$Solid$Code)
    }

return
end



Subroutine Plot_Grids (STA$Pointer)     # place grid on station's display

 ##########################################################
 #$%
 #$% Purpose:   PLOT_GRIDS collects grid data for
 #$%            display to the specified station.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_CIRCLE_C  DRAW_LINES      RRB2LL
 #$%
 #$% Tables:    PLC     STA
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################


BBcommon
PLOTcommon
$poly$styles

real*4  LAT, LON,                       ## grid center pnt, degrees
        LAT2, LON2,                     ## ending pnt of lines, deg.
        LATF, LONF,                     ##  "      "   "  "   , radns.
        tcos,
        range,
        PLAT[36],                       #LAT. (degrees) for rngs 5/17/83
        PLON[36]                        #LON. (degrees) for rngs 5/17/83

integer COLOR,                          ## color of grid
        RADIUS,                         ## radius of grid
        BINCK

integer ir,ista,length

BBDeclare  (STA$Pointer,
            PLC$Pointer,
            PLC$Latitude$F,
            PLC$Longitude$F,
            PLC$Radius$I)                       # MJC 6/1/2K (E2145)
integer NTVL,
        NV,
        IP,
        IA,
        ID,                                     # MJC 6/1/2K (E2145)
	poly_type 				# SMM 5/14
real BEAR                                       # MJC 6/1/2K (2145)

ista = STA$Pointer$Index

COLOR  = $Color$Grid

for (PLC$Pointer$First; PLC$Pointer$Valid; PLC$Pointer$Next)
    {
    if (xPLC$Station$I != ista      ) next      #if station not match, forget

    if (xPLC$Type$I    != $GRID$CODE) next              #if grid

    PLC$Latitude$F  = xPLC$Latitude$F           #get latitude

    PLC$Longitude$F = xPLC$Longitude$F         #get longitude

    if (BINCK(PLC$Latitude$F, PLC$Longitude$F) == NO) next

    PLC$Radius$I = xPLC$Radius$I                # get radius

    length = PLC$Radius$I * 5                   # length of line to last circle

    LAT = PLC$Latitude$F * 180/ $PI
    LON = PLC$Longitude$F * 180/ $PI

    range = length
##  ntvl = 15; nV = 24    # jb - 'Economical' circle            10/14/88
    ntvl = 10; nV = 36    # jb - Smoother   circle            10/14/88

    ip = 0      # init. counter for 12 radiating lines          5/17/83
    for (ia=0; ia<360; ia=ia+ntvl)  # jb (ntvl vice 10)        10/14/88         
        {       
        ip = ip +1      # line counter/1st indx for PLAT, PLON  5/17/83 
        bear = float(ia)/180. * $pi            # Bearing in radians

        LATF = PLC$Latitude$F
        LONF = PLC$Longitude$F

        tcos = cos(LatF) 

        call Rrb2ll(_                               #get second point for line
                     LATF,
                     LONF,
                     range,
                     bear,
                     0.0,
                     tcos)

        LAT2 = LATF * 180/ $PI
        LON2 = LONF * 180/ $PI

        if (mod(ia,30) == 0)          # lines drawn at 30-degree intervals
            call Draw_Line_C (LAT,LON, LAT2,LON2, COLOR)

        PLAT[ip] = lat2
        PLON[ip] = lon2
        }

    ID = 0

        # Note:  nV set above to either 24 or 36 vertices -jb-    10/14/88
    poly_type = poly_line_style[$poly$GRID]
    call Draw_polygon_c (ID, PLAT, PLON, nV, COLOR, poly_type)# outer circle

                                                # draw four inner circles
    for (ir=PLC$Radius$I ; ir < length; ir=ir+ PLC$Radius$I)
        {
        RADIUS = ir

        if (RADIUS == 0) RADIUS = 1

        call Draw_Circle_c (LAT, LON, RADIUS, COLOR, $Poly$Solid$Code)
        }

    }

return
end



Subroutine Plot_Survsat (STA$Pointer)           #  place SURVSAT ground track 
                                                ## on station's display

 ##########################################################
 #$%
 #$% Purpose:   PLOT_SURVSAT collects satellite data for
 #$%            display to the specified station.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_CIRCLE_C  DRAW_LINES      
 #$%
 #$% Tables:    STA     SAT
 #$%
 #$% Date:      JUNe 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################


BBcommon
PLOTcommon

real*4          LAT1, LON1, LAT2, LON2
integer         BINCK, COLOR

BBDeclare  (STA$Firstorbit$I,
            STA$Pointer,
            STA$Lastorbit$I,
            STA$Firstlat$F,
            STA$Lastlat$F,
            STA$Satindx$I,
            SAT$Pointer,
            SAT$Tracklatitude$F,
            SAT$Tracklongitude$F,
            SAT$Orbitnumber$I)                      # MJC 6/1/2K (E2145)
integer IR                                          # MJC 6/1/2K (E2145)

COLOR = $Color$SURVSAT

STA$FirstOrbit$I = xSTA$FirstOrbit$I            ## get satellite plotting data
STA$LastOrbit$I  = xSTA$LastOrbit$I             ##
STA$FirstLat$F   = xSTA$FirstLat$F              ##
STA$LastLat$F    = xSTA$LastLat$F               ##


STA$SatIndx$I = xSTA$SatIndx$I                  ## set SAT pointer
SAT$Pointer$To (STA$SatIndx$I)

SAT$TrackLatitude$F  = xSAT$TrackLatitude$F     ## satellites current position
SAT$TrackLongitude$F = xSAT$TrackLongitude$F    ## &
SAT$OrbitNumber$I    = xSAT$OrbitNumber$I       ## current orbit

if (SAT$OrbitNumber$I <= STA$FirstOrbit$I & 
    SAT$OrbitNumber$I >= STA$FirstOrbit$I )  return

LAT1 = SAT$TrackLatitude$F  * 180/ $PI          ## convert satellites LAT&LON
LON1 = SAT$TrackLongitude$F * 180/ $PI          ## from radians to degrees

if (BINCK(SAT$TrackLatitude$F, SAT$TrackLongitude$F) == NO) RETURN

call Draw_Line_C (LAT1,LON1, LAT2,LON2, COLOR)

COLOR = $Color$Obj$Fading                       ## temp for leader
IR    = 1                                       ##
call Draw_CIRCLE_C (LAT1, LON1, IR, COLOR, $Poly$Solid$Code) 

if (LAT2 != LAT1 & LON2 != LON1)
    {
    LAT2 = LAT1
    LON2 = LON1
    }

return
end



Subroutine Plot_Xmarks (STA$Pointer)                         #receive station

#########################################################
 #$%
 #$% Purpose:   XMARK collects X marks for display
 #$%            to the specified station.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK   DRAW_XMARK
 #$%
 #$% Tables:    PLC
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon

real*4          LAT, LON
integer         COLOR,
                BINCK

BBDeclare  (STA$Pointer,
            PLC$Pointer,
            PLC$Latitude$F,
            PLC$Longitude$F)                        # MJC 6/1/2K (E2145)
integer ISTA                                        # MJC 6/1/2K (E2145)

ista = STA$Pointer$Index

COLOR = $Color$Xmark

for (PLC$Pointer$First; PLC$Pointer$Valid; PLC$Pointer$Next)
    {
    if (xPLC$Station$I != ista)   next    #station MISmatch 8/19/87
#if (xPLC$View$I  != ista)        next          #if station match
    if (xPLC$Type$I  != $Xmark$Code) next        #if mark

    PLC$Latitude$F  =  xPLC$Latitude$F           #get latitude

    PLC$Longitude$F =  xPLC$Longitude$F         #get longitude

    if (BINCK (PLC$Latitude$F,PLC$Longitude$F) == NO) next

    LAT = PLC$LATITUDE$F * 180/ $PI
    LON = PLC$LONGITUDE$F * 180/ $PI

    call Draw_Xmark_c (LAT, LON, COLOR)
    }

return
end



Subroutine Plot_MrkWB (iview, ista, STA$Pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_MRKWB gets data to display marker
 #$%            with bearing.
 #$%
 #$% Called By: PLOT_ASSUMED
 #$%
 #$% Calls:     BINCK   DRAW_UNIT_C
 #$%
 #$% Tables:    MRK        STA          UNT
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################


BBcommon
PLOTcommon
Select_common

integer         BINCK,
                COLOR,
                NTDS,
                SELECT_RMT,
                draw_unit_c,
                TYPE
integer*4       SPEED
real*4          LAT, 
                LON,
                COURSE
character       NAME1[20], NAME2[20]

BBDeclare  (MRK$Pointer,
            MRK$Latitude$F,
            MRK$Longitude$F,
            MRK$Type$I,
            MRK$Cat$I,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)

integer ISTA,
        istat,
        IVIEW,
        ITYPE,
        ISIDE,
        ID,
        N1,
        N2,
        INFO                                    # MJC 6/1/2K (E2145)
integer X1, X2, X3                              # MJC 6/1/2K (E2145)
literal CSTRIP8                                 # MJC 6/1/2K (E2145)

STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
STA$Label$I = xSTA$Label$I

for (MRK$Pointer$First; MRK$Pointer$Valid; MRK$Pointer$Next)
    {
    if(xMRK$Station$I != ista) next             #if not correct station

    MRK$Latitude$F  = xMRK$Latitude$F           ## extract marks lat/long
    MRK$Longitude$F = xMRK$Longitude$F

    if (BINCK (MRK$Latitude$F,MRK$Longitude$F) == NO) next

    MRK$Type$I = xMRK$Type$i                    #get mark type
    MRK$Cat$I  = xMRK$Cat$i                     #get mark cat

    if (SELECT_RMT (iview,MRK$Cat$I,MRK$Type$I,itype,iside,COLOR) == NO) next

    NTDS   = NTDS_Symbol[itype,iside]
    ID     = 0
    LAT    = MRK$Latitude$F  * 180/ $PI         ## convert to degrees
    LON    = MRK$Longitude$F * 180/ $PI
    COURSE = 0.0
    SPEED  = 0
    TYPE   = MRK$Type$I

    if (STA$Label$I == YES)            #if labels requested
        {
        n1 = 0
        call smovh (xMRK$Label1$C,$$MaxName,NAME1,n1)  #enter label 1
        call smov  (EOS,                    NAME1,n1)  
        
        n2 = 0
        call smovh (xMRK$Label2$C,$$MaxName,NAME2,n2)  #enter label 2
        call smov  (EOS,                    NAME2,n2)  
        }
    else
        { 
        NAME1[1] = EOS
        NAME2[1] = EOS
        }                               

    istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                   NAME2, COLOR, COURSE,
                   SPEED, TYPE, x1, 
                   x2, x3, 
                   INFO)

   }

return
end



Subroutine Plot_Esm_Sonar (STA$Pointer)

###########################################################
#$%
#$% Purpose:   PLOT_ESM_SONAR gets data to display ESM
#$%            and Sonar targets with bearing lines and
#$%            any TMA solutions.
#$%
#$% Called By: PLOT_UP
#$%
#$% Calls:     RRB2LL   BINCK   DRAW_BEARING_C
#$%            DRAW_UNIT_C
#$%
#$% Tables:    STA      RMT     BMK     MRK
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
#$% Modified:  Carol Kropp - 8/95 (E1450 and E1451)
#$%            Had to redo handling of ESM detections,
#$%            additions to plot jammer detections in
#$%            yellow caused ERASE LOB ESM to wipe out
#$%            sonar lobs and PLOT LOB EMITTER not to work.
#$%
###########################################################

BBcommon
PlotCommon
$poly$styles

integer         BINCK, sview, COLOR, TYPE, ibtype # JFR 9/28/94 (added ibtype)
integer*4       SPEED, search_eer_list, eerfirst, eerlast, j
integer         istat, draw_unit_c
real*4          LAT, LON, COURSE
character       clet, NAME1[20], NAME2[20]
literal         a_track

BBDeclare  (STA$Pointer,
            STA$Plotsonar$I,
            STA$Plotesmair$I,
            STA$Plotesmsurf$I,
            STA$Plotesmjam$I,
            STA$Eernum$I,
            STA$Bearingsource$I,
            STA$Altbearingsource$I,
            STA$Label$I,
			STA$PlotLabelDeclutter$I,
            STA$EER$Index)                      # MJC 6/1/2K (E2145)
BBDeclare  (RMT$Pointer,
            RMT$Detectiontype$I,
            RMT$Detectee$I,
            RMT$Emittername$C,
            RMT$Detector$I,
            RMT$Origlat$F,
            RMT$Origlon$F,
            BMK$Pointer,
            BMK$Name$C,
            MRK$Pointer,
            MRK$Latitude$F,
            MRK$Longitude$F,
            UNT$Pointer,
            UNT$Type$I,
            RVU$Pointer)                        # MJC 6/1/2K (E2145)
integer ISTA,
        ILAST,
        LSTMIN,
        ISJAM,
        LITCMP,
        N1,
        N2,
        NTDS,
        ID,
        INFO,
        GAME_TIME,
        ID2                                     # MJC 6/1/2K (E2145)
integer X1, X2, X3
real RNG,
     BEARING                                    # MJC 6/1/2K (E2145)
literal CSTRIP8                                 # MJC 6/1/2K (E2145)

ista  = STA$Pointer$Index
sview = xsta$view$i

STA$PlotSonar$I   = xSTA$PlotSonar$I 
STA$PlotESMair$I  = xSTA$PlotESMair$I   # jb            6/18/86
STA$PlotESMsurf$I = xSTA$PlotESMsurf$I  # jb            6/18/86 
STA$PlotESMjam$I  = xSTA$PlotESMjam$I   # JFR 7/26/94 - plot LOB's from Jammers only
STA$EERnum$I = xSTA$EERnum$I

sta$bearingsource$i = Xsta$bearingsource$i

if (sta$bearingsource$i == 0) return

sta$AltBearingSource$i = Xsta$AltBearingSource$i

rng = min(max(1,xsta$plotradius$i) * 0.98, 50.0)

RVU$Pointer$to sview

rmt$pointer$to xRVU$LastRMTIndx$I

ilast = rmt$pointer

lstmin = kmin - 1

STA$Label$i = xSTA$Label$i
STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

for (rmt$pointer$to xRVU$FirstRmtIndx$i;rmt$pointer<=ilast;rmt$pointer$next)
  {
   if (xrmt$inuse$i      == $no)        next
   if (xrmt$ignore$i     == $yes)       next    # bearing dropped by CORMOD
   if (xrmt$LastDetTime$f < lstmin &
       xRMT$LastDetType$I != $Bistatic$Type)     next

   rmt$DetectionType$i = Xrmt$DetectionType$i

   if (rmt$DetectionType$i == $ActiveNonVisual$Code |         # 7/7/86
       rmt$DetectionType$i == $ActiveVisual$Code     )  NEXT  # 7/7/86
   else if (rmt$DetectionType$i == $PassiveSonar$code )  #else  7/7/86
     {
      if (STA$PlotSonar$I == $NO)       NEXT
     }
   else  # if (rmt$DetectionType$i == $ESM$code)        # jb    6/18/86
     {
      rmt$DetectEE$i = Xrmt$DetectEE$i                  # jb    6/18/86
      UNT$Pointer$TO (rmt$detectee$i)                   # jb    6/18/86
      UNT$TYPE$i = XUNT$TYPE$i                          # jb    6/18/86
      search_eer_list = $no

      call Is_ESM_Jammer (RMT$Pointer, isjam)       # handle jammer detections separate 
      if (isjam == $yes)                            # from other ESM contacts
        {
         if (STA$PlotESMjam$i == $YES)
             search_eer_list = $no
         else         
             search_eer_list = $yes
        }
      else if (UNT$TYPE$i ==$AIR$code | UNT$TYPE$i ==$CruiseMissile$Code) 
        {
         if (STA$PlotESMair$i == $NO)  search_eer_list = $yes
        }
      else      # (UNT$TYPE$i is SURFACE or SUB or SURFACEwithAC)
        {
         if (STA$PlotESMsurf$i == $NO) search_eer_list = $yes
        }

      if (search_eer_list == $yes)
        {
         if (sta$eernum$i == 0)
           NEXT
         else
           {
            rmt$EmitterName$c = xrmt$EmitterName$c
            eerfirst = 1
            eerlast = sta$eernum$i
            repeat # binary search the array for emitter name
              { 
               sta$eer$index = (eerfirst + eerlast) / 2
               j = litcmp(rmt$EmitterName$c,xsta$eer$name$c)
               if (j == 0) 
                 {
                  search_eer_list = $no
                  BREAK
                 }
               else if (j < 0)
                 eerlast = sta$eer$index - 1
               else 
                 eerfirst = sta$eer$index + 1
               if (eerlast < eerfirst) BREAK
              } # end binary search
            if (search_eer_list == $yes) NEXT
           } # end if sta$eernum == 0
        } # end if search_eer_list == $yes
     } # end if rmt$detectiontype$i

    rmt$Detector$i = Xrmt$Detector$i

    if (sta$BearingSource$i    <= UNT$slots      &      # if not plot all esm
        sta$BearingSource$i    != rmt$Detector$i &      # & not specific unit1
        sta$AltBearingSource$i != rmt$Detector$i) next  # & not specific unit2

    if (RMT$DetectionType$I == $PassiveSonar$Code &    
        xRMT$LastDetType$I == $Bistatic$Type) # need the detector lat and long,
        {                                     # not the center of the ellipse
         UNT$Pointer$To xRMT$Detector$I
         rmt$OrigLat$f = xUNT$TrueLatitude$F
         rmt$OrigLon$f = xUNT$TrueLongitude$F
        }
    else
        {
         rmt$OrigLat$f = Xrmt$OrigLat$f
         rmt$OrigLon$f = Xrmt$OrigLon$f
        }

    if (BINCK (rmt$OrigLat$f,rmt$OrigLon$f) == NO) next

    LAT = rmt$OrigLat$f * 180/$pi               # convert origin lat/lon
    LON = rmt$OrigLon$f * 180/$pi               ## to degrees

    if (RMT$detectionType$i == $PassiveSonar$Code) # no x     6/18/86
        {
        COLOR = $color$LOB$Sonar                # Set color for sonar
        ibtype = poly_line_style[$Poly$Sonar]
        }
    else                                        # otherwise, set color
        {                                       # for ESM
         if (isjam == $yes)
           { 
            COLOR = $Color$LOB$jam
            ibtype = poly_line_style[$Poly$JammerESM]
           }
         else
           { 
            COLOR = $color$LOB$ESM
            ibtype = $Poly$Solid$Code
           }
        }

    if (STA$Label$I == YES)                     ## if labels requested
        {
        if (rmt$DetectionType$i == $PassiveSonar$code) clet = 'P'
        else                                           clet = 'E'

        n1 = 0
        call smovhn (a_track(CTKCD, clet, xRMT$TrackNumber$I),
                     $$MaxLit,NAME1,n1)                     # DEW 11/99 (E2172)
        call smov   (EOS,                 NAME1,n1)    

        n2 = 0
        if (Track$Time$Tag == $ON)      # put up last detection time
            {
            call smoviz(Game_Time(xrmt$LastDetTime$f),5,NAME2,n2)  # zulu time
            }
        else if (Track$Time$Tag == 2)   # random
            {
            call smovv ("00000",NAME2,n2)
            }

        call smov  (EOS, NAME2,n2)  # terminate the name string
        }
    else
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    if (Xrmt$OmniFlag$i == YES)         # omni directional Buoy
        {
        NTDS  = $NTDS$XMark

        ID     = RMT$Pointer$Index + OWN$Slots +UNT$Slots # UNT 7/8/86
        COURSE = 0.0
        SPEED  = 0
        TYPE   = 0

        istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                       NAME2, COLOR, COURSE,
                       SPEED, TYPE, x1, 
                       x2, x3, 
                       INFO)
        }
    else
        {
        ID  = RMT$Detector$I 
        ID2 = RMT$Pointer$Index + OWN$Slots + UNT$Slots   # UNT 7/8/86
  
        BEARING = xRMT$Bearing$I

        # added ibtype to allow dashed/dotted bearing lines - JFR 9/28/94
        call Draw_Bearing_c (ID, LAT, LON, ID2, BEARING, NAME1, COLOR, ibtype) # JFR 9/28/94
        }

    if (RMT$DetectionType$I == $PassiveSonar$Code & xRMT$TMAFlag$I == YES)
        {
        call Plot_TMA (RMT$Pointer, STA$Label$I, STA$Pointer, sview)
        }

    } #end of RMT Loop

if (sta$BearingSource$i <= UNT$slots) return

COLOR = $color$LOB$ESM

for (BMK$Pointer$First; BMK$Pointer$Ok; BMK$Pointer$Next)
   {
    if (xBMK$Station$I != ista) next            #if correct station

    bmk$name$c = xbmk$name$c                    #get name of mark

    for (mrk$pointer$first;mrk$pointer$ok;mrk$pointer$next) #search mtks
       {
        if (xMRK$Station$I != ista) next        #if correct station

        if (xmrk$label1$c != bmk$name$c) next   #if correct mark

        mrk$latitude$f  = xmrk$latitude$f       # get lat and lon
        mrk$longitude$f = xmrk$longitude$f

        if (BINCK (MRK$LATITUDE$F, MRK$LONGITUDE$F) == NO) next

        LAT = mrk$latitude$f  * 180/$pi         # set arguments to draw lines
        LON = mrk$longitude$f * 180/$pi


        if (STA$Label$I == YES)                 ## if labels requested
            {
            n1 = 0
            call smovhn (BMK$Name$C, $$MaxLit, NAME1, n1)
            call smov  (EOS,           NAME1, n1)
            }
        else
            {
            NAME1[1] = EOS
            }

        ID  = 0
        ID2 = 0
  
        BEARING = xBMK$Bearing$F *  180 / $PI     # conv rad to deg

        ibtype = $Poly$Solid$Code # JFR 9/28/94
        call Draw_Bearing_c (ID, LAT, LON, ID2, BEARING, NAME1, COLOR, ibtype) # JFR 9/28/94
       }                         
   }                             

return
end



Subroutine Plot_TMA (RMT$Pointer, STA$Label$I, STA$pointer, iview)

##########################################################
 #$%
 #$% Purpose:   PLOT_TMA collects passive TMA solutions for 
 #$%            display to the specified view.
 #$%
 #$% Called By: PLOT_ESM_SONAR
 #$%
 #$% Calls:     BINCK   DRAW_UNIT_C
 #$%
 #$% Tables:    RMT     STA
 #$%
 #$% Date:      OCT 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_Common

character       NAME1[20],
                NAME2[20]
integer         NTDS,
                COLOR,
                BINCK,
                DRAW_UNIT_C,
                TYPE,
                SELECT_RMT
integer*4       SPEED, achar
literal         a_track
real*4          LAT,
                LON,
                LENGTH,                          ## NTDS speed vector length
                BEARING,                         ## NTDS speed vector heading
                latitude,
                longitude,
                COURSE
VMSchar         ASTAB_Class*($$MaxName+1)

BBDeclare  (STA$Plotspeedair$I,
            STA$Pointer,
            STA$Plotspeedship$I,
            STA$Label$I,
			STA$PlotLabelDeclutter$I,
            RMT$Tracknumber$I,
            RMT$Pointer,
            RMT$Targetid$I,
            RMT$Class$I)                            # MJC 6/1/2K (E2145)
integer IVIEW,
        ITYPE,
        ISIDE,
        ID,
        N1,
        N2,
        ISTAT,
        GAME_TIME,
        INFO                                        # MJC 6/1/2K (E2145)
integer X1,
        X2,
        X3                                          # MJC 6/1/2K (E2145)

STA$plotspeedair$i  = xSTA$plotspeedair$i       ## extract for speed vectors
STA$plotspeedship$i = xSTA$plotspeedship$i
STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

latitude  = xRMT$TMALat$F                       ## get TMA position
longitude = xRMT$TMALon$F

if (BINCK (latitude,longitude) == NO) Return    ## check if within bin

RMT$TargetId$I = xRMT$TargetId$I                ## get target ident
RMT$Class$I    = xRMT$Class$I                   ## get class

if (SELECT_RMT (iview,RMT$Class$I,RMT$TargetId$I,itype,iside,COLOR) == NO) 
          return

NTDS   = NTDS_Symbol[itype,iside]               ## build symbol
ID     = RMT$Pointer$Index + OWN$Slots + UNT$Slots      # UNT   7/8/86
LAT    = latitude  * 180/ $PI                   ## convert to radians
LON    = longitude * 180/ $PI
COURSE = xRMT$Course$I
SPEED  = xRMT$Speed$I
TYPE   = RMT$Class$I

if (STA$Label$I == $YES)                        ## if labels requested
    {
    RMT$TrackNumber$I = xRMT$TrackNumber$I

    achar = 'P'
    n1 = 0
    
    call smovhn (a_track(ctkcd, achar, RMT$TrackNumber$I),
                 $$MaxLit,NAME1,n1)                         # DEW 11/99 (E2172)
    call smov  (EOS,      NAME1,n1)

    n2 = 0
    if (Track$Time$Tag == $ON)      # put up last detection time
        {
        call smoviz(Game_Time(xrmt$LastDetTime$f),5,NAME2,n2)  # zulu time
        }
    else if (Track$Time$Tag == 2)   # random
        {
        call smovv ("00000",NAME2,n2)
        }
     else                            # it's off, no time tags so put up class
        {
        call smovv (Astab_Class(RMT$Pointer),NAME2,n2) # Std Track Classification (E2183)
        }

    call smov (EOS,NAME2,n2)    # terminate the name string
    }
else
    {
    NAME1[1] = EOS
    NAME2[1] = EOS
    }

istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                  NAME2, COLOR, COURSE,
                  SPEED, TYPE, x1, 
                  x2, x3, 
                  INFO)

if      (istat == NO) continue
else if (STA$plotspeedair$i == YES & itype == $$$Air)
    {
    BEARING = xRMT$Course$I
    LENGTH  = 40.0 * int(xRMT$Speed$I / 200 + 0.5)
    call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
    }
else if (STA$plotspeedship$i == YES & itype != $$$Air)
    {
    BEARING = xRMT$Course$I
    LENGTH  = 40.0 * int(xRMT$Speed$I / 7 + 0.5)
    call Draw_Vector_C (ID, LAT, LON, LENGTH, BEARING)
    }

return
end


Subroutine Select_Set (STA$Pointer)

###########################################################
#$%
#$% Purpose:   SELECT_SET builds an array of flags for plot orders
#$%             
#$% Called By: PLOT
#$%
#$% Calls:     
#$%
#$% Tables:    STA
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
#$% Modified:  SMM 1/94 added plotting enemy and friendly missiles
###########################################################

BBcommon
Select_common

BBDeclare  (STA$Pointer)                        # MJC 6/1/2K (E2145)
integer JTYPE,
        JSIDE                                   # MJC 6/1/2K (E2145)

select_mask[$$$Air ,   $$$Friendly] = xSTA$PlotFriendlyAir$I          
select_mask[$$$Sub ,   $$$Friendly] = xSTA$PlotFriendlySub$I          
select_mask[$$$Surf,   $$$Friendly] = xSTA$PlotFriendlySurf$I         
select_mask[$$$Boat,   $$$Friendly] = xSTA$PlotFriendlyBoat$I         
select_mask[$$$Land,   $$$Friendly] = xSTA$PlotFriendlyBase$I         
select_mask[$$$Site,   $$$Friendly] = xSTA$PlotFriendlySite$I
select_mask[$$$Miss,   $$$Friendly] = xSTA$PlotMissileObject$I
select_mask[$$$Vehicle,$$$Friendly] = xSTA$PlotFriendlyBase$I

select_mask[$$$Air ,   $$$Neutral]  = xSTA$PlotNeutralAir$I           
select_mask[$$$Sub ,   $$$Neutral]  = xSTA$PlotNeutralSub$I           
select_mask[$$$Surf,   $$$Neutral]  = xSTA$PlotNeutralSurf$I          
select_mask[$$$Boat,   $$$Neutral]  = xSTA$PlotNeutralBoat$I          
select_mask[$$$Land,   $$$Neutral]  = xSTA$PlotNeutralBase$I          
select_mask[$$$Site,   $$$Neutral]  = xSTA$PlotNeutralSite$I
select_mask[$$$Vehicle,$$$Neutral]  = xSTA$PlotNeutralBase$I

select_mask[$$$Air ,   $$$Unknown]  = xSTA$PlotUnknownAir$I           
select_mask[$$$Sub ,   $$$Unknown]  = xSTA$PlotUnknownSub$I           
select_mask[$$$Surf,   $$$Unknown]  = xSTA$PlotUnknownSurf$I          
select_mask[$$$Boat,   $$$Unknown]  = xSTA$PlotUnknownBoat$I          
select_mask[$$$Land,   $$$Unknown]  = xSTA$PlotUnknownBase$I          
select_mask[$$$Vehicle,$$$Unknown]  = xSTA$PlotUnknownBase$I          

select_mask[$$$Air ,   $$$Enemy]    = xSTA$PlotEnemyAir$I             
select_mask[$$$Sub ,   $$$Enemy]    = xSTA$PlotEnemySub$I            
select_mask[$$$Surf,   $$$Enemy]    = xSTA$PlotEnemySurf$I            
select_mask[$$$Boat,   $$$Enemy]    = xSTA$PlotEnemyBoat$I            
select_mask[$$$Land,   $$$Enemy]    = xSTA$PlotEnemyBase$I            
select_mask[$$$Site,   $$$Enemy]    = xSTA$PlotEnemySite$I
select_mask[$$$Miss,   $$$Enemy]    = xSTA$PlotMissileObject$I
select_mask[$$$Vehicle,$$$Enemy]    = xSTA$PlotEnemyBase$I

for (jtype = 1; jtype <= $$$Max_Type; jtype = jtype + 1)
    {
    for (jside = 1; jside <= $$$Max_Side; jside = jside + 1)
        {
        if (select_mask[jtype, jside] != NO) select_mask[jtype, jside] = YES
        }
    }

return
end



Subroutine Generr (ival)                # generate network error message

###########################################################
#$%
#$% Purpose:   GENERR generates a network error message or logout.
#$%
#$% Called By: PLOTUP     PLOT
#$%
#$% Calls:     TYPERR     LOGOUT
#$%
#$% Tables:    None
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
###########################################################

PlotCommon                              

integer IVAL                        # MJC 6/1/2K (E2145)

#$% if plot is running in detached mode, display error message
if (idetch != $yes) call typerr(ival)

#$% else logout
else                call logout

return
end

Subroutine Echo (ichar)                 

###########################################################
#$%
#$% Purpose:   ECHO passes one character for ttyout if not detached
#$%
#$% Called By: GET_CH
#$%
#$% Calls:     TTYOUT
#$%
#$% Tables:    None
#$%
#$% Date:      JAN 82
#$%
#$% Author:    DONGOG
#$%
###########################################################

bbcommon
PlotCommon

integer ICHAR                                   # MJC 6/1/2K (E2145)

#$% if plot is running in detached mode, return
if (idetch == $yes) return

#$% output character
call ttyout(ichar)

return
end

Subroutine Getch  (ichar)               # this program is required by parse
                                        # it will not return until something
                                        # is input.

###########################################################
#$%
#$% Purpose:   GETCH reads the next character from the file
#$%
#$% Calls:     TTYIN     DELAY
#$%
#$% Tables:    NONE
#$%
#$% Date:      JAN 82
#$%
#$% Author:    DONGOG
#$%
###########################################################

bbcommon
PlotCommon

integer ICHAR                                   # MJC 6/1/2K (E2145)

#$% if runnig in detached mode, stop program
if (idetch == $yes) stop

repeat
   {
    #$% input character
    call ttyin(ichar,0)

    #$% if character is a null delay, else break loop
    if (ichar == $null) call delay(1000)
    else                break
   }

return
end



subroutine get_ch (char,itime)   

###########################################################
#$%
#$% Purpose:   GET_CH gets an input from ttydly
#$%            
#$%
#$% Called By: NONE
#$%
#$% Calls:     GETFCH
#$%            
#$%
#$% Tables:    NONE
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
###########################################################

BBcommon

CHARACTER    char                       # VAX conversion                2/2/82

integer itime

call getfch (char,$no,itime) # command file in (using ttydly)  2/2/82

#$% if character is ^Z
if (char == $CNTLZ) 
   {
    call echor
    call echop ("XTEE")    # close typescript file (if it exists) [echop 2/2/82
    call hltslf

    #$% display message to user
    call echor
    call echov ("PLAYER....")

    #$% set character to ^R (retype line)
    char = $CNTLR
   }

return
end
 


subroutine gen_Updates (ista)   

###########################################################
#$%
#$% Purpose:   GEN_UPDATES calls subroutines for plot marks, 
#$%            circles and center points
#$%
#$% Called By: PLOT
#$%
#$% Calls:     GPLOTC     GPLOTM
#$%
#$% Tables:    NONE
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
###########################################################

bbcommon

integer ISTA                            # MJC 6/1/2K (E2145)

call gplotc  (ista)                     # set up center points
call gplotm  (ista)                     # set up xmarks/circles

return
end

 

subroutine gplotm (ista)                

###########################################################
#$%
#$% Purpose:   GPLOTM generates position data for plot 
#$%            marks (X's and circles)
#$%            
#$%
#$% Called By: GEN_UPDATES
#$%
#$% Calls:     NONE
#$%            
#$% Tables:    UNT
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
###########################################################

bbcommon

BBDeclare  (PLC$Pointer,
            PLC$Referencetype$I,
            PLC$Reference$I,
            PLC$Latitude$F,
            PLC$Longitude$F,
            UNT$Pointer,
            OWN$Pointer,
            RMT$Pointer)                        # MJC 6/1/2K (E2145)
integer ISTA                                    # MJC 6/1/2K (E2145)

#$% for each place pointer (place = x's and circles)
for (plc$pointer$first; plc$pointer$valid; plc$pointer$next)
   {
    if (Xplc$Station$i != ista) next    #ignore marks for other stations

    #$% get reference type and reference pointer location
    plc$ReferenceType$i = Xplc$ReferenceType$i
    plc$Reference$i     = Xplc$Reference$i

    #$% if reference type ok
    if (plc$ReferenceType$i == $true$code)
       {
        #$% set unit pointer to reference pointer
        UNT$pointer$to plc$Reference$i

        #$% if unit is being deleted
        if (xUNT$status$i == $BeingDeleted$code)
           {
            #$% delete unit data in blackboard and get next entry            
            plc$zero
            next
           }

        #$% make place postition same as unit position
        plc$latitude$f  = xUNT$TrueLatitude$f
        plc$longitude$f = xUNT$TrueLongitude$f
       }
    #$% else if refernece type is own force
    else if (plc$ReferenceType$i == $OwnForce$code)
       {
        #$% set own pointer to reference pointer
        own$pointer$to plc$Reference$i

        #$% if own unit not in the table
        if (Xown$Unit$i == $null)
           {
            #$% delete unit data in blackboard and get next entry            
            plc$zero
            next
           }

        #$% make place postition same as unit position
        plc$latitude$f  = Xown$Latitude$f
        plc$longitude$f = Xown$Longitude$f
       }
    #$% else if reference type is other force
    else if (plc$ReferenceType$i == $OtherForce$code)
       {
        #$% set remote track table pointer to reference
        rmt$pointer$to plc$Reference$i

        #$% if other unit not in rmt table
        if (Xrmt$InUse$i == $null)
           {
            #$% delete unit data in blackboard and get next entry            
            plc$zero
            next
           }

        #$% make place postition same as unit position
        plc$latitude$f  = Xrmt$ApparentLat$f
        plc$longitude$f = Xrmt$ApparentLon$f
       }
    else        # it must be by POSITION
       {
        next
       }

    #$% save unit/place position
    PUTplc$latitude$f
    PUTplc$longitude$f
   }

return
end

 

subroutine gplotc (ista)                

###########################################################
#$%
#$% Purpose:   GPLOTC generates position data for center points
#$%            
#$% Called By: GEN_UPDATES
#$%
#$% Calls:     RLL2RB
#$%            
#$% Tables:    STA
#$%
#$% Date:      May 83
#$%
#$% Author:    Adamos T.
#$%
#$% Modified:  Carol Kropp - 12/92  (E1036)
#$%            Added checks to determine if the station is
#$%            plotting its own geo or another station's.
#$%            If plotting another station's geo, resizing
#$%            and relocating the center of the display is
#$%            now allowed, and the data for the center posit
#$%            is stored in the control station's STA slot.
###########################################################

bbcommon

BBDeclare  (STA$Pointer,
            STA$Plotcopy$I,
            STA$Plotsourcetype$I,
            STA$Plotsource$I,
            STA$Plotradius$I,
            UNT$Pointer,
            OWN$Pointer,
            RMT$Pointer)                        # MJC 6/1/2K (E2145)
integer ISTA                                    # MJC 6/1/2K (E2145)
real F_LATITUDE,
     F_LONGITUDE,
     RANGE,
     BRNG                                       # MJC 6/1/2K (E2145)

#$% set station pointer to the pointer being processed
sta$pointer$to ista

STA$PlotCopy$I = xSTA$PlotCopy$I

#$% get plot source type and plot source
if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
  {
   sta$PlotSourceType$i = Xsta$PlotSourceType$i
   sta$PlotSource$i     = Xsta$PlotSource$i
  }
else                       # control plotting another station's geo
  {
   STA$PlotSourceType$I = xSTA$CopyPlotSourceType$I
   STA$PlotSource$I     = xSTA$CopyPlotSource$I
  }

#$% if plot source type not there, return
if (sta$PlotSourceType$i == $null$code)  return

#$% if plot source type ok
if (sta$PlotSourceType$i == $true$code)
   {
    #$% set unit pointer to plot source 
    UNT$pointer$to sta$PlotSource$i

    #$% if unit is being deleted
    if (XUNT$status$i == $BeingDeleted$code)
        {
        #$% save plot source type (null) and return
        if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
          PUTsta$PlotSourceType$i ($null$code)
        else                       # control plotting another station's geo
          putSTA$PlotSourceType$I ($Null$Code)
        return
        }

    #$% make sta position same as unit's position
    f_latitude  = XUNT$TrueLatitude$f
    f_longitude = XUNT$TrueLongitude$f
   }

#$% else if plot source is own force
else if (sta$PlotSourceType$i == $OwnForce$code)
    {
    #$% set own pointer to plot source
    own$pointer$to sta$PlotSource$i

    #$% if own unit not in the table
    if (Xown$Unit$i == $null)
        {
        #$% save plot source type (null) and return
        if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
          PUTsta$PlotSourceType$i ($null$code)
        else                       # control plotting another station's geo
          putSTA$PlotSourceType$I ($Null$Code)
        return
        }

    #$% make sta position same as units position
    f_latitude  = xOWN$Latitude$f
    f_longitude = xOWN$Longitude$f
    }

#$% else if plot source is another force
else if (sta$PlotSourceType$i == $OtherForce$code)
    {
    #$% set remote track table to plot source
    rmt$pointer$to sta$PlotSource$i

    #$% if other unit not in table
    if (Xrmt$InUse$i == $null)
        {
        #$% save plot source type (null) and return
        if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
          PUTsta$PlotSourceType$i ($null$code)
        else                       # control plotting another station's geo
          putSTA$PlotSourceType$I ($Null$Code)
        return
        }
    #$% make sta position same as unit's position
    f_latitude  = xRMT$ApparentLat$F
    f_longitude = xRMT$ApparentLon$F
    }

#$% if new map requested.....
if (Xsta$PlotMap$i == $yes)
    {
    #$% save position and return
    if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
      {
       PUTsta$latitude$f   (f_latitude)
       PUTsta$longitude$f  (f_longitude)
      }
    else                       # control plotting another station's geo
      {
       putSTA$CopyLatitude$F   (f_latitude)
       putSTA$CopyLongitude$F  (f_longitude)
      }
    return
    }

#$% find distance from new center point to old center point
if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
  {
   call RLL2RB (Xsta$latitude$f,
                Xsta$longitude$f,
                COS(Xsta$latitude$f),
                f_latitude,
                f_longitude,
                COS(f_latitude),
                range,brng)
   STA$PlotRadius$I = xSTA$PlotRadius$I
  }
else                       # control plotting another station's geo
  {
   call RLL2RB (xSTA$CopyLatitude$F, xSTA$CopyLongitude$F,
                COS(xSTA$CopyLatitude$F),
                f_latitude, f_longitude,
                COS(f_latitude), range, brng)
   STA$PlotRadius$I = xSTA$CopyPlotRadius$I
  }

#$% if range is beyond a tenth of the plot radius
if (range >= (max(1,sta$PlotRadius$i) * 0.10) )
   {
    #$% save the plot and position
    PUTsta$PlotMap$i ($YES)             # request map refresh

    if (STA$PlotCopy$I == $no) # if station is plotting own geo vs.   # clk 12/92
      {
       PUTsta$latitude$f   (f_latitude)
       PUTsta$longitude$f  (f_longitude)
      }
    else                       # control plotting another station's geo
      {
       putSTA$CopyLatitude$F   (f_latitude)
       putSTA$CopyLongitude$F  (f_longitude)
      }
    }

return
end



 Integer Function MADMIN(RAD)

##########################################################
 #$%
 #$% Purpose:   MADMIN converts radian value to degrees
 #$%            and minutes for display.
 #$%
 #$% Called By: PLOTUP     BARERS     LATLON
 #$%
 #$% Calls:     ABS        INT        FLOAT
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

 integer IABDEG,
         IABMIN                                 # MJC 6/1/2K (E2145)
 real XBDEG,
      RAD,
      XBMIN                                     # MJC 6/1/2K (E2145)

 XBDEG = ABS(RAD * (180./$PI))                  #convert to absolute degrees

 IABDEG = INT(XBDEG)                            #take integer part

 XBMIN = 60. * (XBDEG - FLOAT(IABDEG))          #convert excess to minutes

 IABMIN = INT(XBMIN + .5)                       #round to nearest whole minute

 if(IABMIN >= 60)                               #if 60 minutes

   {
    IABDEG = IABDEG + 1                         #make one more degree

    IABMIN = 0                                  #and zero minutes
   }                                            #end if 60 minutes

 MADMIN = 100 * IABDEG + IABMIN                 #assemble to DDDMM format

 return
 end






Subroutine Plot_Pim_Lines (STA$pointer,
                           UNT$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_PIM_LINES plots points of intended movements
 #$%            with lines for display to the specified view.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     DRAW_POLYGON_C
 #$%
 #$% Tables:    UNT     STA     PIM
 #$%
 #$% Date:      DEC 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  Jim Allen - 2/98 (E1864)
 #$%            Added the UNT$Pointer to the routine interface,
 #$%            since the caller already determined it.  The old
 #$%            way stored the PIM name and searched the UNT table
 #$%            for a match.
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_Common
$poly$styles

integer  STA$Pointer, UNT$Pointer

real*4          lLAT[10],               ## lat of pim lines
                lLON[10]                ## long of pim lines

integer         COLOR                  ## color of pim XMARK OR LINE

integer ISTA,
        IX,
        ID,
        NPTS                                            # MJC 6/1/2K (E2145)
BBDeclare  (STA$View$I,
            UNT$Name$C,
            UNT$View$I,
            UNT$Pimindx$I,
            PIM$Pointer,
            PIM$Nlegs$I,
            PIM$PTS$Index,
            PIM$PTS$latitude$F,
            PIM$PTS$longitude$F)                        # MJC 6/1/2K (E2145)
literal CSTRIP8                                         # MJC 6/1/2K (E2145)
 integer poly_type #SMM 5/14

  ista          = STA$Pointer$Index       ## save STA pointer index
  STA$View$I    = xSTA$View$I             ## get STA view

  UNT$Name$C = xUNT$Name$C
  UNT$View$I = xUNT$View$I              
  UNT$PimIndx$I = xUNT$PimIndx$I

  COLOR = $Color$PIM$LINE   

  ############### Substitution <<<>>>             1/28/86
  if (UNT$PimIndx$I == 0) RETURN               # 9/98 JOA (E2030)
  else if (sta$View$i != $Neutral$view) 
    {                                          #       7/6/86
     if (UNT$View$I != sta$View$i ) RETURN     # 9/98 JOA (E2030)
    }
                                                #       7/6/86
  PIM$Pointer$To (UNT$PimIndx$I)              ## init PIM pointer
  PIM$NLegs$I = xPIM$NLegs$I                  ## get number of legs
  npts = PIM$NLegs$I + 1                      ## add 1 for starting point

  for (PIM$PTS$Index=1; PIM$PTS$Index <= npts;        
                        PIM$PTS$Index = PIM$PTS$Index+1) ## loop for lat/long
    {
     PIM$PTS$Latitude$F  = xPIM$PTS$Latitude$F
     PIM$PTS$Longitude$F = xPIM$PTS$Longitude$F
    
     lLAT[PIM$PTS$Index] = PIM$PTS$Latitude$F  * 180/ $PI
     lLON[PIM$PTS$Index] = PIM$PTS$Longitude$F * 180/ $PI
        
     next
    }

  if (Xpim$ContinuousFlag$I == YES)   # drop first leg of PIM (if Orbit)
    {
     ix = 2
     Npts = Npts - 1
    }
  else
    {    
     ix = 1
    }

  ID = 0
  poly_type = poly_line_style[$poly$PIM]
  call Draw_polygon_c (ID, lLAT[ix], lLON[ix], -Npts, 
       		      COLOR, poly_type)

return
end



Subroutine Plot_Pim_Marks (kview, STA$Label$I, STA$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_PIM_MARKS plots points of intended movements
 #$%            with x-marks for display to the specified view.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK   DRAW_UNIT_C
 #$%
 #$% Tables:    UNT     STA     PIM
 #$%
 #$% Date:      DEC 83
 #$%
 #$% Author:    Adamos T.
 #$%
 #$% Modified:  James Allen - 8/96 (E1641)
 #$%            If the pim is marked for deletion don't
 #$%            plot it.
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_Common

real*4          LAT,                    ## lat of pim xmarks
                LON,                    ## long of pim xmarks
                LENGTH,
                BEARING,
                COURSE

integer         COLOR,                  ## color of pim XMARK OR LINE
                BINCK,
                TYPE
integer*4       SPEED

character       NAME1[20],                      ## name of PIM
                NAME2[20]                       ##

literal CSTRIP8                                 # MJC 6/1/2K (E2145)
BBDeclare  (UNT$Pointer,
            UNT$View$I,
            UNT$Type$I,
            UNT$Truelatitude$F,
            UNT$Truelongitude$F,
            STA$Pointer,
			STA$PlotLabelDeclutter$I,
            STA$Label$I)                        # MJC 6/1/2K (E2145)
integer ISTA,
        KVIEW,
        NTDS,
        ID,
        NN,
        ISTAT,
        INFO                                    # MJC 6/1/2K (E2145)
integer X1, X2, X3, DRAW_UNIT_C                   # MJC 6/1/2K (E2145)

STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

ista          = STA$Pointer$Index       ## save STA pointer index

for (UNT$Pointer$First; UNT$Pointer$Valid; UNT$Pointer$Next)
    {
    UNT$View$I = xUNT$View$I              
    if (UNT$View$I != kview)      next   ## check for same view

    UNT$Type$I = xUNT$Type$I
    if (UNT$Type$I != $Pim$Code)  next   ## must be PIM code
    
    if (xUNT$Status$I == $BeingDeleted$Code)  # joa 8/96 (E1641)
      next

    if (kview >= $FirstBlue$View & kview <= $LastBlue$View)
        {
        Color = $Color$PIM$Bmark
        } 
    else if (kview < $FirstBlue$View)
        {
        Color = $Color$PIM$Nmark
        } 
    else 
        {
        Color = $Color$PIM$Omark
        } 

    UNT$TrueLatitude$F  = xUNT$TrueLatitude$F   ## extract unit latitude
    UNT$TrueLongitude$F = xUNT$TrueLongitude$F  ## and longitude

    if (BINCK (UNT$TrueLatitude$F, UNT$TrueLongitude$F) == NO) next 

    NTDS   = $NTDS$XMark
    ID     = UNT$Pointer$Index
    LAT    = UNT$TrueLatitude$F * 180/ $PI              ## convert to degrees
    LON    = UNT$TrueLongitude$F * 180/ $PI    
    COURSE = xUNT$TrueCourse$F * 180 / $PI
    SPEED  = xUNT$TrueSpeed$F
    TYPE   = xUNT$Type$I


    if (STA$Label$I == YES)                     ## if labels are requested
        {
        nn = 0
        call smovhn (xUNT$Name$C, $$MaxLit, NAME1, nn)
        call smov  (EOS,            NAME1, nn)

        NAME2[1] = EOS
        }
    else                                        ## no labels
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                      NAME2, COLOR, COURSE,
                      SPEED, TYPE, x1, 
                      x2, x3, 
                      INFO)

    if (istat == NO) continue

    if (Xsta$plotspeedship$i == YES)
      {
       BEARING = xUNT$TrueCourse$F * 180/ $PI       #convert radians to degrees
       if (xUNT$TrueSpeed$F > 100)
           LENGTH  = 40.0 * int(xUNT$TrueSpeed$F / 200 + 0.5)
       else 
           LENGTH  = 40.0 * int(xUNT$TrueSpeed$F / 7 + 0.5)
       call Draw_Vector_c (ID, LAT, LON, LENGTH, BEARING)
      }
    }
# ?????

#    UNT$PimIndx$I = xUNT$PimIndx$I             ## init PIM pointer
#    PIM$Pointer$To (UNT$PimIndx$I)
#
#    PIM$NLegs$I = xPIM$NLegs$I                         ## get number of legs
#    PIM$NLegs$I = PIM$NLegs$I+1                        ## add starting point
#
#    for (PIM$PTS$Index=1; PIM$PTS$Index <= PIM$NLegs$I; 
#                     PIM$PTS$index = PIM$PTS$index+1) ## loop for lat/long
#        {
#        PIM$PTS$Latitude$F  = xPIM$PTS$Latitude$F
#        PIM$PTS$Longitude$F = xPIM$PTS$Longitude$F
#
#        if (BINCK (PIM$PTS$Latitude$F,PIM$PTS$Longitude$F) == NO) next
#
#        xLAT = PIM$PTS$Latitude$F  * 180/ $PI
#        xLON = PIM$PTS$Longitude$F * 180/ $PI
#    
#        call Draw_Xmark_c (xLAT, xLON, Color)
#    
#        if (STA$Label$I == $YES)               ## if labels requested
#            {
#           nn = 0                                      ## get name of base
#            call smovhn (xUNT$Name$C,$$MaxLit,NAME1,nn)
#            call smov  (EOS,          NAME1,nn)
#                   
#            NAME2[1] = EOS
#           }
#       else
#           {
#           NAME1[1] = EOS
#           NAME2[1] = EOS
#           }
#        }
#    }  

return
end



Subroutine Plot_Nuclear (STA$Pointer)                         #receive view

 ##########################################################
 #$%
 #$% Purpose:   PLOT_NUCLEAR collects circle data for
 #$%            display to the specified station.
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_CIRCLE_C
 #$%
 #$% Tables:    NUC
 #$%
 #$% Date:      May 83
 #$%
 #$% Author:    Adamos T.
 #$%
 ##########################################################

BBcommon
PLOTcommon

integer         BINCK,
                RADIUS,
                COLOR
real*4          LAT,
                LON

BBDeclare  (STA$Pointer,
            NUC$Pointer,
            NUC$Latitude$F,
            NUC$Longitude$F)                        # MJC 6/1/2K (E2145)
integer ISTA                                        # MJC 6/1/2K (E2145)

ista  = STA$Pointer$Index

COLOR = $Color$Nuc$Circle

for (NUC$Pointer$First; NUC$Pointer$Valid; NUC$Pointer$Next) 
    {
    RADIUS = xNUC$Radius$I
    
    NUC$Latitude$F  = xNUC$Latitude$F          #get latitude
    NUC$Longitude$F = xNUC$Longitude$F         #get longitude

    if (BINCK(NUC$Latitude$F, NUC$Longitude$F) == NO) next

    LAT = NUC$Latitude$F  * 180/ $PI
    LON = NUC$Longitude$F * 180/ $PI

    if (RADIUS == 0) RADIUS = 1

    if (RADIUS == 25)
        {
        call Draw_Circle_c (LAT, LON, RADIUS, COLOR, $Poly$NucBlast)
        }
    else
        {
        call Draw_Circle_c (LAT, LON, RADIUS, COLOR,$Poly$NucCircle)
        }
    }
return
end


Subroutine Plot_LINEseq(STA$Pointer)

 ##########################################################
 #$%
 #$% Purpose:   PLOT_LINEseq collects POLYGON and LINEsequence
 #$%            data for display to the APPROPRIATE STATIONS....
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_LINEseq
 #$%
 #$% Tables:    LIN
 #$%
 #$% Date:      November 1989
 #$%
 #$% Author:    Joe Bryant
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

literal CSTRIP8
integer     BINCK, COLOR
real        flats[LIN$PTS$Slots], flons[LIN$PTS$Slots]
#real        plats[LIN$PTS$Slots], plons[LIN$PTS$Slots]

BBDeclare  (STA$Pointer,
			STA$PlotLabelDeclutter$I,
            LIN$Pointer,
            LIN$Numpts$I,
            LIN$Color$I,
            LIN$PTS$Index)                      # MJC 6/1/2K (E2145)
integer ISTA,
        NPTS,
        KABSPTS,
        KCNT,
        ID                                      # MJC 6/1/2K (E2145)
integer         name_len, mark
integer 	poly_type #SMM 5/14
character       name1[ARB], name2[ARB]

ista  = STA$Pointer$Index
STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I

for (LIN$Pointer$First; LIN$Pointer$Valid; LIN$Pointer$Next)
   {
    If (xLIN$Station$i != ista)    NEXT 

    # Line/polygon is currently erased
    If (Xlin$PlotFlag$i == 0)      NEXT    # joa 3/05 per_ordsyntax

    LIN$numPTS$i = xLIN$numPTS$i    # (Signed)
    Npts = LIN$numPTS$i             # (Signed)
    kabspts = abs(Npts)             # non-negative

    LIN$Color$I = xLIN$Color$I                    # jb    9/18/90
    if(LIN$Color$I != $NO) COLOR = LIN$Color$I    # jb    9/18/90
    else                   COLOR = $Color$BOX$red
    
    kcnt = 0
    for(LIN$PTS$index=1;LIN$PTS$index <=kabspts;LIN$PTS$index =LIN$PTS$index +1)
       {
        flats[LIN$PTS$index] = xLIN$PTS$Latitude$f
        flons[LIN$PTS$index] = xLIN$PTS$Longitude$f
        kcnt = kcnt + BINCK (flats[LIN$PTS$index], flons[LIN$PTS$index])
 
        flats[LIN$PTS$index] = flats[LIN$PTS$index] * 180/$PI
        flons[LIN$PTS$index] = flons[LIN$PTS$index] * 180/$PI

       }

    if (kcnt == NO) next        # no points within Plot Radius

    if(xLIN$LINE$I == $YES)                # LINEseq, NOT a POLYGON..
        Npts = -Npts                      # jb            12/18/89

    ID = 0
    poly_type = poly_line_style[$poly$O_Minefield]
    call Draw_polygon_c (ID, FLATs, FLONs, Npts, COLOR, poly_type)
#                                      signed  dk-red      Dashed Line
    if (xLIN$LabelFlag$I == $yes)
    {
        name_len = 0
        call smovhn (xLIN$Name$C, $$MaxLit, name1, name_len)
        call smov  (EOS, name1, name_len)  
        name_len = 0
        call smov  (EOS, name2, name_len) 
	mark = $NTDS$Xmark 
        call draw_ntds_c (mark, FLATs[1],FLONs[1],
                               COLOR, STA$PlotLabelDeclutter$I, name1, name2)
    }   # end of if labels are on
   }

return
end




Subroutine PLOT_ROUTES ( STA$Pointer )
##########################################################
#$%
#$% Purpose:    PLOT_ROUTES draws specified routes.
#$%
#$% Called By:  PLOT_UP
#$%
#$% Calls:      DRAW_POLYGON_C   RRB2LL
#$%
#$% Tables:     RTE     PRT
#$%
#$% Date:       6 Sep 05
#$%
#$% Author:     James O. Allen
#$%
##########################################################

BBcommon
#GEOcommon
PLOTcommon
SELECT_common
$poly$styles

real            LATs[ $play$stack$max ], LONs[ $play$stack$max ], 
                Save_Lat, Save_Lon

integer         BINCK
integer         npoints, route_color
integer         kargs, isee, ipos, iseq, icnt, nord
integer*4       sta_Index

integer         name_len 
character       name1[ARB], name2[ARB]      # for labeling routes


BBDeclare  (STA$Pointer,
            STA$View$I,
            STA$Label$I,
			STA$PlotLabelDeclutter$I,
            PRT$Pointer,
            PRT$View$I,
            PRT$Color$I)                        # MJC 6/1/2K (E2145)
BBDeclare  (RTE$Pointer,
            RTE$NumOrders$I,
            RTE$Name$C)
BBDeclare  (RTO$Pointer,
            rto$wrd$index)

integer I_PRT_RTE_INDEX,
        ISTASIDE,
        IPRTSIDE,
        ID,
        ITYPE,
        isorbit,
        orbitIndx,
        isPlottableOrder,
	mark

real FRANGE,
     BRG,
     FCOS                                       # MJC 6/1/2K (E2145)
real orbit_lat[2], orbit_lon[2]

literal CSTRIP8                                 # MJC 6/1/2K (E2145)

sta_Index = STA$Pointer$Index

sta$view$i = xsta$view$i

if      (sta$view$i < $FirstBlue$View)    iSTAside = $neutral$code
else if (sta$view$i < $FirstOrange$View)  iSTAside = $blue$code
else                                      iSTAside = $orange$code

STA$Label$I = xSTA$Label$I   # clk 11/96 (E1677) - route labeling
STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I

for (PRT$Pointer$First; PRT$Pointer$ok ; PRT$Pointer$Next)
    {
    IF ( sta_index != xPRT$STA_Index$i ) next

    PRT$View$I = xPRT$View$I                 

    if      (PRT$view$i < $FirstBlue$View)    iPRTside = $neutral$code
    else if (PRT$view$i < $FirstOrange$View)  iPRTside = $blue$code
    else                                      iPRTside = $orange$code
 
    #$% control sees both sides, blue and orange see same side
    if ( iSTAside != $Neutral$code & iPRTside != iSTAside ) next

    PRT$RTE_Index$i  = xPRT$RTE_Index$i
    PRT$Color$i  = xPRT$Color$i

    RTE$Pointer$to  PRT$RTE_Index$i
    icnt  = XRte$NumOrders$i# Number of orders in route
    isee = 0                # Number of currently visible positions
    ipos = 0                # Number of position type orders
    rto$pointer = Xrte$RTOpntr$i
    # Loop through orders in route.
    for (iseq = 1; iseq <= icnt; iseq = iseq + 1)
    {
        if (iseq > 1 & isorbit == NO)
            rto$pointer$next            # Next route order
        # Is this order a positon type order? If not skip
        rto$wrd$index = 3           # Order Number
        nord = Xrto$wrd$$c
        kargs = Xrto$NbrArgs$i - 7
        if (isPlottableOrder(iseq, nord, kargs, Xrto$args$i) == $NO) next

        if (isorbit == YES)
        {
            orbitIndx = 2
            save_lat = orbit_lat[orbitIndx]
            save_lon = orbit_lon[orbitIndx]
            isorbit = NO
        }            

        else if (nord == orbit$order)
        {
            isorbit = YES
            orbitIndx = 1
            icnt = icnt + 1
            call plot_route_orbit (nord, kargs, Xrto$args$i,
                                   orbit_lat, orbit_lon)
            save_lat = orbit_lat[orbitIndx]
            save_lon = orbit_lon[orbitIndx]
        }
        else
            call get_position_from_order(nord, kargs, Xrto$args$i, save_lat,
                                     save_lon)
        ipos = ipos + 1

        isee = isee + BINCK ( Save_Lat, Save_Lon )

        #At this point, Save_Lat and Save_Lon contain the position to move to,
        #in radians. Convert it to decimal lat/lon, and store it in the arrays.

        LATs[ipos] = Save_Lat * 180/ $PI
        LONs[ipos] = Save_Lon * 180/ $PI
    
        if (xPRT$LabelRouteFlag$I == $yes)    # clk 11/96 (E1677) - labeling routes
        {
            name_len = 0
            if (ipos == 1)
            {
                call smovhn (xRTE$Name$C, $$MaxLit, name1, name_len)
                call smovv  ("-", name1, name_len)
                call smovi (iseq, name1, name_len)
            }
            else
            {
                call smovib (iseq, 4, name1, name_len)
            }

            call smov  (EOS, name1, name_len)  
            name_len = 0
            call smov  (EOS, name2, name_len)
	    mark = $NTDS$Xmark  
            call draw_ntds_c (mark, LATs[ipos], LONs[ipos],
                            PRT$Color$i, STA$PlotLabelDeclutter$I, name1, name2)
        }   # end of if labels are on
    } # End of the loop thru list of orders

    #$% if all points outside of screen, don't plot
    IF ( isee == 0 ) next

    #$% if no fixed position orders, don't plot
    IF ( ipos == 0 ) next

    npoints = ipos
   
    ID = Rte$Pointer$Index
    itype = poly_line_style[$Poly$PIM]
    route_color   = PRT$Color$i
    RTE$Name$c= xRTE$Name$c   

    npoints = -npoints # DON'T close polygon....
    #Now, call the routine to actually draw the route.
    call DRAW_POLYGON_C (ID, LATs, LONs,npoints, 
                         route_color, itype )
}

return
end

Subroutine plot_route_orbit (nord, nargs, args, orbit_lat, orbit_lon)
##########################################################
#$%
#$% Purpose:    plot_route_orbit plots orbit order in route
#$%
#$% Called By:  PLOT_ROUTES 
#$%
#$% Calls:      UNTFND   RRB2LL    DMS2rad
#$%
#$% Tables:     UNT
#$%
#$% Date:       13 Jun 09
#$%
#$% Author:     James O. Allen
#$%
##########################################################
BBcommon

integer nord, nargs, integer route_color
literal args[ARB]
real lat, lon, DMS2rad, brg, frange,fcos
literal base_name
BBDeclare (unt$pointer, unt$view$i)
real orbit_lat[2], orbit_lon[2]

#  1          2            3           4           5          6 
#ORBIT <nautical-miles> <latitude> <longitude> <latitude> <longitude>


Orbit_lat[1] = DMS2rad (args[3])
Orbit_lon[1] = DMS2rad (args[4])
Orbit_lat[2] = DMS2rad (args[5])
Orbit_lon[2] = DMS2rad (args[6])

return
end



Subroutine plot_SPAs ( STA$Pointer )
##########################################################
#$%
#$% Purpose:    Plot_SPAs draws specified Submarine
#$%             Patrol Areas.
#$%
#$% Called By:  PLOT_UP
#$%
#$% Calls:      DRAW_POLYGON_C   RRB2LL
#$%
#$% Tables:     SPA      PSP
#$%
#$% Date:       October 1991
#$%
#$% Author:     Carol L. Kropp
#$%
##########################################################
BBcommon
PLOTcommon
SELECT_common
$poly$styles

literal CSTRIP8

BBDeclare (STA$Pointer, STA$View$I, STA$PlotLabelDeclutter$I)

integer  PSP$Pointer, PSP$Side$I, PSP$Color$I
integer  SPA$Pointer, SPA$NumPoints$I, SPA$POS$Index
real     SPA$POS$Latitude$F, SPA$POS$Longitude$F
integer  station_side
real     LAT [SPA$POS$Slots], LON [SPA$POS$Slots] 
integer  binck

integer ICNT                                    # MJC 6/1/2K (E2145)
integer         name_len, mark
integer		poly_type #SMM 5/14
character       name1[ARB], name2[ARB]


  STA$View$I = xSTA$View$I

  if (STA$View$I < $FirstBlue$View)
    station_side = $Neutral$Code
  else if (STA$View$I < $FirstOrange$View)
    station_side = $Blue$Code
  else
    station_side = $Orange$Code

STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I

  for (PSP$Pointer$First; PSP$Pointer$Valid; PSP$Pointer$Next)
    {
     if (xPSP$InUse$I == $no)     # if the slot is not in use - next
       next

     SPA$Pointer$To  (xPSP$SPA_Index$I)
     SPA$NumPoints$I = xSPA$NumPoints$I
     if (SPA$NumPoints$I == 0)    # if the SPA was deleted - delete PSP entry
       {
        PSP$Zero
        next
       }

     if (STA$Pointer$Index != xPSP$STA_Index$I)   # if not the correct station - next
       next

     PSP$Side$I = xPSP$Side$I
 
     #$% control sees both sides, blue and orange see same side
     if (station_side != $Neutral$code &   # if the station is not control and
         PSP$Side$I != station_side)       # the station and the SPA are not
        next                               # for the same side - next

     icnt = 0                # count points within BIN

     for (SPA$POS$Index = 1; SPA$POS$Index <= SPA$NumPoints$I;
                             SPA$POS$Index = SPA$POS$Index + 1)
       {
        SPA$POS$Latitude$F  = xSPA$POS$Latitude$F
        SPA$POS$Longitude$F = xSPA$POS$Longitude$F

        icnt = icnt + BINCK (SPA$POS$Latitude$F, SPA$POS$Longitude$F) 

        LAT [SPA$POS$Index] = SPA$POS$Latitude$F * 180.0 / $pi
        LON [SPA$POS$Index] = SPA$POS$Longitude$F * 180.0 / $pi
       }
    
     if (icnt == $no)     # if no points are within plot radius - next
       next

     PSP$Color$I = xPSP$Color$I

     # call the routine to actually draw the SPA
     poly_type = poly_line_style[$Poly$SPA]
     call DRAW_POLYGON_C (0, LAT, LON, SPA$NumPoints$I,
                          PSP$Color$I, poly_type)

     if (xPSP$LabelFlag$I == $yes)
     {
        name_len = 0
        call smovhn (xSPA$Name$C, $$MaxLit, name1, name_len)
        call smov  (EOS, name1, name_len)  
        name_len = 0
        call smov  (EOS, name2, name_len)
	mark = $NTDS$Xmark  
        call draw_ntds_c (mark, LAT[1], LON[1],
                          PSP$Color$i, STA$PlotLabelDeclutter$I, name1, name2)
     }   # end of if labels are on
    }

return
end



Subroutine Plot_LandingZones (STA$Pointer)  # receive view

 ##########################################################
 #$%
 #$% Purpose:   PLOT_LANDINGZONES collects data for
 #$%            display to the APPRORRIATE STATIONS....
 #$%
 #$% Called By: PLOT_UP
 #$%
 #$% Calls:     BINCK     DRAW_PLOYGON
 #$%
 #$% Tables:    ALZ
 #$%
 #$% Date:      November 19889
 #$%
 #$% Author:    R. Hundt
 #$%
 ##########################################################

BBcommon
PLOTcommon
$poly$styles

literal CSTRIP8

real*4          fLAT[ ALZ$BND$Slots ], fLON[ ALZ$BND$Slots ]
integer         BINCK, COLOR

BBDeclare  (STA$Pointer,
            STA$View$I,
			STA$PlotLabelDeclutter$I,
            ALZ$Pointer,
            ALZ$Side$I,
            ALZ$BND$Index,
            ALZ$BND$latitude$F,
            ALZ$BND$longitude$F)                        # MJC 6/1/2K (E2145)
integer ISTA,
        ICNT,
        ISTASIDE,
        ID                                              # MJC 6/1/2K (E2145)
integer poly_type #SMM 5/14

integer         name_len, mark
character       name1[ARB], name2[ARB]


IF (xSTA$PlotLandingZones$i == $no ) return

ista  = STA$Pointer$Index
icnt = $NO

COLOR = $color$LandZone   

STA$View$I    = xSTA$View$I                

if      (sta$view$i < $FirstBlue$View)    iSTAside = $neutral$code
else if (sta$view$i < $FirstOrange$View)  iSTAside = $blue$code
else                                      iSTAside = $orange$code

STA$PlotLabelDeclutter$I = XSTA$PlotLabelDeclutter$I

for (ALZ$Pointer$First; ALZ$Pointer$Valid; ALZ$Pointer$Next)
    {
    ALZ$Side$I = xALZ$Side$I                 
 
    #$% if invalid for land zones
#    if (ALZ$side$i == 0) next

    #$% control sees both sides, blue and orange see same side
    if ( iSTAside != $Neutral$code & ALZ$side$i != iSTAside ) next

    FOR (ALZ$BND$Index=1; ALZ$BND$Index$OK; ALZ$BND$Index=ALZ$BND$Index +1)
        {
        ALZ$BND$Latitude$F  = xALZ$BND$Latitude$F               # RADIANS
        ALZ$BND$Longitude$F = xALZ$BND$Longitude$F              # RADIANS

        #$% if no more points
        IF ( ALZ$BND$Latitude$F == $no ) 
            {
            ALZ$BND$Index = ALZ$BND$Index - 1
            BREAK
            }
        icnt = icnt + BINCK ( ALZ$BND$Latitude$F, ALZ$BND$Longitude$F) 

        fLAT [ ALZ$BND$Index ] = ALZ$BND$Latitude$F * 180/ $PI     # convert to degrees
        fLON [ ALZ$BND$Index ] = ALZ$BND$Longitude$F * 180/ $PI
        }                       

    if (icnt == NO |               # all points no within screen display
        ALZ$BND$Index < 3 ) NEXT   # number of points too small

    ID = 0
    poly_type = $Poly$Solid$Code
    call Draw_Polygon_C (ID, FLAT, fLON, ALZ$BND$Index, COLOR, poly_type)

    if (xALZ$LabelFlag$I == $yes)
    {
        name_len = 0
        call smovhn (xALZ$Name$C, $$MaxLit, name1, name_len)
        call smov  (EOS, name1, name_len)  
        name_len = 0
        call smov  (EOS, name2, name_len)
        mark = $NTDS$Xmark  
        call draw_ntds_c (mark, FLAT[1],FLON[1],
                               COLOR, STA$PlotLabelDeclutter$I, name1, name2)
    }   # end of if labels are on
    } # end loop thru landing zones

return
end


Subroutine Plot_EOIR (iview, STA$Label$I, STA$pointer)

##########################################################
 #$%
 #$% Purpose:   PLOT_EOIR collects EOIR data and validates for 
 #$%            display to the specified view.
 #$%
 #$% Date:      May 92
 #$%
 #$% Author:    D. Wills
 #$%
 ##########################################################

BBcommon
PLOTcommon
Select_Common

character       NAME1[20],
                NAME2[20]
integer         NTDS,
                COLOR,
                BINCK,
                label_id,
                DRAW_UNIT_C,
                SELECT_RMT,
                TYPE
integer*4       SPEED
real*4          LAT,
                LON,
                COURSE,
                LENGTH                          ## NTDS speed vector length
#                BEARING,                         ## NTDS speed vector heading
#                latitude,
#                longitude

Literal         Astab_EOIR_Class
Literal         D_Type
vaxcharacter    h_msg*60
integer         h_len

literal CSTRIP8                                 # MJC 6/1/2K (E2145)
BBDeclare  (IRD$Pointer,
            IRD$Time$F,
            IRD$Latitude$F,
            IRD$Longitude$F,
            IRD$Course$I,
            IRD$Speed$I,
            IRD$Trackseq$I,
            IRD$Targetname$C,
            IRD$Detectorname$C,
            STA$Label$I,
            STA$Pointer,
			STA$PlotLabelDeclutter$I,
            UNT$Pointer,
            UNT2$Pointer,
            RVU$Pointer)                        # MJC 6/1/2K (E2145)
integer IVIEW,
        ICLASS,
        ITYPE,
        ISIDE,
        N1,
        N2,
        ID,
        ISTAT,
        INFO                                    # MJC 6/1/2K (E2145)
integer TID, X1, X2, X3                         # MJC 6/1/2K (E2145)

RVU$Pointer$To iview
STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

for (IRD$Pointer$First; IRD$Pointer$ok; IRD$Pointer$Next)
    {
    if(xIRD$InUse$I == $no) next                # Empty entry

    UNT$Pointer$to (xIRD$DetectorIndx$I)        # clf 1/21/93
    if(xUNT$View$I != iview) next               # Skip other views
    UNT2$Pointer$to (xIRD$TargetIndx$I)

    ird$Time$f   = xird$Time$f
    if (ird$Time$f + Minutes$to$old < imin) next   # Skip Old entries

    IRD$Latitude$F      = xIRD$Latitude$F   
    IRD$Longitude$F     = xIRD$Longitude$F  
    IRD$Course$I        = xIRD$Course$I      
    IRD$Speed$I         = xIRD$Speed$I       
    IRD$TrackSEQ$I      = xIRD$TrackSEQ$I    
    IRD$TargetName$C    = xUNT2$Name$C  
    IRD$DetectorName$C  = xUNT$Name$C

    if (BINCK (IRD$Latitude$F, IRD$Longitude$F) == NO) next

    d_type = Astab_EOIR_Class (IRD$Pointer)

    IF  (xIRD$TargetType$I == $Air$Code) iClass = $Air$Code
    ELSE                                 iClass = $Surface$Code

    Tid = $Unknown$Code
    label_id = 'I'

    if (SELECT_RMT (iview,iClass,Tid,itype,iside,COLOR) == NO) 
          next

    NTDS   = NTDS_Symbol[itype,iside]
    LAT    = IRD$Latitude$F * 180/ $PI       
    LON    = IRD$Longitude$F * 180/ $PI
    COURSE = IRD$Course$I
    SPEED  = IRD$Speed$I
    TYPE   = xUNT2$Type$I                   # clf 1/21/93

    if (ird$Time$f + Minutes$to$YELLOW < imin) 
        {
        COLOR = $Color$Obj$Fading
        }

    if (STA$Label$I == $YES)                    ## if labels requested
        {
        n1 = 0

        call smov  (ctkcd,               NAME1,n1)
        call smov  (label_id,            NAME1,n1)
        call smoviz(IRD$TrackSeq$I,3,    NAME1,n1)
        call smov  (EOS,                 NAME1,n1)    

        n2 = 0
        call smovhn (D_Type,$$MaxLit,    NAME2,n2)
        call smov  (EOS,                 NAME2,n2)    
        }
    else
        {
        NAME1[1] = EOS
        NAME2[1] = EOS
        }

    call get_hook_id (ID)       # Get a unique hook reference

    h_len = 0
    if (level$ir == 0) call vmovv ("EOIR Track;By ",h_msg,h_len)
    else
       {
        call vmovv ("ID: ",h_msg,h_len)
        call vmov (ctkcd,h_msg,h_len)
        call vmov (label_id,h_msg,h_len)
        call vmoviz (IRD$TrackSeq$I,3,h_msg,h_len)
        call vmovv ("(IR);By ",h_msg,h_len)
       }
    call vmovhn (IRD$DetectorName$C,$$MaxLit,h_msg,h_len)
    call vmovv (";Of ",h_msg,h_len)
    call vmovhn (D_Type,$$MaxLit,h_msg,h_len)

    istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                      NAME2, COLOR, COURSE,
                      SPEED, TYPE, x1, 
                      x2, x3, 
                      INFO)

    if      (istat == NO) continue              # Plot Speed - jms 10/26/92
    else if (xSTA$plotspeedair$i == YES & itype == $$$Air)
        {
        LENGTH  = 40.0 * int(SPEED / 200 + 0.5)
        call Draw_Vector_C (ID, LAT, LON, LENGTH, COURSE)
        }
    else if (xSTA$plotspeedship$i == YES & itype != $$$Air)
        {
        LENGTH  = 40.0 * int(SPEED / 7 + 0.5)
        call Draw_Vector_C (ID, LAT, LON, LENGTH, COURSE)
        }

    Call Add_Hook_Info (Id, H_Msg[1:H_Len])

   } #   End of loop thru IRD table

return
end


Subroutine Plot_hide_sites (kview,STA$Pointer)
##########################################################
#$%
#$% Purpose:   PLOT_hide_sites sets up plot data for all 
#$%            hide sites that are to be plotted.
#$%
#$% Called By: PLOT_hide_sites
#$%
#$% Calls:     BINCK   SMOVH   SMOV    DRAW_UNIT_C
#$%            SELECT_hide_sites
#$%
#$% Tables:    STA     UNT
#$%
#$% Date:      July 92
#$%
#$% Author:    Adamos T./Chris P. Acantilado
#$%
##########################################################
BBcommon
PLOTcommon
Select_common

real*4          LAT, LON, COURSE
integer         select_hide_sites    # integer function
integer*4       kview, kside,
                SPEED, TYPE, NTDS,
                itype, iside, COLOR,
                BINCK                # integer function
character       NAME1[20], NAME2[20]

literal CSTRIP8                                 # MJC 6/1/2K (E2145)
BBDeclare  (UNT$Pointer,
            UNT$Truelatitude$F,
            UNT$Truelongitude$F,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)
integer ID,
        NN,
        istat,
        draw_unit_c,
        INFO                                    # MJC 6/1/2K (E2145)
integer X1, X2, X3                              # MJC 6/1/2K (E2145)

  STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
  STA$Label$i = xSTA$Label$I

  if      (kview == $Neutral$View )   kside = $$$Neutral
  else if (kview <= $LastBlue$View)   kside = $$$Blue
  else                                kside = $$$Orange

  for (UNT$Pointer$First; UNT$Pointer$OK; UNT$Pointer$Next)  
    {       # Search UNT table for all shorebases....
     if ( SELECT_hide_sites(kside,UNT$Pointer,itype,iside,COLOR,NTDS) == NO )
       next

     UNT$TrueLatitude$F  = xUNT$TrueLatitude$F   ## Get Lat/Long of base 
     UNT$TrueLongitude$F = xUNT$TrueLongitude$F
     if (BINCK (UNT$TrueLatitude$F, UNT$TrueLongitude$F) == NO)
       next

     ID     = UNT$Pointer$Index
     LAT    = UNT$TrueLatitude$F  * 180/$PI      ## Convert Lat to degrees
     LON    = UNT$TrueLongitude$F * 180/$PI      ## Convert Lon to degrees
     COURSE = 0.0
     SPEED  = 0
     TYPE   = xUNT$Type$I

     if (STA$Label$I == YES)
       {
        nn = 0                                  ## get name of base
        call smovhn (xUNT$Name$C,$$MaxLit,NAME1,nn)
        call smov  (EOS,          NAME1,nn)
        NAME2[1] = EOS
       }
     else
       {
        NAME1[1] = EOS
        NAME2[1] = EOS
       }

     istat = Draw_UNIT_C (NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                     NAME2, COLOR, COURSE,
                     SPEED, TYPE, x1, 
                     x2, x3, INFO)
    }                     

return
end



Integer Function SELECT_hide_sites (kside,UNT$Pointer,itype,iside,icolor,ntds)
#########################################################
#$%
#$% Purpose:    SELECT_hide_sites validates if a given hide
#$%             site should be plotted on the geo display.
#$%
#$% Called By:  PLOT_UP
#$%
#$% Calls:      None
#$%
#$% Date:       JULY 92
#$%
#$% Author:     C. Leaf/Chris P. Acantilado
#$%
#########################################################
BBcommon
Select_common

BBDeclare  (STA$Pointer)                        # MJC 6/1/2K (E2145)
integer     ISTA,
            IVIEW,
            IFD                                 # MJC 6/1/2K (E2145)
character   MEGNAME[10]                         # MJC 6/7/2K (E2145)

integer*4 kside, itype, iside, icolor, ntds,
          UNT$Pointer

  SELECT_hide_sites = NO

  if (xUNT$Type$I != $Site$Code)
    return

  if ( xUNT$Type$I == $Site$Code & xUNT$SubType$I == $HideSite$SubCode)
    itype = $$$Site

  #$% get the view station 
  call Getsta (ista,sta$pointer,iview,megname,ifd)

  if (xUNT$View$I == $Neutral$View)
    {
     icolor = $Color$Obj$Neutral
     iside = $$$Neutral
    }
  else if (xUNT$View$I <= $LastBlue$View) 
    {
     if (iview > $LastBlue$View)
       return   #Orange views cannot detect blue hide sites. cpa 8/92
     icolor = $Color$Obj$Blue
     iside = $$$Blue

     if (kside == $$$Orange)
       iside = $$$Enemy
    }
  else      # The hide site belongs to the orange side
    {
     if ((iview <= $LastBlue$View) & (Xsta$Side$i != $Control$code))
       return   #Blue views cannot detect orange hide sites. cpa 8/92
     icolor = $Color$Obj$Orange
     iside = $$$Orange

     if (kside == $$$Orange)
       iside = $$$Friendly
    }

  ntds = $NTDS$Site

return (select_mask[itype,iside])
end


Subroutine Plot_NRTs (iview, ista)

##########################################################
#$%
#$% Purpose:   Plot_NRTs
#$%
#$% Called By: Plot_Up
#$%
#$% Calls:     NRT_Table     Plot_NRTrack
#$%
#$% Tables:    STA 
#$%
#$% Date:      December 1992
#$%
#$% Author:    Susan Miller
#$%
##########################################################
BBcommon
PLOTcommon
Select_common

# parameters
integer     iview, ista

# local variables
LitCharEquiv( Cname12 )
literal CSTRIP8                                 # MJC 6/1/2K (E2145)
integer I_SWITCH_1                              # MJC 6/1/2K (E2145)
integer     STA$PlotNRT$I, valid_check, NRTs_plotted, index
integer     single
DATA    Cname12C / "        " /

BBDeclare  (STA$Pointer)                        # MJC 6/1/2K (E2145)

 single = $no

 STA$Pointer$To ista

 STA$PlotNRT$I = xSTA$PlotNRT$I             # extract what NRTs are plotted
 if (STA$PlotNRT$I == 0)    return          # none are plotted
 # 1 to 8 two named NRTs are plotted
 else if ((STA$PlotNRT$I > 0) & (STA$PlotNRT$I < 9))
    {
     for (NRTs_plotted = STA$PlotNRT$I; NRTs_plotted > 0;
          NRTs_plotted = NRTs_plotted - 1)
        {
         switch (NRTs_plotted)
            {
             case 1: index = xSTA$NRTTwoNameIndx1$I 
             case 2: index = xSTA$NRTTwoNameIndx2$I
             case 3: index = xSTA$NRTTwoNameIndx3$I
             case 4: index = xSTA$NRTTwoNameIndx4$I 
             case 5: index = xSTA$NRTTwoNameIndx5$I 
             case 6: index = xSTA$NRTTwoNameIndx6$I 
             case 7: index = xSTA$NRTTwoNameIndx7$I 
             case 8: index = xSTA$NRTTwoNameIndx8$I
            } # end of case statement
         call Plot_NRtrack(index,iview,STA$Pointer)
        } # end of for loop through number of NRTs_plotted
    } # end if there are two name NRTs saved
 else if (STA$PlotNRT$I == 9)               # 1 single named NRT is plotted
    {
     single = $yes
##     call NRT_Table(STA$Pointer, xSTA$NRTSingleName$C,"        ", 
     call NRT_Table(STA$Pointer, xSTA$NRTSingleName$C,Cname12, #jb E2149 8/2/00 
                           valid_check, index, single) 
    }
 else if (STA$PlotNRT$I == 10)      # all NRTs defined for this view are plotted
    {
##     call NRT_Table(STA$Pointer,"        ","        ",  
     call NRT_Table(STA$Pointer,Cname12,Cname12,      # jb E2149  8/2/00
                            valid_check, index, single)
    }

return
end # of subroutine Plot_NRTs

include "plnrt.rin"         

Subroutine NRT_table(STA$Pointer,    # input - station requesting order
                     Name1,          # input - order
                     Name2,          # input - number of words in order
                     valid_check,    # return - yes or no 
                     index,          # return - index of NRT
                     single)         # input - flag for single name
########################################################
#$%
#$% Purpose:   NRT_Table searches the NRT table for the
#$%            particular asking view, i.e. blue, orange or control.
#$%            Returns valid_check = 1 if a match is found and
#$%            the index in the NRT table.
#$%
#$% Called By: Plot_NRTs
#$%
#$% Calls:     Valid_NRT (PLNRT.RIN)    Plot_NRTrack
#$% 
#$% Tables:    STA
#$%
#$% Date:      January 1993
#$%
#$% Author:    Susan Miller
#$%
########################################################
BBCommon

BBDeclare  (NRT$Pointer)                        # MJC 6/1/2K (E2145)

define ($NRT$Orange$Offset,100) # also defined in WGOPNRT.RAT

# parameters
literal    Name1, Name2
integer    STA$Pointer, valid_check, index, single

# functions
integer    Valid_NRT

# local variables
integer    iview

 iview = xSTA$View$I

 valid_check = 0    # initialize as not valid

 # is it a blue view?
 if (iview >= $FirstBlue$View & iview <= $LastBlue$View)
    {
     # then loop through the blue NRTs only
     for (NRT$Pointer$First; NRT$Pointer$Index < $NRT$Orange$Offset; 
          NRT$Pointer$Next)
        {
         valid_check = Valid_NRT(NRT$Pointer, Name1, Name2, iview, single)
         # if we found a match in the NRT table, save index 
         if (valid_check == 1)
            {
             index = NRT$Pointer$Index
             call Plot_NRTrack (index,iview,STA$pointer)
            }
        } # end of for loop through blue slots
    } # end of blue view
 # is it an orange view?
 else if (iview >= $FirstOrange$View & iview <= $LastOrange$View)
    {
     for (NRT$Pointer$To $NRT$Orange$Offset; NRT$Pointer$Valid; 
          NRT$Pointer$Next)
        {
         valid_check = Valid_NRT(NRT$Pointer, Name1, Name2, iview, single)
         # if we found a match in the NRT table, save index
         if (valid_check == 1)
            {
             index = NRT$Pointer$Index
             call Plot_NRTrack (index,iview,STA$Pointer)
            }
        } # end of for loop through orange slots 
    } # end of orange view
 else # it must be control
    {
     for (NRT$Pointer$First; NRT$Pointer$Valid; NRT$Pointer$Next)
        {
         valid_check = Valid_NRT(NRT$Pointer, Name1, Name2, iview, single)
         # if we found a match in the NRT table, save index
         if (valid_check == 1)
            {
             index = NRT$Pointer$Index
             call Plot_NRTrack (index,iview,STA$Pointer)
            }
        } # end of for loop through entire table
    } # end of control view
     
return
end     # end of subroutine NRT_Table


Subroutine Plot_NRTrack (index,view,STA$Pointer)

##########################################################
#$%
#$% Purpose:   Plot_NRTrack plots the NRT symbol
#$%
#$% Called By: NRT_Table, Plot_NRTs
#$%
#$% Calls:     Draw_UNIT_C
#$%
#$% Tables:    NRT
#$%
#$% Date:      December 1992
#$%
#$% Author:    Susan Miller
#$%
##########################################################
BBcommon
PLOTcommon
Select_common

# parameters
integer   index, view, STA$Pointer

# local variables
integer     BINCK, SELECT_RMT
integer     color, NTDS, type, itype, iside, len
integer*4   speed
real        NRT$Latitude$F, NRT$Longitude$F
integer     NRT$Type$I, NRT$Cat$I, NRT$View$I
integer     STA$PlotSpeedAir$I, STA$PlotSpeedShip$I # added 2/10/93
real*4      lat, lon, course, length
character   Name1[20], Name2[20]

BBDeclare  (STA$Label$I,
			STA$PlotLabelDeclutter$I,
            NRT$Pointer)                        # MJC 6/1/2K (E2145)
integer ID,
        istat,
        draw_unit_c,
        INFO                                    # MJC 6/1/2K (E2145)
literal CSTRIP8                                 # MJC 6/1/2K (E2145)
integer X1, X2, X3                              # MJC 6/1/2K (E2145)

 STA$Label$I = xSTA$Label$I
 STA$plotspeedair$i  = xSTA$plotspeedair$i          # added 2/10/93
 STA$plotspeedship$i = xSTA$plotspeedship$i
 STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
 NRT$Pointer$To index

 NRT$Latitude$F  = xNRT$Latitude$F         # extract lat/long
 NRT$Longitude$F = xNRT$Longitude$F

 # check to see if position coordinates are within the display area
 if (BINCK (NRT$Latitude$F,NRT$Longitude$F) == NO) return

 NRT$Type$I = xNRT$Type$i       # get mark type, ie. enemy, friendly, neutral
 NRT$Cat$I  = xNRT$Cat$i        # get mark cat, ie. air, sub, surface
 NRT$View$I = xNRT$View$I       # get the ownership view of track

 # determines the display codes for track, returns itype, iside and color
 if (SELECT_RMT(NRT$View$I,NRT$Cat$I,NRT$Type$I,itype,iside,color) == NO) return

 NTDS   = NTDS_Symbol[itype,iside]
 id     = 0
 lat    = NRT$Latitude$F  * 180/ $PI         ## convert to degrees
 lon    = NRT$Longitude$F * 180/ $PI
 course = xNRT$Course$F
 speed  = xNRT$Speed$I
 type   = NRT$Type$I

 if (STA$Label$I == YES)                    # if labels are requested
    {
     len = 0
     call smovh (xNRT$Name1$C,$$MaxName,Name1,len)  #enter label 1
     call smov  (EOS,Name1,len)  
    
     len = 0
     call smovh (xNRT$Name2$C,$$MaxName,Name2,len)  #enter label 2
     call smov  (EOS,Name2,len)  
    }
 else 
    {
     Name1[1] = EOS  
     Name2[1] = EOS
    }

 istat = Draw_UNIT_C(NTDS, id, lat, lon, STA$PlotLabelDeclutter$I, Name1, 
                Name2, color, course,
                speed, type, x1, 
                x2, x3, 
                INFO)

#call Draw_NRT_N(lat,lon,color,id)

if (STA$plotspeedair$i == YES & itype == $$$Air)
    {
     length  = 40.0 * int(speed / 200 + 0.5)
     call Draw_Vector_C (id, lat, lon, length, course)
    }
 else if (STA$plotspeedship$i == YES & itype != $$$Air)
    {
     length  = 40.0 * int(Speed / 7.0 + 0.5)
     call Draw_Vector_C (id, lat, lon, length, course)
    }

return
end # end of subroutine plot_NRTrack


Subroutine Pl_WideAreaSurv_Trk (sta$pointer)  #Input - index to STA table

#########################################################
#$%
#$% Purpose:    Plot all the wide area surveillance tracks in 
#$%             the STA$TRK sub-table.
#$%
#$% Called By:  Plot_up
#$%
#$% Calls:      Plot_SurvSat_Trk  Plot_HFDF_Trk  Plot_Swabs_Trk  
#$%             Plot_Sosus_Trk  
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################

BBcommon
integer*4       sta$pointer
integer         clear_slot

BBDeclare  (STA$View$I,
            STA$Label$I,
            STA$TRK$Index,
            STA$TRK$tracknumber$I,
            STA$TRK$detectdataindx$I,
            STA$TRK$trackview$I,
            STA$TRK$plottrk$I,
            STA$TRK$tracktype$I,
            SWD$Pointer,
            SWD$Detectorside$I,
            SSR$Pointer,
            HFD$Pointer,
            UNT$Pointer,
            SOS$Pointer)                        # MJC 6/1/2K (E2145)

STA$View$I  = xSTA$View$I
Sta$Label$I = xSTA$Label$I

for (Sta$Trk$Index = 1; Sta$Trk$Index$Ok ; Sta$Trk$Index = Sta$Trk$Index + 1)
   {
    Sta$Trk$TrackNumber$I    = xSTA$Trk$TrackNumber$I
    Sta$Trk$DetectDataIndx$I = xSTA$Trk$DetectDataIndx$I
    Sta$Trk$TrackView$I      = xSTA$Trk$TrackView$I
    Sta$Trk$PlotTrk$I        = xSTA$Trk$PlotTrk$I

    if (Sta$Trk$PlotTrk$I == NO)     # Check for ERASE ALL flag  
      next

    #$% Check for exist slot
    if (Sta$Trk$TrackNumber$I == 0 | Sta$Trk$DetectDataIndx$I == 0)
      next

    #$% Check for correct view
    if (Sta$View$I != Sta$Trk$TrackView$I & XSta$Side$I != $Control$code)
      next

    Sta$Trk$TrackType$I = xSTA$Trk$TrackType$I

    clear_slot = $no
    if (Sta$Trk$TrackType$I == $SURVSAT$PlotCode)       # track of SurvSat type
      {
       SSR$Pointer$To Sta$Trk$DetectDataIndx$I

       #$% If track doesn't exist anymore, then clear out the track sub-table slot.
       if (xSSR$TrackNumber$I != STA$TRK$TrackNumber$I |
           xSSR$ReporteeView$I != STA$TRK$TrackView$I)
         clear_slot = $yes
       else
         call Plot_SurvSat_Trk(SSR$Pointer,STA$Pointer)
      }    # end of track type SURVSAT

    else if (Sta$Trk$TrackType$I == $HFDF$PlotCode)      # track of HFDF type
      {
       HFD$Pointer$To Sta$Trk$DetectDataIndx$I

       #$% If track doesn't exist anymore, then clear out the track sub-table slot.
       if (xHFD$SequenceNmbr$I != STA$TRK$TrackNumber$I)
            clear_slot = $yes
       else
         {
          unt$Pointer$To (xHFD$Detector1$I)

          if (xUNT$view$i != STA$Trk$TrackView$I)     # Want the correct detector 
            {
             if (xHFD$ElpsExists$I == $no)            # there are not two detectors
               clear_slot = $yes
             else # there are two detectors
               {
                unt$Pointer$To (xHFD$Detector2$I)

                #$% If there is no such track which can be plot by this station, then
                #$% clear it out from the track sub-table.
                if (xUNT$view$i != STA$Trk$TrackView$I)
                  clear_slot = $yes
                else
                  call Plot_HFDF_Trk (HFD$Pointer,UNT$Pointer,STA$Label$I)
               }    # end of two detectors
            }       # end detector1 not in the tracks view
          if (clear_slot != $yes)
            call Plot_HFDF_Trk (HFD$Pointer,UNT$Pointer,STA$Pointer)
         } # end HFDF track still in existance
      }    # end of track type HFDF

    else if (Sta$Trk$TrackType$I == $Swabs$PlotCode)     # track of Swabs type
      {
       SWD$Pointer$To (Sta$Trk$DetectDataIndx$I)

       #$% If track doesn't exist anymore, then clear out the track sub-table slot.
       if (xSWD$SequenceNmbr$I != STA$TRK$TrackNumber$I)
         clear_slot = $yes
       else
         {
          SWD$DetectorSide$I = xSWD$DetectorSide$I

          if ( (STA$TRK$Trackview$I == SWABS$B_View & 
                SWD$DetectorSide$I != $blue$code)       |
               (STA$TRK$Trackview$I == SWABS$O_View & 
                SWD$DetectorSide$I != $orange$code)     )
            clear_slot = $yes
          else
            call Plot_Swabs_Trk(SWD$Pointer,Sta$Pointer)
         }
      }    # end of track type SWABS

    else                                                 # track of Sosus type
      {
       SOS$Pointer$To (Sta$Trk$DetectDataIndx$I)

       #$% If track doesn't exist anymore, then clear out the track sub-table slot.
       if (xSOS$SequenceNmbr$I != STA$TRK$TrackNumber$I)
         clear_slot = $yes
       else
         call Plot_Sosus_Trk(SOS$Pointer,Sta$Pointer)
      }    # end of track type SOSUS


    if (clear_slot == $yes)
      {
       putSTA$TRK$DetectDataIndx$I  (0)
       putSTA$TRK$TrackNumber$I     (0)
       putSTA$TRK$TrackView$I       (0)
      }

   } # end of loop thru. sta$trk subtable.

return
end


Subroutine Pl_All_SURVSAT_Trk (sta$pointer) # Input - Pointer to STA Table

#########################################################
#$%
#$% Purpose:    Plot all SurvSat tracks
#$%
#$% Called By:  Plot_up
#$%
#$% Calls:      Plot_SurvSat_Trk
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################
BBcommon

integer*4       kview

BBDeclare  (STA$Pointer,
            STA$View$I,
            STA$Label$I,
            SSR$Pointer,
            SSR$Reporteeview$I)                     # MJC 6/1/2K (E2145)

kview = xSTA$PlotAllSurvSat$I
STA$View$I = xSTA$View$I

#$% Check for the correct view 
if (STA$View$I != kview & XSTA$Side$I != $Control$code)
  return

STA$Label$I = xSTA$Label$I

for (SSR$Pointer$First; SSR$Pointer$Valid; SSR$Pointer$Next)
   {
    SSR$ReporteeView$I = xSSR$ReporteeView$I
    if (SSR$ReporteeView$I != kview)
      next

    call Plot_SurvSat_Trk (SSR$Pointer,STA$Pointer)
   } # End of loop thru. SSR table.

return
end


Subroutine Plot_SURVSAT_Trk (SSR$Pointer, #Input-pointer to SSR Table
                             STA$Pointer) 
                                        
#########################################################
#$%
#$% Purpose:    Plot an ellipse or circle around a SurvSat track
#$%
#$% Called By:  Pl_All_SurvSat_Trk    Pl_WideAreaSurv_Trk
#$%
#$% Calls:      Draw_Unit_c Draw_Rectangle Draw_Circle_c
#$%             smov         smovi      Binck
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#$% Modified:   Carol Kropp - 3/99 (E2064)
#$%             If the contact is from a RADAR SurvSat then
#$%             the contact is to be displayed as an "unknown".
#$%
#########################################################
BBcommon
PLOTcommon
Select_common

character       NAME1[20],
                NAME2[20],
                ctktype
integer         NTDS,
                COLOR,
                BINCK,
                TYPE,
                RADIUS
integer*4       SPEED,
                istat,
                draw_unit_c,
                itype,
                iside
real*4          LAT,
                LON,
                COURSE

literal CSTRIP
BBDeclare  (UNT2$Pointer,
            UNT2$Status$I,
            SSR$Pointer,
            SSR$Dettype$I,
            SSR$Offlatcenter$F,
            SSR$Offloncenter$F,
            UNT2$Type$I,
            UNT2$Supertype$I,
            UNT2$View$I,
            SAT$Pointer,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I,
            RVU$Pointer,
            SSC$Pointer)                        # MJC 6/1/2K (E2145)
integer NN,
        ID,
        INFO,
        KORIENT,
        LENGTH,
        KWIDTH                                  # MJC 6/1/2K (E2145)
integer X1, X2, X3                              # MJC 6/1/2K (E2145)

unt2$Pointer$To  (xSSR$DetecteeIndx$I)
UNT2$Status$I = xUNT2$Status$I                ## get unit status

if (UNT2$Status$I == $AcAwaitingLaunch$Code)
  return

if (UNT2$Status$I == $BeingDeleted$Code)
  {
   return
  }

STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
STA$Label$i              = xSTA$Label$I

if (STA$Label$I == YES)                     ## if labels are requested
  {
   RVU$Pointer$To (xSSR$ReporteeView$I)     # switch from vue to rvu table - clk 5/20/93
   ctkcd = xRVU$TrackCode$C

   SSR$DetType$I = xSSR$DetType$I

   #$% Determines the type of track for the label
   if      (SSR$DetType$I == $Null$Code)            ctktype = 'E'
   else if (SSR$DetType$I == $Air$Code)             ctktype = 'A'
   else if (SSR$DetType$I == $Surface$Code)         ctktype = 'S'
   else if (SSR$DetType$I == $SatIr$code)           ctktype = 'I'
   else                                             ctktype = 'U'

   nn = 0
   call smov  (ctkcd,               NAME1,nn)
   call smov  (ctktype,             NAME1,nn)
   call smoviz(xSSR$TrackNumber$I,3,NAME1,nn)
   call smov  (EOS,                 NAME1,nn)

   NAME2[1] = EOS
  }
else                                        ## no labels
  {
   NAME1[1] = EOS
   NAME2[1] = EOS
  }

SSR$OffLatCenter$F = xSSR$OffLatCenter$F
SSR$OffLonCenter$F = xSSR$OffLonCenter$F

#$% Is track within the radius of display ?
if (BINCK (SSR$OffLatCenter$F, SSR$OffLonCenter$F) == NO)    return 

UNT2$Type$I = xUNT2$Type$I 

#$% Determine type of detectee
if      (UNT2$Type$I == $Shorebase$Code)          itype = $$$Land
else if (UNT2$Type$I == $Air$Code |
         UNT2$Type$I == $CruiseMissile$Code)      itype = $$$Air
else if (UNT2$Type$i == $Sub$Code)                itype = $$$Sub
else if (UNT2$Type$I == $Surface$Code)            itype = $$$Surf
else if (UNT2$Type$I == $SAMissile$Code)          itype = $$$MISS
else                                              return

UNT2$SuperType$I = xUNT2$SuperType$I 
if (UNT2$SuperType$I == $SmallBoat$SuperCode)     itype = $$$Boat

UNT2$View$I = xUNT2$View$I 

# clk 3/99 (E2064)
# if the satellite has a radar sensor then report contact as unknown.
SAT$Pointer$To  (xSSR$DetectorIndx$I)
SSC$Pointer$TO  (xSAT$SSCIndx$I)
if (xSSC$RadarSensor$I == $Radar$Sensor)
  {  iside = $$$Unknown }
else   # Determine side of detectee
  {
   UNT2$View$I = xUNT2$View$I 
   if      (UNT2$View$I == $Neutral$View)            iside  = $$$Neutral
   else if (UNT2$View$I <= $LastBlue$View)           iside = $$$Blue
   else                                              iside = $$$Orange
  }

# khc - 5/93 : So that the track number will be displayed rather than
#              the name of the detected unit.
#ID         = UNT2$Pointer$Index                     ## unit identification
ID         = SSR$Pointer$Index + RMT$Slots + OWN$Slots + UNT$Slots

NTDS       = NTDS_Symbol[itype,iside]               ## symbol type
LAT        = SSR$OffLatCenter$F * 180/ $PI          ## convert to degrees
LON        = SSR$OffLonCenter$F * 180/ $PI    
COURSE     = 0
SPEED      = 0
TYPE       = xUNT2$Type$I
COLOR      = $COLOR$SurvSat

istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
               NAME2, COLOR, COURSE,
               SPEED, TYPE, x1, 
               x2, x3, 
               INFO)

length  = xSSR$SemiMinorAxis$I * 2   # get minor axis
korient = xSSR$Orientation$I         # get orientation
kwidth  = xSSR$SemiMajorAxis$I * 2   # get major axis

if (length == 0) length = 1
if (kwidth == 0) kwidth = 2

if (length != kwidth)
  call Draw_RECTANGLE(SSR$OffLatCenter$F,SSR$OffLonCenter$F,length,
                      korient,kwidth,color,0)
else
  {
   radius = int (length/2)
   if (radius == 0)
     radius = 1
   call Draw_Circle_C(Lat,Lon,Radius,Color, $Poly$Solid$Code)
  }

return
end


Subroutine Pl_All_HFDF_Trk (sta$pointer) # Input - Pointer to STA Table
#########################################################
#$%
#$% Purpose:    Plot all HFDF tracks
#$%
#$% Called By:  Plot_up
#$%
#$% Calls:      Plot_HFDF_Trk
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################
BBcommon

integer*4       kview

BBDeclare  (STA$Pointer,
            STA$View$I,
            STA$Label$I,
            HFD$Pointer,
            UNT$Pointer,
            UNT$View$I)                     # MJC 6/1/2K (E2145)

kview = xSTA$PlotAllHFDF$I
STA$View$I = xSTA$View$I

#$% Check for the correct view 
if (STA$View$I != kview & XSTA$Side$I != $Control$code)    return

STA$Label$I = xSTA$Label$I

for (HFD$Pointer$First; HFD$Pointer$Valid; HFD$Pointer$Next)
   {
    unt$Pointer$To (xHFD$Detector1$I)
    UNT$View$I = xUNT$View$I

    if (UNT$view$i != kview)            # Want detection from the same view 
      {
       if (xHFD$ElpsExists$I == $no)
         next 
       unt$Pointer$To  (xHFD$Detector2$I)
       UNT$View$I = xUNT$View$I
       if (UNT$view$i != kview)
         NEXT
      }

    call Plot_HFDF_Trk(HFD$Pointer,UNT$Pointer,STA$Pointer)

   } # End of loop thru. HFD table.

return
end


Subroutine Plot_HFDF_Trk (HFD$Pointer,  # Input - pointer to HFD Table
                          UNT$Pointer,  # Input - pointer to UNT Table (detector)
                          STA$Pointer)  # 
                                        # 
#########################################################
#$%
#$% Purpose:    Plot an ellipse or circle around a HFDF track, 
#$%             or a bearing line of the HFDF track.
#$%
#$% Called By:  Pl_All_HFDF_Trk    Pl_WideAreaSurv_Trk
#$%
#$% Calls:      Draw_Unit_c Draw_Rectangle Draw_Circle_C
#$%             Draw_Bearing_c smov       smoviz          Binck
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################
BBcommon
PLOTcommon
Select_common

character       NAME1[20],
                NAME2[20]
integer         NTDS,
                COLOR,
                BINCK,
                TYPE,
                Radius
integer*4       SPEED,
                itype,
                istat,
                draw_unit_c,
                iside
real*4          LAT,
                LON,
                COURSE
integer         ibtype  # JFR 11/23/94 (hfdf bearings)

BBDeclare  (HFD$Pointer,
            HFD$Elpsexists$I,
            HFD$Elpsoffsetlat$F,
            HFD$Elpsoffsetlon$F,
            UNT2$Pointer,
            UNT2$Type$I,
            UNT2$Supertype$I,
            UNT2$View$I,
            UNT2$Status$I,
            UNT$View$I,
            UNT$Pointer,
            UNT$Truelatitude$F,
            UNT$Truelongitude$F,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)
integer NN,
        ID,
        INFO,
        KORIENT,
        KWIDTH,
        LENGTH,
        ID2                                     # MJC 6/1/2K (E2145)
integer X1, X2, X3
real    BEARING                                 # MJC 6/1/2K (E2145)

unt2$Pointer$To  (xHFD$Detectee$I)
UNT2$Status$I = xUNT2$Status$I                ## get unit status

if (UNT2$Status$I == $AcAwaitingLaunch$Code)    return

if (UNT2$Status$I == $BeingDeleted$Code)
  {
   return
  }
STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
STA$Label$i              = xSTA$Label$I

if (STA$Label$I == YES)                     ## if labels are requested
  {
   UNT$View$I = xUNT$View$I

   #$% Determines the side of track for the label
   if (UNT$View$I < $FirstOrange$View & 
       UNT$View$I >= $FirstBlue$View)        ctkcd = 'B'
   else                                      ctkcd = 'O'
          
   nn = 0
   call smov  (ctkcd,                NAME1,nn)
   call smovv ("H",                  NAME1,nn)
   call smoviz(xHFD$SequenceNmbr$I,3,NAME1,nn)
   call smov  (EOS,                  NAME1,nn)

   NAME2[1] = EOS
  }
else                                        ## no labels
  {
   NAME1[1] = EOS
   NAME2[1] = EOS
  }

HFD$ElpsExists$I = xHFD$ElpsExists$I
if (HFD$ElpsExists$I == $yes)                   # if ellipse is existed
  {
   HFD$ElpsOffSetLat$F = xHFD$ElpsOffSetLat$F
   HFD$ElpsOffSetLon$F = xHFD$ElpsOffSetLon$F

   #$% Is the track within the radius of display ?
   if (BINCK (HFD$ElpsOffSetLat$F, HFD$ElpsOffSetLon$F) == NO)      return 

   UNT2$Type$I = xUNT2$Type$I 

   #$% Determine type of detectee
   if      (UNT2$Type$I == $Shorebase$Code)       itype = $$$Land
   else if (UNT2$Type$I == $Air$Code | 
            UNT2$Type$I == $CruiseMissile$Code)   itype = $$$Air
   else if (UNT2$Type$i == $Sub$Code)             itype = $$$Sub
   else if (UNT2$Type$I == $Surface$Code)         itype = $$$Surf
   else if (UNT2$Type$I == $SAMissile$Code)       itype = $$$MISS
   else                                           return

   UNT2$SuperType$I = xUNT2$SuperType$I 
   if (UNT2$SuperType$I == $SmallBoat$SuperCode)  itype = $$$Boat

   UNT2$View$I = xUNT2$View$I

   #$% Determine side of detectee
   if      (UNT2$View$I == $Neutral$View)         iside = $$$Neutral
   else if (UNT2$View$I <= $LastBlue$View)        iside = $$$Blue
   else                                           iside = $$$Orange

# khc - 5/93 : So that the track number will be displayed rather than
#              the name of the detected unit.
   #ID         = UNT2$Pointer$Index                     ## unit identification
   ID         = HFD$Pointer$Index + RMT$Slots + OWN$Slots + UNT$Slots + SSR$Slots

   NTDS       = NTDS_Symbol[itype,iside]               ## symbol type
   LAT        = HFD$ElpsOffSetLat$F * 180/ $PI         ## convert to degrees
   LON        = HFD$ElpsOffSetLon$F * 180/ $PI    
   COURSE     = 0
   SPEED      = 0
   TYPE       = xUNT2$Type$I
   COLOR      = $COLOR$HFDF

   istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
                  NAME2, COLOR, COURSE,
                  SPEED, TYPE, x1, 
                  x2, x3, 
                  INFO)

   length  = xHFD$ElpsSemiMinorAxis$I * 2  # get minor axis
   korient = xHFD$ElpsOrientation$I        # get orientation
   kwidth  = xHFD$ElpsSemiMajorAxis$I * 2  # get major axis

   if (length == 0) length = 1
   if (kwidth == 0) kwidth = 2

   if (length != kwidth)
     call Draw_RECTANGLE(HFD$ElpsOffSetLat$F,HFD$ElpsOffSetLon$F,length,
                         korient,kwidth,color,0)
   else
     {
      radius = int(length/2)
      if (radius == 0)
        radius = 1
      call Draw_Circle_C(Lat,Lon,Radius,Color, $Poly$Solid$Code)
     }
  }
else                                            # else draw bearing
  {
   UNT$TrueLatitude$F = xUNT$TrueLatitude$F
   UNT$TrueLongitude$F = xUNT$TrueLongitude$F
   
   #$% Is detector within the radius of display ?
   if (BINCK (UNT$TrueLatitude$F, UNT$TrueLongitude$F) == NO) 
     return 
   ID  = 0

# khc - 5/93 : So that the track number will be displayed rather than
#              the name of the detected unit.
   #ID2 = 0
   ID2 = HFD$Pointer$Index + RMT$Slots + OWN$Slots + UNT$Slots + SSR$Slots

   LAT = UNT$TrueLatitude$F * 180/$PI
   LON = UNT$TrueLongitude$F * 180/$PI
   BEARING = xHFD$AppBearing$I
   COLOR   = $COLOR$HFDF
   ibtype = $Poly$Solid$Code # JFR 9/28/94
   call Draw_Bearing_c (ID,LAT,LON,ID2,bearing,name1,color,ibtype)
  }

return
end


Subroutine Pl_All_SWABS_Trk (sta$pointer) # Input - Pointer to STA Table
#########################################################
#$%
#$% Purpose:    Plot all Swabs tracks
#$%
#$% Called By:  Plot_up
#$%
#$% Calls:      Plot_Swabs_Trk
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################
BBcommon
integer       iside
integer*4     kview

BBDeclare  (STA$Pointer,
            STA$View$I,
            STA$Label$I,
            SWD$Pointer)                        # MJC 6/1/2K (E2145)

kview = xSTA$PlotAllSwabs$I
STA$View$I = xSTA$View$I

#$% Check for the correct view
if (STA$View$I != kview & XSTA$Side$I != $Control$code)    return

STA$Label$I = xSTA$Label$I

#$% Determines side of track
if (kview < $FirstOrange$View)  iside = $Blue$Code
else                            iside = $Orange$Code

for (SWD$Pointer$First; SWD$Pointer$Valid; SWD$Pointer$Next)
   {
    if (xSWD$DetectorSide$I != iside)
      next
    call Plot_Swabs_Trk (SWD$Pointer,STA$Pointer)
   }

return
end


Subroutine Plot_SWABS_Trk (SWD$Pointer,  # Input - pointer to SWD Table
                           STA$Pointer)  
                                         #
#########################################################
#$%
#$% Purpose:    Plot an ellipse or circle around a SWABS track
#$%
#$% Called By:  Pl_All_Swabs_Trk    Pl_WideAreaSurv_Trk
#$%
#$% Calls:      Draw_Unit_c  Draw_Rectangle  Draw_Circle_C
#$%             smov         smoviz     Binck
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################
BBcommon
PLOTcommon
Select_common

character       NAME1[20],
                NAME2[20]
integer         NTDS,
                COLOR,
                BINCK,
                TYPE,
                Radius
integer*4       SPEED,
                itype,
                istat,
                draw_unit_c,
                iside
real*4          LAT,
                LON,
                COURSE

BBDeclare  (UNT2$Pointer,
            UNT2$Status$I,
            UNT2$Type$I,
            UNT2$Supertype$I,
            UNT2$View$I,
            SWD$Pointer,
            SWD$Offsetlat$F,
            SWD$Offsetlon$F,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)

integer NN,
        ID,
        INFO,
        KORIENT,
        LENGTH,
        KWIDTH                                 # MJC 6/1/2K (E2145)
integer X1, X2, X3                             # MJC 6/1/2K (E2145)

unt2$Pointer$To  (xSWD$Detectee$I)
UNT2$Status$I = xUNT2$Status$I                ## get unit status

if (UNT2$Status$I == $BeingDeleted$Code)
  {
   return
  }
STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
STA$Label$I              = xSTA$Label$I

if (STA$Label$I == YES)                     ## if labels are requested
  {
   #$% Determines the side of track for the label
   if (xSWD$DetectorSide$I == $Blue$Code)     ctkcd = 'B'
   else                                       ctkcd = 'O'

   nn = 0
   call smov  (ctkcd,                NAME1,nn)
   call smovv ("T",                  NAME1,nn)
   call smoviz(xSWD$SequenceNmbr$I,3,NAME1,nn)
   call smov  (EOS,                  NAME1,nn)

   NAME2[1] = EOS
  }
else                                        ## no labels
  {
   NAME1[1] = EOS
   NAME2[1] = EOS
  }

SWD$OffSetLat$F = xSWD$OffSetLat$F
SWD$OffSetLon$F = xSWD$OffSetLon$F

#$% Is the track within the radius of display ?
if (BINCK (SWD$OffSetLat$F, SWD$OffSetLon$F) == NO)       return 

UNT2$Type$I = xUNT2$Type$I 

#$% Determine type of detectee
if      (UNT2$Type$I == $Shorebase$Code)                  itype = $$$Land
else if (UNT2$Type$I == $Air$Code |
         UNT2$Type$I == $CruiseMissile$Code)              itype = $$$Air
else if (UNT2$Type$i == $Sub$Code)                        itype = $$$Sub
else if (UNT2$Type$I == $Surface$Code)                    itype = $$$Surf
else if (UNT2$Type$I == $SAMissile$Code)                  itype = $$$MISS
else                                                      return

UNT2$SuperType$I = xUNT2$SuperType$I 
if (UNT2$SuperType$I == $SmallBoat$SuperCode)             itype = $$$Boat

UNT2$View$I = xUNT2$View$I 

#$% Determine side of detectee
if      (UNT2$View$I == $Neutral$View)                    iside  = $$$Neutral
else if (UNT2$View$I <= $LastBlue$View)                   iside = $$$Blue
else                                                      iside = $$$Orange

# khc - 5/93 : So that the track number will be displayed rather than
#              the name of the detected unit.
#ID         = UNT2$Pointer$Index                     ## unit identification
ID         = SWD$Pointer$Index + RMT$Slots + OWN$Slots + UNT$Slots + SSR$Slots + HFD$Slots

NTDS       = NTDS_Symbol[itype,iside]               ## symbol type
LAT        = SWD$OffSetLat$F * 180/ $PI             ## convert to degrees
LON        = SWD$OffSetLon$F * 180/ $PI    
COURSE     = 0
SPEED      = 0
TYPE       = xUNT2$Type$I
COLOR      = $COLOR$Swabs

istat = Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
               NAME2, COLOR, COURSE,
               SPEED, TYPE, x1, 
               x2, x3, 
               INFO)

length  = xSWD$SemiMinorAxis$I * 2      # get minor axis
korient = xSWD$Orientation$I            # get orientation
kwidth  = xSWD$SemiMajorAxis$I * 2      # get major axis

if (length == 0) length = 1
if (kwidth == 0) kwidth = 2

if (length != kwidth)
  call Draw_RECTANGLE(SWD$OffSetLat$F,SWD$OffSetLon$F,length,
                      korient,kwidth,color,0)
else
  {
   radius = int(length/2)
   if (radius == 0)
     radius = 1
   call Draw_Circle_C(Lat,Lon,Radius,Color, $Poly$Solid$Code)
  }

return
end


Subroutine Pl_All_SOSUS_Trk (sta$pointer) # Input - Pointer to STA Table
#########################################################
#$%
#$% Purpose:    Plot all Sosus tracks    
#$%
#$% Called By:  Plot_up
#$%
#$% Calls:      Plot_Sosus_Trk
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################

BBcommon
integer*4     kview

BBDeclare  (STA$Pointer,
            STA$View$I,
            STA$Label$I,
            SOS$Pointer)                        # MJC 6/1/2K (E2145)

kview = xSTA$PlotAllSwabs$I
STA$View$I = xSTA$View$I

#$% Check for the correct view
if (STA$View$I != kview & XSTA$Side$I != $Control$code)      return

STA$Label$I = xSTA$Label$I

for (SOS$Pointer$First; SOS$Pointer$Valid; SOS$Pointer$Next)
    call Plot_Sosus_Trk (SOS$Pointer,STA$Pointer)

return
end


Subroutine Plot_SOSUS_Trk (SOS$Pointer,        # Input - pointer to SOS Table
                           STA$Pointer)        # 
                                               # 
#########################################################
#$%
#$% Purpose:    Plot an ellipse or circle around a Sosus track 
#$%
#$% Called By:  Pl_All_Sosus_Trk    Pl_WideAreaSurv_Trk
#$%
#$% Calls:      Draw_Unit_C Draw_Rectangle Draw_Circle_C
#$%             smov        smoviz     Binck
#$%
#$% Date:       December 1992
#$%
#$% Author:     K. Chang
#$%
#########################################################
BBcommon
PLOTcommon
Select_common

character       NAME1[20],
                NAME2[20]
integer         NTDS,
                COLOR,
                BINCK,
                TYPE,
                Radius
integer*4       SPEED,
                itype,
                istat,
                draw_unit_c,
                iside
real*4          LAT,
                LON,
                COURSE

BBDeclare  (UNT2$Pointer,
            UNT2$Type$I,
            UNT2$Supertype$I,
            UNT2$View$I,
            UNT2$Status$I,
            SOS$Pointer,
            SOS$Offsetlat$F,
            SOS$Offsetlon$F,
			STA$Pointer,
            STA$Label$I,
			STA$PlotLabelDeclutter$I)

integer NN,
        ID,
        INFO,
        KORIENT,
        LENGTH,
        KWIDTH                                  # MJC 6/1/2K (E2145)
integer X1, X2, X3                              # MJC 6/1/2K (E2145)

unt2$Pointer$To  (xSOS$Detectee$I)
UNT2$Status$I = xUNT2$Status$I                ## get unit status

if (UNT2$Status$I == $BeingDeleted$Code)
  {
   return
  }

STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I
STA$Label$I              = xSTA$Label$I

if (STA$Label$I == YES)                     ## if labels are requested
  {
   nn = 0
   call smovv ("B",                  NAME1,nn)
   call smovv ("Z",                  NAME1,nn)
   call smoviz(xSOS$SequenceNmbr$I,3,NAME1,nn)
   call smov  (EOS,                  NAME1,nn)

   NAME2[1] = EOS
  }
else                                        ## no labels
  {
   NAME1[1] = EOS
   NAME2[1] = EOS
  }

SOS$OffSetLat$F = xSOS$OffSetLat$F
SOS$OffSetLon$F = xSOS$OffSetLon$F

#$% Is track within the radius of display ?
if (BINCK (SOS$OffSetLat$F, SOS$OffSetLon$F) == NO)       return 

UNT2$Type$I = xUNT2$Type$I 

#$% Determine the type of detectee
if (UNT2$Type$I == $Shorebase$Code)                       itype = $$$Land
else if (UNT2$Type$I == $Air$Code |
         UNT2$Type$I == $CruiseMissile$Code)              itype = $$$Air
else if (UNT2$Type$i == $Sub$Code)                        itype = $$$Sub
else if (UNT2$Type$I == $Surface$Code)                    itype = $$$Surf
else if (UNT2$Type$I == $SAMissile$Code)                  itype = $$$MISS
else                                                      return

UNT2$SuperType$I = xUNT2$SuperType$I 
if (UNT2$SuperType$I == $SmallBoat$SuperCode)             itype = $$$Boat

UNT2$View$I = xUNT2$View$I 

#$% Determine the side of detectee
if (UNT2$View$I == $Neutral$View)                         iside  = $$$Neutral
else if (UNT2$View$I <= $LastBlue$View)                   iside = $$$Blue
else                                                      iside = $$$Orange

# khc - 5/93 : So that the track number will be displayed rather than
#              the name of the detected unit.
#ID         = UNT2$Pointer$Index                     ## unit identification
ID         = SOS$Pointer$Index + RMT$Slots + OWN$Slots + UNT$Slots + SSR$Slots + HFD$Slots + SWD$Slots

NTDS       = NTDS_Symbol[itype,iside]               ## symbol type
LAT        = SOS$OffSetLat$F * 180/ $PI             ## convert to degrees
LON        = SOS$OffSetLon$F * 180/ $PI    
COURSE     = 0
SPEED      = 0
TYPE       = xUNT2$Type$I
COLOR      = $COLOR$Sosus

istat =  Draw_UNIT_C(NTDS, ID, LAT, LON, STA$PlotLabelDeclutter$I, NAME1, 
               NAME2, COLOR, COURSE,
               SPEED, TYPE, x1, 
               x2, x3, 
               INFO)

length  = xSOS$SemiMinorAxis$I * 2                           # get minor axis
korient = xSOS$Orientation$I                                 # get orientation
kwidth  = xSOS$SemiMajorAxis$I * 2                           # get major axis

if (length == 0) length = 1
if (kwidth == 0) kwidth = 2

if (length != kwidth)
  call Draw_RECTANGLE(SOS$OffSetLat$F,SOS$OffSetLon$F,length,
                      korient,kwidth,color,0)
else
  {
   radius = int(length/2)
   if (radius == 0)
     radius = 1
   call Draw_Circle_C(Lat,Lon,Radius,Color, $Poly$Solid$Code)
  }

return
end


Subroutine Draw_SAM_pairing_line(UNT$Pointer,   # SAM unit pointer
                                 UNT2$Pointer,  # target unit pointer
                                 LAT, LON)      # position of SAM
#########################################################
#$%
#$% Purpose:    Draws the yellow-dashed target-pairing line
#$%             from the SAM to the assigned target.
#$%
#$% Called By:  Plot_True
#$%
#$% Calls:      Set_Dash_C   Draw_Line_C
#$%
#$% Date:       Jan 1994
#$%
#$% Author:     Susan Miller
#$%
#$% Modified:   Susan Miller - 3/28/95
#$%             Added LAT and LON as parameters so that
#$%             the pairing line would match the location
#$%             of the SAM.
#$%
#########################################################
BBcommon
PLOTcommon
Select_common

integer*4 UNT$Pointer, UNT2$Pointer, UNT$AssignedTarget$I
real*4    Tgt_Lat, Tgt_Lon
real*4    LAT, LON 
integer*4 dash_type 

 # as long as the SAM has an assigned target
 UNT$AssignedTarget$I = xUNT$AssignedTarget$I
 if (UNT$AssignedTarget$I != 0)
    {
     UNT2$Pointer$To UNT$AssignedTarget$I
     Tgt_Lat = xUNT2$AssumedLatitude$F * 180./$PI       
     Tgt_Lon = xUNT2$AssumedLongitude$F * 180./$PI

     dash_type = $Poly$Dashed$Code
     call Set_Dash_C(dash_type)
     # SMM 3/27/95 fix for pairing line not starting at SAM location
     call Draw_Line_c (Tgt_Lat, Tgt_Lon, LAT, LON, $color$obj$fading)
     dash_type = $Poly$Solid$Code
     call Set_Dash_C(dash_type) # reset line style
    }

return
end


Subroutine Is_ESM_Jammer(RMT$POINTER,isjam)
#########################################################
#$%
#$% Purpose:    Determines if the track is a Jammer
#$%             detection.
#$%
#$% Called By:  Plot_ESM_Sonar
#$%
#$% Calls:      None
#$%
#$% Date:       July 1994
#$%
#$% Author:     John F. Richardson
#$%
#########################################################
BBcommon
PLOTcommon
Select_common

BBDeclare  (RMT$Detectee$I,
            RMT$Emitterpntr$I,
            DEQ$Pointer,
            DEQ$Ident$I,
            DEQ$Pntr$I,
            UNT$Pointer)                        # MJC 6/1/2K (E2145)

Integer*4 Rmt$POINTER, isjam

isjam = $no # init the jammer detection flag

rmt$detectee$i = xrmt$detectee$i # get the index to the detectee
unt$pointer$to (rmt$detectee$i) # set the unit pointer

For_DEQ_chain
  { # set through equipment looking for jammers
   deq$ident$i = xdeq$ident$i # find equipment ident

   if ((deq$ident$i == $jammer$code |               # non jecewsi games
        deq$ident$i == $RadarJammer$code |          # jecewsi games
        deq$ident$i == $RadComjammer$code |         # jecewsi games
        deq$ident$i == $CommunicationJammer$code))  # jecewsi games
      { # only interested in jammers
       deq$pntr$i = xdeq$pntr$i # pointer to unit's equipment
       rmt$emitterpntr$i = xrmt$emitterpntr$i # pointer to detected equipment
       if (rmt$emitterpntr$i == deq$pntr$i)
          { # hit the jackpot, detection is of a jammer
           isjam = $yes
           break         # don't waste time
          }
      }
  }

return
end


Subroutine Plot_ALSP_Ground_Data (STA$Pointer)   # in: Station Pointer
###########################################################################
#$%
#$% Purpose:   Plot_ALSP_Ground_Data will determine if the "ghosted"
#$%            ground data is to be plotted.  If so, the ALSP Ground Data
#$%            (AGD) Table will be search and the information displayed.
#$%            If threat ranges are desired (for all SAMs or all a
#$%            particular type) a circle will surround the symbol.
#$%
#$% Called By: Plot_Up
#$%
#$% Calls:     Determine_Ground_Symbol
#$%            Draw_Unit_C
#$%            Draw_Circle_C
#$%
#$% Tables:    STA     AGD     MC
#$%
#$% Date:      Sept. 1995
#$%
#$% Author:    Carol Kropp
#$%
###########################################################################
BBcommon
PLOTcommon

integer  STA$Pointer

integer  BINCK     # integer function to determine if posit is within view

integer    AGD$Pointer
integer    plot_all_sam_ranges
integer    MC$Pointer
integer    specified_mc_pointer
integer    threat_radius
integer    STA$Label$I
integer*4  base_id_number
integer    id
integer    color
integer    symbol
integer    speed
real       course
real       speed_length
real       lat, lon
real        xlat [8]
real        xlong[8]
character  Name1[20], Name2[20]
integer    name_len
integer    dummy
integer     in_field
integer     nvert
integer     istat
integer     draw_unit_c
BBDeclare  (LIN$Pointer,
            lin$PTS$index)

BBDeclare  (STA$Plotghostgroundradar$I,
            STA$Plotghostgroundsam$I,
            STA$PlotGhostGroundCombat$I,
            STA$PlotGhostGroundSupport$I,
            STA$PlotGhostGroundConvoy$I,
            STA$PlotGhostGroundSUnit$I,
            STA$Plotgroundsamranges$I,
            STA$Samrange$I,
            sta$PlotGhostPolygonIndx$i,
			STA$PlotLabelDeclutter$I,
            AGD$Alspclass$I,
            AGD$Side$I,
            AGD$Alspsize$I,
            AGD$TrueLatitude$F,
            AGD$TrueLongitude$F,
            AGD$Mcpntr$I)                       # MJC 6/1/2K (E2145)
literal CSTRIP8                                 # MJC 6/1/2K (E2145)

if (ALSP$Game != $no &
    xSTA$PlotGhostGround$I       != $no &
    xSTA$PlotGhostGroundSize$I   != $no &
    xSTA$PlotGhostSide$i         != $no)
{
    STA$PlotGhostGroundRadar$I = xSTA$PlotGhostGroundRadar$I
    STA$PlotGhostGroundSAM$I = xSTA$PlotGhostGroundSAM$I
    STA$PlotGhostGroundCombat$I = xSTA$PlotGhostGroundCombat$I
    STA$PlotGhostGroundSupport$I = xSTA$PlotGhostGroundSupport$I
    STA$PlotGhostGroundConvoy$I = xSTA$PlotGhostGroundConvoy$I
    STA$PlotGhostGroundSUnit$I = xSTA$PlotGhostGroundSUnit$I

    STA$PlotGroundSAMRanges$I = xSTA$PlotGroundSAMRanges$I

    STA$SAMRange$I = xSTA$SAMRange$I
	STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

    MC$Pointer = xSTA$MCPntr$I
    specified_mc_pointer = MC$Pointer
    if (MC$Pointer$Valid)
        plot_all_sam_ranges = $no
    else
        plot_all_sam_ranges = $yes

    STA$Label$I = xSTA$Label$I
    base_id_number = UNT$Slots + OWN$Slots + RMT$Slots + SSR$Slots
    base_id_number = base_id_number + HFD$Slots + SWD$Slots + SOS$Slots

    #Prepare geo filter for inout routine
    sta$PlotGhostPolygonIndx$i = Xsta$PlotGhostPolygonIndx$i
    if (sta$PlotGhostPolygonIndx$i != 0)
    {
        lin$pointer$to sta$PlotGhostPolygonIndx$i
        # move lat/long verticies into array for passing to INOUT
        nvert = xlin$NumPTS$i
        for (lin$PTS$index=1;lin$PTS$index<=nvert;
             lin$PTS$index=lin$PTS$index+1)
        {
            xlat [lin$PTS$index] = xlin$PTS$latitude$f
            xlong[lin$PTS$index] = xlin$PTS$longitude$f
        }
    }

    for (AGD$Pointer$First; AGD$Pointer$Valid; AGD$Pointer$Next)
    {
        if (xAGD$InUse$I == $no) next

        AGD$Side$I = xAGD$Side$I

        # Filter by side 
        if (AGD$Side$I == $Neutral$Code   & Xsta$PlotGhostNeutral$i == $no) next
        else if (AGD$Side$I == $Blue$Code  & Xsta$PlotGhostBlue$i == $no) next
        else if(AGD$Side$I == $Orange$Code & Xsta$PlotGhostOrange$i == $no) next

        # Filter by class

        AGD$ALSPClass$I = xAGD$ALSPClass$I
        if     (AGD$ALSPClass$I == $alsp_class_ground_maneuver_allrad &
                 XSTA$PlotGhostGroundALLRAD$I == $no) next
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_himad &
                 XSTA$PlotGhostGroundHIMAD$I == $no) next
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_radar &
                XSTA$PlotGhostGroundRadar$I == $no) next
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_tel &
                XSTA$PlotGhostGroundTEL$I == $no) next
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_combat &
                XSTA$PlotGhostGroundCombat$I == $no) next
        else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_convoy &
                XSTA$PlotGhostGroundConvoy$I == $no) next
        else if((AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_unit |
              AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_unit_tcu) &
                XSTA$PlotGhostGroundSUnit$I == $no) next

        # Filter by size
        AGD$ALSPSize$i = XAGD$ALSPSize$i

        if      (AGD$ALSPSize$i == $size_army & 
                                       XSTA$PlotGhostGroundArmy$i == $no) next
        else if (AGD$ALSPSize$i == $size_army_group & 
                                    XSTA$PlotGhostGroundArmygroup$i == $no) next
        else if (AGD$ALSPSize$i == $size_battalion & 
                                    XSTA$PlotGhostGroundBattalion$i == $no) next
        else if (AGD$ALSPSize$i == $size_brigade & 
                                     XSTA$PlotGhostGroundBrigade$i == $no) next
        else if (AGD$ALSPSize$i == $size_company & 
                                     XSTA$PlotGhostGroundCompany$i == $no) next
        else if (AGD$ALSPSize$i == $size_corps & 
                                     XSTA$PlotGhostGroundCorps$i == $no) next
        else if (AGD$ALSPSize$i == $size_division & 
                                     XSTA$PlotGhostGroundDivision$i == $no) next
        else if (AGD$ALSPSize$i == $size_platoon & 
                                     XSTA$PlotGhostGroundPlatoon$i == $no) next
        else if (AGD$ALSPSize$i == $size_regiment & 
                                     XSTA$PlotGhostGroundRegiment$i == $no) next
        else if (AGD$ALSPSize$i == $size_section & 
                                     XSTA$PlotGhostGroundSection$i == $no) next
        else if (AGD$ALSPSize$i == $size_squad & 
                                     XSTA$PlotGhostGroundSquad$i == $no) next
        else if (AGD$ALSPSize$i == $size_team & 
                                     XSTA$PlotGhostGroundTeam$i == $no) next

        AGD$TrueLatitude$F = xAGD$TrueLatitude$F
        AGD$TrueLongitude$F = xAGD$TrueLongitude$F

        # check to see if within the display area
        if (BINCK (AGD$TrueLatitude$F, AGD$TrueLongitude$F) == $no) next

        # Filter by polygon
        if (sta$PlotGhostPolygonIndx$i != 0)
        {
            call inout(AGD$TrueLongitude$f,AGD$TrueLatitude$f,
                       nvert,xlong,xlat,in_field)

            if (in_field != $YES) next
        }
        
        id = base_id_number + AGD$Pointer$Index
        dummy = 0

        if (AGD$Side$I == $Neutral$Code)     color = $Color$Obj$Neutral
        else if (AGD$Side$I == $Blue$Code)   color = $Color$Obj$Blue
        else                                 color = $Color$Obj$Orange

        AGD$ALSPSize$I = xAGD$ALSPSize$I
        call Determine_Ground_Symbol (AGD$ALSPSize$I, symbol)

        speed = INT (xAGD$TrueSpeed$F + 0.5)
        course = xAGD$TrueCourse$F * 180 / $pi
        lat = AGD$TrueLatitude$F  * 180/ $pi
        lon = AGD$TrueLongitude$F * 180/ $pi

        if (STA$Label$I == $yes)
        {
            name_len = 0
            call smovhn (xAGD$Name$C, $$MaxLit, Name1, name_len)
            call smov   (EOS, Name1, name_len)
            name_len = 0

            # Assign 8 char name for ground alsp class
            if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_radar)
                call smovv  ("RADAR", Name2, name_len)
            else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_allrad |
                AGD$ALSPClass$I == $alsp_class_ground_maneuver_himad)
                call smovv  ("SAM SITE", Name2, name_len)
            else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_combat)
                call smovv  ("COMBAT", Name2, name_len)
            else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_tel)
                call smovv  ("TEL", Name2, name_len)
            else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_convoy)
                call smovv  ("CONVOY", Name2, name_len)
            else if (AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_unit |
               AGD$ALSPClass$I == $alsp_class_ground_maneuver_support_unit_tcu)
                call smovv  ("SUP UNIT", Name2, name_len)

            call smov   (EOS, Name2, name_len)
        }   # end of if station has labels on
        else  # no labels are desired
        {
            name1[1] = EOS
            name2[1] = EOS
        }   # end of no labels

        # Draw the ground box symbol
        istat = Draw_Unit_C (symbol, id, lat, lon, STA$PlotLabelDeclutter$I, name1, 
                                 name2, color, course,
                                 speed, dummy, dummy, dummy,
                                 dummy, dummy)

        # Draw the ground box symbol
        symbol = $NTDS$Ground_ADA
        name1[1] = EOS
        name2[1] = EOS
        istat = Draw_Unit_C (symbol, 0, lat, lon, STA$PlotLabelDeclutter$I, name1, 
                                 name2, color, course,
                                 speed, dummy, dummy, dummy,
                                 dummy, dummy)

        # the same computation is used here as for ships (Plot_Own)
        speed_length = 40.0 * xAGD$TrueSpeed$F / 7.0 + 0.5
        call Draw_Vector_C (id, lat, lon, speed_length, course)

        if (STA$PlotGroundSAMRanges$I != $no &            # range circles for SAMs
                (AGD$ALSPClass$I == $alsp_class_ground_maneuver_allrad |
                 AGD$ALSPClass$I == $alsp_class_ground_maneuver_himad))
        {
            AGD$MCPntr$I = xAGD$MCPntr$I
            if (plot_all_sam_ranges == $yes |              # if all are desired or
                    specified_mc_pointer == AGD$MCPntr$I)      # this is the right one
            {
                if (STA$SAMRange$I > 0)                     # if a particular range desired
                    threat_radius = STA$SAMRange$I 
                else
                {
                    MC$Pointer = AGD$MCPntr$I
                    threat_radius = xMC$MaxRange$I
                }   # end of if SAM max range is desired
                call Draw_Circle_C (lat,lon,threat_radius,color, $Poly$Solid$Code)
            }   # end of if this SAM range to be displayed
        }   # end of if a SAM site - for range drawing
    }   # end of loop through the AGD table
}   # end of if an ALSP game and ghosts are to be displayed

return
end



Subroutine Determine_Ground_Symbol (_
                   size,        # in:  size code from alsp.inc
                   symbol)      # out: the symbol to use on the plot
###########################################################################
#$%
#$% Purpose:   Determine_Ground_Symbol will determine the type of ground
#$%            symbol to use base on the size of the object.
#$%
#$% Called By: Plot_ALSP_Ground_Data
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      Sept. 1995
#$%
#$% Author:    Carol Kropp
#$%
###########################################################################

integer  size, symbol

integer I_SWITCH_1                      # MJC 6/1/2K (E2145)

  symbol = $NTDS$Ground_Box
  switch (size)
    {
     case $size_army           : symbol = $NTDS$Ground_Box
     case $size_base           : symbol = $NTDS$Ground_Box
     case $size_brigade        : symbol = $NTDS$Ground_Brigade
     case $size_battalion      : symbol = $NTDS$Ground_Battalion
     case $size_battery        : symbol = $NTDS$Ground_Box
     case $size_company        : symbol = $NTDS$Ground_Company
     case $size_corps          : symbol = $NTDS$Ground_Corps
     case $size_detachment     : symbol = $NTDS$Ground_Box
     case $size_division       : symbol = $NTDS$Ground_Division
     case $size_headquarters   : symbol = $NTDS$Ground_Box
     case $size_platoon        : symbol = $NTDS$Ground_Platoon
     case $size_regiment       : symbol = $NTDS$Ground_Regiment
     case $size_squad          : symbol = $NTDS$Ground_Squad
     case $size_squadron       : symbol = $NTDS$Ground_Box
     case $size_team           : symbol = $NTDS$Ground_Box
     case $size_taskforce      : symbol = $NTDS$Ground_Box
     case $size_troop          : symbol = $NTDS$Ground_Box
     case $size_wing           : symbol = $NTDS$Ground_Box
     case $size_section        : symbol = $NTDS$Ground_Section
     case $size_army_group     : symbol = $NTDS$Ground_Box
    }

return
end



Subroutine Plot_Local_Detections (UNT$Pointer)
#############################################################################
#$%
#$% Purpose:    Plots x-marks on the graphics for the locally held tracks
#$%             of the specified unit.
#$%
#$% Called By:  Plot_JTIDS_Tracks
#$%
#$% Calls:      binck         <lbplot.rat>
#$%             smov..        <lbsmov.rat>
#$%
#$% Tables:     UNT     LCL
#$%
#$% Date:       December 1995
#$%
#$% Author:     Carol Kropp
#$%
#############################################################################
BBcommon

integer  UNT$Pointer

integer  binck         # function to determine if within displayed area
#integer  Draw_Local_L 

integer  lcl_index
integer  LCL$Pointer
integer  LCL$LastDetType$I
real     LCL$ApparentLat$F, LCL$ApparentLon$F
integer  on_display
real     degree_lat, degree_long
integer  LCL$TargetId$I
integer  color
integer  len
character  name1 [arb], name2 [arb]

  lcl_index = xUNT$FirstLclIndx$I
  while (lcl_index != 0)
    {
     LCL$Pointer$TO  (lcl_index)
     LCL$LastDetType$I = xLCL$LastDetType$I
     if (LCL$LastDetType$I == $Radar$Type |    # only do the radar and visuals
         LCL$LastDetType$I == $Visual$Type)
       {
        LCL$ApparentLat$F = xLCL$ApparentLat$F
        LCL$ApparentLon$F = xLCL$ApparentLon$F

        on_display = BINCK (LCL$ApparentLat$F, LCL$ApparentLon$F)
        if (on_display != no)
          {
           degree_lat  =  LCL$ApparentLat$F * 180.0 / $pi
           degree_long =  LCL$ApparentLon$F * 180.0 / $pi

           LCL$TargetId$I = xLCL$TargetId$I
           if (LCL$TargetId$I == $Enemy$Code)
             color = $Color$Obj$Orange
           else if (LCL$TargetId$I == $Friendly$Code)
             color = $Color$Obj$Blue
           else if (LCL$TargetId$I == $Neutral$Code)
             color = $Color$Obj$Neutral
           else
             color = $Color$Obj$Unknown

           len = 0
           call smovv ("       ", name1, len)
           call smov  (EOS, name1, len)
           len = 0
           call smovv ("       *", name2, len)
           call smov  (EOS, name2, len)
           #len = Draw_Local_L (degree_lat, degree_long, color)
          }   # end of if in the geo area
       }   # end of if a radar or visual
     lcl_index = xLCL$NextIndx$I
    }   # end of loop through the unit's lcl linked list

return
end


Subroutine Plot_Persistent_Munitions (STA$Pointer)
#############################################################################
#$%
#$% Purpose:    Draws x-marks at the location of persistent munitions.
#$%             The color of the x-mark depends upon the side of the
#$%             munition and the name line will be the munition type.
#$%
#$% Called By:  Plot_Up
#$%
#$% Calls:      binck          <lbplot.rat>
#$%             int
#$%             smov..         <lbsmov.rat>
#$%             Draw_Unit_C    <cdwdraw.rat>
#$%             Draw_Vector_C  <cdwdraw.rat>
#$%             Plot_Local_Detections
#$%
#$% Tables:     STA     PEM     BOM
#$%
#$% Date:       January 1997 (E1731)
#$%
#$% Author:     Carol Kropp
#$%
#############################################################################
BBcommon
PLOTcommon

integer  STA$Pointer

integer  BINCK       # function to determine if location is on display area
integer  Game_DTG    # function to produce Day Time Group

integer    STA$View$I
integer    STA$PlotPEMDataBlue$I
integer    STA$PlotPEMDataNeutral$I, STA$PlotPEMDataOrange$I
integer    PEM$Pointer, PEM$Side$I, PEM$BOMIndx$I
BBDeclare  (STA$PlotLabelDeclutter$I)
real       PEM$Latitude$F, PEM$Longitude$F
integer    BOM$Pointer
integer    name_len
character  name1[ARB], name2[ARB]
integer    color, mark
real       lat, long

literal CSTRIP8                                 # MJC 6/1/2K (E2145)

  if (xSTA$PlotPEMData$I != $no)
    {
     STA$View$I = xSTA$View$I
     STA$PlotPEMDataBlue$I = xSTA$PlotPEMDataBlue$I
     STA$PlotPEMDataNeutral$I = xSTA$PlotPEMDataNeutral$I
     STA$PlotPEMDataOrange$I = xSTA$PlotPEMDataOrange$I
     STA$PlotLabelDeclutter$I = xSTA$PlotLabelDeclutter$I

     for (PEM$Pointer$First; PEM$Pointer$Valid; PEM$Pointer$Next)
       {
        PEM$Side$I = xPEM$Side$I
        if ((PEM$Side$I == $Blue$Code & STA$PlotPEMDataBlue$I == $yes)       |
            (PEM$Side$I == $Neutral$Code & STA$PlotPEMDataNeutral$I == $yes) |
            (PEM$Side$I == $Orange$Code & STA$PlotPEMDataOrange$I == $yes)   )
          {
           PEM$Latitude$F = xPEM$Latitude$F
           PEM$Longitude$F = xPEM$Longitude$F
           if (BINCK (PEM$Latitude$F, PEM$Longitude$F) != NO)
             {
              PEM$BOMIndx$I = xPEM$BOMIndx$I
              BOM$Pointer$To  (PEM$BOMIndx$I)
              name_len = 0
              call smovhn (xBOM$Name$C, $$MaxLit, name1, name_len)
              call smovv  (" - ", name1, name_len)
              call smovi  (xPEM$NbrDetsRemaining$I, name1, name_len)
              call smov   (EOS, name1, name_len)
              name_len = 0
              call smoviz (Game_DTG (xPEM$TerminationTime$F), 6, name2, name_len)
              call smovv  ("Z", name2, name_len)
              call smov   (EOS, name2, name_len)

              if (PEM$Side$I == $Blue$Code)
                color = $Color$Obj$Blue
              else if (PEM$Side$I == $Orange$Code)
                color = $Color$Obj$Orange
              else
                color = $Color$Obj$Neutral

              lat = PEM$Latitude$F * 180.0 / $pi
              long = PEM$Longitude$F * 180.0 / $pi
	      mark = $NTDS$Xmark
              call draw_ntds_c (mark, lat, long,
                              color, STA$PlotLabelDeclutter$I, name1, name2)
             }   # end of if this one is on the display area
          }   # end of if this station can see this PEM entry
       }   # end of loop through the PEM table
    }   # end of if station wants to see the persistent munitions

return
end   # end of Plot_Persistent_Munitions


subroutine draw_new_map (map_name)
implicit none
GPH2common

literal         map_name
character       new_name[ARB]
integer*4       kk
integer		c_munmap_geomap, irc, trnlog_v, ierr
integer		fopenm, seg_jfn
integer		ok_to_write

ok_to_write = 0		# readonly

kk = trnlog_v ("MAP_TOOLS",     new_name)
call smovv  ("/pt",    new_name, kk)
call smovhn (map_name,$$MaxLit, new_name, kk)
call smovv  ("g.dat",           new_name, kk)
call smov   (EOS, new_name, kk)

#call releasemap
irc = c_munmap_geomap($MAP_PAGES*512)


ierr = FOPENM (seg_jfn,new_name,$MAP_PAGES,ierr)

#call getmap
call c_mmap_geomap(seg_jfn, mapdef, $MAP_PAGES*512)

return
end
