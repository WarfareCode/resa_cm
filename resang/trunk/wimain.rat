##  File    WIMAIN.rat
###
###  Aug. 1998     J.O. Allen  Moved load_shore_alt to lbelevation.rat
###
###  Nov. 1996     J.O. Allen  Added call to build DTED map file.
###
###  15-Sept-1994  C.L. Kropp  Moved routine wgvue to new file wivue.rat
###                            (Code was duplicated in glmain.rat).
###
###  13-July-1988  D.E. Wills  Added call to GET_COMMAND_LINE
###                            changed references to '20' arguments to $MAX$ARGS
###

###
### WES version 3.1 converted to the VAX 11/780     dated 15-jan-1982
###
### smn   prog    module  comments
### ===   ====    ======  =================================================
### VAX00 kmd     wimain  converted to the VAX11/780 and to handle the 
###                       parser redesign


#####   version 3.1  dated-  7apr81  


###
### mod to version 3.0          dated 4-mar-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 rjw     wgvue   added code to init default embarcation, circuit
###


###
### mod to version 3.0          dated 13-jan-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 dew     wgcat   removed -- moved to wcommn.rat
###             asktsk  changed parser format to include max number of tracks
###                     and validate within max rmt$slots
### 002 rjw     wgvue   modified init of plot center to use OWN tbl
###


###
### mod to version 3.0          dated 02-jan-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 dew     start0  removed question about number of tracks.
###             asktsk  added argument for number of remote tracks.
###             wgplay  added code to init vue$FirstRmtIndx$i & LastRmtIndx,
###                     added argument to asktsk for number of remote tracks.
###


#####   version 3.0  dated- 22dec80


# 

#$%      MODULE                        UTILITY                     DATA
#$%    SUBROUTINES                   SUBROUTINES                  TABLES
#$%    ===========                   ===========                  ======
#$%
#$%      WARGAM                        ECHO                        VUE
#$%      GETCH                         ECHOH                       UNT
#$%      ASKNUM                        ECHOHN                      OWN
#$%      ASKTSK                        ECHOI                       ANO
#$%      ASKNAM                        ECHOR                       PRL
#$%      ASKQST                        ECHOFF                      SON
#$%      ASKSYS                        MONTYP                      SOB
#$%      START0                        RUNP                        SHN
#$%      START1                        TYPERR                      SWB
#$%      START2                        TTYIN                       LDK
#$%      START3                        HLTSLF
#$%      WGVUE                         SMOVH
#$%      WGPLAY                        SMOVI
#$%      ORDGEN <WGORDS>               XDEFIN
#$%      ORDPAR <ORDPAR>               XPRINT
#$%      BBLODM <WCOMMN>
#$%      BBLOD1 <WCOMMN>
#$%      WGLOAD <WCOMMN>
#$%      SORTTN <SORTTN>
#$%      LDENV  <LDENV >
#$%      LDLDK  <WILDLDK.RAT>
#$%      OSAVE1 <WGSAVE>
#$%      RESTBB <WGSAVE>
#$%
#$%
#$%
#$%    NOTES
#$%    =====
#$%
#$%    1.  <FILENAME> INDICATES WHERE SUBROUTINE IS LOCATED.
#$%
#$%    2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%    3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%
#$%    FLOWCHART FOR FILE WARGAM
#$%    =========================
#$%
#$%    WARGAM - ORDGEN*
#$%           - ORDPAR*
#$%           - START0 - ASKNUM - ORDPAR*
#$%                    - BBINIT*
#$%                    - BBLOD1*
#$%                    - WGPLAY - ASKTSK - ORDPAR*
#$%                    - ASKSYS - BBLODM*
#$%                             - ORDPAR*
#$%                    - BBLODM*
#$%                    - WGVUE *
#$%                    - LDENV *
#$%                    - LDLDK *
#$%                    - ASKQST - ORDPAR*
#$%                    - SORTTN*
#$%                    - OSAVE1*
#$%           - START1 - ASKNUM - ORDPAR*
#$%                    - ASKQST - ORDPAR*
#$%                    - ASKSYS - BBLODM*
#$%                             - ORDPAR*
#$%           - START2 - RESTBB*
#$%           - START3 - RESTBB*
#$%                    - ASKQST - ORDPAR*
#$%                    - ASKSYS - BBLODM*
#$%                             - ORDPAR*
#$%           - ASKNUM - ORDPAR*
#$%           - ASKQST - ORDPAR*

define ($DEBUGP,)                       # display packing savings
define ($DEBUGv,#)                       # debug for vax conversion
define ($DEBUGF,)                       # allow command file input
define ($oldcode,#)
define ($newcode,)

include "bbctl.inc"         
include "bbcode.inc"         
include "bbvue.inc"         
include "bbunt.inc"         
include "bbown.inc"         
include "bbrmt.inc"         
include "ascii.inc"         
include "plplay.inc"                                                  #VAX00
include "bbswb.inc"         
include "bbsta.inc"         
include "bbshc.inc"              # joa 11/95 (E1422)
include "bbwet.inc"              # joa 11/95 (E1422)
include "elevation.inc"          # joa 11/95 (E1422)

define (BBimplicit,Implicit None)


program wargame_init

########################################################
#$%
#$% Purpose:   WARGAME_INIT loads the scenario file into the
#$%            blackboard and processes interactive player
#$%            commands to define game parameters.
#$%
#$% Called By: None
#$%
#$% Calls:     ASKNUM     ASKQST     ECHO
#$%            ECHOFF     ECHOH      ECHOHN
#$%            ECHOR      GETCH      MONTYP
#$%            ORDGEN     ORDPAR     RUNP
#$%            SMOVH      START0     START1
#$%            START2     START3     TYPERR
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 11/95 (E1422)
#$%            Set flag so that program can write to
#$%            terrain database.
#$%
########################################################
BBcommon
literal pvlex[$max$args]                                       #VAX00
integer*4    num_pages
integer      ierr

EXTERNAL ERROR_HANDLER
integer      ok_to_write         # DTED map flag (E1422)


parse$common(orders)             # tell the parser the          #VAX00
                                 # symbolic name of the parse table

integer     ihandle, ichan_in, ichan_out, istat, nargs, nord, ians, sta$pointer
string pmsg1 "Enter the type of run: "

call process_command_line (num_pages)

#call echoff
call tty_set_echo (NO)          # turn off keyboard echoing

BBmap
DTED_map

#call check_active (ierr)
#if (ierr == YES) call exit

ok_to_write = 1

#$% initialize values
sync$a = 0
detached$mode = $yes              # swar detached from keyboard
halt$request = $no
auto$logout = $no

                                 # set up for parser interface    VAX00
parse$set$NotFor($clear$NotFor)  # reset not for option back to for-all

ihandle = 0

CALL Recall_Init (iHandle, ichan_in, 20, 130)

PARSE$SET$RECALL(ihandle)
 

#CALL LIB$ESTABLISH (ERROR_HANDLER)  # required for ALPHA capture of Errors
#call init_errset                # turn off Arithimetic Errors

#$% display message to user
call echor
call echov ("WARGAM. (Initialization)")
call echor

repeat
   {
    #$% if last scenerio name found
    if (scenario$name != 0)
       {
        #$% display message to user
        call echor
        call echov ("The last wargam was for the scenario named ")
        call echohn (scenario$name,$$MAXname) # jb E2141    1/25/00
        call echo ($period)
       }

    #$% carriage return    
    call echor

    #$% initialize status to YES
    istat = $yes

    parse$set$group($grp$InitStrt)   # parse only the wargame initialization
                                     # commands that start the game   #VAX00
    # call the parser so the player can input one command
    # the parser will return the arguments entered by the player       VAX00

    parse$command(orders,    # symbolic name used in parse$common
                  nargs,     # variable to receive the argument count
                  pvlex,     # literal array to receive the arguments
                  nord,      # variable to receive the order code number
                  3,         # time in seconds to return in if no input given
                  pmsg1)     # string to display prior to input

    $DEBUGv call echor
    $DEBUGv call echov ("done with parser first call ")
    $DEBUGv call echoi (int(pvlex[1]))
    $DEBUGv call echor

    #$% if input is ^K command to cancel
    if (nord < 0)                       
       {
        #$% display message to user and get next user input
        call echor
        call echor
        call exit
       }

    #$% if "new" game mode selected by user
    if (pvlex[1] == $lex$new$)
       {
        #$% set mode of execution to indicate a new game
        execution$mode = new$mode               
        #$% get system set up for a new game
        call start0 (pvlex,istat)
        #$% if new game parameters not all set up, get next user input
        if (istat != $yes) next
       }
    #$% else if "continue" game mode selected by user
    else if (pvlex[1] == $lex$continue$)
       {
        #$% get system set up for continue mode
        call start1 (pvlex,istat)
        #$% if continue game parameters not all set up, get next user input
        if (istat != $yes) next
       }
    #$% else if "review" game mode selected by user
    else if (pvlex[1] == $lex$review$)
       {
        #$% set execution mode to review
        execution$mode = review$mode    
        #$% get system set up for review mode
        call start2 (pvlex,istat)
        #$% if review game parameters not all set up, get next user input
        if (istat != $yes) next
       }
    #$% else if "restart" game mode selected by user
    else if (pvlex[1] == $lex$restart$)
       {
        #$% set execution mode to restart
        execution$mode = restart$mode    
        #$% get system set up for restart mode
        call start3 (pvlex,istat)
        #$% if restart game parameters not all set up, get next user input
        if (istat != $yes) next
       }

    call echor
    #$% ask for length of a game minute:
    call asknum("Enter number of clock seconds per cycle (3-400): ",3,400,ians)
     #$% if answer is not valid get next entry from user
    if (ians < 0) next
    #$% if answer is valid set game minute length to input
    game$rate = 60. / ians
    time$spec = time$step * $Seconds$per$Minute / game$rate

     #$% repeat loop until all requirements have been satisfied
   } until (istat == $yes)

#$% reinitialize values
halt$request = $yes+$yes  #Small halt-allow player sign on; avoid in use warning
auto$logout = $no
read$count = 0
read$request = -1
write$count = 0
write$request = -1
sync$a = game$minute
sync$b = sync$a
cycle$start$time = 1
cycle$stop$time = 10

for (STA$Pointer$First; STA$Pointer$Valid; STA$Pointer$Next)
  putSTA$PlayerOn$I (NO)             # clear the station info

#call Write_C2_Data_Files     # <wic2.rat> - clk 2/95

#$% display messages to user
call echor
call echov ("Black Board Initialized.")
call echor
call echor
call echov ("Start up STATIONs and, when ready, start up SWARGAME")
call echor
call echor

call endr4

end


subroutine process_command_line (num_pages)

###########################################################
#$%
#$% Purpose:   Process_Command_line reads all of the command line arguments
#$%            
#$% Calls:     
#$%            
#$%
#$% Tables:    NONE
#$%
#$% Date:      NOV 90 
#$%
#$% Author:    WILLS
#$%
###########################################################
implicit none

integer*4       num_pages

character       buf[30]
integer         ctoi, getarg3, ic, k

call initr4

call help_pgm(0,
              "sinit: Initialize exercise",
              "sinit Tags: Scenario, Blackboard, DTED",
              "Usage: sinit [ | <scenario initialization file>]",
              "",
              "",
              "",
              "",
              "Example: sinit port.ini")

call get_command_line           # load file name for command file input (arg 1)

return
end


subroutine get_ch (char,itime)   # This routine calls ttyin for input

#############################################################
#$%
#$% Purpose:   GET_CH gets character inputs from the terminal.
#$%
#$% Called By: WARGAM
#$%
#$% Calls:     HLTSLF     GETFCH (TTYIN)
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
#############################################################
BBimplicit              # jb E2145  7/27/00

integer char,itime

repeat
    {
     #$% call for characters until a null is received
     call getfch (char,$yes,0)  # command file in (using ttyin)
    }until (char != $null)

#$% if the characters are ^Z, stop
if (char == $CNTLZ) call hltslf

return
end



subroutine send_  (iview,icode,ilen,itxt)                # dummy routine
BBimplicit              # jb E2145  7/27/00

integer itxt[10]

integer ilen, iview, icode                              # MJC 5/1/2000 (E-2145)

call echor
call echoh (itxt,ilen*5)
call echor

return
end


subroutine bbsavr                                       # dummy routine
                                                        # to lockout PLAYER
BBimplicit              # jb E2145  7/27/00

return
end



subroutine asknum (promptX,lo,hi,ians) # jb E2144 (X) 8/1/00
    # WARNING: lo and hi MAY BE CONSTANTS:  DON'T CHANGE!
##########################################################################
#$%
#$% Purpose:   ASKNUM displays the prompt and accepts a numeric answer 
#$%            from the player.  It then checks the number to see if 
#$%            it is within the desired interval and sets ians accordingly.
#$%            
#$%
#$% Called By: WARGAM     ASKWHO     START0
#$%            START1
#$%
#$% Calls:     ORDPAR     ECHOH      ECHOI
#$%            ECHO       ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBimplicit              # jb E2145  7/27/00

parse$common(orders)             # tell the parser the          
                                 # symbolic name of the parse table
literal pvlex[$max$args]
integer lo,hi,ians
integer NARGS, NORD              # MJC 5/1/2000 (E-2145)
character prompt[ARB]
VMSchar*(*) promptX                # jb E2144  8/1/00

call fs2rs(promptX, prompt)

repeat
   {
    ians = -1

    parse$set$group($grp$InitNum)    # parse only the wargame initialization
                                     # number command            

$DEBUGv call echor
$DEBUGv call echov ("call parser to get number")
$DEBUGv call echor


    #$% receive command entered by player from parser              

    parse$command(orders,    # symbolic name used in parse$common
                  nargs,     # variable to receive the argument count
                  pvlex,     # literal array to receive the arguments
                  nord,      # variable to receive the order code number
                  3,         # time in seconds to return in if no input given
                  prompt )    # string to display prior to input

$DEBUGv call echor
$DEBUGv call echov ("done with parser number call ")
$DEBUGv call echoi (int(pvlex[1]))
$DEBUGv call echor

    #$% if input is ^K command to cancel
    if (nord < 0) return
    ians = pvlex[1]          # The numeric value returned from the parser
                             # in pvlex[1] is stored as a floating point
                             # value with decimal value of .0
                             # Here it is placed into an integer variable
                             # and the decimal is stripped off.

    #$% if the input value is between the high and low limits, break loop
    if (ians >= lo & ians <=hi) break

    #$% otherwise, send "invalid" message to user
    call echov ("Invalid Input.  Must be between ")
    call echoi (lo)
    call echov (" and ")
    call echoi (hi)
    call echo ($PERIOD)
    call echor
   }

return
end
 



subroutine asktsk (prompt,lo,hi,itask,itrk,ibot,nrmt)
    # WARNING: lo and hi MAY BE CONSTANTS:  DON'T CHANGE!
########################################################
#$%
#$% Purpose:   ASKTSK generates a request for and
#$%            accepts a task number, track code,
#$%            bottle assignment, and number of
#$%            remote tracks.
#$%
#$% Called By: WGPLAY
#$%
#$% Calls:     ORDPAR     SMOVI      ECHOH
#$%            ECHOI      ECHO       ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBimplicit              # jb E2145  7/27/00

integer lo,hi,itask,nrmt
character prompt[ARB]                                                
literal pvlex[$max$args],ibot,itrk

integer NARGS,NORD,IANS,ILEN     # MJC 5/1/2000 (E-2145)

parse$common(orders)             # tell the parser the          
                                 # symbolic name of the parse table

repeat
   {
    itask = -1

    parse$set$group($grp$InitTask)  # parse only the wargame initialization
                                    # task-no, track-code, bottle command VAX00

    # receive command entered by player from parser                  

    parse$command(orders,    # symbolic name used in parse$common
                  nargs,     # variable to receive the argument count
                  pvlex,     # literal array to receive the arguments
                  nord,      # variable to receive the order code number
                  3,         # time in seconds to return in if no input given
                  prompt)    # string to display prior to input

    #$% if input is ^K command to cancel
    if (nord < 0) return

    #$% get task number, track code, bottle assignment, and
    #$% number of remote tracks from the orders parser
    ians = pvlex[1]
    if (ians <= 9999) ians = ians * 10 # convert from 4 to 5-digit task numbers
    itask = ians/1000
    itrk = pvlex[2]
    nrmt = pvlex[3]                                                   #smn002

    #$% if above inputs and command entered , set # bottles
    if (nargs >= 4 & pvlex[4] != $lex$none$)                          
        {
        ilen = 0; call smovv("        ", ibot, ilen)
        ilen = 0                                                      #smn002
        call smovi (int(pvlex[4]),ibot,ilen)                          #smn002
       }
    else                                                              #smn002
       {
        ibot = 'NONE'                                                 #smn002
       }

    #$% if task # is within the set limits, break from loop
    if (itask >= lo & itask <=hi & itask*1000 == ians) break

    #$% otherwise display "invalid" message to user
    call echov ("Invalid Input.  Task number must be between ")
    call echoi (lo/10)
    call echo ($PERIOD)
    call echoi (mod(lo,10))
    call echov (" and ")
    call echoi (hi/10)
    call echo ($PERIOD)
    call echoi (mod(hi,10))
    call echov (" and not exceed 2 digits.")
    call echor
   }

return
end
 



subroutine asknam (prompt,nans)                       

####################################################################
#$%
#$% Purpose:   ASKNAM generates a request and accepts a five 
#$%            character name input from the history file
#$%
#$% Called By: WIRSTART
#$%
#$% Calls:     ORDPAR
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
###################################################################
BBimplicit              # jb E2145  7/27/00

character prompt[ARB]                                              
literal pvlex[$max$args],nans

integer NARGS,NORD               # MJC 5/1/2000 (E-2145)

parse$common(orders)             # tell the parser the          
                                 # symbolic name of the parse table

repeat
   {
    nans = -1

    parse$set$group($grp$InitName)   # parse only the wargame initialization
                                     # name command                

    #$% receive command entered by player from parser                
    parse$command(orders,    # symbolic name used in parse$common
                  nargs,     # variable to receive the argument count
                  pvlex,     # literal array to receive the arguments
                  nord,      # variable to receive the order code number
                  3,         # time in seconds to return in if no input given
                  prompt)    # string to display prior to input

    #$% if input is ^K command to cancel, return for user input
    if (nord < 0) return

    #$% get five character name for calling subroutine
    nans = pvlex[1]

    #$% if order code # not a zero, break from loop (name inputted)
    if (nord != 0) break
   }

return
end
 


subroutine asksys (istat)                

########################################################
#$%
#$% Purpose:   ASKSYS generates a request for, and
#$%            accepts basic system wide values.
#$%
#$% Called By: START0     START1     START3
#$%
#$% Calls:     BBLODM     ECHO       ECHOH
#$%            ECHOR      ORDPAR     XDEFIN
#$%            XPRINT
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
bbcommon

literal pvlex[$max$args]                                        #VAX00
integer     istat, nargs, nord, ierr

parse$common(orders)             # tell the parser the          #VAX00
                                 # symbolic name of the parse table

string prompt ">>"

#$% display message to user
call echor
call echov  ("Define values now. (enter DONE to exit)")
call echor

#$% set status to indicate player input - changes to yes with
#$% no player input
istat = $no

#$% if review mode requested
if (execution$mode == Review$mode)                              #VAX00
    {
     parse$set$NotFor($Not$review)    # set not for option to not review 
    }
else
    {
     parse$set$NotFor($clear$NotFor)  # reset not for option back to for-all
    }

parse$set$group($grp$InitDfn)    # parse only the wargame initialization
                                 # define, display, and done commands

repeat
   {
    #$% receive command entered by player from parser             
    parse$command(orders,    # symbolic name used in parse$common
                  nargs,     # variable to receive the argument count
                  pvlex,     # literal array to receive the arguments
                  nord,      # variable to receive the order code number
                  3,         # time in seconds to return in if no input given
                  prompt)    # string to display prior to input

    #$% if input is ^K command to cancel
    if (nord < 0) return

    #$% if command input is "DONE"
    if      (pvlex[1] == $lex$DONE$) break
    #$% else if command input is "DEFINE"
    else if (pvlex[1] == $lex$DEFINE$)   
       {
        call xdefin (nargs,pvlex,ierr)      # process the define command

        #$% if valid value was entered
        if (ierr == $no) next
        #$% if invalid value was entered
        if (ierr == $yes)
           {
            #$% send warning message to user
            call echo ($bell)
            call echov ("Bad Value")
            call echo ($bell)
            call echor
           }
        #$% if category to be defined not available
        else
           {
            #$% send warning message to user
            call echov ("Sorry, that command is not enabled yet")
            call echor
           }
       }
    else if (pvlex[1] == $lex$DISPLAY$)    # if command is display (old print)
       {
        #$% display requested initialization data
        call xprint (pvlex[2],ierr) 

        #$% if data requested for display not available
        if (ierr != $no)
           {
            #$% send warning message to user
            call echov ("Sorry, that command is not enabled yet")
            call echor
           }
       }
    else
       {
        #$% else if entered command makes no sense
        call echov (" ???")
        call echo ($BELL)
       }
   }

parse$set$NotFor($clear$NotFor)  # reset not for option back to for-all

istat = $yes

return
end

define($no$vue,)
define($no$wet,#)
define($no$unt,#)

include "bbsta.inc"         

include "wixdefin.rin"         

include "wixprint.rin"         



subroutine start0 (param,istat)                         # startup new game

########################################################
#$%
#$% Purpose:   START0 initiates a new game.
#$%
#$% Called By: WARGAM
#$%
#$% Calls:     ASKNUM     ASKQST     ASKSYS
#$%            BBINIT     BBLOD1     BBLODM
#$%            ECHOH      ECHOI      ECHOR
#$%            LDENV      OSAVE1     SORTTN
#$%            WGCAT      WGLOAD     WGPLAY
#$%            WGVUE      LDLDK
#$%
#$% Tables:    VUE        UNT        OWN
#$%            ANO        PRL        SON
#$%            SOB        SHN        LDK
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 11/95 (E1422)
#$%            Call routine to init unit elevations.
#$%
########################################################
bbcommon
ElevationCommon   # (E1422)

literal param[$max$args]                                            #VAX00
character cfile[21]                                                 #VAX00

VAXcharacter v_prompt*80
Integer*4    v_len
integer     i, istat, ians, imax, jstat, nerrs, jj

for (i = 1; i <= $$BB$BeginTables; i = i + 1) { ibb[i] = 0 }

Scenario$name = param[2]                # name of scenario
call litlower(Scenario$name)

record$from$minute = 0

environment$name = param[3]             # name of environment file
call litlower(environment$name)

IF(param[4] == $lex$BETTER$)                # jb --to rank the de-
   {        # fault Environment with respect to the 3 others 10/23/90
    if(param[5] == $lex$GOOD$)
         Environment$DefaultLevel = 0        # jb 10/23/90
    else if(param[5] == $lex$FAIR$)
         Environment$DefaultLevel = 1        # jb 10/23/90
    else Environment$DefaultLevel = 2        # jb 10/23/90
   }
ELSE     Environment$DefaultLevel = 3        # jb 10/23/90

repeat
   {
    istat = $no

    ######################################### set up VUEs
    $neutral$view = 1
    $firstblue$view = 2

    v_len = 0
    call vmovv ("How many BLUE views will there be (1-", v_prompt, v_len)
    call vmovi ($MAX$Views$per$Side, v_prompt, v_len)
    call vmovv ("): ",v_prompt, v_len)    
    call vmov (EOS,v_prompt, v_len)    

#   call asknum (pmsg1,1,$MAX$Views$per$Side,ians) # ask how many BLUE views
##    call asknum (%%ref(v_prompt),1,$MAX$Views$per$Side,ians) # ask question
    call asknum (v_prompt,1,$MAX$Views$per$Side,ians) # 
    #$% if input value not valid
    if (ians < 0) return

    #$% establish number of last blue view
    $lastblue$view = ians + $firstblue$view - 1

    #$% set the first orange view to immediately follow the last blue view
    $firstorange$view = $lastblue$view + 1

    #$% set max number of views to $MAX$Views$per$Side
    imax = $MAX$Views$per$Game - ians - 1
    if (imax > $MAX$Views$per$Side) imax = $MAX$Views$per$Side

    v_len = 0
    call vmovv ("How many ORANGE views will there be (1-", v_prompt, v_len)
    call vmovi (imax, v_prompt, v_len)
    call vmovv ("): ",v_prompt, v_len)    
    call vmov (EOS,v_prompt, v_len)    

    call echor
    call asknum (v_prompt,1,imax,ians) # jb E2144 how many ORANGE views? 7/27/00
    #$% if number of views entered not valid, get next input
    if (ians < 0) next
    #$% set number of last orange view
    $lastorange$view = ians + $firstorange$view - 1

    #########################################

    call echor

    #$% initialize the blackboard
    call bbinit

    random$seed = 3                     # initialize random seed

    vue$used = vue$size                 # assign vue table size

    call wgplay (jstat)                 # initialize player info (task/track/
    if (jstat != $yes) next             #                         bottle/rmt)

    call asksys (jstat)                 # get basic system values
    if (jstat != $yes) next

    istat = $yes

   } until (istat == $yes)

call wgload                             # load scenario/characteristics tables

call bbinit_after                       # allocate remaining tables

call wgvue                              # set up default vue info (PLOT order)

call gen_rvu                            # initialize RVU Table

last$bb$page      = (Max$BB$Words-1)/128          #BB page = 128 words
last$bb$page$save = (Max$BB$Words$save-1)/128     #BB page = 128 words

#if ( last$bb$page$save == 0 |
#     Max$BB$Words$save == 0  )
#    {
#    last$bb$page$save = last$bb$page 
#    Max$BB$Words$save = Max$BB$Words
#    }

#$% display message to user
call echor
call echov ("Last blackboard address used =")
call echoi (Max$BB$Words$save)
call echov (".  (")
call echoi (last$bb$page$save+1)
call echov (" pages)")
call echor

# call wgcat (environment$name,".ENV ",cfile)

#$% set header info to start in first column
jj = 0
#$% move header in position to display cfile
call smovhn (environment$name,$$MaxName,cfile,jj) # SMM 8/99 E2141
call smov (EOS,cfile,jj)

call ldenv (cfile,nerrs)                # load environment file

if (nerrs < 0)
   {
    continue # stop                     # fatal error in ENV load
   }
else if (nerrs > 0)
   {
    #$% sent warning message to user
    call echoi (nerrs)
    call echov (" errors loading ")
    call echoh (cfile,10)

    #$% ask user if he wants to abort
    call askqst (". Do you want to abort? ",ians)
    if (ians != $no) stop
   }

if (LIDAR$File$Name != 0)
  {
   #$% LIDAR Diffuse Coefficient Probability File
   #$% set header info to start in first column
   jj = 0
   #$% move header in position to display cfile
   call smovhn (LIDAR$File$Name,$$MaxName,cfile,jj) # SMM 8/99 E2141
   call smovvn (".lid",cfile,jj)
   call smov (EOS,cfile,jj)

   call ldldk (cfile,nerrs)                # load LIDAR probability file
   
   if (nerrs < 0)
      {
       continue # stop                     # fatal error in LDK load
      }
   else if (nerrs > 0)
      {
       #$% sent warning message to user
       call echoi (nerrs)
       call echov (" errors loading ")
       call echoh (cfile,10)

       #$% ask user if he wants to abort
       call askqst (". Do you want to abort? ",ians)
       if (ians != $no) stop
      }
  }         # end of if a LIDAR file was specified


call sorttn                             # sort tonals in noise tables

#$% initialize values
game$minute = 1      # match up to PGA - JFR 6/12/94
game$time = game$minute
read$request = 1
read$count = 0

#$% OK to continue
Continue$ok = $yes

data$base$version = $$BBVersion

call load_shore_alt  # retrieve shorebase altitudes from dted data (E1422)

#$% display message to user
call echor
call echov ("Last blackboard address = ")
call echoi (Max$BB$Words$save)
call echov (".  (")
call echoi (last$bb$page$save+1)
call echov (" pages)")
call echor

call echov ("A total of ")
call echoi (Data$base$highwater / 128 + 1 )
call echov (" pages were used to initialize this scenario.")
call echor

#$% process a beginning save
call osave1 ($neutral$view)

return
end



subroutine start1 (param,istat)         # START-UP is CONTINUE

########################################################
#$%
#$% Purpose:   START1 starts a game in the CONTINUE
#$%            mode.
#$%
#$% Called By: WARGAM
#$%
#$% Calls:     ASKNUM     ASKQST     ASKSYS
#$%            ECHOH      ECHOI      ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
bbcommon

literal param[$max$args]                                          #VAX00
integer     istat, ierr, ians
character       vmsg[ARB]

#$% intialize status
istat = $no

#$% if not ok to continue
if (Continue$ok != $yes)
   {
    #$% display warning message to user
    call echor
    call echov ("The current state of the data base")
    call echov (" is not Continue-able")
    call echor
    call echov ("A New game or a Restart must be performed.")
    call echor

    return
   }

call check_version (ierr,vmsg)          # Correct Database Version?

if (vmsg[1] != EOS)
    {
    call echor
    call echoh (vmsg,ARB)
    }

if (ierr == YES)
    {
    call echor
    call echov ("A New initialization or a Restart from a compatible")
    call echov (" save must be performed.")
    call echor

    return
    }
else if (vmsg[1] != EOS)
    {
    call echor
    call echov ("Some system features will not be supported.")
    call echor
    }

#$% if in review mode
if (execution$mode == review$mode)
   {
    #$% display information message user
    call echor
    call echov ("Continuing in the review mode......  ")
    call echov ("Current game minute is ")
    call echoi (game$minute-1)
    call echor

    #$% ask for user input of which game minute to continue review through
    call asknum ("End at what minute? ",game$minute,99999,ians) # jb E2144 7/00
    #$% if user input invalid, return to calling subroutine
    if (ians < 0) return
    #$% get game minute to continue review through
    replay$thru$minute = ians

    #$% reset status to YES
    istat = $yes
   }
else
   {
    #$% else if in continue mode
    execution$mode = continue$mode
    #$% ask user if he wishes to modify any parameters (yes/no)
    call askqst ("Do you wish to modify any system parameters? ",ians) # jb /\ 
    #$% if answer invalid, return to calling subroutine     
    if (ians < 0) return
    #$% reset istat to YES
    istat = $yes
    #$% if answer is YES, get user input of values
    if (ians == $yes) call asksys (istat)
   }

return
end



subroutine start2 (param,istat)         

########################################################################
#$%
#$% Purpose:   START2 starts a game in the review mode (instant replay).
#$%
#$% Called By: WARGAM
#$%
#$% Calls:     ECHOH      RESTBB
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
##########################################################################
bbcommon

literal param[$max$args],name
character       vmsg[ARB]
integer         istat, ipnt, itype, iversn, ithru, jstat, ierr

#$% initialize status
istat = $no

#$% get scenerio name
name = param[2]      
#$% initialize ipnt for save function
ipnt = 3

#$% if command entered is "review from save"
if (param[ipnt] == $lex$save$)
   {
    #$% set variables for save function
    itype = 'sve'
    iversn = param[ipnt+1]
    ipnt = ipnt + 2
   }
else
   {
    #$% otherwise, set values for "review from begining"
    itype = 'beg'
    iversn = 0
    ipnt = ipnt + 1
   }

#$% get value of game minute to save through
ithru = param[ipnt]

#$% if "save through minute is prior to save minute
if (ithru <= iversn)
   {
    #$% display warning message to user and return
    call echov ("The thru-minute is prior to the save. Try again!")
    return
   }

game$designation = 0
game$Index       = 0

#$% call to restore blackboard
call restBB (name,itype,iversn,jstat)

#$% do not allow game to continue
Continue$ok      = $no
game$designation = 0
game$Index       = 0

if (jstat != $yes) return                       # if all restore OK ? NO...

call check_version (ierr,vmsg)          # Correct Database Version?

if (vmsg[1] != EOS)
    {
    call echor
    call echoh (vmsg,ARB)
    }

if (ierr == YES)
    {
    call echor
    call echov ("A New initialization or a Restart from a compatible")
    call echov (" save must be performed.")
    call echor

    return
    }
else if (vmsg[1] != EOS)
    {
    call echor
    call echov ("Some system features will not be supported.")
    call echor
    }

#$% get review mode data
scenario$name = name
call litlower(scenario$name)
replay$thru$minute = ithru
execution$mode = review$mode
review$fast = 0
next$order$to$execute = next$order$id
last$order$to$execute = 999999
game$pause = $no

if (iversn > 0)                             # fix time cause save$request
{
    game$minute = game$minute + 1           # is processed last in loop
    game$time = game$minute
}   
#$% reset status flag and allow game to continue
istat = $yes
Continue$ok = $yes

return
end



subroutine start3 (param,istat)         

#############################################################
#$%
#$% Purpose:   START3 starts a game in the restart mode.
#$%
#$% Called By: WARGAM
#$%
#$% Calls:     ASKQST     ASKSYS     RESTBB
#$%            
#$%
#$% Tables:    None
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
#############################################################
bbcommon

literal param[$max$args],name, label, ldtg
literal dtg
character cdtg[8]
equivalence (dtg, cdtg)

character       vmsg[ARB]
integer         istat, ipnt, itype, iversn, jstat, ierr, ians, kstat

character copyfrom[ARB]
character copyto[ARB]
character deletename[ARB]
literal   alsp_save_label
literal   alsp_save_day
literal   alsp_save_hhmm
 
integer       context, result1, result2
integer       copy_file, delete_file_version
integer       len

vmschar*4 itype_v
equivalence (itype_v, itype)

#$% initialize status
istat = $no

#  1              2                  3             4
#RESTART (from) ALSP (save label) <name> (at dtg) <dtg>

#  1              2                  3             4         4           5
#RESTART (from) LOCAL (save)      <name> (from) [BEGINNING | SAVE (at) <number>

if (param[2] == $lex$LOCAL$)
{
    #$% get scenerio name
    name = param[3] 
	call litlower(name)     

    #$% initialize ipnt for save function
    ipnt = 4

    #$% if "save from restart" command has been entered 
    if (param[ipnt] == $lex$save$)
    {
        #$% set variables for save function
        itype_v = "sve"
        iversn = param[ipnt+1]
        ipnt = ipnt + 2
    }
    else
    {
        #$% otherwise set variables for "restart from begining" function
        itype_v = "beg"
        iversn = 1
        ipnt = ipnt + 1
    }
}
# Restart from ALSP save file using ALSP file naming convention.
# Using label preceding day and dtg.
else if (param[2] == $lex$ALSP$)
{
    #$% get alsp label name
    label = param[3]
	call litlower(label)           
    name = scenario$name
    itype_v = "sve"
    iversn = 0

    # delete temporary save file
    len = 0
    call smovhn (name, $$MaxName, deletename, len)
    call smovv  ("h_0.sve",deletename,len)
    call smov   (EOS, deletename, len)
    #result1 = delete_file_version (deletename)

    len = 0; call smovv ("        ", alsp_save_label, len)
    len = 0
    call smovhn (label, $$MaxName, alsp_save_label, len)

    len = 0
    ldtg = param[4]
    call smoviz (int(ldtg), 6, dtg, len)
    len = 0
    if (cdtg[1] == '0') call smovh(cdtg[2], 1, alsp_save_day, len)
    else                call smovh(cdtg[1], 2, alsp_save_day, len)
    call smov   (EOS, alsp_save_day, len)

    len = 0
    call smovh (cdtg[3], 4, alsp_save_hhmm, len)
    call smov   (EOS, alsp_save_hhmm, len)


    # copy alsp save file to temporary file
    len = 0
    call smovv  ("*", copyfrom, len)
    call smovhn (alsp_save_label, $$MaxLit, copyfrom, len)
    call smovv  ("*", copyfrom, len)
    call smovhn (alsp_save_day, ARB, copyfrom, len)
    call smovv  ("_", copyfrom, len)
    call smovhn (alsp_save_hhmm, ARB, copyfrom, len)
    call smovv  ("*h.sve", copyfrom, len)
    call smov   (EOS, copyfrom, len)

    len = 0
    call smovhn (name, $$MaxName, copyto, len)
    call smovv  ("h_0.sve",copyto,len)
    call smov   (EOS, copyto, len)
    result2 = copy_file (copyfrom, copyto)

    # 275190088 means higher version exists so it is ok
    if (result2 != 0)
    {
        # save file not found. ask for another save file
        jstat = 0
        return
    } 
    
}

game$designation = 0
game$Index       = 0

#$% restore the blackboard
call restBB (name,itype,iversn,jstat)

#$% do not allow game to continue
Continue$ok      = $no
game$designation = 0
game$Index       = 0

#$% if all valid entries made
if (jstat != $yes) return

call check_version (ierr,vmsg)          # Correct Database Version?

if (vmsg[1] != EOS)
    {
    call echor
    call echoh (vmsg,ARB)
    }

if (ierr == YES)
    {
    call echor
    call echov ("A New initialization or a Restart from a compatible")
    call echov (" save must be performed.")
    call echor

    return
    }
else if (vmsg[1] != EOS)
    {
    call echor
    call echov ("Some system features will not be supported.")
    call echor
    }

if (param[2] == $lex$ALSP$)
{
	# delete temporary save file
	result1 = delete_file_version (deletename)
}

#$% get review mode data
scenario$name = name
call litlower(scenario$name)

record$from$minute = iversn
execution$mode = restart$mode
restore$name = name              # Rainform name for DMD
restore$time = iversn            # Rainform DMD version (game time)

#$% ask if any system modifications are desired (yes/no)
    ##call askqst (pmsg1,ians)                                      ## 7/26/00
call askqst ("Do you wish to modify any system parameters? ",ians)  # jb E2144
#$% if input is invalid, return to calling subroutine
if (ians < 0) return
#$% if answer is YES, get user input values - kstat is set to NO
#$% if inputs are made
if (ians == $yes) call asksys (kstat)
#$% else set kstat to YES to indicate no user inputs
else              kstat = $yes
#$% if no user inputs made, return to calling subroutine
if (kstat != $yes) return

#$% if version found and time between records exists
if (iversn != 0 & time$between$records != 0)
    {
    # continue
    }
else
    {
    execution$mode = new$mode               # flag startup as NEW
    kstat = $yes
    }

if (kstat == $yes)
{
    istat = $yes

    if (iversn > 0)                         # fix time cause save$request
    {        
        game$minute = game$minute + 1       # is processed last in loop
        game$time = game$minute
    }

}

#$% allow game to continue
Continue$ok = $yes

return
end



subroutine wgplay (istat)               # initialize player info

#############################################################
#$%
#$% Purpose:   WGPLAY initializes the player information.
#$%
#$% Called By: START0
#$%
#$% Calls:     ASKTSK     ECHOH      ECHOI
#$%            ECHOR
#$%
#$% Tables:    VUE
#$%
#$% Date:      OCT 80
#$%
#$% Author:    Dana Wills
#$%
#############################################################
bbcommon

literal ibot,itrk,cstrip

string pmsg0 "Enter CONTROL Task Id: "
string pmsg1 "Enter BLUEx Task Id: "
string pmsg2 "Enter ORANGEx Task Id: "

integer     istat, itask, nrmt, i, ierr, k 
BBdeclare  (VUE$pointer, vue$bottle$c, vue$trackcode$c, vue$forcecode$i, 
            vue$lastrmtindx$i, vue$firstrmtindx$i)

vue$pointer$first                       # init CONTROL

8000

#$% initialize values
istat = $no
vue$LastRmtIndx$i = 0                                                 #smn002

#$% display pmsg0 string
call echor
call asktsk (pmsg0,90,99,itask,itrk,ibot,nrmt)                        #smn002

#$% if task number not valid, return to calling subroutine
if (itask < 0) return

#$% reset values
istat = $yes
nrmt = 0

vue$bottle$c = ibot                                                   #smn002
putvue$bottle$c

vue$TRACKCODE$C = itrk
PUTVUE$TRACKCODE$C

vue$ForceCode$i = itask
PUTVUE$ForceCode$i

vue$FirstRmtIndx$i = vue$LastRmtIndx$i + 1                            #smn002
PUTvue$FirstRmtIndx$i                                                 #smn002

vue$LastRmtIndx$i = vue$FirstRmtIndx$i - 1 + nrmt                     #smn002
PUTvue$LastRmtIndx$i                                                  #smn002

call echor

#$% for each blue view
for (i = $firstblue$view; i <= $lastblue$view; i=i+1)   
   {
    #$% initialize blue views
    pmsg1[11] = i - $firstblue$view + $dig1

    repeat                              # ask for Task Number
       {
        #$% ask for user task number
        call asktsk (pmsg1,10,49,itask,itrk,ibot,nrmt)
        #$% if task number invalid, repeat subroutine
        if (itask < 0) goto 8000

        #$% data requested for display ok, set error flag
        ierr = $no
        #$% set view pointer to first position in view table
        vue$POINTER$first

        #$% for each view up to current one being processed
        for (k = $first$view; k < i; k = k + 1)
           {
            #$% through each view
            vue$POINTER$TO k
            #$% if task number in use
            if (itask == xVUE$ForceCode$i)
               {
                #$% send warning message and reset error flag
                call echov ("That Task Number is being Used.")
                call echor
                ierr = $yes
               }
            #$% if track code in use
            if (itrk == xVUE$TrackCode$c)
               {
                #$% send warning message and reset error flag
                call echov ("That Track Code is being Used.")
                call echor
                ierr = $yes
               }
            #$% if bottle in use
            if (ibot == xVUE$bottle$c & ibot != 'NONE')
               {
                #$% send warning message and reset error flag
                call echov ("That Bottle is being Used.")
                call echor
                ierr = $yes
               }
           }
         
        #$% if remote track table full
        if ((vue$LastRmtIndx$i + nrmt) > rmt$slots)                   #smn002
           {
            #$% send warning message and reset error flag
            call echov ("Maximum track storage exceeded (")        #smn002
            call echoi (rmt$slots)                                    #smn002
            call echov (").")                                       #smn002
            call echor                                                #smn002
            ierr = $yes                                               #smn002
           }

        #$% if no errors encountered, break
        if (ierr == $no) break

        #$% otherwise, send prompt message
        call echov ("Sorry, Re-Enter Please.")
        call echor

       }                                # until task, track-code & bottle ok

    #$% set pointer 
    vue$POINTER$TO i

    vue$ForceCode$i = itask
    PUTVUE$ForceCode$i

    vue$TrackCode$c = itrk
    PUTVUE$TrackCode$c

    vue$Bottle$c = ibot
    PUTVUE$bottle$c

    vue$FirstRmtIndx$i = vue$LastRmtIndx$i + 1                        #smn002
    PUTvue$FirstRmtIndx$i                                             #smn002

    vue$LastRmtIndx$i = vue$FirstRmtIndx$i - 1 + nrmt                 #smn002
    PUTvue$LastRmtIndx$i                                              #smn002
   }                                    # BLUE all defined


call echor

#$% for each orange view
for (i = $firstorange$view; i <= $lastorange$view; i=i+1)   
   {
    #$% initialize orange views
    pmsg2[13] = i - $firstorange$view + $dig1

    repeat                              # ask for Task Number
       {
        #$% ask for user task number
        call asktsk (pmsg2,50,89,itask,itrk,ibot,nrmt)
        #$% if task number is invalid, repeat subroutine
        if (itask < 0) goto 8000

        
        #$% data requested for display ok, set error flag
        ierr = $no
        
        #$% for each view up to current one being processed
        vue$POINTER$first

        #$% for each view up to current view being processed
        for (k = $first$view; k < i; k = k + 1)
           {
            #$% set pointer to view
            vue$POINTER$TO k
            #$% if task number in use
            if (itask == xVUE$ForceCode$i)
               {
                #$% send warning message and reset error flag
                call echov ("That Task Number is being Used.")
                call echor
                ierr = $yes
               }
            #$% if track code in use
            if (itrk == xVUE$TrackCode$c)
               {
                #$% send warning message and reset error flag
                call echov ("That Track Code is being Used.")
                call echor
                ierr = $yes
               }
            #$% if bottle in use
            if (ibot == xVUE$bottle$c & ibot != 'NONE')
               {
                #$% send warning message and reset error flag
                call echov ("That Bottle is being Used.")
                call echor
                ierr = $yes
               }
           }

        #$% if remote track table full
        if ((vue$LastRmtIndx$i + nrmt) > rmt$slots)                   #smn002
           {
            #$% send warning message and reset error flag
            call echov ("Maximum track storage exceeded (")        #smn002
            call echoi (rmt$slots)                                    #smn002
            call echov (").")                                       #smn002
            call echor                                                #smn002
            ierr = $yes                                               #smn002
           }

        #$% if no errors encountered, break from loop
        if (ierr == $no) break

        #$% otherwise send prompt message to user
        call echov ("Sorry, Re-Enter Please.")
        call echor
       }                                # until task, track-code & bottle ok

    #$% set view poointer
    vue$POINTER$TO i

    #$% get and save values
    vue$ForceCode$i = itask
    PUTVUE$ForceCode$i

    vue$TrackCode$c = itrk
    PUTVUE$TrackCode$c

    vue$Bottle$c = ibot
    PUTVUE$bottle$c

    vue$FirstRmtIndx$i = vue$LastRmtIndx$i + 1                        #smn002
    PUTvue$FirstRmtIndx$i                                             #smn002

    vue$LastRmtIndx$i = vue$FirstRmtIndx$i - 1 + nrmt                 #smn002
    PUTvue$LastRmtIndx$i                                              #smn002
   }                                    # ORANGE all defined

return
end


subroutine chkeq            # dummy routine 
BBimplicit              # jb E2145  7/27/00

return
end


subroutine chkflt           # dummy routine
BBimplicit              # jb E2145  7/27/00

return
end

subroutine close_alsp_log_file     # dummy routine - clk 1/94
BBimplicit              # jb E2145  7/27/00

return             # since wgmdsave.rat is linked into
end                # game initialization (this is for wargame)
