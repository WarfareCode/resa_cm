####    WGMDCOM Package
####
####    Entry Point into this Package: COMMOD
####
####    Package Call Tree:
####
####    COMMOD
####        INITIALIZE_COMMS_JAMMERS
####        CEQOFF
####        COMCLR
####        COMPRO
####            INTRA_NODE_ADVANCE
####            COMRDY
####                CMDLVR
####            SENDOK
####                DEPBOY
####                BLDHFT
####            COMACK
####            WHONXT
####                LORDHO
####            COMCON
####                HGTCOM
####                BOYRCV
####                    INTER_NODE_ADVANCE
####                    NODE_ADVANCE
####                    ACMLNK
####                        ACOUSDET
####                    HGTCOM
####                UNTRCV
####                    INTER_NODE_ADVANCE
####                    CHKLNK
####                        HGTCOM
####                        ACMLNK
####                            ACOUSDET
####            NUHOLD
####                ROGER
####            COMAGN
####        ADD_JAMMER_HFDF_ENTRIES

####    Record of Modifications:
####
####        Programmer          Date        Modification
####
####        trs                2/15/91      modified sui$ch$frequency$i to
####                                        sui$ch$frequency$f
####
####        G. G. Gustafson     3/2/88      Reordered the subprograms in this
####                                        package to be ascending by subpro-
####                                        gram name (either SUBROUTINE or
####                                        FUNCTION name).
####
####        G. G. Gustafson     3/2/88      Replaced the two lines
####
####                                            RETURN
####                                            END
####
####                                        with a single END statement.
####
####        G. G. Gustafson     3/2/88      Replaced the package call tree.
####
####        G. G. Gustafson     3/2/88      Added INITIALIZE_COMMS_JAMMERS
####                                        invocation in COMMOD.
####
####
####        G. G. Gustafson     3/3/88      Deleted $debug tests throughout.
####
####        G. G. Gustafson     3/3/88      Replaced ADVANC by the two subpro-
####                                        grams:
####
####                                            INTER_NODE_ADVANCE
####                                            INTRA_NODE_ADVANCE
####
####        G. G. Gustafson     3/7/88      Replaced HGTCOM by a generalized
####                                        subprogram which performs the same
####                                        functions as HGTCOM and HGTCOM2.
####                                        Replaced HGTCOM2 invocations by
####                                        HGTCOM invocations.
####
####        G. G. Gustafson     3/8/88      Added NODE_ADVANCE subprogram
####
####        G. G. Gustafson     3/21/88     Revised following subprograms:
####
####                                            BOYRCV
####                                            COMCON
####                                            COMMOD
####                                            UNTRCV
####
####        G. G. Gustafson     5/10/88     In COMMOD, added call to
####                                        ADD_JAMMER_HFDF_ENTRIES

###                     fILE  wgmdcom.RAT
###   VERSION 3.1  DATED-  7APR81
 
 
###
### MOD TO VERSION 3.0          DATED 27-FEB-1981
###
### SMN PROG    MODULE  COMMENTS
### === ====    ======  =================================================
### 002 RJW             SHORTENED ALL TRACE MESSAGES
###
 
###
### MOD TO VERSION 3.0          DATED 18-FEB-1981
###
### SMN PROG    MODULE  COMMENTS
### === ====    ======  =================================================
### 008 RJW     DEPBOY  ADDED CODE TO SET FIELD BOY$aCOUSTIC$I
###             SENDOK  NOW TESTS FIELD BOY$aCOUSTIC$I
###             BOYRCV  NOW TESTS FIELD BOY$aCOUSTIC$I
###
 
###
### MOD TO VERSION 3.0          DATED 14-JAN-1981
###
### SMN PROG    MODULE  COMMENTS
### === ====    ======  =================================================
### 002 DEW     WHSIDE  MOVED CODE TO WCOMMN.RAT
###
 
###
### MOD TO VERSION 3.0          DATED 29-DEC-1980
###
### SMN PROG    MODULE  COMMENTS
### === ====    ======  =================================================
### 002 RJW     COMPRO  ADDED NEW STUFF FOR REPORTING POLICY
###             COMAGN  NEW ROUTINE TO ALLOW RETRY USING ALTERNATE PATH
###
 
 
###   VERSION 3.0  DATED- 22DEC80
 
 
#

define(trace$sonar$Passive,istrip(trace$sonar,1,M1bits))
define(trace$Comm$EMI     ,istrip(trace$comm,1,M1bits))
 
undefine write
 
 include "ascii.inc"
 include "bbctl.inc"
 include "bbcode.inc"
 include "bbacc.inc"
 INCLUDE "bbano.inc"                                    #       6/26/84
 INCLUDE "bbboy.inc"
 INCLUDE "bbcob.inc"
 INCLUDE "bbcom.inc"
 INCLUDE "bbdeq.inc"
 INCLUDE "bbhft.inc"
 INCLUDE "bbpai.inc"
 INCLUDE "bbpat.inc"
 INCLUDE "bbprl.inc"
 INCLUDE "bbshn.inc"
 INCLUDE "bbson.inc"
 INCLUDE "bbsui.inc"
 INCLUDE "bbser.inc"                                    #       6/21/83
 INCLUDE "bbunt.inc"
 INCLUDE "hscmt.inc"
 
define (BBimplicit,IMPLICIT NONE)   # jb E2145  7/5/00
 
define(CMcommon,
 integer*4  nspec,          ##number of specific receivers at next node
            ispec[5],       ##array of specific receivers at next node
            navail,         ##number of holder slots available for new holders
            iavail[5],      ##ordered list of available holder slots
            nlinks,         ##number of receivers who could get message
            nrcvrs,         ##number of receivers who do get message
            ircvr[5],       ##array of receivers who do get message
            idonow[5],      ##flags indicating which holders to test this minute
            iacous,         ##flag indicating whether acoustic comm required
            level,          ##source level of acoustic transmission
            ifreq,          ##frequency of acoustic transmission
            isdeep,         ##flag indicating whether sender in or below layer
            isdpth,         ##sender depth
            ixequip,        ##senders DEQ equip index for Comm gear
            ixequip2,       ##receivers DEQ equip index for Comm gear
            ixequip3,       ##sender's DEQ equip pointer
            ndcatr,         ##type of platform for next node
            istype,         ##type of sending platform
            irtype,         ##type of receiving platform
            iflo,           ##lower limit of receiver band
            irdpth,         ##receiver depth
            irdeep,         ##flag indicating whether receiver in or below layer
            icount_Tx,      ## counter for entries in transmissions this cycle
            ifhi,           ##upper limit of receiver band
            I_am_Tx[com$slots*5], ## DEQ pointers that are transmitting this cy
            I_am_Tx_Channel[com$slots*5] # Tx Channel. akin to I_AM_TX above
 real*4     slope,          ##maximum depth/range within vertical beam width
            halfhb,         ##half of horizontal beam width
            rbrg,           ##bearing of sender wrt receiver
            rrlbrg,         ##relative bearing of sender wrt receiver
            rng,            ##range from sender to receiver
            shgt,           ##square root of sender antenna height
            scors          ##sender course
 
    common/scratch$pad/_
            nspec,ispec,navail,iavail,nlinks,nrcvrs,ircvr,idonow,iacous,
            level,ifreq,isdeep,isdpth,ixequip,ixequip2,ixequip3,ndcatr,istype,
            irtype,iflo,irdpth,irdeep,icount_Tx,ifhi,I_am_Tx,I_am_Tx_Channel,
            slope,halfhb,rbrg,rrlbrg,rng,shgt,scors
    )
 

 Subroutine acmlnk(ipntr,son$pointer,link,transmitter_pointer)
 
 
#######################################################
 #$%
 #$% Purpose:   ACMLNK validates for acoustic comm
 #$%            within limits to be heard.
 #$%
 #$% Called By: CHKLNK
 #$%
 #$% Calls:     INDFRQ     ACNOIS     ACOUSdet
 #$%
 #$% Tables:    SON        BOY        UNT
 #$%            PRL
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #validates acoustic comm within limits to be heard
 BBcommon
 CMcommon
 
REAL DI,RD,P,DIRDP, HALFVB                   # jb E2145  7/5/00
integer IBELOW,IABOVE,IFBELO,IFABOV,         # jb E2145  7/5/00
    IPNTR,IRNG,ITEST,LINK,BOY2$Pointer,      # jb E2145  7/5/00
    SON$Pointer,SON$SPD$Index,SON$SEC$Index, # jb E2145  7/5/00
    UNT2$Pointer, UNT2$Serindx$I,            # jb E2145  7/5/00
    SER$Pointer,  SER$Envnum$I,              # jb E2145  7/5/00
    PRL$Pointer,PRL$NV$Index,PRL$NV$FQ$Index # jb E2145  7/5/00
 Integer*4  transmitter_pointer,receiver_pointer
 
 #$% if receiver is commbuoy
 receiver_pointer = ipntr
 if (irtype == $commbuoy$code)
    {
     boy2$pointer = ipntr
     irdpth = xboy2$truedepth$i
     son$spd$index = 0
     di = 0
    }
 else
    {
     unt2$pointer = ipntr
     irdpth = xUNT2$truealtdepth$i
 
     son$sec$index = 1.0 + abs(rrlbrg) * (18./$pi)
     son$sec$index = min0(son$sec$index,18)
 
     di = xson$sec$di$i
 
     son$spd$index = XUNT2$TRUESPEED$F * .2 + .5
     if (son$spd$index > 6) son$spd$index = 6
     else if (son$spd$index < 1) son$spd$index = 1
    }
 
 #$% compute half vertical beam
 halfvb = xson$vertbeam$i * ($pi/360.)
 
 #$% compute maximum depth and range within beam width
 slope = 6075. * SIN(halfvb)/COS(halfvb)
 
 if (abs(isdpth - irdpth) > rng * slope)
    {
     link = $no
     return
    }
 
 #$% if receiver depth exceeds layer depth, set receiver depth to NO
 if (irdpth > layer$depth)  irdeep = $no
 #$% else set receiver depth to YES
 else                       irdeep = $yes
 
 #$% get recognition difference
 RD = XSON$RECOGNITIONDIFF$I
 
 #$% determine index (irng) and set PRL$pointer:
 irng = rng + .5
 irng = max0(irng,1)
 irng = min0(irng,120)
 PRL$Pointer$TO    IRNG                         #       6/21/83
 
 unt2$SerIndx$i = Xunt2$SerIndx$i       # Envrnmt tbl   6/26/84
 unt2$SerIndx$i =max(unt2$SerIndx$i,1)  #ensure nonzero 6/26/84
 SER$Pointer$to unt2$SerIndx$i          # Envrnmt tbl   6/26/84
 SER$EnvNum$i = Xser$EnvNum$i           # Envrnmt #     6/21/83
 PRL$NV$index = ser$EnvNum$i            # Envrnmt #     6/21/83
 
 call indfrq(ifreq,ibelow,iabove,ifbelo,ifabov) #(in WGMDSNR.rat)
 
 if (ifreq-ifbelo>ifabov-ifreq) prl$NV$FQ$index =ibelow #6/21/83
 else                           prl$NV$FQ$index =iabove #6/21/83
 
 ITEST = ISDEEP + IRDEEP   # ITEST=2 if both units below layer
 if      (ITEST == 0)  p = XPRL$NV$FQ$PROPLOSSIN$F      # 6/21/83
 else if (itest == 1)  p = XPRL$NV$FQ$PROPLOSSCROSS$F   # 6/21/83
 else                  p = XPRL$NV$FQ$PROPLOSSDEEP$F    # 6/21/83
 
 
 iflo = xson$loendfreq$i                #$% get low end frequency
 ifhi = xson$hiendfreq$i                #$% get high end frequency
 DiRdP = di - rd - p                    #               6/26/84
 
 call acousDET(DiRdP,                   # di-rd-p,      6/26/84
             son$pointer,
             son$spd$index,
             ser$EnvNum$i,
             link,
             transmitter_pointer,
             receiver_pointer)
End                    # End acmlnk subroutine

 Subroutine acousDET(_                  #Acoustic-Comm DETection
                   DiRdP,               # TERM (DI-RD-PRPLSS)   8/26/84
                   son$pointer,
                   son$spd$index,
                   ser$EnvNum$i,
                   link,                #detect flag (out)
                   transmitter_pointer,
                   receiver_pointer)
 
 #######################################################
 #$%
 #$% Purpose:   acousDET determines if a certain
 #$%            frequency is detected.
 #$%
 #$% Called By: ACMLNK
 #$%
 #$% Calls:     INDRFQ (in wgmdsnr.rat,
 #$%                            and invokes NLTEST, in lbmath.rat )
 #$% Tables:    ANO     SON
 #$%
 #$% Date:      6/26/84 (Adapted from FRQDET, in wgmdsnr.rat)
 #$%
 #$% Author:    Joe Bryant
 #$%
 ##############################################################
 BBcommon
 CMcommon                                       #               6/27/84
 
LITERAL    CSTRIP8                  # jb E2145  7/5/00
REAL    SN,FNOISE,FSE,              # jb E2145  7/5/00
    DIRDP, PROB1,PROB2              # jb E2145  7/5/00
 Real*4 Intra_Degradation, AN
 Integer LINK,NLTEST,NLTEST2,       # jb E2145  7/5/00
    IBELOW,IABOVE,IFBELO,IFABOV,    # jb E2145  7/5/00
    IFLAG1,IFLAG2,IFLAG3, KANO,     # jb E2145  7/5/00
    ANO$Pointer,ANO$NV$Index,       # jb E2145  7/5/00
    SON$Pointer,SON$SPD$Index,      # jb E2145  7/5/00
    SON$SPD$TN$Index,               # jb E2145  7/5/00
    ITX$Pointer,SER$Envnum$I        # jb E2145  7/5/00
 Integer*4 UNT$Pointer,UNT2$Pointer,DEQ2$Pointer,transmitter_pointer,
           receiver_pointer,DEQ$Pointer
 Logical Logged_This_Minute
 
 
 if (ifreq < iflo |                     #if outside of detector band
     ifreq > ifhi)
    {
     link = $no                 #no detection
     return
    }
 
 call INDFRQ( _
             IFREQ,
             IBELOW,
             IABOVE,
             IFBELO,
             IFABOV)
 
   ##Note: PPS pg 3-22 specifies NEAREST tabulated frequency    7/19/83
 if (iFabov -iFREQ < iFREQ -iFbelo )            # NEAREST       8/5/83
      kano = iabove
 else kano = ibelow                             #  tabulated    8/5/83
 
 ANO$POINTER$TO (kano)                          #   frequency.. 8/5/83
 ANO$NV$index = ser$EnvNum$i                    #               6/26/84
 
    ##Note:  PPS pg 3-18 specifies AN taken directly from file  7/19/83
 AN = XANO$NV$NOISE$F/10.       # AMBIENT noise right from tbl  7/19/83
    #NOTE: dividing AN by 10. prepares for FNOISE computation, below
 
 if(son$spd$index == 0) SN = 0.         #if no self-noise, set to zero
 else
    {
     SON$SPD$TN$INDEX = kano            #set index for freq     8/8/83
 
     SN = XSON$SPD$TN$LEVEL$I/10.       #Self-Noise @ IFREQ.    7/19/83
    # NOTE: dividing SN by 10. prepares for FNOISE computation, below
    ##---------------------------------------------------------
     if (trace$sonar$PASSIVE != $NO)            #       12/14/83
      {
       call echov (" nbSN=")                # 14
       call echof (SN,2)                        #       8/8/83
       call echov (" nbAN=")                # 14
       call echof (AN,2)                        #       8/8/83
      }
    ##-----------------------------------------------------------
    }   #endelse
 
 FNOISE = 10.*log10((1.0D+1)**SN + (1.0D+1)**AN) #PPS pg 3-20   8/11/83
 FSE  = level -FNOISE + DiRdP        #Sig.Excess; PPS pg 3-16   6/26/84
 
 if (rng < 5.)                                  # <<<>>>        6/27/84
        FSE = max(Sonar$Sigma,FSE)              # <<<>>>        6/26/84
 
 link = nltest(0.0,Sonar$SIGMA,FSE)# detect. flag               12/13/83
 
END           #  End  Subroutine acousDET
 

 Subroutine bldhft(unt$pointer,pai$pointer,lrflag)
 
#######################################################
 #$%
 #$% Purpose:   BLDHFT builds high frequency detection
 #$%            finder transmission data.
 #$%
 #$% Called By: SENDOK
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT        HFT
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #build high frequency detection finder transmission data
 
 BBcommon
 
Integer LRFLAG,                    # jb E2145  7/5/00
    HFT$Pointer,HFT$Senderindx$I,  # jb E2145  7/5/00
    HFT$Lowrisk$I,HFT$Frequency$I, # jb E2145  7/5/00
    UNT$Pointer, PAI$Pointer       # jb E2145  7/5/00
 
 #$% increment counter
 hft$pointer = hft$last + 1
 
 #$% if HFT pointer not valid, return
 if (!hft$pointer$valid)  return
 
 #$% set sender pointer
 hft$SenderIndx$i = unt$pointer$index
 puthft$SenderIndx$i
 
 #$% set low risk
 hft$LowRisk$i = lrflag
 puthft$LowRisk$i
 
 #$% set frequency
 hft$Frequency$i = xpai$freq$i
 puthft$frequency$i
 
 hft$pointer$next
 
 #$% Save high water mark
 hft$last$to hft$pointer - 1
 
 end

 
SUBROUTINE boyrcv ( transmitter_pointer,  # in: BOY or UNT Table pointer
                    com$pointer,          # in: COM Table pointer - comm msg
                    pat$pointer,          # in: PAT Table pointer - comm path
                    pai$pointer,          # in: PAI Table pointer - comm pair
                    pat$nod$index )       # in: PAT Table Receive Node Index
#################################################################
#$%
#$% Purpose:   Tests for message receipt at buoys.
#$%
#$% Called By: ComCon
#$%
#$% Calls:     acmlnk
#$%            echo..    <lbecho.rat>
#$%            hgtcom
#$%            proxim_m
#$%            inter_node_advance
#$%            node_advance
#$%            los_test
#$%
#$% Tables:    BOY     COM     PAI     PAT     SON
#$%
#$% Date:      February 1981
#$%
#$% Author:    Ron Williams
#$%            System Development Corporation
#$%
#$% Modified:  G. G. Gustafson - 3/21/88
#$%            Modified formal arguments and replaced ADVANC
#$%            calls by calls to INTER_NODE_ADVANCE and NODE_ADVANCE.
#$%
#$%            Jim Allen - 11/95 (E1422)
#$%            Added DTED Terrain LOS test.
#$%
#################################################################
BBcommon
CMcommon
 
LITERAL      ibuoy, CSTRIP8        # jb E2145  7/5/00
integer*4    los_test        # integer function - joa 11/95 (E1422)
INTEGER*4    transmitter_pointer,Dummy_Deq
REAL    BRG, RHGT                  # jb E2145  7/5/00
Integer I,IBX,LINK,                # jb E2145  7/5/00
    PAT$Pointer,  PAT$NOD$Index,   # jb E2145  7/5/00
    COM$Pointer,  COM$HO$Index,    # jb E2145  7/5/00
    BOY2$Pointer, PAI$Pointer,     # jb E2145  7/5/00
    SON$Pointer, UNT$Pointer       # jb E2145  7/5/00
LOGICAL*1  inter_node_advance, node_advance
EXTERNAL   inter_node_advance, node_advance
 
irtype = $commbuoy$code
IF ( nspec != 0 )                       # if sub deploying own buoy
    {                                   #     no condition to test
    FOR ( i=1; i<=navail; i=i+1 )
        {
        IF ( trace$comm != $no )
            {
            call echor
            call echoi(ispec[i])
            call echov (' is spec rcv buoy')
            call echov ('..link ok')
            }
        nlinks = nlinks + 1
        IF ( ! node_advance ( xPAI$ServiceRateInterval$F,                          # GGG
                              xPAI$PercentUtilization$I ) ) NEXT           # GGG
        IF ( trace$comm != $no )
            {
            call echov (' *** Rcvd ***')
            }
        #$% increment number of receivers
        nrcvrs = nrcvrs + 1
        ircvr [ nrcvrs ] = ispec [ i ]
        }
    }
ELSE
    {
    ibuoy = xpat$nod$platformtype$c     # type of buoy required
    FOR ( BOY2$POINTER$FIRST; still_ok (BOY2) ; BOY2$POINTER$NEXT )# 9/26/88
        {
        IF ( XBOY2$TYPE$I != $commbuoy$code ) NEXT
        IF ( xboy2$commname$c != ibuoy ) NEXT
        IF ( xboy2$KillTime$f <= game$time ) NEXT
        ibx = boy2$pointer$index
        FOR ( com$ho$index=1; com$ho$index$ok; com$ho$index=com$ho$index+1 )
            {
            #$% if holding buoy and is right buoy, break loop
            IF ( xcom$ho$buoy$i == $yes &
                 ibx == xcom$ho$indx$i ) BREAK
            }
        IF ( com$ho$index$ok ) NEXT     # skip if already holding
        IF ( trace$comm != $no )
            {
            call echor
            ibx = boy2$pointer$index
            call echoi(ibx)
            call echov (' right type buoy')
            }
        CALL proxim_M ( 0,                        # jb  _M    8/30/89
                      XBOY2$TRUELATITUDE$F,
                      XBOY2$TRUELONGITUDE$F,
                      xboy2$costruelat$f,
                      rng,
                      brg )
        IF ( rng < 0.0 ) NEXT
        IF ( iacous == $yes )           #if acoustic comm
            {
            #$% compute range and bearing
            rbrg = brg + $pi
            #$% if receiver is not acoustic, check next
            IF ( xboy2$Acoustic$i == $no ) NEXT                     #smn008
            #$% set sonar pointer
            son$pointer = XBOY2$EQPNTR$I
 
            #$% check if acoustic comm can be heard and can make a link
            CALL acmlnk ( boy2$pointer, son$pointer, link, transmitter_pointer)
 
            #$% if link is NO, get next
            IF ( link == $no ) NEXT
            }
        ELSE IF ( xpai$lineofsight$i == $yes )
            {
            #$% check antenna height
            CALL hgtcom ( irtype, boy2$pointer, ixequip2, rhgt )
 
            #$% if range exceeds LOS, get next
            IF ( rng > 1.23 * ( shgt + rhgt ) )
              NEXT
 
            unt$pointer = transmitter_pointer
            if (los_test (                  # Uses GP terrain grid to determine LOS  (E1422)
                    Xunt$TrueLatitude$f,    # Detector latitude: real: in: rad
                    Xunt$TrueLongitude$f,   # Detector longitude: real: in: rad
                    Xunt$CosTrueLat$f,      # Cosine of detector latitude: real: in:rad
                    shgt,                   # Sqrt Detector altitude: real: in: ft
                    Xboy2$TrueLatitude$f,   # Target latitude: real: in: rad
                    Xboy2$TrueLongitude$f,  # Target longitude: real: in: rad
                    Xboy2$CosTrueLat$f,     # Cosine of target latitude: real: in:rad
                    rhgt) == $NO)           # Sqrt Target altitude: real: in: ft
              {
                next                 # Comms obscured by terrain
              }
            }
        IF ( trace$comm != $no )
            {
            call echov ('..link ok')
            }
 
        #$% increment number of links counter
        nlinks = nlinks + 1
 
        #$% call test message advance
 
        IF ( ! inter_node_advance ( PAI$Pointer,                           # GGG
                                    BOY2$Pointer,                          # GGG
                                    transmitter_pointer,
                                    dummy_deq) ) NEXT           # GGG
        IF ( trace$comm != $no )
            {
            call echov (' *** Rcvd ***')
            }
 
        #$% increment number of receivers counter
        nrcvrs = nrcvrs + 1
        ircvr [ nrcvrs ] = ibx
 
        #$% if number of receivers exceeds number available, break loop
        IF ( nrcvrs >= navail ) BREAK
        }
    }
END

 Subroutine ceqoff              #switches everybody's comm equipment off
 
#######################################################
 #$%
 #$% Purpose:   CEQOFF flags all communication
 #$%            equipment as "Not Emitting".
 #$%
 #$% Called By: COMMOD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    HFT        UNT        DEQ
 #$%            BOY
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 CMcommon
 
Integer  UNT$Pointer,UNT$Type$I,   # jb E2145  7/5/00
    DEQ$Pointer,DEQ$Ident$I,       # jb E2145  7/5/00
    BOY$Pointer,BOY$On$I           # jb E2145  7/5/00
 
 hft$used = 0               # hf transmission list treated as empty
 icount_Tx = 0              # counter for entries in transmissions this cycle
 
 if (EMI$Analysis == $NO)
    {
     #$% for each entry
     for (unt$pointer$first; still_ok(unt) ;unt$pointer$next) # 9/26/88
        {
         if (xUNT$GhostedUnit$I == $YES) next   # skip ghosted units 5/18/92 SMM
 
         unt$type$i = Xunt$type$i
 
         if (unt$type$i != $surface$code       &                    # 17NOV83
#            unt$type$i != $Surfacewithac$code &                    #    "
             unt$type$i != $Sub$code           &                    #    "
             unt$type$i != $ShoreBase$code     &                    #    "
             unt$type$i != $air$code            )  next             #    "
 
         #$% for each dynamics entry
          FOR_DEQ_Chain
            {
             #$% get equipment ID
             deq$ident$i = xDEQ$ident$i
 
             #$% if equipment is acoustic and commsuite, get next
             if (DEQ$ident$i != $AcousticComm$Code &
                 DEQ$ident$i != $CommSuite$Code)  next
 
             putDEQ$on$i ($OFF)
             putDEQ$AllBands$i ($OFF)               # 12/90 reh
            }
        }
    }
 
 #$% for each buoy entry
 for (boy$pointer$first;still_ok(boy);boy$pointer$next) # 9/26/88
    {
     #$% if type is commbuoy
     if (xboy$type$i == $CommBuoy$Code)
        {
         #$% set buoy to OFF
         boy$on$i = $off
         putboy$on$i
        }
    }
 
 end

 Subroutine ceqoff_pass2         #switches everybody's comm equipment off
                                 # with on According to I_AM_Tx array
 
#######################################################
 #$%
 #$% Purpose:   CEQOFF flags all communication
 #$%            equipment as "Not Emitting".
 #$%
 #$% Called By: COMMOD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    HFT        UNT        DEQ
 #$%            BOY
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 CMcommon
 
 Integer N, UNT$Pointer, UNT$Type$I,       # jb E2145  7/5/00
    DEQ$Pointer,DEQ$Ident$I,DEQ$EM$Index   # jb E2145  7/5/00
 
 if (EMI$Analysis == $no) return
 
 #$% for each entry
 for (unt$pointer$first; still_ok(unt) ;unt$pointer$next) # 9/26/88
    {
     if (xUNT$GhostedUnit$I == $YES) next   # skip ghosted units 5/18/92 SMM
 
     unt$type$i = Xunt$type$i
 
     if (unt$type$i != $surface$code       &                    # 17NOV83
#        unt$type$i != $Surfacewithac$code &                    #    "
         unt$type$i != $Sub$code           &                    #    "
         unt$type$i != $ShoreBase$code     &                    #    "
         unt$type$i != $air$code            )  next             #    "
 
     #$% for each dynamics entry
      FOR_DEQ_Chain
        {
         #$% get equipment ID
         deq$ident$i = xDEQ$ident$i
 
         #$% if equipment is acoustic and commsuite, get next
         if (DEQ$ident$i != $AcousticComm$Code &
             DEQ$ident$i != $CommSuite$Code)  next
 
         putDEQ$on$i ($OFF)
         putDEQ$AllBands$i ($OFF)               # 12/90 reh
        }
    }
 
for ( N = 1; N <= icount_tx; N = N + 1)
    {
    DEQ$pointer = I_am_Tx[N]  # DEQ pointers that are transmitting this cycle
    DEQ$EM$Index = I_Am_Tx_Channel [N]  # 12/5/90 reh
 
    putDEQ$EM$Band$i ($On)              # 12/5/90 reh
    putDEQ$on$i ($ON)
    }
 
 end

Subroutine chklnk(unt2$pointer,
                  pai$pointer,
                  ispecific,                   #flag indicating specific rec
                  link,                        #flag indicating if link ok
                  transmitter_pointer)
 
#######################################################
#$%
#$% Purpose:   CHKLNK validates receiver equipment
#$%            and posture.
#$%
#$% Called By: UNTRCV
#$%
#$% Calls:     PROXIM     HGTCOM2     ANGPI
#$%            ACMLNK
#$%
#$% Tables:    UNT        PAI
#$%            ACD        SB         SHD
#$%            SON
#$%
#$% Date:      FEB 81
#$%
#$% Author:    Ron Williams
#$%
#$% Modified:  Jim Allen - 11/95 (E1422)
#$%            Added DTED Terrain LOS test.
#$%
#######################################################
#validate receiver equipment and posture
 
BBcommon
CMcommon
 
literal LRCVEQ,SNDREQ
LITERAL DEQ2$Type$C, CSTRIP8    # jb E2145  7/6/00
REAL PAI$Offcourse$F, RCORS,    # jb E2145  7/6/00
    BRG,RHGT,OFFNS,SRLBRG       # jb E2145  7/6/00
Integer LDEPTH,LSPEED,LINK,     # jb E2145  7/6/00
    ISPECIFIC,UNT2$Pointer,     # jb E2145  7/6/00
    DEQ2$Pointer,DEQ2$Ident$I,  # jb E2145  7/6/00
    PAI$Pointer,SON$Pointer,    # jb E2145  7/6/00
    UNT$Pointer                 # jb E2145  7/6/00
integer*4    los_test        # integer function - joa 11/95 (E1422)
Integer*4    transmitter_pointer
Integer      LCOMP   # jb AAI01/LCOMP E2145 2/13/00
 
if (trace$comm != $no) call echov ('..rng/eq')
 
#$% set flag to NO
link = $no
 
#$% get range and bearing to target
call proxim_M (unt2$Pointer$Index,    # jb    _M        8/29/89
               xunt2$truelatitude$f,
               xunt2$truelongitude$f,
               xunt2$costruelat$f,
               rng,
               brg)
 
 
#$% if range less than zero, return
if (rng < 0.0)  return
 
LRCVEQ = XPAI$RECEIVINGEQUIPMENT$C             #get rcvr equipment name
SNDREQ = XPAI$SENDINGEQUIPMENT$C             #get sender equipment name
 
#$% if receiver is aircraft
if (irtype == $air$code)                       #if receiver is aircraft
    {
    #$% aircraft must have mission of relay, or comm pair has mission
    #$% override authority.
    if(ispecific              == $NO             &
       xunt2$mission$i        != $commrelay$code &
       xpai$missionoverride$i == $no              )  return
 
 
    #$% for each aircraft equipment entry
    FOR_DEQ2_CHAIN
        {
        #$% if commsuite and right receiving equipment
        if(xdeq2$ident$i == $commsuite$code & #if right receiving equipment
          LCOMP(XDEQ2$type$C,LRCVEQ) == 0)  # jb AAI01/LCOMP  2/13/01
            {
            LINK = $YES                          #link ok
            ixequip2 = deq2$Pointer$index
            break
            }
        }
    }
 
else if(irtype == $SHOREBASE$CODE)             #if receiver is shorebase
    {
    #$% for each shorebase equipment entry
    FOR_DEQ2_CHAIN
        {
        #$% if commsuite and right receiving equipment
        if(xdeq2$ident$i == $commsuite$code &  #if right receiving equipment
           LCOMP(XDEQ2$type$C,LRCVEQ) == 0)  # jb AAI01/LCOMP  2/13/01
             {
            LINK = $YES                          #link ok
            ixequip2 = deq2$pointer$index            # reh 3/89
            break
            }
        }
    }
 
else if(irtype == $SUB$CODE |              #if receiver is ship or sub
        irtype == $SURFACE$CODE)       #NOTE: INCLUDES SURFACEWITHAC...
    {                                   # (see calling subroutine)
    #$% if not acoustic
    if (iacous == $no)
        {
        #$% for each ship equipment entry
        FOR_DEQ2_CHAIN
            {
            #$% if commsuite and right receiving equipment
            deq2$ident$i = xdeq2$ident$i
            DEQ2$type$C  = xDEQ2$type$C
 
            if (deq2$ident$i == $commsuite$code & #if right receiving equipment
                LCOMP(DEQ2$type$C,LRCVEQ) == 0)  # jb AAI01/LCOMP  2/13/01
                {
                #$% link OK
                link = $yes
                ixequip2 = deq2$Pointer$Index
                break
                }
            }
        }
    else
        {
        #$% for each ship equipment entry
        FOR_DEQ2_CHAIN
            {
            #$% if acoustic comm and right receiving equipment
            deq2$ident$i = xdeq2$ident$i
            DEQ2$type$C  = xDEQ2$type$C
 
            IF  (deq2$ident$i == $acousticcomm$code & #right receiving equipment
                 LCOMP(DEQ2$type$C,LRCVEQ) == 0)  # jb AAI01/LCOMP  2/13/01
                {
                #$% get sonar pointer
                link = $yes
                son$pointer = xdeq2$pntr$i
                ixequip2 = deq2$Pointer$index
                break
                }
            }
        }
    }                          #end if ship or sub
 
#$% if no link, return
if (LINK == $no)  return
 
##----------------------------------------------------------------
 
link = $no
 
#$% if line of sight                    # put back above - 10/29/85
if (xpai$lineofsight$i == $yes)        # & returned here  1/7/87
{
    #$% get antenna height
    call hgtcom ( irtype, UNT2$pointer, ixequip2, rhgt)
 
    #$% if range exceeds LOS, return
    if (rng > 1.23 * (shgt + rhgt))
        {
        return
        }
 
    unt$pointer = transmitter_pointer
    if (los_test (                          # Uses GP terrain grid to determine LOS (E1422)
                    Xunt$TrueLatitude$f,    # Detector latitude: real: in: rad
                    Xunt$TrueLongitude$f,   # Detector longitude: real: in: rad
                    Xunt$CosTrueLat$f,      # Cosine of detector latitude: real: in:rad
                    shgt,                   # Sqrt Detector altitude: real: in: ft
                    Xunt2$TrueLatitude$f,   # Target latitude: real: in: rad
                    Xunt2$TrueLongitude$f,  # Target longitude: real: in: rad
                    Xunt2$CosTrueLat$f,     # Cosine of target latitude: real: in:rad
                    rhgt) == $NO)           # Sqrt Target altitude: real: in: ft
      {
           return                 # Comms obscured by terrain
      }
}
##-------------------------------------------------------------------
if (trace$comm != $no) call echov (' ok')
 
#$% if receiver is submarine
if (irtype == $SUB$CODE)
    {
    #$% set flag to NO
    link = $no
 
    if (trace$comm != $no) call echov ('..mast/wire/buoy')
 
    #$% get depth
    LDEPTH = XUNT2$TRUEALTDEPTH$I   #get depth
 
    if (XPAI$MASTTORECEIVE$I == $YES &         #if mast needed
        (XUNT2$DEPLOYMAST$I == $no |             #but not in proper posture
         Xunt2$TimeMast$f > game$time |
         LDEPTH > MAST$DEPTH$MAX))  return
 
    if (XPAI$WIRETORECEIVE$I == $YES &         #if wire needed
        (XUNT2$DEPLOYWIRE$I == $no |             #but not in proper posture
         Xunt2$TimeWire$f > game$time |
         LDEPTH > WIRE$DEPTH$MAX))  return
 
    if (XPAI$BUOYTORECEIVE$I == $YES &         #if buoy needed
        (XUNT2$DEPLOYBUOY$I == $no |             #but not in proper posture
         Xunt2$TimeBuoy$f > game$time |
         LDEPTH > BUOY$DEPTH$MAX))  return
 
    if (trace$comm != $no) call echov (' ok')
    }
 
 
link = $no
 
if (iacous == $no)                             #if not acoustic
    {
    if (trace$comm != $no) call echov ('..true brng')
 
    #$% get off course
    pai$offcourse$f = xpai$offcourse$f
 
    if (pai$offcourse$f != 0.0)                #if true bearing test reqd
        {
        #$% get receiver course
        rcors = xunt2$truecourse$f
        $angpi(rcors)
 
        #$% compute receiver off course
        offns = abs(rcors)
        if (offns > $pi/2.) offns = $pi - offns
 
        #$% if receiver off course more than allowed for link connect,return
        if (offns > pai$offcourse$f)  return
        }
 
        if (trace$comm != $no) call echov (' ok')
 
    #$% link OK, return
    link = $yes
    return
    }
else                                           #if acoustic comm
    {
    rbrg = brg + $pi                           #bearing of sender wrt rcvr
 
    if (istype != $commbuoy$code)              #if sender is ship or sub
        {
        srlbrg = brg - scors
        $angpi(srlbrg)                     #rel bearing wrt sender
 
        if (abs(srlbrg) > XPAI$OFFCOURSESEND$F)
            {
            if (trace$comm != $no)
                {
                call echov ('..senders rel brng NOT ok:')
                }
 
            return
            }
 
        if (trace$comm != $no)
            {
            call echov ('..send rel brng ok')
            }
 
        }
 
    LSPEED = XUNT2$TRUESPEED$F                 #get receiver speed
 
    #$% get receiver depth
    ldepth = xunt2$truealtdepth$i
 
    if (trace$comm != $no) call echov ('..spd')
 
    if ((LDEPTH <= LAYER$DEPTH &               #if too fast
         LSPEED > XPAI$RECEIVESPEEDIN$I) |
        (LDEPTH > LAYER$DEPTH &
         LSPEED > XPAI$RECEIVESPEEDBELOW$I))
        return
 
    if (trace$comm != $no) call echov (' ok')
 
    #$% get receiver course
    RCORS = XUNT2$TRUECOURSE$F                 #rcvr course
 
    rrlbrg = rbrg - RCORS                      #rel bearing wrt receiver
    $angpi(rrlbrg)
 
    if (trace$comm != $no) call echov ('..rcvr rel brng')
 
    if (abs(rrlbrg) > XPAI$OFFCOURSERECEIVE$F)
        return
 
    if (trace$comm != $no) call echov (' ok')
 
    #$% check if link within limits to be heard
    call acmlnk(unt2$pointer,son$pointer,link,transmitter_Pointer)
    }
 
end

 Subroutine cmdlvr(com$pointer,com$ho$index)
 
#######################################################
 #$%
 #$% Purpose:   CMDLVR delivers the message to the
 #$%            view, "it made it".
 #$%
 #$% Called By: COMRDY
 #$%
 #$% Calls:     SMOVHN     SMOVH      SMOVI
 #$%            SEND       SMOV
 #$%
 #$% Tables:    COM        UNT        PAT
 #$%            PAI
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #deliver the message to the view
 
 BBcommon
 
 literal msg[65], CSTRIP8                   # jb E2145  7/6/00
Integer ILEN,PAI$Pointer,UNT$Pointer,       # jb E2145  7/6/00
    COM$Pointer,COM$Type$I,COM$Status$I,    # jb E2145  7/6/00
    COM$Holders$I,COM$Receivers$I,          # jb E2145  7/6/00
    COM$HO$Index,COM$HO$indx$I,             # jb E2145  7/6/00
    COM$RE$Index,COM$RE$indx$I,             # jb E2145  7/6/00
    PAT$Pointer,PAT$NOD$Index               # jb E2145  7/6/00
 integer Game_DTG
 
 
 com$type$i = xcom$type$i                       # get com type
 
 
 
 
 
 
 if (com$type$i != $commData$code &             # reh 12/91
     com$type$i != $commtext$code &             # if not(commtext or autoroger)
     com$type$i != $autoroger$code)             # i.e. PLAYER ORDER
    {
     com$status$i = $received$code              # set received status
     putcom$status$i
 
     if (trace$comm != $no)
        {
        call echov (' Delivered !')
        }
 
    return
    }
 
 #$% get pointer to holding unit
 unt$pointer$to xcom$ho$indx$i
 
 #$% zero line length
 ilen = 0
 #$% move message
 call smovhn (xunt$name$c,$$MaxLit,msg,ilen)
 call smovv (": Commtext received at minute ",msg,ilen)
 
 #$% for each receiver entry
 for (com$re$index=1;com$re$index$ok;com$re$index=com$re$index+1)
    {
     #$% if receiver is holding, break loop
     if (xcom$re$indx$i == xcom$ho$indx$i)  break      #find which receiver
    }
 
 call smoviz(Game_DTG(xcom$Re$ArrivalTime$f),6,msg,ilen)  #arrival dTG of msg
                                        ## tpa 4/11/83
 
 com$ho$indx$i = 0                              #clear holder
 putcom$ho$indx$i
 
 com$re$indx$i = 0                              #clear receiver
 putcom$re$indx$i
 
 com$holders$i = xcom$holders$i - 1             #decrement holders
 putcom$holders$i
 
 com$receivers$i = xcom$receivers$i - 1         #decrement receivers
 putcom$receivers$i
 
 #$% if no more receivers of this message available
 if (com$receivers$i <= 0)
    {
     #$% set received status
     com$status$i = $received$code
     putcom$status$i
    }
 
 #$% get path pointer
 pat$pointer = xcom$PathPntr$i
 
 #$% back up to find path used to send message to this holder
 pat$nod$index = xcom$ho$node$i - 2
 
 call smovv(" via ",msg,ilen)
 
 #$% if it first node in path, get pair index out of PAT table
 if (pat$nod$index < 1) pai$pointer$to Xpat$pairindx$i
 #$% get subsequent node information from sub table "PAT$NOD"
 else                   pai$pointer$to Xpat$nod$pairindx$i
 
 #$% enter type of comm pair used for message delivery
 call smovhn (xpai$Type$c,$$MaxLit,msg,ilen)
 
 call smovv(":",msg,ilen)
 
 #$% add nulls to string to fill last word
 while (mod(ilen,5) != 0) call smov ($null,msg,ilen)
 
 call send_(xunt$view$i,0,ilen,msg)              #send preamble to addressee
 
## call send_(xunt$view$i,'COMM',xcom$diskaddr$i,0)  #send msg text to addressee
 call send_V(xunt$view$i,'COMM')    # jb E2144  8/3/00
 
 end

 Subroutine COMACK(com$pointer)           #generates acknowledgement
 
#######################################################
 #$%
 #$% Purpose:   COMACK generates acknowledgement
 #$%            of message transmission.
 #$%
 #$% Called By: COMPRO
 #$%
 #$% Calls:     SMOVHN     SMOVH      SMOVI
 #$%            SEND
 #$%
 #$% Tables:    COM        UNT
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 
 literal MSG[45],   CSTRIP8         # jb E2145  7/6/00
 Integer ILEN, UNT$Pointer,         # jb E2145  7/6/00
    COM$Pointer,COM$Acknowledge$I   # jb E2145  7/6/00
 
 #$% if type is not commtext/comm data, CommData logic added 12/91
 if (xcom$type$i != $commtext$code &
     xcom$type$i != $commData$code ) return
 
 #$% set unit pointer to sender
 UNT$POINTER$TO xcom$senderIndx$i
 
 #$% clear line length
 ilen = 0
 #$% move message
 call smovhn(xunt$name$c,$$MaxLit,msg,ilen)
 call smovv(": Message #",msg,ilen)
 call smovi(xcom$messageid$i,msg,ilen)
 call smovv(" transmission begun.",msg,ilen)
 
 #$% while line length is less than 44, move spaces
 while (ilen < 44) call smov($space,msg,ilen)
 
 #$% call send_ unit view
 call send_(XUNT$VIEW$I,0,45,MSG)
 
 #$% set acknowledge to NO
 COM$ACKNOWLEDGE$I = $no
 PUTCOM$ACKNOWLEDGE$I
 
 end            # End COMACK subroutine

Subroutine COMAGN(com$pointer,icode)
 
########################################################
#$%
#$% Purpose:   COMAGN sets up message to try delivery
#$%            via an alternate path.
#$%
#$% Called By: COMPRO
#$%
#$% Calls:     None
#$%
#$% Tables:    COM
#$%
#$% Date:      FEB 81
#$%
#$% Author:    Ron Williams
#$%
########################################################
# set up msg to try delivery via an alternate path
 
BBcommon
 
Integer ICODE, COM$Pointer,            # jb E2145  7/6/00
    COM$Status$I,COM$Pathpntr$I,       # jb E2145  7/6/00
    COM$Twoway$I,COM$Tryaltpath$I,     # jb E2145  7/6/00
    COM$Anyready$I,COM$Anysending$I    # jb E2145  7/6/00
 
#$% if not trying alternate path
if (xcom$TryAltPath$i == $no)
   {
    #$% set status to code
    com$status$i = icode
    putcom$status$i
   }
else
   {
    #$% set path pointer to alternate path pointer
    com$PathPntr$i = xcom$AltPathPntr$i
    PUTcom$PathPntr$i
 
    #$% set two way to alternate path two way
    com$TwoWay$i = xcom$AltPathTwoWay$i
    PUTcom$TwoWay$i
 
    #$% set try alternate path to no
    com$TryAltPath$i = $no
    PUTcom$TryAltPath$i
 
    #$% set any ready to NO
    com$AnyReady$i = $no
    PUTcom$AnyReady$i
 
    #$% set any sending to NO
    com$AnySending$i = $no
    PUTcom$AnySending$i
 
    #$% decrement COM counter
    com$pointer = com$pointer - com$entry
    }
 
end

 Subroutine COMCLR(com$pointer)
 
######################################################
 #$%
 #$% Purpose:   COMCLR eliminates deleted platforms,
 #$%            expired buoys and expired messages
 #$%            from communication message link.
 #$%
 #$%
 #$% Called By: COMMOD
 #$%
 #$% Calls:     COMMNH
 #$%
 #$% Tables:    COM        UNT        BOY
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #### Eliminates deleted platforms, expired buoys and expired messages
 #### from comm message link.
 
 BBcommon
 Integer    ICODE, BOY$Pointer,                 # jb E2145  7/6/00
    COM$Pointer,COM$Holders$I,COM$Receivers$I,  # jb E2145  7/6/00
    COM$Node$I,COM$Status$I,COM$HO$Index,       # jb E2145  7/6/00
    COM$HO$indx$I,COM$RE$Index,COM$RE$indx$I    # jb E2145  7/6/00
 Integer UNT$Pointer,UNT$Status$I,              # jb E2145  7/6/00
    PAT$Pointer,PAT$Pairindx$I,                 # jb E2145  7/6/00
    PAI$Pointer,SUI$Pointer,SUI2$Pointer        # jb E2145  7/6/00
 
 com$node$i = xcom$node$i
 
 #$% if flight
 if (xcom$flightIndx$i != 0)
    {
     #$% set unit pointer to flight
     unt$pointer$to xcom$flightIndx$i
 
     #$% if being deleted
     if (xunt$status$i == $beingdeleted$code)
        {
         #$% save comm information for Post-game analysis
         call commnh(XCOM$MESSAGEID$I,    #comm node history for
                     COM$NODE$I,          #post game analysis
                     5,                   #code indicating relay flt no good
                     COM$POINTER)
 
         #$% set COM status to being deleted
         com$status$i = $beingdeleted$code
         putcom$status$i
 
         return
        }
    }
 
 do COM$HO$INDEX=1,COM$HO$SLOTS             #for all holders
    {
     com$ho$indx$i = xcom$ho$indx$i
     #$% if comm holder is zero, get next
     if (com$ho$indx$i == 0)  next            #skip if blank
 
     #$% zero code
     icode = 0
 
     if (xcom$ho$ready$i == $yes &           #if ready for transmission
         xcom$Ho$KillTime$f <= game$time)    # & message life exceeded
        {
        icode = 3
        } # end if time to kill message
 
     if (xcom$ho$buoy$i == $no)                    #if unit
        {
         #$% set UNT pointer
         unt$pointer$to com$ho$indx$i
 
         #$% get unit status
         UNT$STATUS$I = XUNT$STATUS$I
 
         #$% if being deleted or sinking
         if (UNT$STATUS$I == $BEINGDELETED$CODE)  #if dying
#            UNT$STATUS$I == $sinking$CODE)
             icode = 8
        }
     else                                   #if buoy
        {
         #$% set BOY pointer
         boy$pointer$to com$ho$indx$i
 
         if (xboy$KillTime$f <= game$time) #if expired
             icode = 4
        }
 
     if (icode == 0) next                   #ok if not to be removed
 
     # message is to be deleted (killed)
 
     com$ho$indx$i = 0                      #zero holder
     putcom$ho$indx$i
 
     if (xcom$ho$node$i != com$node$i) next #ok if not leading node
 
     COM$HOLDERS$I = XCOM$HOLDERS$I-1       #reduce leading holders
     PUTCOM$HOLDERS$I
 
     if (com$holders$i > 0)  next           #ok if still some left
 
     call commnh(XCOM$MESSAGEID$I,          #record fact all leading
                 COM$NODE$I,                #  holders gone
                 icode,                     #send appropriate code
                 COM$POINTER)
 
     com$status$i = $beingdeleted$code      #remove message in order not to
     putcom$status$i                        # generate confusing node history
 
 
     break
    }
 
 #$% do loop for receivers
 do COM$RE$INDEX=1,COM$RE$SLOTS             #do rcvrs
    {
     #$% set unit pointers
     com$re$indx$i = xcom$re$indx$i
 
     #$% if no receivers for this comm message, get next
     if (com$re$indx$i == 0)  next
 
     #$% get unit status
     unt$pointer$to com$re$indx$i
     UNT$STATUS$I = XUNT$STATUS$I
 
     #$% if unit being removed from the game
     if (UNT$STATUS$I == $BEINGDELETED$CODE) # | UNT$STATUS$I == $sinking$CODE)
        {
         #$% remove corresponding receiver from the list too
         com$re$indx$i = 0
         putcom$re$indx$i (0)
 
         #$% reduce the number of receivers for this message by 1
         com$receivers$i = max(0,xcom$receivers$i - 1)
         putcom$receivers$i
        }
    }
 
 #$% if no one available to receive this message
 if (xcom$receivers$i < 1)                 #if no rcvrs
    {
     call COMMNH(XCOM$MESSAGEID$I,
                 COM$NODE$I,
                 9,
                 COM$POINTER)
 
     #$% designate it to be removed from the COM table
     com$status$i = $beingdeleted$code
     putcom$status$i
    }
 
 end            # End COMCLR subroutine

###    Name: COMCON
###
###    Usage:
###
###        CALL comcon ( com$pointer,
###                      com$ho$index,
###                      pai$pointer )
###
###    Purpose:
###
###        Test sender and receiver communications connectivity and build
###        an array of eligible receivers.
###
###    Arguments:
###
###        Input:
###
###            COM$Pointer -   INTEGER*4 variable containing the blackboard
###                            pointer which, in turn, points to the current
###                            COM table communication messsage.
###
###            COM$HO$Index -  INTEGER*4 value of the transmitter node index
###                            within the current COM table communication
###                            message.
###
###            PAI$Pointer -   INTEGER*4 variable containing the blackboard
###                            pointer which, in turn, points to the PAI
###                            table communication pair.
###
###        Input/Output: None.
###
###        Output: None.
###
###        Function Result: None.
###
###        COMMON:
###
###            Name            Source                   Use
###
###            BBoard          BBCommon                 Input/Output
###            SCRATCH$PAD     CMcommon                 Input/Output
###
###    Limitations: None.
###
###    Warnings: None.
###
###    Notes: None.
###
###    Author:
###
###        Ron Williams
###        System Development Corporation
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required:
###
###        BOYRCV
###        HGTCOM
###        PREPRX
###        UNTRCV
###
###    Tables Required:
###
###        BOY
###        CODE
###        COM
###        PAI
###        PAT
###        UNT
###
###    Algorithm: N/A.
###
###    Date Developed: February 1981
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###        G. G. Gustafson     3/21/88     Added TRANSMITTER_POINTER to the
###                                        invocations of BOYRCV and UNTRCV.
###
###    Waivers: None.

SUBROUTINE comcon ( COM$Pointer,
                    COM$HO$Index,
                    PAI$Pointer )
 
BBcommon
CMcommon
 
INTEGER*4    maximum_range                                                 # GGG
INTEGER*4    transmitter_index                                             # GGG
INTEGER*4    transmitter_pointer                                           # GGG
Integer I, BOY$Pointer, PAI$Pointer, # jb E2145  7/6/00
    COM$Pointer,COM$Flightindx$I,    # jb E2145  7/6/00
    COM$Buoyindx$I,COM$HO$Index,     # jb E2145  7/6/00
    PAT$Pointer, PAT$NOD$Index,      # jb E2145  7/6/00
    UNT$Pointer                      # jb E2145  7/6/00
 
PAT$Pointer = xCOM$PathPntr$I
transmitter_index = xCOM$HO$Indx$I                                         # GGG
 
IF ( istype == $commbuoy$code )
    {
    BOY$Pointer$To transmitter_index                                       # GGG
    transmitter_pointer = BOY$Pointer                                      # GGG
    }
ELSE
    {
    UNT$Pointer$To transmitter_index                                       # GGG
    transmitter_pointer = UNT$Pointer                                      # GGG
    }
nrcvrs = 0
nlinks = 0
DO i = 1, 5
    {
    ircvr [ i ] = 0
    }
maximum_range = xPAI$MaxCommRange$I
 
#$% if holder is not a buoy and LOS
IF ( xPAI$LineOfSight$I == $yes &
     istype != $commbuoy$code )             # 1/4/91 reh
    {
    CALL hgtcom ( istype, UNT$Pointer, ixequip, shgt ) # jb UNT vs POS 3/23/89
    }
ELSE IF ( maximum_range == 0 )              # else if acoustic comm
    {
    maximum_range = acoustic$range
    IF ( istype == $commbuoy$code )
        {
        isdpth = xBOY$TrueDepth$I
        }
    ELSE
        {
        scors = xUNT$TrueCourse$F                        # jb UNT vs POS 3/23/89
        isdpth = xUNT$TrueAltDepth$I                    # jb UNT vs POS 3/23/89
        }
    IF ( isdpth > layer$depth )
        {
        isdeep = $yes
        }
    ELSE
        {
        isdeep = $no
        }
    }
IF ( istype == $commbuoy$code )
    {
    CALL preprx_M ( 0,                                # jb    _M    8/29/89
                  xBOY$TrueLatitude$F,
                  xBOY$TrueLongitude$F,
                  xBOY$CosTrueLat$F,
                  FLOAT ( maximum_range ) )                                # GGG
    }
ELSE
    {
    CALL preprx_M (unt$Pointer$Index,                  # jb  _M        8/29/89
                  xUNT$TrueLatitude$F,                 # jb UNT vs POS 3/23/89
                  xUNT$TrueLongitude$F,                # jb UNT vs POS 3/23/89
                  xUNT$CosTrueLat$F,                   # jb UNT vs POS 3/23/89
                  FLOAT ( maximum_range ) )                                # GGG
    }
 
PAT$NOD$Index = xCOM$HO$Node$I              # receiver node index
ndcatr = xPAT$NOD$NodeCategory$I            # receiver node type
IF ( ndcatr == $commbuoy$code )
    {
    CALL boyrcv ( transmitter_pointer,                                     # GGG
                  COM$Pointer,
                  PAT$Pointer,
                  PAI$Pointer,
                  PAT$NOD$Index )
    }
ELSE
    {
    CALL untrcv ( transmitter_pointer,                                     # GGG
                  COM$Pointer,
                  COM$HO$Index,
                  PAI$Pointer )
    }
IF ( ( xCOM$FlightIndx$I != 0 ) &           # if flight and aircraft
     ( ndcatr == $air$code ) &              # with receivers
     ( nrcvrs > 0 ) )
    {
    COM$FlightIndx$I = 0                    # set com flight to zero
    putCOM$FlightIndx$i
    }
ELSE IF ( ( xCOM$BuoyIndx$I != 0 ) &        # else if buoy and commbuoy
          ( ndcatr == $commbuoy$code ) &    # with receivers
          ( nrcvrs > 0 ) )
    {
     COM$BuoyIndx$I = 0                     # set com buoy to zero
     putCOM$BuoyIndx$I
    }
END

###    Name: COMMOD
###
###    Usage:
###
###        CALL commod
###
###    Purpose:
###
###        Implements the Communications Model within RESA.
###
###    Arguments:
###
###        Input: None.
###
###        Input/Output: None.
###
###        Output: None.
###
###        Function Result: None.
###
###        COMMON:
###
###            Name            Source                   Use
###
###            BBoard          BBCommon                 Input/Output
###
###    Limitations: None.
###
###    Warnings: None.
###
###    Notes: None.
###
###    Author:
###
###        Ron Williams
###        System Development Corporation
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required:
###
###        CEQOFF
###        COMCLR
###        COMPRO
###        INITIALIZE_COMMS_JAMMERS
###
###    Tables Required:
###
###        CODE
###        COM
###        CTL
###
###    Algorithm: N/A.
###
###    Date Developed: February 1981
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###        G. G. Gustafson     3/21/88     Added INITIALIZE_COMMS_JAMMERS
###                                        invocation.
###
###    Waivers: None.

SUBROUTINE commod
BBcommon
 
Integer     COM$Pointer,COM$Type$I   # jb E2145  7/6/00
 
CALL initialize_comms_jammers                                              # GGG
CALL ceqoff                                    #turn off everyone's comm eq
 
# For all entries in the COM message table clean up as needed then for all
# entries except auto-roger, process the messages
 
FOR ( COM$Pointer$First; still_ok(COM); COM$Pointer$Next ) # 9/26/88
    {
    COM$Type$I = xCOM$Type$I
    IF ( COM$Type$I != $null$code )
        {
        CALL comclr ( COM$Pointer )
        IF ( ( COM$Type$i == $commtext$code |
               COM$Type$i == $CommData$code |           # CommData added 12/91,reh
               COM$Type$i == $autoroger$code ) &
             ( xCOM$Status$i != $OkToProcess$code ) )
            {
            COM$Zero                               #clear entry
            }
        ELSE IF ( COM$Type$i != $autoroger$code )
            {
            CALL compro ( COM$Pointer )                   #process message
            }
        ELSE
            {
            CONTINUE
            }
        }
    }
 
# Now go through communications table again to process the auto-roger
 
FOR ( COM$Pointer$First; still_ok(COM); COM$Pointer$Next ) # 9/26/88
    {
    IF ( xCOM$Type$i == $autoroger$code )
        {
        CALL compro ( COM$Pointer )
        }
    }
 
CALL ceqoff_pass2                   # selectivly turn on comm eq (10/89 dew)
CALL add_jammer_hfdf_entries                                               # GGG
END

 Subroutine compro(com$pointer)     #Main procedure for comm
                                    #process the comm msg passed to it
#######################################################
 #$%
 #$% Purpose:   COMPRO processes the communication
 #$%            message passed to it. This is the main
 #$%            procedure for COMM.
 #$%
 #$% Called By: COMMOD
 #$%
 #$% Calls:     COMRDY     SENDOK     INTRA_NODE_ADVANC
 #$%            COMACK     WHONXT     COMCON
 #$%            COMAGN     NUHOLD
 #$%
 #$% Tables:    COM        PAT        PAI
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 CMcommon
 
LITERAL    CSTRIP8                          # jb E2145  7/6/00
REAL       COM$Sendtime$F                   # jb E2145  7/6/00
Integer INDXHI,NODEHI,IREDHI,ITEST,IUPOVR,  # jb E2145  7/6/00
    COM$Pointer,COM$Type$I,COM$Overs$I,     # jb E2145  7/6/00
    COM$Trys$I,COM$HO$Index,COM$HO$node$I,  # jb E2145  7/6/00
    COM$HO$ready$I,COM$Anysending$I,        # jb E2145  7/6/00
    COM$Sendersatisfied$I                   # jb E2145  7/6/00
Integer PAT$Pointer,PAT$NOD$Index,          # jb E2145  7/6/00
    PAT$Pairindx$I,PAT$NOD$pairindx$I,      # jb E2145  7/6/00
    PAI$Pointer, UNT$Pointer                # jb E2145  7/6/00
LOGICAL*1    intra_node_advance
EXTERNAL     intra_node_advance
 
if (trace$comm != $no)
    {
    call echor
    call echov ('COM #')
    call echoi(com$pointer$index)
    }
 
 #$% for every holder of this message
 do com$ho$index = 1, com$ho$slots
    {
     #$% if comm holder valid, set to YES to process this below
     if (xcom$ho$indx$i != 0) idonow[com$ho$index] = $yes
     #$% else set to NO to skip below
     else                        idonow[com$ho$index] = $no
    }
 
 iupovr = xcom$anysending$i
 
 #$% get path pointer
 pat$pointer = xcom$PathPntr$i
 
 repeat
    {
     #$% zero node high
     nodehi = 0
     iredhi = -1
 
     #$% for every holder of ths message
     do com$ho$index = 1, com$ho$slots      #find furthest progress of msg
        {                                   # among all holders not yet
         if (idonow[com$ho$index] == $no)   #  tried this minute
             next
 
         #$% get comm holder node
         com$ho$node$i = xcom$ho$node$i
 
         #$% get comm holder ready
         com$ho$ready$i = xcom$ho$ready$i
 
         #$% if the message has processed past this holder or if this
         #$% holder has the message and the next holder is ready
         if (com$ho$node$i > nodehi |
             (com$ho$node$i == nodehi &
              com$ho$ready$i > iredhi))
            {
             #$% reset the indexes to this holder
             indxhi = com$ho$index
             nodehi = com$ho$node$i
             iredhi = com$ho$ready$i
            }
        }
 
     if (nodehi == 0)  break                #exit repeat loop if no more
                                            # holders to process this min
     #$% restore information to the last holder of the message
     com$ho$index = indxhi
     com$ho$node$i = nodehi
     com$ho$ready$i = iredhi
 
       if (trace$comm != $no)
          {
           call echov ('..Path ')
           call echohn(xpat$Type$c,$$MaxLit)
           call echov ('..Ckt ')
           call echoi(xpat$Circuit$i)
           call echor
           call echov ('Holder ')
           call echoi(com$ho$index)
           call echov ('..Node ')
           call echoi(xcom$ho$node$i)
           call echov ('..Ready = ')
           call echoi(xcom$ho$ready$i)
           call echor
           if (xcom$ho$buoy$i == $no)
              {
               unt$pointer$to xcom$ho$indx$i
               call echohn(xunt$name$c,$$MaxLit)
              }
           else  call echoi(xcom$ho$indx$i)
          }
 
     #$% set path node index
     pat$nod$index = com$ho$node$i - 1
 
     #$% if it is the first node in the comm path
     if (pat$nod$index < 1)
        {
         #$% get path pair index out of the the PAT table
         pat$pairindx$i = xpat$pairindx$i       #get pair pointer
         if (pat$pairindx$i == 0) pai$pointer = 0
         else                     pai$pointer$to pat$pairindx$i
        }
     else
        {
         #$% get path pair index out of the sub-table "PAT-NOD"
         pat$nod$pairindx$i = xpat$nod$pairindx$i       #get pair pointer
         if (pat$nod$pairindx$i == 0) pai$pointer = 0
         else                         pai$pointer$to pat$nod$pairindx$i
        }
 
     if (xcom$type$i == $autoroger$code & com$ho$node$i == 2)
         pai$pointer = 0                #2nd node is last for roger msg
 
     #$% set do now to NO
     idonow[com$ho$index] = $no
 
     #$% if comm holder ready is No
     if (xcom$ho$ready$i == $no)        #if still awaiting intranode delay
        {
         #$% see if message can advance to next holder ths minute
 
         IF ( intra_node_advance ( PAT$Pointer, PAT$Nod$Index ) )
            {
             #$% call first holder ready at leading node
             call comrdy(com$pointer,com$ho$index,pai$pointer)
 
             #$% if message received
             if (xcom$status$i == $received$code) #if msg delivered to all addressees
                {
                COM$Type$i = xCOM$Type$i
 
                #$% if comm text or autoroger
                if (com$type$i == $commtext$code |
                    COM$Type$i == $commData$code |      # added 12/91, reh
                    com$type$i == $autoroger$code)
                    {
 
                     com$zero       #$% clear this comm entry
                    } # end if delivered
 
                 break
                }
            }
        }
     else                            #if ready to send
        {
         #$% call validate sender equipment and sender posture
         call sendok(com$pointer,com$ho$index,pai$pointer,itest)
 
         #$% if sending posture and equipment is OK
         if (itest == $yes)          #if can send
            {
             #$% if trace comm is on
             if (trace$comm != $no)
                {
                 call echov (' *** Sending ***')
                }
 
             #$% if acknowledgement required
             if (xcom$Acknowledge$i != $no)
                 #$% call generates acknowledgement of message transmission
                 call comack(com$pointer)
 
             if (xcom$ho$node$i == xcom$node$i &    #if this is first
                 xcom$anysending$i == $no)          # holder able to send
                {                                   #  at leading node
                 #$% set send time
                 com$SendTime$f = game$time
                 putcom$SendTime$f
 
                 #$% set any sending to YES
                 com$anysending$i = $yes
                 putcom$anysending$i
 
                 iupovr = $yes
                }
 
             call whonxt(com$pointer,com$ho$index)
 
             #$% call tests sender/receiver communications connectivity
             call comcon(com$pointer,com$ho$index,pai$pointer) #test
                                                               #  connectivity
             if (trace$comm != $no)
                {
                 call echor
                 call echoi(nlinks)
                 call echov (' links, ')
                 call echoi(nrcvrs)
                 call echov (' rcvrs')
                }
 
             if (nlinks > 0)               #if anyone can get message
                {
                 if (xcom$ho$node$i == xcom$node$i)
                     iupovr = $no
 
                 if (nrcvrs > 0)           #if anyone does get message
                     call nuhold(com$pointer,xcom$ho$node$i)
 
                }                          #end if anyone can receive
 
            }                              #end if holder can send
        }                                  #end if holder ready to send
    }                                      #end repeat
 
 #$% if up over is YES
 if (iupovr == $yes)
    {
     #$% increment counter
     com$overs$i = xcom$overs$i + 1
     putcom$overs$i
    }
 
 #$% else if any ready and no one sending
 else if (xcom$anyready$i == $yes & xcom$anysending$i == $no)
    {
     #$% increment trys counter
     com$trys$i = xcom$trys$i + 1
     putcom$trys$i
    }
 
 #$% get comm type
 com$type$i = xcom$type$i
 
 #$% if player order or report
 if (com$type$i == $playerorder$code |
     com$type$i == $report$code      )
    {
     #$% set path node to one
     pat$nod$index = 1
 
     if (xcom$node$i >= 2 |
        (xpat$nod$rogerflag$i == $no & xcom$anysending$i != $no))
        {
         #$% set sender satisified to YES
         com$SenderSatisfied$i = $yes
         PUTcom$SenderSatisfied$i
        }
 
     #$% if someone trying
     if (xcom$trys$i > 0)
        {
         #$% call try alternate path
         call COMAGN(com$pointer,$CantSend$code)
        }
     #$% else if message over
     else if (xcom$overs$i > 0 & xpat$numberofnodes$i <= 2)
        {
         #$% if roger flag valid
         if (xpat$nod$rogerflag$i != $no)
            {
             #$% call to try alternate path
             call COMAGN(com$pointer,$DidntRoger$code)
            }
        }
    }
 
 end

 Subroutine comrdy(com$pointer,com$ho$index,pai$pointer)
 
#######################################################
 #$%
 #$% Purpose:   COMRDY determines if appropriate
 #$%            delay has been executed and message is
 #$%            ready to move on.
 #$%
 #$% Called By: COMPRO
 #$%
 #$% Calls:     COMMNH     CMDLVR
 #$%
 #$% Tables:    COM        PAI
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
 #determine if appropriate delay has passed and message is ready to move on
 
 BBcommon
 CMcommon
 
Integer COM$HO$killtime$F,           # jb E2145  7/6/00
    COM$Readytime$F,COM$Sendtime$F   # jb E2145  7/6/00
Integer COM$Pointer,COM$Anyready$I,  # jb E2145  7/6/00
    COM$Anysending$I, COM$HO$Index,  # jb E2145  7/6/00
    COM$HO$ready$I,  PAI$Pointer     # jb E2145  7/6/00
 
       if (trace$comm != $no)
          {
           call echov (' *** Ready ***')
          }
 
 if (xcom$ho$node$i == xcom$node$i &   #if this is first
     xcom$anyready$i == $no)           # holder ready at
    {                                  #  leading node
     #$% set ready time
     com$ReadyTime$f = game$time
     putcom$ReadyTime$f
 
     #$% set any ready time to YES
     com$anyready$i = $yes
     putcom$anyready$i
 
     if (pai$pointer == 0)          # if last node
        {
         #$% set send time
         com$SendTime$f = game$time
         putcom$SendTime$f
 
         #$% set any sending to yes
         com$anysending$i = $yes
         putcom$anysending$i
 
         call commnh(xcom$messageid$i,
                     xcom$node$i,
                     2,               #delivery to player
                     com$pointer)
        }
    }
 
 if (pai$pointer == 0)                # if last node
    {
     call cmdlvr(com$pointer,com$ho$index)
     return
    }
 
 #$% compute holding kill time
 com$Ho$KillTime$f = game$time + xpai$lifeofmessage$i
 putcom$Ho$KillTime$f
 
 #$% set holding ready to YES
 com$ho$ready$i = $yes
 putcom$ho$ready$i
 
 idonow[com$ho$index] = $yes           #ok to process further
 
 end

 Subroutine depboy(unt$pointer,         #deploys detachable buoy  #in
 
##                   shd$pointer,         #in
                   deq$Pointer,         #in
                   boy$pointer)         #out
 
#######################################################
 #$%
 #$% Purpose:   DEPBOY deploys detachable buoys.
 #$%
 #$% Called By: SENDOK
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT        SHD     BOY
 #$%            COB        SON
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 
 literal iname1,iname2
 LITERAL BOY$Commname$C,  CSTRIP8        # jb E2145  7/6/00
 REAL BOY$Birthtime$F,BOY$Killtime$F,    # jb E2145  7/6/00
    BOY$Truelatitude$F,BOY$Costruelat$F, # jb E2145  7/6/00
    BOY$Truelongitude$F                  # jb E2145  7/6/00
 Integer BOY$Pointer,BOY$Type$I,         # jb E2145  7/6/00
    BOY$Truedepth$I,BOY$Nbrbuoys$I,      # jb E2145  7/6/00
    BOY$Acoustic$I,BOY$Eqpntr$I,BOY$Ownerindx$I, # jb E2145  7/6/00
    DEQ$Pointer,DEQ$Remaining$I,         # jb E2145  7/6/00
    COB$Pointer,SON$Pointer,UNT$Pointer  # jb E2145  7/6/00
 Integer LCOMP              # jb AAI01/LCOMP  E2145  2/13/01
 for (boy$pointer$first;still_valid(boy);boy$pointer$next) # 9/26/88
    {
     if (xboy$type$i == $null$code)  break      #find slot in buoy table
    }
 
 #$% if BOY pointer not valid
 if (!boy$pointer$valid)
    {
     #$% zero BOY pointer, return
     boy$pointer = 0                    ####perhaps should send an error
     return                             ####message in this case
    }
 
 #$% decrement equipment remaining
 deq$remaining$i = xdeq$remaining$i - 1
 putdeq$remaining$i
 
 #$% get COB pointer (commbuoy)
 cob$pointer = xdeq$pntr$i
 
 iname1 = xcob$comsuite1$c
 iname2 = xcob$comsuite2$c
 
 #$% for each sonar entry
 for (son$pointer$first;still_ok(son);son$pointer$next) # 9/26/88
    {
     if (LCOMP(xson$type$c,iname1) == 0 |  #see if buoy has acoustic char
       LCOMP(xson$type$c,iname2) == 0) BREAK # jb AAI01/LCOMP 2/13/01
    }
 
 #$% if sonar pointer OK
 if (son$pointer$ok)
    {
     #$% set acoustic to YES
     boy$Acoustic$i = $yes                              #smn008
 
     #$% set BOY equipment pointer
     boy$eqpntr$i = son$pointer
     putboy$eqpntr$i
    }
 else
    {
     #$% set acoustic to NO
     boy$Acoustic$i = $no                               #smn008
    }
 #$% save acoustic
 putboy$Acoustic$i
 
 #$% get comm name
 boy$commname$c = xdeq$type$c
 putboy$commname$c
 
       if (trace$comm != $no)
          {
           call echov ('..deploy ')
           call echohn(boy$commname$c,$$MaxLit)
           call echov (' [')
           call echoi(boy$pointer$index)
           call echov (']')
          }
 
 #$% set owner
 boy$ownerindx$i = unt$pointer$index
 putboy$ownerindx$i
 
 #$% set type
 boy$type$i = $commbuoy$code
 putboy$type$i
 
 #$% set number of buoys
 boy$nbrbuoys$i = 1
 putboy$nbrbuoys$i
 
 #$% set birth time
 boy$BirthTime$f = game$time
 putboy$BirthTime$f
 
 #$% set kill time
 boy$KillTime$f = game$time + xcob$life$i
 putboy$KillTime$f
 
 #$ set buoy latitude
 boy$truelatitude$f = xUNT$truelatitude$f        # jb UNT vs POS 3/23/89
 putboy$truelatitude$f
 
 #$% set buoy longitude
 boy$truelongitude$f = xUNT$truelongitude$f      # jb UNT vs POS 3/23/89
 putboy$truelongitude$f
 
 #$% set cosine true latitude
 boy$costruelat$f = xUNT$costruelat$f            # jb UNT vs POS 3/23/89
 putboy$costruelat$f
 
 #$% set buoy depth
 boy$truedepth$i = 0
 putboy$truedepth$i
 
 #$% if BOY pointer OK
 if (!boy$pointer$ok)
     #$% set last buoy to BOY pointer and decrement
     boy$last$to boy$pointer + boy$entry - 1
 
 end

###    Name: HGTCOM
###
###    Usage:
###
###        CALL hgtcom ( unit_type, UNT$Pointer, DEQ$Pointer,
###                      square_root_height )
###
###    Purpose:
###
###        Depending upon the type of unit, returns the square root of the
###        communication antenna height.
###
###    Arguments:
###
###        Input:
###
###            unit_type -     INTEGER*4 variable containing the type of unit
###                            for which the square root of antenna height is
###                            desired.
###
###            UNT$Pointer -   INTEGER*4 variable containing the pointer into
###                            UNT table if UNIT_TYPE is not $COMMBUOY$CODE.
###
###            DEQ$Pointer -  INTEGER*4 variable containing the pointer into
###                            DEQ btable if UNIT_TYPE is neither
###                            $COMMBUOY$CODE nor $AIR$CODE.
###
###        Input/Output: None.
###
###        Output:
###
###            SQUARE_ROOT_HEIGHT - REAL*4 variable which will contain the
###                            square root of the communication antenna
###                            height.
###
###        Function Result: None.
###
###        COMMON:
###
###            Name            Source                   Use
###
###            BBoard          BBCommon                 Input
###
###    Limitations:
###
###        HGTCOM does not correctly process antenna heights for partially
###        submerged submarines.  Partially submerged submarines are considered
###        as surface ships.  The correction requires that the current depth
###        be subtracted from the specified antenna height.
###
###    Warnings: None.
###
###    Notes:
###
###        1.  If the UNIT_TYPE is $COMMBUOY$CODE, a constant value is
###            returned for SQUARE_ROOT_HEIGHT and both UNT$POINTER and
###            DEQ$Pointer are ignored.
###
###        2.  If the UNIT_TYPE is $AIR$CODE, the value returned in
###            SQUARE_ROOT_HEIGHT is extracted from the UNT table.
###
###        3.  If the UNIT_TYPE is neither $COMMBUOY$CODE nor $AIR$CODE,
###            the value returned in SQUARE_ROOT_HEIGHT is extracted from
###            the DEQ table (through UNT$POINTER and DEQ$pointer ).
###
###    Author:
###
###        Ron Willaims
###        Systems Development Corporation
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required: None.
###
###    Tables Required:
###
###        CODE
###        DEQ
###        UNT
###
###    Algorithm:
###
###        CASE unit_type OF
###            communications buoy :
###                return 4.5 feet
###            aircraft :
###                return SQRT ( aircraft height )
###            OTHERWISE
###                return SQRT ( equipment antenna height )
###        END CASE
###
###    Date Developed: February 1981
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###        G. G. Gustafson     3/7/88      Added DYN$EQ$Index as an argument.
###                                        This eliminated the requirement for
###                                        the HGTCOM2 subprogram.
###
###        R. Hundt            3/89        Modifications relating to new
###                                        blackboard were made.
###    Waivers: None.

SUBROUTINE hgtcom ( unit_type,
                    UNT$Pointer,                # jb UNT vs POS 3/23/89
                    DEQIndex,                ## reh 3/89, was DYN$EQ$Index,
                    square_root_height )
 
BBcommon
 
REAL*4       square_root_height
INTEGER*4    DEQIndex                        ## reh 3/89 DYN$EQ$Index
INTEGER*4    UNT$Pointer                        # jb UNT vs POS 3/23/89
INTEGER*4    unit_type
Integer I_SWITCH_1, DEQ$Pointer  # jb E2145  7/6/00
 
SWITCH ( unit_type )
    {
    CASE $commbuoy$code:
        {
        square_root_height =  4.5
        }
    CASE $air$code:
        {
        square_root_height = SQRT ( FLOAT ( xUNT$TrueAltDepth$I ) )
        }
    DEFAULT:
        {
        DEQ$Pointer$To DEQIndex            ## reh 3/89
        square_root_height = SQRT ( FLOAT ( xDEQ$AntHeight$I ) )
        }
    }
END

###    Name: INTRA_NODE_ADVANCE
###
###
###        LOGICAL*1    intra_node_advance
###        EXTERNAL     intra_node_advance
###        :
###        :
###        PAT$Pointer$To ???
###        PAT$Nod$Index = ???
###        IF ( intra_node_advance ( PAT$Pointer, PAT$Nod$Index ) )
###            {
###            do something with advanced message
###            }
###        ELSE
###            {
###            do something with delayed message
###            }
###
###    Purpose:
###
###        Determines if a message can advance within a node (i.e., from the
###        reciever to the transmitter) during the current game minute.
###
###    Arguments:
###
###        Input:
###
###            PAT$Pointer -   INTEGER*4 variable containing the blackboard
###                            pointer which points to the PAT table entry of
###                            interest.
###
###            PAT$Nod$Index - INTEGER*4 variable containing the node of
###                            interest within the PAT table entry pointed
###                            to by PAT$Pointer.
###
###        Input/Output: None.
###
###        Output: None.
###
###        Function Result:
###
###            intra_node_advance - LOGICAL*1 value.  Set TRUE if the message
###                            can advance during the current game minute;
###                            otherwise set FALSE.
###
###        COMMON:
###
###            Name            Source                   Use
###
###            BBoard          BBCommon                 Input
###
###    Limitations: None.
###
###    Warnings:
###
###        No test for a nonzero value of PAT$Pointer occurs.
###
###    Notes: None.
###
###    Author:
###
###        G. G. Gustafson
###        Computer Sciences Corporation
###        4045 Hancock Street
###        San Diego CA 92110
###
###        (619) 225-8401
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required:
###
###        RANDOM (LBMATH)
###
###    Tables Required:
###
###        CODE
###        PAT
###
###    Algorithm:
###
###        IF communications delays are not in effect
###            return TRUE
###        ELSE
###            IF PAT$Nod$Index is zero
###                extract the values of Mu and Rho from PAT
###            ELSE
###                extract the values of Mu and Rho from the PAT node
###            END IF
###            compute probability of delay from Mu and Rho
###            compare a uniform random number with probability of delay
###            IF delayed
###                return FALSE
###            ELSE
###                return TRUE
###            END IF
###        END IF
###
###
###    Date Developed: March 3, 1988
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###    Waivers: None.

LOGICAL*1 FUNCTION intra_node_advance ( PAT$Pointer,
                                        PAT$Nod$Index )
BBcommon
 
INTRINSIC    EXP
INTRINSIC    FLOAT
REAL         DUMMY      # jb E2145  7/6/00
REAL*4       mu, rho
REAL*4       RANDOM
EXTERNAL     RANDOM
INTEGER*4    PAT$Pointer, PAT$Nod$Index
 
IF ( no$comm$delay != $no )
    {
    intra_node_advance = .TRUE.
    }
ELSE
    {
    IF ( PAT$Nod$Index == 0 )
        {
        mu = xPAT$ServiceRateInterval$f
        rho = FLOAT ( xPAT$Utilization$I ) * 0.01
        }
    ELSE
        {
        mu = xPAT$Nod$ServiceRateInterval$F
        rho = xPAT$Nod$Utilization$I * 0.01
        }
    intra_node_advance = ( RANDOM ( dummy ) <= _
                           1.0 - EXP ( - mu * ( 1.0 - rho ) ) )
    }
end

INTEGER Function lordho(ihold,inode,iready) # jb E2145 7/6/00
 
#######################################################
 #$%
 #$% Purpose:   LORDHO determines maximum node
 #$%            for the holder.
 #$%
 #$% Called By: WHONXT
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #determine max node for the holder
 
Integer IHOLD,INODE,IREADY  # jb E2145  7/6/00
 
 if (ihold == 0) lordho = 0
 else            lordho = 2 * inode + iready
 
 end

###    Name: NODE_ADVANCE
###
###    Usage:
###
###        IF ( node_advance ( mu, rho ) )
###            {
###            do something with advanced message
###            }
###        ELSE
###            {
###            do something with delayed message
###            }
###
###    Purpose:
###
###        Returns the result of the comparision between a uniformly
###        distributed random variate and the computed probability that
###        a given MU and RHO will allow a message to advance.
###
###    Arguments:
###
###        Input:
###
###            mu -    REAL*4 value containing the communication channel
###                    service rate (msg/interval), usually any one of:
###
###                        xPAI$ServiceRateInterval$I
###                        xPAT$ServiceRateInterval$I
###                        xPAT$NOD$ServiceRateInterval$I
###
###            rho -   INTEGER*4 value containing the communication channel
###                    percent utilization(0-100), usually any one of:
###
###                        xPAI$PercentUtilization$I
###                        xPAT$Utilization$I
###                        xPAT$NOD$Utilization$I
###
###        Input/Output: None.
###
###        Output: None.
###
###        Function Result:
###
###            node_advance - LOGICAL*1 value which returns TRUE if the
###                    result of the comparision between a uniformly
###                    distributed random variate and the computed
###                    probability allows a message to advance; otherwise
###                    FALSE.
###
###        COMMON:
###
###            Name            Source                   Use
###
###            BBoard          BBCommon                 Input
###
###    Limitations: None.
###
###    Warnings: None.
###
###    Notes:
###
###        1.  The two input actual arguments must be of INTEGER*4 type.
###
###    Author:
###
###        G. G. Gustafson
###        Computer Sciences Corporation
###        4045 Hancock Street
###        San Diego CA 92110
###
###        (619) 225-8401
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required:
###
###        RANDOM (LBMATH)
###
###    Tables Required:
###
###        CODE
###
###    Algorithm:
###
###        IF no communications delay is inm effect
###            return TRUE
###        ELSE
###            return comparison result
###        END IF
###
###    Date Developed: March 8, 1988
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###    Waivers: None.

LOGICAL*1 FUNCTION node_advance ( mu,
                                  rho )
BBCommon
 
REAL*4       x, mu
REAL*4       random
EXTERNAL     random
INTEGER*4    rho
 
node_advance = ( ( no$comm$delay == $yes ) |
                 ( random ( x ) <= _
                   1.0 - EXP ( - mu * ( 1.0 - FLOAT ( rho ) * 0.01 ) ) ) )
END

 Subroutine nuhold(com$pointer,node)
 
#######################################################
 #$%
 #$% Purpose:   NUHOLD passes the message to
 #$%            a new holder.
 #$%
 #$% Called By: COMPRO
 #$%
 #$% Calls:     COMMNH     ROGER
 #$%
 #$% Tables:    COM        PAT
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #pass message to a new holder
 
 BBcommon
 CMcommon
 
 REAL  COM$Readytime$F,COM$Receivetime$F, # jb E2145  7/6/00
    COM$RE$arrivaltime$F,COM$Sendtime$F   # jb E2145  7/6/00
 Integer I,ICODE,NODE,                    # jb E2145  7/6/00
    COM$Pointer,COM$Overs$I,COM$Type$I,   # jb E2145  7/6/00
    COM$Anysending$I,COM$Node$I,          # jb E2145  7/6/00
    COM$Anyready$I, COM$Trys$I,           # jb E2145  7/6/00
    COM$HO$Index,COM$HO$indx$I,           # jb E2145  7/6/00
    COM$HO$buoy$I,COM$HO$node$I,          # jb E2145  7/6/00
    COM$HO$ready$I,COM$RE$Index,          # jb E2145  7/6/00
    PAT$Pointer,PAT$NOD$Index             # jb E2145  7/6/00
 
 if (node == xcom$node$i)              #if from leading node
    {
     #$% if autoroger                     #$% set code to seven
     if (xcom$type$i == $autoroger$code)  icode = 7
     #$% else set code to one
     else                                 icode = 1
 
     call commnh(xcom$messageid$i,
                 xcom$node$i,
                 icode,
                 com$pointer)
 
     #$% set receive time
     com$ReceiveTime$f = game$time
     putcom$ReceiveTime$f
 
     #$% increment node counter
     com$node$i = xcom$node$i + 1
     putcom$node$i
 
     #$% clear trys
     com$trys$i = 0
     putcom$trys$i
 
     #$% set any ready to NO
     com$anyready$i = $no
     putcom$anyready$i
 
     #$% clear ready time
     com$ReadyTime$f = 0                #indicates for comm history printout
     putcom$ReadyTime$f                 #that message never got ready
 
     #$% clear overs
     com$overs$i = 0
     putcom$overs$i
 
     #$% set any sending to NO
     com$anysending$i = $no
     putcom$anysending$i
 
     #$% clear send time
     com$SendTime$f = 0                 #indicates for comm history printout
     putcom$SendTime$f                  #that sending never began
    }
 
 #$% get path pointer
 pat$pointer = xcom$PathPntr$i
 
 #$% for each possible receiver
 for (i=1;i<=nrcvrs;i=i+1)
    {
     #$% set available holding slot
     com$ho$index = iavail[i]
 
     #$% set receiver holding and store the receiver into the holding slot
     com$ho$indx$i = ircvr[i] # UNT or BOY index
     putcom$ho$indx$i
 
     #$% if receiver is commbuoy, set holding buoy to YES
     if (irtype == $commbuoy$code)  com$ho$buoy$i = $yes
     #$% else set holding buoy to NO
     else                           com$ho$buoy$i = $no
 
     #$% save holding buoy
     putcom$ho$buoy$i
 
     #$% increment node counter
     com$ho$node$i = node + 1
     putcom$ho$node$i
 
     #$% set holding ready to NO
     com$ho$ready$i = $no
     putcom$ho$ready$i
 
     #$% set do now to YES
     idonow[com$ho$index] = $yes
 
     #$% get com type
     com$Type$i = Xcom$Type$i
 
     #$% if commtext, if last node and autoroger, Commdata stuff added 12/91,reh
     if (((com$Type$i    == $Commtext$code | COM$Type$i == $CommData$code ) &
          com$ho$node$i == xpat$numberofnodes$i) |  #if at last node
         (com$Type$i    == $AutoRoger$code &
          com$ho$node$i == 2                   ))
        {
         #$% for each receiver entry
         for (com$re$index=1;com$re$index$ok;com$re$index=com$re$index+1)
            {
             if (xcom$re$indx$i == com$ho$indx$i) break #find which receiver
            }
 
         #$% if receiver index OK
         if (com$re$index$ok)
            {
             #$% set receive arrival time
             com$Re$ArrivalTime$f = game$time
             putcom$Re$ArrivalTime$f
            }
        }
    }
 
 #$% if first node and roger
 if (node == 1 & xcom$roger$i != $no)
    {
     #$% set node to one
     pat$nod$index = 1
 
     #$% if roger flag
     if (xpat$nod$rogerflag$i == $yes)
         call roger(com$pointer)                     #build roger msg
    }
 
 #$% if number of receivers is number of specific receivers
 if (nrcvrs == nspec)
    {
     #$% for each holding entry
     for (com$ho$index=1;com$ho$index$ok;
          com$ho$index=com$ho$index+1)
        {
         #$% if holding is less than node
         if (xcom$ho$node$i <= node)
            {
             #$% set do now to NO
             idonow[com$ho$index] = $no
 
             #$% clear holding
             com$ho$indx$i = 0
             putcom$ho$indx$i
            }
        }
    }
 
 end

 Subroutine ROGER(icpntr)     #generates automatic roger message
 
#######################################################
 #$%
 #$% Purpose:   ROGER generates the text and
 #$%            controls information for auto-
 #$%            matic roger messages.
 #$%
 #$% Called By: NUHOLD
 #$%
 #$% Calls:     BLDCOM     COMMNH     SMOVH
 #$%            SMOVI      SMOVHN
 #$%
 #$% Tables:    COM        PAT        UNT
 #$%            PAI
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 CMcommon
 CMT$Record$Definition         #PGA interface, from HSHDR.inc
 
 LITERAL UNT$Name$C, UNT2$Name$C,                # jb E2145  7/6/00
         PAT$Type$C, CSTRIP8                     # jb E2145  7/6/00
 REAL    COM$Readytime$F,COM$HO$killtime$F       # jb E2145  7/6/00
 Integer ID,IDSK,ILEN,ICPNTR,LINES,MSGID,MSGADR, # jb E2145  7/6/00
    COM$Pointer,COM$Roger$I,COM$Messageid$I,     # jb E2145  7/6/00
    COM$Diskaddr$I,COM$Anyready$I,               # jb E2145  7/6/00
    COM$HO$Index, COM$HO$ready$I                 # jb E2145  7/6/00
 Integer UNT$Pointer, UNT2$Pointer,              # jb E2145  7/6/00
    PAT$Pointer,PAT$Pairindx$I,                  # jb E2145  7/6/00
    CMT$REC$Index, PAI$Pointer                   # jb E2145  7/6/00
 
 integer Game_DTG
 
        if (trace$comm != $no)
        {
         call echor
         call echov ('Building roger msg')
        }
 
 #$% set comm pointer
 com$pointer = icpntr
 #$% get path pointer
 pat$pointer = xcom$PathPntr$i
 
 if (xpat$numberofnodes$i > 2)                  #this restricts multiple
    {                                           #  rogers only when the
     com$roger$i = $yes                         #    rogerer is not an
     putcom$roger$i                             #      ultimate receiver
    }
 
 unt$pointer$to ircvr[1]                 # first receiver will originate roger
 
 #$% set message ID
 id = xcom$messageid$i
 #$% set comm sender pointer
 unt2$pointer$to xcom$senderIndx$i
 
 #$% set next message number
 msgid = Next$Comm$MsgNbr
 msgadr = Next$Comm$Disk
 idsk = msgadr
 
 #$% increment message number counter
 Next$Comm$MsgNbr = Next$Comm$MsgNbr + 1
 #$% increment disk counter
 Next$Comm$Disk = Next$Comm$Disk + 2
 
 #$% set line count
 cmt$zero
 
 lines = 1                                      #1 line of text
 PUTcmt$NLines$I(lines)
 PUTcmt$GameTime$f(game$time)
 PUTcmt$MsgId$I(id)
 
 PAT$Type$c = xpat$type$c                       # PATH NAME
 PUTcmt$PathType$C(pat$type$c)
 
 unt$name$c = xUNT$Name$C                       #sender of roger msg
 PUTcmt$Sender$C(unt$name$c)
 
 CMT$Rec$Index = 1
 unt2$name$c   = xunt2$name$c                   #receiver of roger msg
 PUTcmt$Rec$name$C (unt2$name$c)
 
 write ($lfc$comm,rec=idsk) cmt$record          #write msg header
 
 cmt$zero
 
 ilen = 0
 #$% move message for display in proper format
 call smovv ("ROGER -- MESSAGE #",cmt$record,ilen)
 call smovi (id,cmt$record,ilen)
 call smovv (" RECEIVED BY ",cmt$record,ilen)
 call smovhn (Xunt$name$c,$$MaxLit,cmt$record,ilen)
 call smovv (" AT MINUTE ",cmt$record,ilen)
 call smoviz(Game_DTG(game$time),6,cmt$record,ilen)
 
 #$% increment disk counter
 idsk = idsk + 1
 
 #$% write message text
 write ($lfc$comm, rec = idsk) cmt$record
 
 call bldcom($autoroger$code,                   #build COM entry
             pat$pointer,
             0,
             unt$pointer$index,
             unt2$pointer$index,
             1,
             com$pointer)                 # in, pointer to msg requiring 'roger'
                                          # out, pointer to roger msg
 
 if (com$pointer == 0)                          #if none available
    {
     call commnh(msgid,0,4,0)                   #record fact
     return
    }
 
       if (trace$comm != $no)
       {
       call echov ('..COM #')
       call echoi(com$pointer$index)
       }
 
 #$% set message ID
 com$messageid$i = msgid
 putcom$messageid$i
 
 #$% set disk address
 com$diskaddr$i = msgadr
 putcom$diskaddr$i
 
 #$% set any ready to YES
 com$anyready$i = $yes
 #$% set ready time
 putcom$anyready$i
 
 com$ReadyTime$f = game$time
 putcom$ReadyTime$f
 
 #$% set comm holder to one
 com$ho$index = 1
 
 #$% set comm holder ready to YES
 com$ho$ready$i = $yes
 #$% if path pair valid
 putcom$ho$ready$i
 
 #$% get path pair pointer
 pat$pairindx$i = xpat$pairindx$i
 
 #$% get comm node
 if (pat$pairindx$i != 0)
    {
     #$% set pair pointer
     pai$pointer$to pat$pairindx$i
 
     #$% set kill time
     com$Ho$KillTime$f = game$time + xpai$lifeofmessage$i
     putcom$Ho$KillTime$f
    }
 
 end

 Subroutine SENDOK(com$pointer,                 #Validates sender eq & posture
 
                   com$ho$index,
                   pai$pointer,
                   itest)                       #out:valid/invalid flag
 
#######################################################
 #$%
 #$% Purpose:   SENDOK validates sender equipment
 #$%            and sender posture.  Posture in-
 #$%            cludes the status of required masts,
 #$%            wires, buoys, and any required course or depth.
 #$%
 #$% Called By: COMPRO
 #$%
 #$% Calls:     DEPBOY     BLDHFT
 #$%
 #$% Tables:    COM        PAI        PAT
 #$%            UNT        BOY        SON
 #$%            DEQ        SHD
 #$%            SUI
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 BBcommon
 CMcommon
 
 literal  LSNDEQ,ibuoy,DEQ2$type$C
 LITERAL DEQ$Type$C, CSTRIP8                       # jb E2145  7/6/00
 REAL    DEQ$Timewhenuse$F                         # jb E2145  7/6/00
 Integer*4 maxcomrange,ieqid2,Deq2$Ident$I,DEQ2$Pointer,
           UNT2$Pointer,UNT$Pointer
integer*4   i, I_Channel, IStat, LCOMP      # jb LCOMP  E2145  2/13/01
Integer     IEQID,ITEST,LDEPTH,LSPEED,IDENT_FOUND, # jb E2145  7/6/00
    COM$Pointer,COM$Sendchannel$I,                 # jb E2145  7/6/00
    COM$Buoyindx$I,COM$HO$Index,                   # jb E2145  7/6/00
    PAT$Pointer,PAT$NOD$Index                      # jb E2145  7/6/00
Integer BOY$Pointer,BOY$On$I,                      # jb E2145  7/6/00
    DEQ$Pointer,DEQ$Ident$I,                       # jb E2145  7/6/00
    DEQ$Oktosend$I,DEQ$EM$Index,                   # jb E2145  7/6/00
    SUI$Pointer,SUI$Band$I,                        # jb E2145  7/6/00
    PAI$Pointer, SON$Pointer                       # jb E2145  7/6/00
logical*1   match_found
 
#$% commented out 1/91, trs
# if (xcom$buoyindx$i != 0) ### If automatic buoy deployment required, don't
#    {                      ### check sender posture since new buoy is
#     itest = $yes          ### deployed each time sendok called. Besides,
#     return                ### no posture requirement need be met in that case.
#    }
 
 #$% set path pointer
 pat$pointer = xcom$PathPntr$i
 pat$nod$index = xcom$ho$node$i
 
 #$% if holder is not a buoy
 if (xcom$ho$buoy$i == $no)
    {
     #$% set UNT pointer to holder
     unt$pointer$to xcom$ho$indx$i
     #$% set type of holder
     istype = xunt$type$i
    }
 else
    {
     #$% set BOY pointer of holder
     boy$pointer$to xcom$ho$indx$i
     #$% set holder type to commbuoy
     istype = $commbuoy$code
    }
 
 ITEST = $NO                                    #initialize test flag
 
       if (trace$comm != $no)
       {
        call echor
        call echov ('Send posture ')
       }
 
 LSNDEQ = XPAI$SENDINGEQUIPMENT$C               #equipment type
 
 #$% if max comm range is zero, set acoustic to YES
 maxcomrange = xpai$maxcommrange$i
 if (xpai$maxcommrange$i == 0)  iacous = $yes
 #$% else set acoustic to NO
 else                           iacous = $no
 
 if (istype == $COMMBUOY$CODE)                  #if comm buoy
    {
     if(Xboy$KillTime$f > game$time) #if not expired
       {
        #$% set send OK flag to YES
        itest = $yes
 
        #$% if acoustic commpair being used
        if (iacous == $yes)
           {
            #$% and buoy is acoustic
            if (xboy$Acoustic$i == $yes)                #smn008
               {
                #$% set SON pointer to get info on this buoy
                son$pointer = xboy$eqpntr$i
 
                #$% set source level
                level = XSON$SOURCELEVEL$I
                #$% set center frequency
                IFREQ = XSON$CENTERFREQ$I
               }
            #$% else not OK to send
            else  itest = $no
           }
       }                                        #end if not expired
    }                                           #end if comm buoy
 
 else
    {
     #$% if acoustic is YES, set acoustic comm
     if (iacous == $yes) ieqid = $acousticcomm$code
     #$% else set commsuite
     else                ieqid = $commsuite$code
 
     #$% for each dynamics entry
        FOR_DEQ_CHAIN
        {
         DEQ$ident$i       = xDEQ$ident$i
         DEQ$type$C        = XDEQ$type$C
         DEQ$oktosend$i    = xDEQ$oktosend$i
         deq$TimeWhenUse$f = xdeq$TimeWhenUse$f
 
         if (DEQ$ident$i == ieqid &             # \/if has required transmitter
             LCOMP(DEQ$type$C, LSNDEQ) == 0 & # jb AAI01/LCOMP  2/13/01
             deq$TimeWhenUse$f <= game$time & # device operational (10/89 dew)
             (pat$nod$index == 1 |              # and allowed to transmit
              DEQ$oktosend$i == $yes))
            {
             ITEST = $YES                         #test is good
             ixequip = DEQ$Pointer$index
             IF  (( EMI$IntraPlatform != $no ) & (EMI$Analysis != $NO))
                 {
                 IF  (ieqid == $acousticcomm$code)
                     { # search for comm suite entry for acoust. comm. sonar
                     ieqid2 = $commsuite$code
                     UNT2$Pointer = UNT$Pointer
                     FOR_DEQ2_CHAIN
                         {
                         Deq2$Ident$I = xDEQ2$ident$i
                         DEQ2$type$C  = XDEQ2$type$C
                         IF  (DEQ2$ident$i == ieqid2 &
                              LCOMP(DEQ2$type$C,LSNDEQ)== 0 ) # jb LCOMP 2/13/01
                             {
                             ixequip3 = DEQ2$Pointer
                             Break 2
                             }
                         }
                     }
                 } # end if intra emi is on
             break
            }  # end if has required transmitter
        } # end for deq chain
 
     #$% if test is no good, return
     if (itest == $no) return
 
     #$% if acoustic is YES
     if (iacous == $yes)
        {
         #$% get sonar info for this ship/sub
         son$pointer = xdeq$pntr$i
         level = XSON$SOURCELEVEL$I
         IFREQ = XSON$CENTERFREQ$I
        }
 
     #$% set true latitude depth
     LDEPTH = XUNT$TRUEALTDEPTH$I                  # jb UNT vs POS 3/23/89
 
     #$% set true speed
     lspeed = XUNT$TRUEspeed$f                     # jb UNT vs POS 3/23/89
 
     if (istype == $SUB$CODE)                    #if sender is sub
       {
        ### this test good enuf for now to determine if auto buoy deploy reqd
 
        if (xpat$nod$nodecategory$i == $commbuoy$code &  #if next node is buoy
            iacous == $no)                               # but not acoustic
           {
            ibuoy = xpat$nod$platformtype$c
 
            #$% set test flag to No
            itest = $no
 
            #$% for each equipment entry
##            for(shd$eq$index=1;shd$eq$index$ok;shd$eq$index=shd$eq$index+1)
                ident_found = $no
                FOR_DEQ_CHAIN
               {
                #$% test for the needed buoy
                if (xdeq$ident$i == $commbuoy$code &
                    LCOMP(xdeq$type$c, ibuoy) == 0 &  # jb  AAI01/LCOMP 2/13/00
                    xdeq$remaining$i > 0)
                    {
                    ident_found = $yes
                    break              #see if has required buoy
                    }
               }
 
            if (ident_found == $yes)               #if found
               {
                #$% if commbuoy already delpoyed and this transmission is next
                #$% minute, don't deploy another buoy. added 1/91, reh
                if (xcom$buoyindx$i != 0)
                    {
                    itest = $yes
                    return
                    }
 
                #$% call deploy buoy
                call depboy(unt$pointer,
##                            shd$pointer,          # reh 3/89
                            deq$pointer,            ## reh 3/89
                            boy$pointer)
 
 
                if (boy$pointer != 0)       #if there was room in table
                   {
                    #$% set comm buoy pointer
                    com$buoyindx$i = boy$pointer$index
                    putcom$buoyindx$i
 
                    #$% set test flag to YES
                    itest = $yes
                   }
               }
 
            return                              #remaining tests don't apply
           }
 
        if(XPAI$WIRETOSEND$I == $YES)           #if wire needed
          {
           ITEST = $NO
 
           if(XUNT$DEPLOYWIRE$I == $YES &       #if ordered
              LDEPTH <= WIRE$DEPTH$MAX &
              Xunt$TimeWire$f <= game$time)   #and deployed
             {
              ITEST = $YES                      #test good
             }
          }
        else if(XPAI$MASTTOSEND$I == $YES)      #if mast needed
          {
           ITEST = $NO
 
           if(XUNT$DEPLOYMAST$I == $YES &       #if ordered
              LDEPTH <= MAST$DEPTH$MAX &
              Xunt$TimeMast$f <= game$time)   #and deployed
             {
              ITEST = $YES                      #test good
             }
          }
        else if(XPAI$BUOYTOSEND$I == $YES)      #if wire buoy needed
          {
           ITEST = $NO
 
           if(XUNT$DEPLOYBUOY$I == $YES &       #if ordered
              LDEPTH <= BUOY$DEPTH$MAX &
              Xunt$TimeBuoy$f <= game$time)   #and deployed
             {
              ITEST = $YES                      #test good
             }
          }
       }                                        #end wire/mast/buoy tests
 
     if(ITEST == $YES &                         #if eq/posture good
        iacous == $yes)                         #  & acoustic comm
       {
        if ((ldepth <= layer$depth &            #if too fast
             lspeed > xpai$sendspeedin$i) |
            (ldepth > layer$depth &
             lspeed > xpai$sendspeedbelow$i))
            itest = $no                         #test fails
       }                                        #end if eq/posture good
    }                                           #end if ship or sub
 
 if (itest == $yes)                             #switch on comm gear
    {                                           #  for possible detection
     #$% if commbuoy
     if (istype == $commbuoy$code)
        {
         #$% turn buoy on
         boy$on$i = $on
         putboy$on$i
        }
     else
        {
         #$% set equipment to ON
         putDEQ$on$i ($ON)
 
        IF ( EMI$Analysis != $No )                  # reh 10/5/89
            {
            SUI$pointer = xDEQ$pntr$i           # reh 12/90
 
            #$% find Commsuite channel corresponding to CommPair Freq, 12/90
            call get_Commsuite_Channel ( _
                       SUI$Pointer,     # in
                       PAI$Pointer,     # in
                       I_Channel,       # out, 1 if hopper
                       IStat)           # out, 0 if freq. align err.
 
            #$% if we can transmit on this Communications Pair
            If ( IStat != 0 )                       # REH 12/90
                {
                COM$SendChannel$i = I_Channel       # 12/90
                putCOM$SendChannel$i
 
                match_found = $no
 
                #$% for all unique transmissions this game minute
                for ( i = 1; i <= icount_Tx; i = i + 1 )
                    {
                    if ( I_am_Tx[i] == DEQ$pointer &
                         I_am_Tx_Channel[i] == I_Channel )
                        {
                        match_found = $yes
                        break
                        }
                    }
 
                if ( match_found == $no )
                    {
                    icount_Tx = icount_Tx + 1               # DEW 10/89
                    I_am_Tx_Channel[icount_Tx] = I_Channel  # REH 12/90
                    I_am_Tx[icount_Tx] = DEQ$pointer    # DEQs that are Tx'ing
 
                    DEQ$EM$Index = I_am_Tx_Channel[icount_Tx]      # 12/90
                    putDEQ$EM$Band$i ($ON)                         # 12/90 reh
                    }
                }
            else # else we don't send this communication       # 12/90 reh
                {
                IF ( trace$comm != $no )
                    {
                    call echov (' Pair-Suite freq align error. ')
                    }
                itest = $no
                }
            }# end if EMI analysis
 
         #$% if acoustic is NO and unit is not shorebase
         if (iacous == $no & istype != $shorebase$code)
            {
             #$% set SUI pointer
             sui$pointer = xDEQ$pntr$i
 
             #$% set SUI band
             sui$band$i = xsui$band$i
 
             #$% if commsuite band is high frequency low risk of intercept
             if (sui$band$i == $hflri$code)
                 #$% build HFDF transmission data
                 call bldhft(unt$pointer,pai$pointer,$yes)
 
             #$% else if commsuite band is high frequency
             else if (sui$band$i == $hf$code)
                 #$% build HFDF transmission data
                 call bldhft(unt$pointer,pai$pointer,$no)
            }
        }
    }
 
 end            # End SENDOK subroutine

###    Name: BOYRCV
###
###    Usage:
###
###        CALL untrcv ( transmitter_pointer,
###                      COM$Pointer,
###                      COM$HO$Index
###                      PAI$Pointer )
###
###    Purpose:
###
###        Tests for message receipt at ship, shore, or aircraft.
###
###    Arguments:
###
###        Input:
###
###            transmitter_pointer - INTEGER*4 value containing the blackboard
###                            BOY or UNT table pointer which, in turn, points
###                            to the communications receiver.
###
###            COM$Pointer -   INTEGER*4 variable containing the blackboard
###                            pointer which, in turn, points to the current
###                            COM table communication messsage.
###
###            COM$HO$Index -  INTEGER*4 value of the transmitter node index
###                            for the current COM table communication message.
###
###            PAI$Pointer -   INTEGER*4 variable containing the blackboard
###                            pointer which, in turn, points to the PAI
###                            table communication pair.
###
###        Input/Output: None.
###
###        Output: None.
###
###        Function Result: None.
###
###        COMMON:
###
###            Name            Source                   Use
###
###            BBoard          BBCommon                 Input/Output
###            SCRATCH$PAD     CMcommon                 Input/Output
###
###    Limitations: None.
###
###    Warnings: None.
###
###    Notes: None.
###
###    Author:
###
###        Ron Williams
###        System Development Corporation
###
###    Customer:
###
###        Naval Ocean Systems Center
###        Code 413
###        San Diego CA 92152-5000
###
###        (619) 553-3972
###
###    Subprograms Required:
###
###        COMCON
###        CHKLNK
###        CSTRIP
###        ECHOH
###        ECHOR
###        INTER_NODE_ADVANCE
###        WHSIDE
###
###    Tables Required:
###
###        BOY
###        CODE
###        COM
###        UNT
###        UNT2
###
###    Algorithm: N/A
###
###    Date Developed: February, 1981
###
###    Record of Modifications:
###
###        Programmer          Date        Modification
###
###        G. G. Gustafson     3/21/88     Modified formal arguments and
###                                        replaced ADVANC calls by calls
###                                        to INTER_NODE_ADVANCE and
###                                        NODE_ADVANCE.
###
###    Waivers: None.

SUBROUTINE untrcv ( transmitter_pointer,
                    COM$Pointer,
                    COM$HO$Index,
                    PAI$Pointer )
 
#######################################################
 #$%
 #$% Purpose:
 #$%
 #$% Called By: COMCON
 #$%
 #$% Calls:     WHSIDE     CHKLNK     ADVANC
 #$%
 #$% Tables:    COM        PAI        PAT
 #$%            BOY        UNT
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
BBcommon
CMcommon
 
LITERAL    CSTRIP8                   # jb E2145  7/6/00
Integer I,JJ,DUMMY_DEQ,              # jb E2145  7/6/00
    IRSIDE,ISSIDE,IUX,LINK,          # jb E2145  7/6/00
    COM$Pointer,COM$HO$Index,        # jb E2145  7/6/00
    COM$Receivechannel$I             # jb E2145  7/6/00
Integer UNT2$Pointer,UNT2$Status$I,  # jb E2145  7/6/00
    DEQ$Pointer, DEQ2$Pointer,       # jb E2145  7/6/00
    BOY$Pointer, PAI$Pointer,        # jb E2145  7/6/00
    SUI$Pointer, UNT$Pointer         # jb E2145  7/6/00
integer*4    Receive_Channel
INTEGER*4    transmitter_pointer
LOGICAL*1    Rx_of_interest
LOGICAL*1    inter_node_advance
EXTERNAL     inter_node_advance
 
#$% if number of specific receivers is zero, look for all possible receivers
IF ( nspec == 0 )                                #if generic
    {
    #$% if sender is a commbuoy
    IF ( istype == $commbuoy$code )
        {
        #$% get BOY pointer to holder
        BOY$Pointer$To xCOM$HO$Indx$I
        #$% get UNT pointer to owner
        UNT$Pointer$To xBOY$OwnerIndx$I
        }
    ELSE
        {
        #$% get UNT pointer to holder
        UNT$Pointer$To xCOM$HO$Indx$I
        }
    CALL whside ( xUNT$View$I, isside )            #determine side of sender
 
    #$% for each unit entry
    FOR ( UNT2$Pointer$First; still_ok(UNT2); UNT2$Pointer$Next ) # 9/26/88
        {
        UNT2$Status$I = xUNT2$Status$I
        IF (( UNT2$Status$I == $beingdeleted$code |
              UNT2$Status$I == $acawaitinglaunch$code ) |
             (xUNT2$GhostedUnit$I == $YES)) # if ghosted unit, skip it SMM 5/92
            {
            NEXT
            }
        irtype = xUNT2$Type$I
        IF ( irtype != ndcatr )            #skip unless right type
            {
            NEXT
            }
        CALL whside ( xUNT2$View$I, irside )       #determine side of receiver
        IF ( irside != isside )            #skip unless same side
            {
            NEXT
            }
        iux = UNT2$Pointer$Index
        jj = COM$HO$Index                      #save COM$HO$Index for nuhold
        #$% for each holder
        FOR ( COM$HO$Index=1; COM$HO$Index$ok; COM$HO$Index=COM$HO$Index+1 )
            {
            #$% if buoy is not holding, break loop
            IF ( xCOM$HO$Buoy$I == $no &
                 iux == xCOM$HO$Indx$I )
                {
                BREAK
                }
            }
        IF ( COM$HO$Index$Ok )             #skip if already holding
            {
            NEXT
            }
        COM$HO$Index = jj                      #restore COM$HO$Index
        IF ( trace$comm != $no )
            {
            CALL echor
            CALL echohn ( xUNT2$Name$C, $$MaxLit )
            CALL echov (' right type unit')
            }
        #$% check comm link
        CALL chklnk ( UNT2$Pointer,              #send
                      PAI$Pointer,               #send
                      $NO,                       #flag indicating specific rec
                      link,                      #receive
                      transmitter_pointer)
        #$% if no link, get NEXT
        IF ( link == $no )
            {
            NEXT
            }
        IF ( trace$comm != $no )
            {
            CALL echov ('..link ok')
            }
        #$% increment links counter
        nlinks = nlinks + 1
 
        Rx_of_interest = .false.
 
        IF ( EMI$Analysis != $No )
            {
            SUI$Pointer = xPAI$RecvSuitePntr$I           # receiving commsuite
 
            deq$pointer$to ixequip                      # transmitter reference
            deq2$pointer$to ixequip2                    # receiver reference
 
            #$% if this is receiver of interest
            IF ( xDEQ2$EMIInterest$i != $No )
                {
                #$% reh, new call as of 4/91 to handle:
                     # 1) Rx with some EMI channels and some non-EMI channels
                     # 2) Rx of old frequency hopper type
                     # 3) Rx of BEES frequency hopper type
 
                call Comms_Rx_Of_Interest (_
                                  SUI$Pointer,      # in
                                  PAI$Pointer,      # in
                                  Receive_Channel,  # out
                                  Rx_Of_Interest)   # out
 
 
                }
            } # end EMI analysis
 
        if (Rx_of_interest)
            {
            # commented out 4/91, reh
            #$% find Commsuite channel corresponding to CommPair Freq, 12/90
 
            #$% if freq. align error, 12/90 reh
 
            COM$ReceiveChannel$i = Receive_Channel
            putCOM$ReceiveChannel$i                         # 12/90
 
            } # end if receiver of interest (with EMI)
        else
            {
            # else call test advance message
            IF ( ! inter_node_advance ( PAI$Pointer,
                                        UNT2$Pointer,
                                        transmitter_pointer,
                                        Dummy_Deq ) ) next
            } # end normal (non-emi) processing
 
        IF ( trace$comm != $no )
            {
            CALL echov (' *** Rcvd ***')
            }
        #$% increment number of receivers counter
        nrcvrs = nrcvrs + 1
        ircvr[nrcvrs] = iux
        #$% if number of receivers exceeds number available , break loop
        IF ( nrcvrs >= navail )
            {
            BREAK
            }
        }
    }
ELSE                                           #if specified receiver(s)
    {
    #$% for each available entry
    FOR ( i=1; i<=navail; i=i+1 )
        {
        UNT2$Pointer$to ispec[i]
        UNT2$Status$I = xUNT2$Status$I
        IF ( UNT2$Status$I == $beingdeleted$code |
             UNT2$Status$I == $acawaitinglaunch$code )
            {
            NEXT
            }
        irtype = xUNT2$Type$I
        IF ( trace$comm != $no )
            {
            CALL echor
            CALL echohn ( xUNT2$Name$C, $$MaxLit )
            CALL echov (' spec rcv unit')
            }
        CALL chklnk ( UNT2$Pointer,
                      PAI$Pointer,
                      $YES,                      #flag indicating specific rec
                      link,
                      transmitter_pointer)
 
        #$% if no comm link, get next
        IF ( link == $no )
            {
            NEXT
            }
        IF ( trace$comm != $no )
            {
            CALL echov ('..link ok')
            }
        #$% increment links counter
        nlinks = nlinks + 1
 
        Rx_of_interest = .false.
 
        IF ( EMI$Analysis != $No )
            {
            SUI$Pointer = xPAI$RecvSuitePntr$I           # receiving commsuite
 
            deq$pointer$to ixequip                      # transmitter reference
            deq2$pointer$to ixequip2                    # receiver reference
 
            #$% if this is receiver of interest
            IF ( xDEQ2$EMIInterest$i != $No )
                {
                #$% reh, new call as of 4/91 to handle:
                     # 1) Rx with some EMI channels and some non-EMI channels
                     # 2) Rx of old frequency hopper type
                     # 3) Rx of BEES frequency hopper type
 
                call Comms_Rx_Of_Interest (_
                                  SUI$Pointer,      # in
                                  PAI$Pointer,      # in
                                  Receive_Channel,  # out
                                  Rx_Of_Interest)   # out
 
#                if ( Receive_Channel == 0 ) next    # get next receiver unit
 
#                Rx_of_interest = .true., commented out 4/91
                }
            } # end EMI analysis
 
 
        if (Rx_of_interest)
            {
            # commented out 4/91, reh
            #$% find Commsuite channel corresponding to CommPair Freq, 12/90
#            call get_Commsuite_Channel ( SUI$Pointer,       # in
#                                         PAI$Pointer,       # in
#                                         Receive_Channel)   # out
 
            #$% if freq. align error, we can't receive. 12/90 reh
#            if ( Receive_Channel == 0 ) next       # get next receiver unit
 
            COM$ReceiveChannel$i = Receive_Channel
            putCOM$ReceiveChannel$i                         # 12/90
 
            } # end if receiver of interest (with EMI)
        else
            {
            #$% call test advance message
            IF ( ! inter_node_advance ( PAI$Pointer,
                                        UNT2$Pointer,
                                        transmitter_pointer,
                                        deq$Pointer ) ) next
 
            } # end normal (non-emi) processing
        IF ( trace$comm != $no )
            {
            CALL echov (' *** Rcvd ***')
            }
        #$% increment number of receivers counter
        nrcvrs = nrcvrs + 1
        ircvr[nrcvrs] = ispec[i]
        }
    }
END

 Subroutine whonxt(com$pointer,
                   indxho)
 
#######################################################
 #$%
 #$% Purpose:   WHONXT finds out where the
 #$%            message should go next.
 #$%
 #$% Called By: COMPRO
 #$%
 #$% Calls:     LORDHO
 #$%
 #$% Tables:    COM        PAT     UNT
 #$%
 #$% Date:      FEB 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 #finds out where the message should go next
 BBcommon
 CMcommon
 
 LITERAL PAT$NOD$platformtype$C, CSTRIP8   # jb E2145  7/6/00
 Integer I,INDXHO,IRDY,ILOWST,LOWEST,      # jb E2145  7/6/00
    LO,LORDHO,MAXNOD,NODE,NSLOTS           # jb E2145  7/6/00
 Integer PAT$Pointer,PAT$NOD$Index,        # jb E2145  7/6/00
    COM$Pointer,COM$HO$Index,COM$RE$Index, # jb E2145  7/6/00
    UNT$Pointer                            # jb E2145  7/6/00
 integer igot[com$ho$slots], LCOMP   # jb LCOMP E2145  2/13/01
 integer com$ho$indx$i
 com$ho$index = indxho
 pat$pointer = xcom$PathPntr$i
 pat$nod$index = xcom$ho$node$i                 #index for next node
 node = xcom$ho$node$i
 irdy = xcom$ho$ready$i
 
 #$% zero number of specific receivers
 nspec = 0
 
 if (node == xpat$numberofnodes$i - 1 |         #if sending to msg recipients
     xcom$type$i == $autoroger$code)
    {
     #$% for each comm receiver entry
     for (com$re$index=1;com$re$index$ok;com$re$index=com$re$index+1)
        {
         #$% if recipient slot is empty, check next slot
         if (xcom$re$indx$i == 0)  next
 
         #$% for each holding entry
         for (com$ho$index=1;com$ho$index$ok;com$ho$index=com$ho$index+1)
            {
             #$% if recipient is holding and holder is not a buoy, break loop
             if (xcom$ho$indx$i == xcom$re$indx$i &
                 xcom$ho$buoy$i == $no)  break
            }
         if (com$ho$index$ok)  next             #skip if recipient holding
 
         #$% increment counter and store receiver
         nspec = nspec + 1
         ispec[nspec] = xcom$re$indx$i
        }
    }
 
 #$% else if sending to a commbuoy
 else if (xcom$buoyindx$i != 0 &
          xpat$nod$nodecategory$i == $commbuoy$code)
    {
     #$% set number of specific receivers to one
     nspec = 1
     #$% initialize save array
     ispec[1] = xcom$buoyindx$i
    }
 
 #$% else if sending to an aircraft in flight
 else if (xcom$flightIndx$i != 0 &
          xpat$nod$nodecategory$i == $air$code)
    {
     #$% set number of specific receivers to one
     nspec = 1
     #$% initialize save array
     ispec[1] = xcom$flightindx$i
    }
 
 #$% else if sending to a shorebase
 else if (xpat$nod$nodecategory$i == $shorebase$code &
          xpat$nod$platformtype$c != 0)
    {
     #$% get platform type
     pat$nod$platformtype$c = xpat$nod$platformtype$c
 
     #$% for each unit entry
     for (unt$pointer$first;still_ok(unt);unt$pointer$next) # 9/26/88
        {
         if (xUNT$GhostedUnit$I == $YES) next   # skip ghosted units 5/18/92 SMM
 
         #$% if name and type match path node
###         if (xunt$name$c == pat$nod$platformtype$c & # jb AAI01/LCOMP 2/13/01
         if (LCOMP(xunt$name$c,pat$nod$platformtype$c)== 0 & # jb AAI01  2/13/01
             xunt$type$i == $shorebase$code )
            {
             #$% set number of specific receivers to one
             nspec = 1
             #$% initialize save array and break loop
             ispec[1] = unt$pointer$index
             break
            }
        }
    }
 
 #$% determine maximum node
 maxnod = lordho(1,node,irdy)
 
 if (nspec == 0)  nslots = com$ho$slots
 else             nslots = nspec
 
 #$% for each slot entry
 for (i=1;i<=com$ho$slots;i=i+1)
    {
     #$% set got slot to NO
     igot[i] = $no
    }
 
 #$% zero number available
 navail = 0
 
 repeat
    {
     #$% zero lowest
     ilowst = 0
     #$% increment counter
     lowest = maxnod + 1
 
     #$% for each holder/ if there are any
     for (com$ho$index=1;com$ho$index$ok;com$ho$index=com$ho$index+1)
        {
         #$% if holding, get next
         if (igot[com$ho$index] == $yes)  next      #skip if already gotten
 
         com$ho$indx$i = xcom$ho$indx$i  # integer*2 to integer*4
         lo = lordho(com$ho$indx$i,xcom$ho$node$i,xcom$ho$ready$i)
 
         if (lo < lowest)
            {
             lowest = lo
             ilowst = com$ho$index
            }
        }
 
     #$% if no holders, break loop
     if (ilowst == 0)  break
 
     #$% increment number of available holder slots
     navail = navail + 1
     iavail[navail] = ilowst
     igot[ilowst] = $yes
 
     #$% if number available exceeds number of slots, break loop
     if (navail >= nslots)  break
    }
 
 end
 

#$% determine if this actually is a receiver of interest, 4/91
subroutine Comms_Rx_Of_Interest ( SUI$Pointer,      # in
                                  PAI$Pointer,      # in
                                  SUI$CH$Index,     # out
                                  Rx_Of_Interest)   # out
BBCommon
integer*4   SUI$Pointer
integer*4   PAI$Pointer
integer*4   SUI$CH$Index
logical*1   Rx_Of_Interest
integer*4   Istat
 
#$% set up default
Rx_Of_Interest = $no
SUI$CH$Index = 1                        # 7/91 reh
 
#$% if no channels are EMI capable, also non-BEES frequency hopper
IF (xSUI$EMIFlag$i != $BEESProcessing)
    {
    return
    }
 
# if we get here, the commsuite has some potential to be affected by EMI
 
if ( xSUI$DeviceType$i == $FixedMode )
    {
    #$% find Commsuite channel corresponding to CommPair Freq, 12/90
    call get_Commsuite_Channel (_
                                SUI$Pointer,       # in
                                PAI$Pointer,       # in
                                SUI$CH$Index,      # out, 1 if non-fixed freq
                                Istat)             # out, zero if freq align err.
 
    #$% if freq. align error, 12/90 reh
    if ( IStat == $no )
        {
        return
        }
 
    #$% if this channel is EMI capable
    if ( xSUI$CH$ModulationCode$i != 0 )
        {
        Rx_of_interest = .true.
        }
    } # end if CommSuite is a fixed mode and has at least one EMI capable channel
else if ( xSUI$DeviceType$i == $FrequencyHopper )
    {
    Rx_of_interest = .true.
    }
 
return
end
