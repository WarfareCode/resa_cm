#####   version 3.1  dated-  7apr81
 
 
#####   version 3.0  dated- 22dec80
 
#$%     MODULE                        UTILITY                   DATA
#$%   SUBROUTINES                   SUBROUTINES                TABLES
#$%   ===========                   ===========                ======
#$%
#$%     BSBLDA                         IGETI                    NONE
#$%     BSBLDB                         IGETW
#$%     BSBLDC                         IGETB
#$%     BSCHEK
#$%     BSDELE
#$%     BSHELP
#$%     BSHLPF
#$%     BSLIST
#$%     BSLTBL
#$%     BSPREP
#$%     BSPRIN
#$%     BSSAVE
#$%     BSTBLG
#$%     BSVERF
#$%     GETLN  <BUILD >
#$%     ANALYZ <WCOMMN>
#$%     ORDER1 <WCOMMN>
#$%
#$%
#$%
#$%   NOTES
#$%   =====
#$%
#$%   1.  <FILENAME> INDICATES FILE WHERE SUBROUTINE IS LOCATED.
#$%
#$%   2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%   3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%
#$%   FLOWCHART FOR FILE BSUBS
#$%   ========================
#$%
#$%   BSCHEK*
#$%   BSDELE - ANALYZ*
#$%          - GETLN *
#$%   BSHELP - BSHLPF*
#$%   BSPREP - BSLTBL*
#$%          - BSLIST - BSBLDA*
#$%                   - BSBLDC - BSBLDB*
#$%                   - BSPRIN - PRCONV*
#$%                   - ORDER1*
#$%   BSSAVE*
#$%   BSTBLG*
#$%   BSVERF*
 
# 
 
include "macros.inc"
include "ascii.inc"
 
define ($no_blmain,true)
include "blmain.inc"
undefine $no_blmain
 
# Make FORTRAN intrinsic routine INDEX available                # dew 11/2000
undefine (index)    # index was pointing to RLIB routine indexx # dew
 
#
# Generate standard record skeleton
#
#
  subroutine bsbldA (work,               # current record array
                     wrkopt,             # pointers to the work array
                     defcom,dccom,       # common definition table and size
                     deftyp,dctyp,       # type definition table and size
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg, # argument definition table and size
                     deffmt,dcfmt)       # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSBLDA sets up the work record
  #$%            with the appropriate fields and
  #$%            length for storing the required
  #$%            and optional parameters that
  #$%            characterize the equipment pro-
  #$%            cessor that called it.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%            BSLIST
  #$%
  #$% Calls:     None
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
##  implicit integer (a-q,s-z)
  IMPLICIT NONE     # jb  E2145 3/28/00
#
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt # jb E2145 3/27/00
  literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
             defarg[dsarg,dcarg],deffmt[5,dcfmt],
             work[$work_size],oldtyp
  Real*4 rcnt   # jb E2145 (ok for use in DO loop...) 3/27/00
 
  integer    oldpos,oldlen,wrkopt
  Integer    i,j,ptr,com,fld,acnt    # jb E2145  3/27/00
  Integer    NXTFLD, cur # jb E2145 (Stagement Function & argument)  3/27/00
  Integer    lcomp_v
  logical    typed,rtype,anyinp,found
#
  #common /rdat/ typed,rtype,anyinp,found,oldpos,oldlen,oldtyp
   common /rdat/   oldtyp,                             # jb (LITERAL) 3/27/00
                    oldpos,oldlen,                      # jb (INTEGER) 3/27/00
                    typed,rtype,anyinp,found            # jb (LOGICAL) 3/27/00
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtcom(cur) = cur + 1                      # .DEFCOM
#!!     nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFTYP
     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
#!!     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#
#*****
 
  do i = 1, $work_size
    {work[i] = 0
    }
 
  ptr = 1
  wrkopt = 0
  rtype = .false.
  typed = .false.
  anyinp = .false.
  found = .false.
  oldpos = 0
  oldlen = 0
  oldtyp = $BLANKLIT
 
  #$% loop for each common field
  do com = 1, dccom
    {if(defcom[1,com]=='CAT') rtype = .true.
 
     #$% if field is constant, build into work array
     if (lcomp_v(defcom[1,com], '*CONS') == 0)
       {ptr = ptr + 1 ; work[ptr]= '*CONS'
        ptr = ptr + 1 ; work[ptr]= 1
        ptr = ptr + 1 ; work[ptr]= defcom[2,com]
       }
 
     else
       {
        #$% search FLD table for match
        for (fld=1; deffld[fld] != defcom[1,com]; fld = nxtfld(fld))
          {continue
          }
 
        #$% check "optional" flag and occurance count
        rcnt = defcom[2,com]
        if (rcnt < 0)
          {rcnt = - defcom[2,com]
           #$% if first "optional" field, save "optional" pointer
           if (wrkopt==0)
              wrkopt=ptr
          }
 
        #$% loop for each occurance of this field
        do i = 1, rcnt
          {ptr = ptr + 1 ; work[ptr]= defcom[1,com]
 
           #$% build required fields into work array
           acnt = deffmt[1,abs(deffld[fld+2])]-1
           ptr = ptr + 1 ; work[ptr]= acnt
 
           do j = 1, acnt
             {ptr = ptr + 1 ; work[ptr]= %'*REQ*'%
             }
          }
       }
    }
  #$% determine start of optional fields in work array if not done already
  work[1] = ptr
  if (wrkopt==0) wrkopt = ptr
  return
  end

 
 
  subroutine bsbldB (defcom,dccom,       # common definition table and size
                     deftyp,dctyp,       # type definition table and size
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg, # argument definition table and size
                     deffmt,dcfmt)       # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSBLDB will modify the current
  #$%            work record built by BSBLDA to
  #$%            include the field and a new
  #$%            length to store the required
  #$%            and optional parameters that
  #$%            characteristize the selected
  #$%            category.
  #$%
  #$% Called By: BSBLDC
  #$%
  #$% Calls:     None
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
##  implicit integer (a-q,s-z)
  IMPLICIT NONE     # jb  E2145 3/28/00
 
#
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt # jb E2145 3/27/00
  literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
             defarg[dsarg,dcarg],deffmt[5,dcfmt],buf[$work_size]
 
  include    "blmain.inc"
  Real*4 rcnt   # jb E2145 (ok for use in DO loop...) 3/27/00
  Integer i,j,k,L,acnt,ptr,fld,Ftyp,Ltyp,typ,  # jb E2145  3/27/00
          buflen,bufopt                        # jb E2145  3/27/00
  Integer   cur, NXTTYP,NXTFLD                 # jb E2145  3/27/00
  Integer   lcomp_v
 #
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtcom(cur) = cur + 1                      # .DEFCOM
     nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFTYP
     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
#!!     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#
#*****
 
  do i = 1, $work_size
    {buf[i] = 0
    }
 
  ptr = 0
  bufopt = 0
 
  for (i=1; i < dctyp; i = nxttyp(i))
    {k = i
     if (deftyp[i] == oldtyp) break
    }
 
  Ftyp = k + 2
  Ltyp = k + (2 * deftyp[k+1] )
 
  #$% loop for each TYP field
  do typ = Ftyp, Ltyp, 2
    {
 
     #$% if field is constant, build into work array
     if (lcomp_v(deftyp[typ], '*CONS') == 0)
       {ptr = ptr + 1 ; buf[ptr]= '*CONS'
        ptr = ptr + 1 ; buf[ptr]= 1
###        ptr = ptr + 1 ; buf[ptr]= defcom[2,com]
        ptr = ptr + 1 ; buf[ptr]= defcom[2,typ]  # jb typ vice com 3/23/00
       }
 
     else
       {
        #$% search FLD table for match
        for (fld=1; ; fld = nxtfld(fld))
          {
          if (fld > dcfld)
              {
              pause "That CATegory calls for an UNDEFINED FIELD."
              pause "Refer this problem to the software analysts."
              stop
              }
 
          if (deffld[fld] == deftyp[typ]) break
          }
        #$% check "optional" flag and occurance count
        rcnt = deftyp[typ+1]
        if (rcnt < 0)
          {rcnt = - deftyp[typ+1]
           #$% if first "optional" field, save "optional" pointer
           if (bufopt==0)
              bufopt=ptr
          }
 
        #$% loop for each occurance of this field
        do i = 1, rcnt
          {ptr = ptr + 1 ; buf[ptr]= deftyp[typ]
 
           #$% build required fields into buffer
           acnt = deffmt[1,abs(deffld[fld+2])]-1
           ptr = ptr + 1 ; buf[ptr]= acnt
 
           do j = 1, acnt
             {ptr = ptr + 1 ; buf[ptr]= %'*REQ*'%
             }
          }
       }
    }
  buflen = ptr
  if (bufopt == 0) bufopt = ptr       # BUFOPT = last word of required data
 
  # shift optional area of WORK to the right to allow BUF[req] to be inserted
 
                                       # shift WORK right (bufopt words)
                                       # leftmost word to shift = wrkopt
                                       # rightmost word to shift = work[1]
                                       #
  if (bufopt > 0)
    {
     k = work[1] + bufopt              # NEW rightmost word
     L = work[1]                       # OLD rightmost word
 
     repeat
       {
        work[k] = work[L]
        k = k - 1
        L = L - 1
       } until (k<=wrkopt | L<1)        # reh 4/89, was <
 
     do k = 1, bufopt
       {
        work[k+wrkopt] = buf[k]
       }
 
     #$% update "optional" pointer
     wrkopt = wrkopt + bufopt
     work[1] = work[1] + bufopt
    }
 
  # move optional portion of OUT to WORK
 
  for (k = bufopt+1; k <= buflen; k = k + 1)
    {
     ptr = work[1] + 1
     work[ptr] = buf[k]
     work[1] = ptr
    }
 
  return
 
  end

 
 
  subroutine bsbldC(defcom,dccom,    # common definition table and size
                 deftyp,dctyp,       # type definition table and size
                 deffld,dcfld,       # field definition table and size
                 defarg,dsarg,dcarg, # argument definition table and size
                 deffmt,dcfmt)       # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSBLDC loads the requested record
  #$%            from disk to memory.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%            BSLIST
  #$%
  #$% Calls:     BSBLDB
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
## implicit integer (a-z)
#
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt # jb E2145 3/27/00
  literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
                 defarg[dsarg,dcarg],deffmt[5,dcfmt],args[40],qfld,
                 arg1,qarg
 
  Integer i,j,k,k2,L,m,ninput,ptr,narg,cntL  # jb E2145 3/27/00
  Integer   cur, NXTFLD,NXTWRK # jb E2145 (2 Statement f'ns) 3/27/00
  Integer   lcomp_v
 
  integer    verr,ptrcnt,argcnt,acnt,fldpnt,fldcnt,
             scan,argn,argh,argtyp,argrpt,fld,tpnt,arg
 
  include    "blmain.inc"
 
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtcom(cur) = cur + 1                      # .DEFCOM
#!!     nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFTYP
     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#
#
 i = oldpos
 l = recsz
  read (31, REC=i) (out[m],m=1,l)
  oldlen = out[1]+1
  out[1] = oldlen
  for (k = recsz + 1; k <= oldlen; k = k + recsz)
    {
     i = i + 1
     l = l + recsz
     read (31, REC=i) (out[m],m=k,l)
    }
 
#*********************************************************************
#  read (31, REC=oldpos) (out[m],m=1,recsz)
#  oldlen = out[1]+1
#  out[1] = oldlen
#
#  for (k = recsz + 1; k <= (oldlen+recsz-1); k = k + recsz)
#    {
#     i = oldpos + (k-1)/recsz
#     l = k+recsz-1
#     read (31,REC=i) (out[m],m=k,l)
#    }
######################################################################
 
  ninput = oldlen - 1
 
        #************************************************************
                                         # DATA INPUT ***************
 
          #process input
 
          scan = 2
 
          repeat
           {#   Search for the field entered.......
 
            qfld = OUT[scan]
            fldcnt=0
            fldpnt=0
 
            # find the field (keep cnt and ptrs)
 
            for (ptr=2;ptr < work[1];ptr=nxtwrk(ptr))
             {
              if (work[ptr]!=qfld)       # Match?
               {if (fldpnt==0) next      # haven't found one yet
                else break               # found some and now beyond
               }
              else
               {fldcnt = fldcnt + 1      # count the occurrence
                if (fldcnt == 1)
                 {fldpnt = ptr           # set pointer to first occurrence
                 }
               }
             }
 
            if (fldpnt <= 1)
             {                          # not a field name.......
              scan = scan + 1
              next
             }
                                          # process input field
            else
             {verr = 0                    # reset error count to zero
              ptrcnt = 0                  #     & arguments used counter
              argcnt = 0
              args[1] = %'*REQ*'%
              acnt = work[fldpnt+1]      # save count of arguments
                                         # fldpnt+2 points to first argument
 
              # Validate arguments
 
              # find the field in the field table....
              for (fld=1;deffld[fld] != qfld;fld=nxtfld(fld))
               {continue
               }
 
              narg=deffld[fld+1]-1        # define the number of different arg
 
              do cntl= 0, narg
               {qarg = deffld[fld+3+cntl*2]
 
                                          # find the argument in the arg tbl
                for (arg=1;defarg[1,arg] != qarg;arg=arg+1)
                 {continue
                 }
 
                argrpt = deffld[fld+4+cntl*2]
                argtyp = defarg[2,arg]/1000         # setup the type of test
                if (argtyp>9) argtyp = 6            # types >=9 default to 6
                argn = defarg[2,arg] - argtyp*1000  # setup the size of list
                argh = argtyp
 
                do k = 1, argrpt
                 {argcnt = argcnt + 1
                  ptrcnt = ptrcnt + 1
                  arg1=OUT[scan+ptrcnt]
                  args[argcnt]=arg1
 
                  # ** test the field *********************
                 }
               }
 
              if (verr != 0)
               {                  #Remainder of the input ignored because of
                continue          #the above errors"
               }
 
               #$% otherwise if build is category
              else
               {if (qfld == 'CAT')
                 {if (typed)
                   {
                    continue
                   }
                  else
                   {oldtyp = args[1]
                    typed = .true.
 
                    #$% modify the work record
                    call bsbldB(defcom, # common definition table
                    dccom,              # common definition table size
                    deftyp,dctyp,       # type definition table and size
                    deffld,dcfld,       # field definition table and size
                    defarg,dsarg,dcarg, # argument definition table and size
                    deffmt,dcfmt)       # format definition table and size
 
                   }
                 }
 
                # Find first un-entered field match.....
 
                fld = fldpnt
                tpnt = fldpnt
 
                do j = 1, fldcnt
                 {
                  #$% test if field argument is required
                  if (lcomp_v(work[fld+2], '*REQ*') == 0)
                   {tpnt = fld
                    break
                   }
                  fld = nxtwrk(fld)
                 }
 
                # modify work record
 
                do k2 = 1, argcnt
                 {work[tpnt+1+k2] = args[k2]
                 }
 
                scan = scan + 1 + ptrcnt
               }
             }
 
           } until (scan > ninput)       # end of REPEAT (input scan)
 
 
 
  return
  end

 
 
  subroutine bschek(work,            # current record array
                    wrkopt,          # pointers to the work array
                    out)             # output format record
 
#####################################################
  #$%
  #$% Purpose:   BSCHEK makes sure all required
  #$%            parameters have been entered.
  #$%            If required parameters are miss-
  #$%            ing, it counts the number and
  #$%            stores it in an error count.
  #$%            If no errors exist it builds an
  #$%            output record.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%
  #$% Calls:     None
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-z)
 
  literal   work[$work_size],out[$work_size]
  Integer i,ptr,serr,cnt,wrkopt, loading
  Integer cur, NXTWRK   # jb E2145 (Statement f'n & argument) 3/27/00
  Integer lcomp_v
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#    nxtcom(cur) = cur + 1                      # .DEFCOM
#    nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFTYP
#    nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#    nxtarg(cur) = cur + 1                      # .DEFARG
     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#
#9001 format (1x,'The field ',a5,' still requires input.')
 
call loading_build (loading)                # E2141 dew 6/14/00
 
  ptr = 1
  serr = 0
 
  for (cnt=2; cnt <= work[1]; cnt = nxtwrk(cnt))
     {
      if (work[cnt] == '*CONS')       # Is the field a constant ?
         {
          ptr = ptr + 1               # Yes -- build it in
          out[ptr] = work[cnt+2]
         }
 
      else
         {
          if (lcomp_v(work[cnt+2], '*REQ*') != 0) # Is the field entered ?
             {
              ptr = ptr + 1           # Yes -- Build it in
              out[ptr] = work[cnt]
              do i = 1, work[cnt+1]
                 {
                  ptr = ptr + 1
                  out[ptr] = work[cnt+1+i]
                 }
             }
          else if (cnt <= wrkopt)     # No, Is it required?
             {
              call echov('The field ')
              call echohn(work[cnt],8)
 
              if (loading & cnt > 2)    # Bypass errors (Beyond NAME)
                {                       # Yes -- Display notice
                call echov(' requires input, ignored for LOAD.')
                }
              else
                {                       # No -- Display requirement
                call echov(' still requires input.')
                serr = serr + 1
                }
 
              call echor
             }
         }
     } # end of testing and building OUT
 
  out[1] = ptr-1                      # Save OUT length
 
  if (serr != 0) out[1] = 0           # Any errors ?  If Yes -- zap OUT[1]
 
  return
  end
 

 
 
#    Process field delete
#
      subroutine bsdele(qfld,             # the name of the field to delete
                       defcom,dccom,      # common definition table and size
                       deftyp,dctyp,      # type definition table and size
                       deffld,dcfld,      # field definition table and size
                       defarg,dsarg,dcarg,# argument definition table and size
                       deffmt,dcfmt)      # format definition table and size
 
 
#################################################
      #$%
      #$% Purpose:   BSDELE deletes a field from
      #$%            the current record.
      #$%
      #$% Called By: BUILD PROCESSING EQUIPMENT
      #$%
      #$% Calls:     ANALYZ     GETLN
      #$%
      #$% Tables:    None
      #$%
      #$% Date:      NOV 79
      #$%
      #$% Author:    Dana Wills
      #$%
      #################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##      IMPLICIT INTEGER (A-Q,S-Z)
 
##############################################################################
 
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt # jb E2145 3/27/00
  literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
             defarg[dsarg,dcarg],deffmt[5,dcfmt]
 
##############################################################################
####
####  BASIC DATA DECLARATIONS
###
##############################################################################
 
    literal    wfmt[5],kans[80],qfld
    real*4     fval
 
    Integer cur, NXTFLD,NXTWRK  # jb E2145 (St.Functions & arg) 3/27/00
    Integer j,k,m,acnt,ilen,iwid,fmt,fld,fldcnt,entcnt,ptr,
            nkans,istr          # jb E2145  3/27/00
    Integer IS_ALPHA_NUMERIC    # jb E2145 Function in LBUTIL.rat 3/27/00
    Integer lcomp_v
 
    character  line[80],strg[ARB]
 
 
      include    "blmain.inc"
 
##############################################################################
####
####      FORMAT STATEMENTS
####
##############################################################################
 
9002 format (80a1)
9004 format (1x,'The field "',A5,'" Could not be found.')
9005 format (1x,i3,') ', 100a1 )
9006 format (1x,'Enter the number(s) of the entry(s) to be removed'/,
             1x,'(To not remove anything, enter 0).............', $ )
9007 format (1x,'Field delete is aborted.  Nothing Removed.')
9008 format (x,a5,2x,100a1)
9020 format (1x,'There are no entries of that field to remove.')
9021 format (1x,'Has(have) been removed.')
 
#####################################################################
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtcom(cur) = cur + 1                      # .DEFCOM
#!!     nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFTYP
     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#!!     nxtrec(cur) = cur + (oldlen+recsz-1)/recsz # .Data File
#!!     nutest(r) = $isnumeric (r)                 # Test numeric
#
##############################################################################
####
####   BEGIN LOGIC
####
##############################################################################
#
 
 fldcnt=0    # for counting field occurrences
 entcnt=0    # for counting entered fields
 
 # out[entcnt] will be used to point to entered occurrences
 
 # find the field (keep cnt and ptrs)
 
 for (ptr=2;ptr < work[1];ptr=nxtwrk(ptr))
 
  {if (work[ptr]!=qfld)     # MATCH ?
    {if (fldcnt==0) next      # haven't found one yet
     else break               # found some and now beyond
    }
   else                     # YES
    {fldcnt = fldcnt + 1             # count occurrence
     if (lcomp_v(work[ptr+2], '*REQ*') == 0) next
     # else
     entcnt = entcnt + 1             # count entry
     out[entcnt] = ptr               # point to entry
    }
  }
 
 if (fldcnt <= 0)
  {
	call echov('The field "')
	call echohn(qfld,$$maxlit)
	call echov('" Could not be found.'); call echor
    return
  }
 
 if (entcnt <= 0)
  {
	call echov('There are no entries of that field to remove.')
    return
  }
 
 # find the field in FLDTBL for FMT
 
 for (fld=1;deffld[fld]!=qfld;fld=nxtfld(fld))
    {continue
    }
 istr =    deffld[fld+2]
 fmt = abs(deffld[fld+2])
 acnt = deffmt[1,fmt]  # save # of arguments to print
 
 if (entcnt > 1)            # if more than one occurrence of the field
  { # Display all fields (w/a sequence number)
   do k = 1, entcnt
    {
     ilen = 0
     ptr = out[k]
     call echoib(k,3)
     call echov (')  ')
 
     for (m=ptr+2; m <= ptr+acnt; m=m+1)
       {
        if (istr < 0)
            {
            if (m==ptr+2) call smovv ("  ",strg,ilen)
            call smovh (work[m],$$maxlit,strg,ilen)
            }
        else if (is_alpha_numeric (work[m]) == YES)
            {
            call smovv ("   ",strg,ilen)
            call smovh (work[m],$$MAXname,strg,ilen) # jb E2141 (vice 5) 1/4/00
            }
        else if ($iswhole (work[m]))  # integer check only
            {
            call smovv (" ",strg,ilen)
 
            iwid = 7                   # reh 7/91
 
            if (work[m] > 0)           # reh 7/91
                {
                iwid = max(7,int(1 + log10(work[m]))) # jb E2141 (7; 1+) 1/4/00
                }
            call smovib (int(work[m]),iwid,strg,ilen)
            }
        else
            {
            call smovv (" ",strg,ilen)
            fval = work[m]     # convert to 32-bit real
            call smovf (fval,1303,strg,ilen) # display in floating point
            }
        }
 
        ilen = ilen + 1
 
        call echoh(qfld,5)
        call echoh(strg[1],ilen)
        call echor
    }
 
    call echor
    call echov (' Enter the number(s) of the entry(s) to be removed')
    call echor
    call echov (' separating with a space. ')
    call echor
    call echov (' TO NOT REMOVE ANYTHING, Enter Zero(0)).............')
 
    call getlnh (line,80)
 
    call anlyz (line,kans,nkans)
 
    if (kans[1] <= 0 | kans[1] > entcnt | kans[1] != int(kans[1]))
      {call echor
       call echov (' Field delete is aborted.  Nothing Removed.')
       call echor
       return
      }
  }
 else                       # only one occurrence entered (at this time)
  {kans[1] = 1
   kans[2] = 0
   nkans = 1
  }
 
 #$% loop for each entered field
 for (j = entcnt; j >= 1; j=j-1)
  {
   #$% loop for each number entered (to be removed)
   for (k=1;k<=nkans; k=k+1)
     {
      if (kans[k] == j)
       {
        ilen = 0
        ptr = out[j]
#                                                     begin 11/20/90 trs
 
        for (m=ptr+2; m <= ptr+acnt; m=m+1)
           {
            if (istr < 0)
                {
                if (m==ptr+2) call smovv ("  ",strg,ilen)
                call smovh (work[m],$$MaxLit,strg,ilen)
                }
            else if (is_alpha_numeric (work[m]) == YES)
                {
                call smovv ("   ",strg,ilen)
                call smovh (work[m],$$MAXname,strg,ilen)# jb E2141 vs 5  1/4/00
                }
            else if ($iswhole (work[m]))  # integer check only
                {
                call smovv (" ",strg,ilen)
 
                iwid = 7                   # reh 7/91
 
                if (work[m] > 0)           # reh 7/91
                    {
                    iwid = max(7,int(1 + log10(work[m]))) # jb (7; 1+) 1/4/00
                    }
                call smovib (int(work[m]),iwid,strg,ilen)
                }
            else
                {
                call smovv (" ",strg,ilen)
                fval = work[m]     # convert to 32-bit real
                call smovf (fval,1303,strg,ilen) # display in floating point
                }
           }
 
		call echohn(qfld,$$maxlit)
	    call echov("  ")
		for (m=1; m<=ilen; m=m+1)
			call echo(strg[m])
		call echor
 
        # Replace the fields arguments with '*REQ*'
        do m = ptr+2, ptr+acnt
         {work[m] = %'*REQ*'%
         }
        #$% set flag for "save" function to update disk
        anyinp = .true.
        break
       }
     }
  }
 
call echov('Has(have) been removed.'); call echor
   # end of field delete
 
return
end

 
 
#
# Process Help requests
#
#
  subroutine bshelp (irtn,               # input list
                     defcom,dccom,       # common definition table and size
                     deftyp,dctyp,       # type definition table and size
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg) # argument definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSHELP processes HELP commands.  It
  #$%            displays a short summary of how to
  #$%            use the system commands when requested.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%
  #$% Calls:     BSHLPF
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-q,s-z)
#
  Integer    dccom,dctyp,dcfld,dsarg,dcarg      # jb E2145 3/27/00
  literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
             defarg[dsarg,dcarg],irtn[80],qarg,fname
  Integer  i,j,k,cflg,fopt,kqty                  # jb E2145 3/27/00
 
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
#
#*****
 
define($blhelp_basic,
	call echor; call echov(' *** HELP ***'); call echor
    call echov(' HELP may be used to retrieve information about available'); call echor
    call echov(' commands and defined fields. The form of the help command is:'); call echor
    call echov(' HELP <arg> <arg2> <arg3> .... <argn> '); call echor
    call echov(' where <arg> may be any of the fields in the defined record, or'); call echor
    call echov(' any of the following commands: FIND, SAVE, DELETE, BYE, QUIT,'); call echor
    call echov(' MORE, KILL, PRINT, or LIST.'); call echor
    call echov(' HELP HELP displays the infomation on all commands.'); call echor
    call echov(' HELP ALL displays the infomation for all defined fields.'); call echor
)
define($blhelp_print,
	call echor; call echov(' *** PRINT ***'); call echor
    call echov(' A <return> alone PRINT, will display the current values'); call echor
    call echov(' for the record maintained in the internal working space.  The '); call echor
    call echov(' name of each defined field will be typed out along with its '); call echor
    call echov(' assigned value (if assigned).  If no value has been assigned,'); call echor
    call echov(' then a list of the arguments required for that field will be '); call echor
    call echov(' typed.'); call echor; call echor
    call echov(' Argument lists prefaced with the word "Opt" indicate'); call echor
    call echov(' that the field is optional for the record and is not required'); call echor
    call echov(' to be input prior to a SAVE  command.'); call echor
)
define($blhelp_find,
	call echor; call echov(' *** FIND ***'); call echor
    call echov(' FIND is used to locate and load an existing characteristic'); call echor
    call echov(' record into the internal working space.  Prior to searching for'); call echor
    call echov(' the record, the record that is in the internal working space'); call echor
    call echov(' is written to disc if neccessary.'); call echor
    call echov(' The requested record ,if found, is then typed.  If the record'); call echor
    call echov(' is not found, then the internal working space is left empty.'); call echor
)
define($blhelp_kill,
	call echor; call echov(' *** KILL ***'); call echor
    call echov(' KILL is used in conjunction with MORE to clear all fields in'); call echor
    call echov(' the record in memory.  This can be used to un-do any changes'); call echor
    call echov(' that have been made to a record prior to it being SAVEd (or'); call echor
    call echov(' MOREd).  It also resets the record pointers so that the'); call echor
    call echov(' contents of the record in memory are not associated with any'); call echor
    call echov(' record on disk.'); call echor
)
define($blhelp_quit,
	call echor; call echov(' *** QUIT/BYE ***'); call echor
    call echov(' QUIT and BYE have identical functions, which is to drop all'); call echor
    call echov(' changes, etc. and return to the main BUILD program for '); call echor
    call echov(' further direction.'); call echor
)
define($blhelp_list,
	call echor; call echov(' *** LIST ***'); call echor
    call echov(' LIST itemizes the NAMEs of the current file.  It provides a'); call echor
    call echov(' quick way to check the file for a series of objects.'); call echor
)
define($blhelp_save,
	call echor; call echov(' *** SAVE ***'); call echor
    call echov(' SAVE verifies that all required fields have been entered'); call echor
    call echov(' and rewrites the current record if it has been modified'); call echor
    call echov(' since the last FIND, MORE or KILL command.  New records are'); call echor
    call echov(' added to the end of the file, and modified records are'); call echor
    call echov(' rewritten in the position that they occupied.'); call echor
    call echov(' The NAME is not verified to be unique in the file.  Therefore,'); call echor
    call echov(' the user should do a FIND on the name in question prior'); call echor
    call echov(' to adding it into the file.'); call echor
)
define($blhelp_more,
	call echor; call echov(' *** MORE ***'); call echor
    call echov(' MORE does the same command as SAVE in that the record in the '); call echor
    call echov(' internal working space is verified for all required fields,'); call echor
    call echov(' (if any changes had been made), and rewrites the record as'); call echor
    call echov(' neccessary.  The differance from SAVE is that the values for the'); call echor
    call echov(' defined fields are maintained in memory, with the NAME field'); call echor
    call echov(' reset, to allow another record to be entered that only requires'); call echor
    call echov(' slight changes to the characteristics of the prior record.'); call echor; call echor
    call echov(' For example:'); call echor; call echor
    call echov('       FIND abc'); call echor
    call echov('       MORE'); call echor
    call echov('       NAME xyz'); call echor
    call echov('       MORE'); call echor; call echor
    call echov(' Will duplicate record "abc" (already on file) as record "xyz".'); call echor
    call echov(' In addition, the field values will still remain in the internal'); call echor
    call echov(' working space for additional duplicates to be generated.'); call echor
)
define($blhelp_delete,
	call echor; call echov(' *** DELETE ***'); call echor
    call echov(' DELETE has a dual purpose.  It can be used to remove a complete '); call echor
    call echov(' record (entry) from the file, or to remove a specific occurence of'); call echor
    call echov(' any field.'); call echor
    call echov(' To delete record "abc", the form is:'); call echor; call echor
    call echov('       FIND abc'); call echor
    call echov('       DELETE ENTRY'); call echor; call echor
    call echov(' To remove the value for the field "xsect" from the current record:'); call echor; call echor
    call echov('       DELETE xsect'); call echor; call echor
    call echov(' In the instances of multiple occurrences of the field, the values'); call echor
    call echov(' for all entries will be displayed and you will be requested to'); call echor
    call echov(' identify the specific entry(s) by number.'); call echor
)
9041 format ("1The basic record contains the following",i3," fields:"/)
9042 format (///"0The records of CATegory ",a5," have",i3," additional fields:"/)
 
 
  if (irtn[2] == $BLANKLIT | irtn[2] == 0)
  {
	$blhelp_basic
 
    return
   }
 
  #$% for each entry from input list
  for (i=2; irtn[i] != $BLANKLIT & irtn[i] != 0 ; i = i + 1)
    {qarg = irtn[i]
     if (qarg == 'PRINT')
       {
        $blhelp_print
       }
 
     else if (qarg == 'FIND')
       {
        $blhelp_find
       }
 
     else if (qarg == 'KILL')
       {
        $blhelp_kill
       }
 
     else if (qarg == 'BYE')
       {
        $blhelp_quit
       }
 
     else if (qarg == 'QUIT')
       {
        $blhelp_quit
       }
 
     else if (qarg == 'HELP')
       {
        $blhelp_basic            # basic help
        $blhelp_print            # print
        $blhelp_find             # find
        $blhelp_kill             # kill
        $blhelp_quit             # bye/quit
        $blhelp_list             # list
        $blhelp_save             # save
        $blhelp_more             # more
        $blhelp_delete           # delete
       }
 
     else if (qarg == 'LIST')
       {
        $blhelp_list
       }
 
     else if (qarg == 'SAVE')
       {
        $blhelp_save
       }
 
     else if (qarg == 'MORE')
       {
        $blhelp_more
       }
 
     else if (qarg == 'DELET' | qarg == 'DELETE') # jb  1/4/00
       {
        $blhelp_delete
       }
 
     else if (qarg == 'ALL')
       {
        cflg = 0
		call echov("1The basic record contains the following")
		call echoi(dccom); call echov(" fields:"); call echor
        #$% for each common field entry
        for (k=1; k<=dccom; k=k+1)
           {
            #$% save field name and field option
            fname = defcom[1,k]
            fopt  = defcom[2,k]
 
            #$% if field name is category
            if (fname == 'CAT') cflg = 1
 
            #$% call to display field help
            call bshlpf (fname,fopt,     # field name, and qty option/req flag
                         deffld,dcfld,   # field def table and size
                         defarg,dsarg,dcarg) # argument def table and size
           }
 
        #$% if flag is zero, return
        if (cflg == 0) return
 
        #$% for each def type entry
        for (k=1; k<dctyp; k=k+2)
           {
            #$% type additional fields to CRT
            kqty = deftyp[k+1]
			call echor; call echov("The records of CATegory ")
            call echohn(deftyp[k],$$maxlit)
			call echov(" have")
            call echoib(kqty,2)
			call echov(" additional fields:"); call echor
            #$% for each arguement
            for (j=1; j<=kqty; j=j+1)
               {
                k=k+2
 
                #$% save field name and field option
                fname = deftyp[k]
                fopt  = deftyp[k+1]
 
                #$% call to display field help
                call bshlpf (fname,fopt,     # field name, and qty option/req
                             deffld,dcfld,   # field def table and size
                             defarg,dsarg,dcarg) # argument def table/size
               }
           }
       }
 
     else                               # try for field
       {
        #$% call to display field help
        call bshlpf (qarg,0,            # field name, and qty option/req flag
                     deffld,dcfld,      # field definition table and size
                     defarg,dsarg,dcarg)# argument definition table and size
       }
    }
 
  return
  end
 

 
 
#
# Process Help requests for field info
#
#
  subroutine bshlpf (iarg,iopt,          # field name, and qty option/req flag
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg) # argument definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSHLPF displays the field that
  #$%            HELP requested for, the para-
  #$%            meters that define that field,
  #$%            and the valid entries allowed
  #$%            on these parameters.
  #$%
  #$% Called By: BSHELP
  #$%
  #$% Calls:     None
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-q,s-z)
#
  Integer    dcfld,dsarg,dcarg              # jb E2145 3/27/00
  literal    deffld[dcfld],defarg[dsarg,dcarg],
             qarg,info[3],iarg,argn,jarg,arglst[40],ialfa
  Integer cur, NXTFLD # jb E2145 (Statement f'n & arg.) 3/27/00
  integer j,m,V1,Vn,iopt,cntL,fld,Vx,       # jb E2145  3/27/00
            arg,argrpt,narg,ncnt,argtyp     # jb E2145  3/27/00
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
#
#*****
 
 
9010 format (1h0,a5,1x, $ )
9011 format (1h+,'is not a COMMAND or a FIELD.'/)
9012 format (1h+,4a8,3a5/)
9013 format (1h ,i7,') ',a5,2x, $ )
 
9020 format (1h+,'A Special Value (Refer to the User Manual).'/)
9021 format (1h+,'Any Numeric value.'/)
9022 format (1h+,'Any Numeric value in the range'i5,' to ',i7,'.'/)
9023 format (1h+,'Any Numeric value from the following list:',/,
                  5(20x,6i7/))
9024 format (1h+,'Any Latitude.'/)
9025 format (1h+,'Any Longitude.'/)
9026 format (1h+,'Any Alphanumeric value.'/)
9027 format (1h+,'Any Alphanumeric value in the range'a5,' to ',a5,'.'/)
9028 format (1h+,'Any Alphanumeric value from the following list:',/,
                  5(20x,6(2x,a5/)))
9029 format (1h+,'Any Numeric value in the range'f10.3,' to ',f10.3,'.'/)
9030 format (1x)
 
############################################################################
 
  qarg = iarg
   call echor
   call echor
   call echoh(qarg,5)
   call echov (" ") # for vts jfr 2/9/94
 
  #$% if option flag is zero, enter blanks into info message
  if (iopt == 0)
     {
      info[1]= $BLANKLIT
      info[2]= $BLANKLIT
      info[3]= $BLANKLIT
     }
  #$% else if option flag is less than zero, enter optional into info message
  else if (iopt < 0)
     {
      info[1]= ialfa(iopt)
      info[2]= %' Opti'%
      info[3]= %'onal-'%
     }
  else
     {
      #$% otherwise enter required into info message
      info[1]= ialfa(-iopt)
      info[2]= %' Requ'%
      info[3]= %'ired-'%
     }
 
  ncnt = 0
 
  #$% find field in the table and build into it
  for (fld=1; fld==fld; fld=nxtfld(fld))
    {
     if (fld > dcfld)
       {break
       }
 
     else if (deffld[fld] == qarg)
       {
        # build tbl of args
        narg = deffld[fld+1] - 1     ###############
 
        do cntl = 0, narg
          {jarg = deffld[fld+3+cntl*2]
           argrpt = deffld[fld+4+cntl*2]
 
           do j = 1, argrpt
             {ncnt = ncnt + 1
              arglst[ncnt] = jarg
             }
          }
        break
       }
    }
 
  if (ncnt == 0)
       {
        call echov ('is not a COMMAND or a FIELD.')
        call echor
        return
       }
 
  call echoh(deffld[nxtfld(fld)-4],32)
  call echoh(info[1],5)
  call echoh(info[2],5)
  call echoh(info[3],5)
  call echor
 
 
  do j = 1, ncnt
    {
     argn = arglst[j]
 
     call echor
     call echoib(j,7)
     call echov (') ')
     call echoh(argn,5)
     call echov("  ")
 
     for (arg=1; defarg[1,arg] != argn; arg = arg + 1)
        {continue
        }
 
     # set pointers.......
 
     argtyp = defarg[2,arg]/1000
     V1 = 3
     Vn = defarg[2,arg] - argtyp*1000 + 2
     Vx = defarg[2,arg] - argtyp*1000
 
     if (argtyp  > 9) argtyp = 6
 
     # display specifics......
 
     if      (argtyp == 1)
       {
 
        call echov ('Any Numeric value. ')
        call echor
       }
     else if (argtyp == 2)
       {
 
        call echov ('Any Numeric value in the range ')
        call echoi(int(defarg[3,arg]),5)
        call echov (' to ')
        call echoi(int(defarg[4,arg]),7)
        call echov ('.')
        call echor
       }
     else if (argtyp == 3)
       {
 
        call echov ('Any Numeric value from the following list: ')
        for (m=0; m+V1 <= Vn; m=m+1)
           {
            if (mod(m,6)==0)
              {
                call echor
                call echov("                    ")
              }
 
            call echoib(int(defarg[m+V1,arg]),7)
           }
        call echor
        call echov (" ")
       }
     else if (argtyp == 4)
       {
 
        call echov ('Any Latitude.')
        call echor
       }
     else if (argtyp == 5)
       {
 
        call echov ('Any Longitude.')
        call echor
       }
     else if (argtyp == 6)
       {
 
        call echov ('Any Alphanumeric value.')
        call echor
       }
     else if (argtyp == 9)
       {# ALPHA String
 
        if (Vx > 0)
            {
            call echov ('Any Alphanumeric String (up to ')
            call echoi (Vx)
            call echov (' characters)')
            }
        else
            {
            call echov ('...(more string)...')
            }
        call echor
       }
     else if (argtyp == 7)
       {
        call echov ('Any Alphanumeric value in the range')
        call echoh(defarg[3,arg],5)
        call echov (' to ')
        call echoh(defarg[4,arg],5)
        call echov ('.')
        call echor
 
       }
     else if (argtyp == 8)
       {
        call echov ('Any Alphanumeric value from the following list: ')
        for (m=0; m+V1 <= Vn; m=m+1)
           {
            if (mod(m,6)==0)
              {
                call echor
                call echov("                    ")
              }
            call echov ("  ")
            call echoh(defarg[m+V1,arg],5)
           }
        call echor
        call echov ("  ")
       }
     else if (argtyp == -2)                             # begin 11/20/90 trs
       {# FLOATING POINT RANGE
 
        call echov ('Any Numeric value in the range ')
        call echof(real(defarg[3,arg]),1003)
        call echov (' to ')
        call echof(real(defarg[4,arg]),1003)
        call echov ('.')
        call echor
 
       }                                                # end 11/20/90 trs
     else
       {
        call echov ('A Special Value (Refer to the User Manual).')
        call echor
       }
 
    } # end of do-to-ncnt loop
 
 
  return
 
  end
 

 
 
#
# Generate hard copy output
#
#
  subroutine bslist (object,cfile,       # current object type,file name
                     defcom,dccom,       # common definition table and size
                     deftyp,dctyp,       # type definition table and size
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg, # argument definition table and size
                     deffmt,dcfmt)       # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSLIST sorts the files stored on
  #$%            the disk and generates a hardcopy
  #$%            listing.
  #$%
  #$% Called By: BSPREP
  #$%
  #$% Calls:     BSBLDA     BSBLDC     BSPRIN
  #$%            ORDER1
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-z)
#
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt # jb E2145 3/27/00
  literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
             defarg[dsarg,dcarg],deffmt[5,dcfmt]
  logical    print_flag
  literal    cfile[2],object[4],name[5000]
  Integer cur, NXTREC                           # jb E2145 3/27/00
  Integer i,m,knt,loop                          # jb E2145 3/27/00
  integer    ix[5000],pos[5000]
 
 
  include "blmain.inc"
 
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtcom(cur) = cur + 1                      # .DEFCOM
#!!     nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFTYP
#!!     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
#!!     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
     nxtrec(cur) = cur + (oldlen+recsz-1)/recsz # .Data file
 
9001 format('1',//,' **** ',a8,a4,' **************** ',4a8,' ***************'/)
9002 format (6(i4,')',a8))
9003 format (//,' ---',4a8,' Item #',i3,'  ',a8,' ---') # jb E2142 a8 1/4/00
 
  call echor
  call echoh(object, 4 * $$maxLit)
  call echov ('.....')
 
  name[1] = $BLANKLIT
  knt = 0
 
  print_flag = .true.
  lfc = 55
 
  #$% print current file name and object type
  write (lfc,9001) cfile,object
 
  #$% for each record entry
  for (i = 2; i <= reccnt; i = nxtrec(i))
     {
      knt = knt + 1
 
       #$% read record
      read (31, REC=i) (out[m],m=1,recsz)
 
      oldlen = out[1] + 1
      name[knt] = out[3]
      pos[knt] = i
     }
 
  #$% call to sort record
  call order1 (name,ix,knt)
 
  #$% print record name is sorted order
  write (lfc,9002) (m,name[ix[m]],m=1,knt)
 
  #$% loop through each record name
  for (loop = 1; loop <= knt; loop = loop + 1)
     {
      #$% print header of reocrd
      write (lfc,9003) object,loop,name[ix[loop]]
 
      #$% call to set up work record
      call bsbldA (work,               # current record array
                   wrkopt,             # pointers to the work array
                   defcom,dccom,       # common definition table and size
                   deftyp,dctyp,       # type definition table and size
                   deffld,dcfld,       # field definition table and size
                   defarg,dsarg,dcarg, # argument definition table and size
                   deffmt,dcfmt)       # format definition table and size
 
 
      oldpos = pos[ix[loop]]            # set file pointers to Random Address
 
      #$% call to load the required record from disk to memory
      call bsbldC(defcom,dccom,       # common definition table and size
                  deftyp,dctyp,       # type definition table and size
                  deffld,dcfld,       # field definition table and size
                  defarg,dsarg,dcarg, # argument definition table and size
                  deffmt,dcfmt)       # format definition table and size
 
 
      #$% call to display the current work record
      call bsprin(work,               # current record array
                  wrkopt,             # pointers to the work array
                  print_flag,         # output to be PRINTed (vs TYPEd)
                  deffld,dcfld,       # field definition table and size
                  defarg,dsarg,dcarg, # argument definition table and size
                  deffmt,dcfmt)       # format definition table and size
     }
 
  return
 
  end
 

 
 
define(TBLOK,1)
define(DSCOM,2)
define(DSFMT,5)
define(DSOBJ,4)
#
# Input the data tables from the END of the data file
#
#
  subroutine bsltbl (istat,              # return status indicator
                     object,             # current object type
                     defcom,dccom,       # common definition table and size
                     deftyp,dctyp,       # type definition table and size
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg, # argument definition table and size
                     deffmt,dcfmt)       # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSLTBL inputs the data tables
  #$%            from the end of the data file
  #$%            on disk.
  #$%
  #$% Called By: BSPREP
  #$%
  #$% Calls:     IGETI      IGETW      IGETB
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-z)
#
  literal    defcom[DSCOM,ARB],deftyp[ARB],deffld[ARB],
             defarg[ARB,ARB],deffmt[DSFMT,ARB]
  literal    object[DSOBJ]
 
#  literal    defcom[DSCOM,dccom],deftyp[dctyp],deffld[dcfld],
#            defarg[dsarg,dcarg],deffmt[DSFMT,dcfmt]
 
#  literal    object[DSOBJ]
 
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt    # jb E2145 3/27/00
  Integer    istat,jstat,ival                       # jb E2145 3/27/00
 
  include   "blmain.inc"
 
#
#
#
  istat = ! TBLOK
  jstat = TBLOK
 
  call igeti (jstat,               # INITIALIZE iget
              31,                  # Logical unit number (always 31)
              reccnt+1,            # block to start reading from
              recsz)               # the record size
 
#  if (jstat != TBLOK)
#    { call echor
#      call echov (' Error from IGETI')
#      call echor
#      return
#    }
 
                                   # INPUT DATA TABLES ###################
 
  call igetw (ival,jstat)                # keyword to identify data tables....
 
  if (ival != 811124)
    {
#     call echor
#     call echov (' ival != 811124, ival == ')
#     call echoi (ival)
#     call echor
      return
    }
 
  call igetb (object,DSOBJ*2,jstat)        # object name
 
 
  call igetw (dccom,jstat)               # common table   > size
 
  call igetb (defcom,2*DSCOM*dccom,jstat)  #                > contents
 
 
  call igetw (dctyp,jstat)               # type table     > size
 
  call igetb (deftyp,dctyp*2,jstat)        #                > contents
 
 
  call igetw (dcfld,jstat)               # field table    > size
 
  call igetb (deffld,dcfld*2,jstat)        #                > contents
 
 
  call igetw (dsarg,jstat)               # argument table > size
  call igetw (dcarg,jstat)               #                > number
 
  call igetb (defarg,2*dsarg*dcarg,jstat)  #                > contents
 
 
  call igetw (dcfmt,jstat)               # format table   > number
 
  call igetb (deffmt,2*DSFMT*dcfmt,jstat)  #                > contents
 
  if (jstat == TBLOK) istat = TBLOK
 
  return
 
  end
 

 
 
define(ZCOM,200)
define(ZTYP,300)
define(ZFLD,2000)
define(ZARG,800)
define(ZFMT,200)
define(ZDSOBJ,4)
define(ZDSCOM,2)
define(ZDSFMT,5)
define(TBLOK,1)
#
# Prepare to generate hard copy output
#
#
  subroutine bsprep (cfile)             # Print the file
 
#####################################################
  #$%
  #$% Purpose:   BSPREP prepares to generate a
  #$%            hard copy output.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%
  #$% Calls:     BSLTBL     BSLIST
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-z)
#
 
  literal    defcom[ZCOM],deftyp[ZTYP],deffld[ZFLD],
             defarg[ZARG],deffmt[ZFMT]
 
  literal    cfile[2],object[ZDSOBJ]
  integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt
  Integer    istat                          # jb E2145  3/27/00
 
  call bsltbl (istat, #(status)    # LOAD DATA TABLES
               object,             # object type
               defcom,dccom,       # common definition table and size
               deftyp,dctyp,       # type definition table and size
               deffld,dcfld,       # field definition table and size
               defarg,dsarg,dcarg, # argument definition table and size
               deffmt,dcfmt)       # format definition table and size
 
  if (istat == TBLOK)
      call bslist (object,cfile,       # current object type, file name
                   defcom,dccom,       # common definition table and size
                   deftyp,dctyp,       # type definition table and size
                   deffld,dcfld,       # field definition table and size
                   defarg,dsarg,dcarg, # argument definition table and size
                   deffmt,dcfmt)       # format definition table and size
 
  else
    {
    call echor
    call echov ("Sorry, but the file ")
    call echoHn(cfile,2*$$maxLit)
    call echov (" is not properly initialized.")
    }
 
  return
  end
 

 
 
#
# Print current record (from work array)
#
#
  subroutine bsprin(work,              # current record array
                    wrkopt,            # pointers to the work array
                    print_data_flag,   # logical flag to indicate printed output
                    deffld,dcfld,      # field definition table and size
                    defarg,dsarg,dcarg,# argument definition table and size
                    deffmt,dcfmt)      # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSPRIN either displays the current
  #$%            work record at the terminal or
  #$%            generates a hardcopy printout.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%            BSLIST
  #$%
  #$% Calls:     PRCONV
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #$% Modified:  Carol Kropp - 10/95
  #$%            Changed string parameter dest to logical
  #$%            variable print_data_flag, to that string
  #$%            constants would not be passed.
  #$%
  #$%            Jim Allen - 1/97 (E1618)
  #$%            Add seconds to latitude and longitude format (changed
  #$%            9004 and calls to prconv to accomodate seconds).
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-q,s-z)
#
  literal    work[$work_size]
  integer    wrkopt
  Integer    dcfld,dsarg,dcarg,dcfmt    # jb E2145  3/27/00
  literal    deffld[dcfld],
             defarg[dsarg,dcarg],
             deffmt[5,dcfmt],wfmt[5],
             hfld,
             qarg
 
  real*4     fval
  Integer   cur, NXTFLD,NXTWRK  # jb E2145 (ST.F'ns & arg.) 3/27/00
  Integer   lcomp_v
 
  integer   lcnt,istr,
            j,k,m,acnt,argrpt,cntL,lfc,fmt,     # jb E2145   3/27/00
            ilen,iwid,narg,ptr,fld,pfld,        # jb E2145   3/27/00
            L1,L2,L3,kdir, IS_ALPHA_NUMERIC     # jb E2145   3/27/00
 
  character  arglst[120],line[ARB]
  logical    print_data_flag
#
 
9000 format (1x)
9001 format (1x,a5,1x,i2,1x,i8,'/',a5)
9002 format (1x,a5,'...',120a1)
9003 format (1x,a5,'..Opt',120a1)
9004 format (1x,a5,i4,'-',i2.2,'-',i2.2,a1)
9005 format (5a1)
9006 format (1x,100a1)
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#
 
#*****
 
#$% if print is requested, output to line printer
if (print_data_flag == .true.)  lfc = 55
 
#$% else output to CRT
else                lfc = -2
 
hfld = $BLANKLIT
 
if (print_data_flag) write (lfc,9000)
else                 call echor
 
#$% loop through each field entry
for (ptr=2;ptr<work[1];ptr=nxtwrk(ptr))
{
	#$% if entry is constant, continue
	if (lcomp_v(work[ptr],'*CONS') == 0)
    {
		continue
    }
    else       # find the field info in DEFFLD
    {
		for (fld=1;deffld[fld]!=work[ptr];fld=nxtfld(fld))
        {
           continue
        }
 
        if (work[ptr] != hfld)
        {								# construct a table of argument names
           hfld = work[ptr]
           narg = deffld[fld+1] - 1     # define # of diff args (rel zero)
           pfld = 0                     # set print cnt to zero
 
           lcnt = 1
           arglst[1] = $LPAREN
           do j = 2, 120
           {
		   		arglst[j] = $SPACE
           }
 
			do cntl = 0, narg
            {
				qarg = deffld[fld+3+cntl*2]
                argrpt = deffld[fld+4+cntl*2]
 
                if (cntl > 0) call smov(BLANK,arglst,lcnt)
 
                do j = 1, argrpt
                {
                	if (j > 1) call smov(BLANK,arglst,lcnt)
 
                	call smovhn(qarg,$$MAXname,arglst,lcnt) # jb #2141 vs 5 1/4/00
                }
			}
            lcnt = lcnt + 1
            arglst[lcnt] = $RPAREN
		}
        # put the format in WFMT
        istr =    deffld[fld+2]
        fmt = abs(deffld[fld+2])
        #$% if field entry is required
        if (work[ptr+2]== %'*REQ*'%)
        {
			if (ptr < wrkopt)
            {										# REQUIRED
            	#$% write field and arguement
                if (print_data_flag)
                {
			    	write (lfc,9002) work[ptr],(arglst[m],m=1,lcnt)
                }
                else
			    {
					call echoh(work[ptr],$$maxlit)
			   		call echov("...")
					for( m=1; m<=lcnt; m=m+1)
						call echo(arglst[m])
					call echor
			    }
			}
        	else
        	{						# OPTIONAL
     		  	if (pfld == 0 & print_data_flag != .true.)
        	    {
       		     	#$% write optional field and its argument
      		      	#write (lfc,9003) work[ptr],(arglst[m],m=1,lcnt)
					call echoh(work[ptr],$$Maxlit)
					call echov("..Opt")
					for( m=1; m<=lcnt; m=m+1)
					call echo(arglst[m])
					call echor
				  }
			}
       		pfld = pfld + 1
		}
    	#$% if field is latitude
    	else if (istr < 0)
        {
            acnt= deffmt[1,fmt]+ptr
 
            ilen=0
            call smovhn(work[ptr],$$MAXname,line,ilen)
            call smovv ("  ",line,ilen)
            for (m = ptr+2; m <= acnt; m=m+1)
            {
                call smovh (work[m],$$MaxLit,line,ilen)
            }
			if (print_data_flag)
            	write (lfc,9006) (line[m], m=1, ilen)
			else
			{
				for (m=1; m<=ilen; m=m+1)
					call echo(line[m])
				call echor
			}
            pfld = pfld + 1
        }
        #$% if field is latitude
        else if (work[ptr] == 'LAT')
        {
           call prconv (work[ptr+2],1,l1,l2,l3,kdir)
           #$% write the field name and its argument
		   if (print_data_flag)
           	write (lfc,9004) work[ptr],l1,l2,l3,kdir
		   else
		   {
				call echoh(work[ptr],$$Maxlit)
				call echoib(l1,4)
				call echov("-")
				call echoiz(l2,2)
				call echov("-")
				call echoiz(l3,2)
				call echo(kdir)
				call echor
		   }
           pfld = pfld + 1
        }
        else if (work[ptr] == 'LONG')
        {
           call prconv (work[ptr+2],2,l1,l2,l3,kdir)
           #$% write the field name and its argument
		   if (print_data_flag)
           	write (lfc,9004) work[ptr],l1,l2,l3,kdir
		   else
		   {
				call echoh(work[ptr],$$maxlit)
				call echoib(l1,4)
				call echov("-")
				call echoiz(l2,2)
				call echov("-")
				call echoiz(l3,2)
				call echo(kdir)
				call echor
		    }				
           pfld = pfld + 1
        }
        else
        {
            acnt= deffmt[1,fmt]+ptr
 
            ilen=0
            call smovhn(work[ptr],$$MAXname,line,ilen) # jb E2141 (vs 5) 1/4/00
            for (m = ptr+2; m <= acnt; m=m+1)
            {
                if (is_alpha_numeric (work[m]) == YES)
                {
                    call smovv ("   ",line,ilen)
                    call smovh (work[m],$$MAXname,line,ilen) # jb E2141 1/4/00
                }
                else if ($iswhole (work[m]))  # integer check only
                {
                    call smovv (" ",line,ilen)
 
                    iwid = 7                   # reh 7/91
 
                    if (work[m] > 0)           # reh 7/91
                    {
                        iwid = max(7,int(1 + log10(work[m]))) # jb 7; 1+ 1/4/00
                    }
                    call smovib (int(work[m]),iwid,line,ilen)
                }
                else
                {
                    call smovv (" ",line,ilen)
                    fval = work[m]     # convert to 32-bit real
                    call smovf (fval,1303,line,ilen) # display in floating point
                }
           }
		   if (print_data_flag)
				write (lfc,9006) (line[m], m=1, ilen)
		   else
		   {
				for (m=1; m<=ilen; m=m+1)
					call echo(line[m])
				call echor
		   }
           pfld = pfld + 1
 
		}
	}
}
  return
  end

 
 
  subroutine bssave
 
#####################################################
  #$%
  #$% Purpose:   BSSAVE saves the current record
  #$%            on disk and determines if the
  #$%            record is new or old.  It then
  #$%            keeps track of the number of
  #$%            records saved on disk.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%
  #$% Calls:     None
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
 
      include "blmain.inc"
 
  Integer i,i1,i2,i3,j,m, newcnt,oldsiz,newsiz,dest, shift # jb E2145 3/27/00
 
  newcnt = reccnt
  oldsiz = (oldlen+recsz-1)/recsz  # oldlen includes the VLI
  newsiz = (out[1]+recsz  )/recsz  # out[1] does not include the VLI
  dest = oldpos
 
  if (out[1] == 0) newsiz = 0      # delete record ?
 
  if (oldpos == 0)                 # New record ?
     {
      dest = reccnt + 1            # Yes -- store it on the end
      newcnt = reccnt + newsiz
     }
 
  else                             # NO --
     {
      if (newsiz < oldsiz)            # Is it smaller than it was ?
         {
          shift = oldsiz - newsiz     # Yes -- SHIFT LEFT the rest of the file
 
          do i = oldpos+oldsiz, reccnt
             {
              j = i - shift
              read (31,REC=i) (work[m],m=1,recsz)
              write (31, REC=j) (work[m],m=1,recsz)
             }
          newcnt = reccnt - shift            # Save the shorter record cnt
         }
 
      else if (newsiz > oldsiz)       # Is it larger than it was ?
         {
          shift = newsiz - oldsiz     # Yes -- SHIFT RIGHT the rest of the file
 
          for (i=reccnt; i>=oldpos+oldsiz; i=i-1)
             {
              j = i + shift
              read (31, REC=i) (work[m],m=1,recsz)
              write (31, REC=j) (work[m],m=1,recsz)
             }
          newcnt = reccnt + shift            # Save the larger record cnt
         }
     } # end of shifting section
 
  for (i=0; i<newsiz; i=i+1)          # Rewrite the record for the NEWSIZ
      {
       i1 = i * recsz + 1
       i2 = dest + i
       i3 = i1 + recsz - 1
 
       if (i3 > out[1]) i3 = out[1] + 1
 
       write (31, REC=i2) (out[m],m=i1,i3)
      }
 
  if (reccnt != newcnt)               # Update the RECCNT if needed
     {
      reccnt = newcnt
      write (31, REC=1) $Count_W_fingerprint(reccnt)
     }
 
  return
  end
 

 
 
define(DSCOM,2)
define(DSFMT,5)
define(DSOBJ,4)
#
# Output the data tables to the END of the data file
#
#
  subroutine bstblg (object,             # current object type
                     defcom,dccom,       # common definition table and size
                     deftyp,dctyp,       # type definition table and size
                     deffld,dcfld,       # field definition table and size
                     defarg,dsarg,dcarg, # argument definition table and size
                     deffmt,dcfmt)       # format definition table and size
 
#####################################################
  #$%
  #$% Purpose:   BSTBLG outputs the data tables (of
  #$%            the calling equipment processor)
  #$%            to the end of the data file on disk.
  #$%
  #$% Called By: BUILD PROCESSING ROUTINES
  #$%
  #$% Calls:     IPUTI      IPUTW      IPUTB
  #$%            IPUTC
  #$%
  #$% Tables:    None
  #$%
  #$% Date:      NOV 79
  #$%
  #$% Author:    Dana Wills
  #$%
  #####################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##  implicit integer (a-z)
#
  literal    defcom[DSCOM,ARB],deftyp[ARB],deffld[ARB],
             defarg[ARB,ARB],deffmt[DSFMT,ARB]
 
  literal    object[DSOBJ]
 
#  literal    defcom[DSCOM,dccom],deftyp[dctyp],deffld[dcfld],
#            defarg[dsarg,dcarg],deffmt[DSFMT,dcfmt]
 
#  literal    object[DSOBJ]
 
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt    # jb  E2145 3/27/00
  Integer    ival                                   # jb  E2145 3/27/00
 
  include    "blmain.inc"
 
 
#
#
#
 
  call iputi (_                    # INITIALIZE iput
              31,                  # Logical unit number (always 31)
              reccnt+1,            # block to receive next record
              recsz)               # the record size
 
                                   # OUTPUT DATA TABLES ###################
 
  ival = 811124
  call iputw (ival)                # keyword to identify data tables....
 
  call iputb (object,2*DSOBJ)      # object name
 
 
  call iputw (dccom)               # common table   > size
 
  call iputb (defcom,2*DSCOM*dccom)#                > contents
 
 
  call iputw (dctyp)               # type table     > size
 
  call iputb (deftyp,2*dctyp)      #                > contents
 
 
  call iputw (dcfld)               # field table    > size
 
  call iputb (deffld,2*dcfld)        #                > contents
 
 
  call iputw (dsarg)               # argument table > size
  call iputw (dcarg)               #                > number
 
  call iputb (defarg,2*dsarg*dcarg)  #                > contents
 
 
  call iputw (dcfmt)               # format table   > number
 
  call iputb (deffmt,2*DSFMT*dcfmt)  #                > contents
 
 
  call iputc                       # close out the last record
 
  return
 
  end

 
 
      subroutine bsverf(arg,        # pointer to the argument being checked
                     argtyp,        # type of argument (1-8)
                     argn,          # length of validation list
                     qfld,          # name of the field being input
                     arg1,          # the input value being tested
                     verr,          # error count
                     irtn,          # array of input values
                     scan,          # input array pointer
                     scan2,         # initial input argument pointer
                     ptrcnt,        # arguments used counter
                     args,          # array of verified arguments
                     argcnt,        # verified arguments counter
                     defcom,dccom,  # common definition table and size
                     deftyp,dctyp,  # type definition table and size
                     deffld,dcfld,  # field definition table and size
                     defarg,dsarg,dcarg, # argument definition table and size
                     deffmt,dcfmt)  # format definition table and size
 
#################################################
      #$%
      #$% Purpose:   BSVERF verifies that the data
      #$%            being entered is a valid entry
      #$%            (i.e., that an argument describ-
      #$%            ing a field within allowed
      #$%            parameters).
      #$%
      #$% Called By: BUILD PROCESSING ROUTINES
      #$%
      #$% Calls:     None
      #$%
      #$% Tables:    None
      #$%
      #$% Date:      NOV 79
      #$%
      #$% Author:    Dana Wills
      #$%
      #$% Modified:  James Allen - 1/97 (E1618)
      #$%            Added seconds to latitude and longitude
      #$%            values.
      #$%
      #################################################
 
##############################################################################
####
####  BASIC DATA DECLARATIONS
####
##############################################################################
  IMPLICIT NONE     # jb  E2145 3/28/00
##      IMPLICIT INTEGER (A-Q,S-Z)
 
  Integer    dccom,dctyp,dcfld,dsarg,dcarg,dcfmt # jb E2145 3/27/00
      literal    defcom[2,dccom],deftyp[dctyp],deffld[dcfld],
                 defarg[dsarg,dcarg],deffmt[5,dcfmt]
 
      literal    qfld,arg1,arg2,irtn[80],args[40],argcnt
      literal    angle       # joa 1/97 (E1618)
      LITERAL    R_lit # jb E2145 (argument for NUTEST)    3/27/00
 
     integer    verr, is_valid_build_string
     integer    lcomp_v
     Integer    arg,    # pointer to argument being checked  E2145 3/27/00
                argtyp, # type of argument (1-8)        jb  E2145 3/27/00
                argn,   # length of validation list     jb  E2145 3/27/00
                scan,   # input array pointer           jb  E2145 3/27/00
                scan2,  # init'l input argument pointer jb  E2145 3/27/00
                ptrcnt  # arguments used counter        jb  E2145 3/27/00
      integer   e,h,j,k,k2,L,m, ISNUMBER               #jb  E2145 3/27/00
 
      LOGICAL NUTEST    # jb E2145 (Statement Function) 3/27/00
 
      VMSchar   vArg1 * $$MaxLit
 
      literal   sHold[10]
      VMSchar   vHold*80
      equivalence (vHold, sHold)
      integer   str_ptr /0/, str_len /0/
 
      include "blmain.inc"
 
##############################################################################
####
####      FORMAT STATEMENTS
####
##############################################################################
 
9013 format (1x,'Word #',i2,', "',i7,'" of the ',a5,' field is NOT in the ',
             'range',i5,' to ',i7)
9014 format (1x,'Word #',i2,', "',a5,'" of the ',a5,' field is NOT in the ',
             'range',a5,' to',a5)
9015 format (1x,'Word #',i2,', "',i7,'" of the ',a5,' field is NOT one of ',
             'the following:')
9016 format (1x,'Word #',i2,', "',i7,'" of the ',a5,' field is NOT allowed ',
             'to be BLANK.')
9017 format (1x)
9018 format (1x,'Word #',i2,', "',A5,'" of the ',a5,' field is NOT one of ',
             'the following:')
9019 format (1x,10a7)
9022 format (1x,'Word #',i2,' of the field "',a5,'" is NOT valid for a ',
                'LATITUDE',/,
             1x,'The form is DD-MM-SSP where:',/,
             1x,'       DD = Degrees from 0 to 90,',/,
             1x,'       MM = Minutes from 0 to 59, and',/,
             1x,'       SS = Seconds from 0 to 59, and',/,
             1x,'       P  = Pole- North or South')
9023 format (1x,'Word #',i2,' of the field "',a5,'" is NOT valid for a ',
                'LONGITUDE',/,
             1x,'The form is DDD-MM-SSH where:',/,
             1x,'       DDD = Degrees from 0 to 180,',/,
             1x,'       MM  = Minutes from 0 to 59, and',/,
             1x,'       SS = Seconds from 0 to 59, and',/,
             1x,'       H   = Hemisphere- East or West')
9031 format (1x,'Word #',i2,', "',f7.2,'" of the ',a5,' field is NOT in the ',
             'range',f7.2,' to ',f7.2)
9024 format (1x,'The string for the field "',a5,'" is NOT valid ',/,
             1x,'       Only A-Z, a-z, 0-9, dash, (, ), and space.',/,
             1x,'       First word must be capitalized, all words must ',/,
             1x,'       begin with a letter, single spaced.  Multiple ',/,
             1x,'       dashes or parens in a row are not allowed.',/,
             1x,'       This field is limited to ',i2,' characters.')
 
#####################################################################
#
#
#    define statement functions                 # These functions step thru
#                                               # the various data tables...
#!!     nxtcom(cur) = cur + 1                      # .DEFCOM
#!!     nxttyp(cur) = cur + 2 + deftyp[cur+1]*2    # .DEFtyp
#!!     nxtfld(cur) = cur + 7 + deffld[cur+1]*2    # .DEFFLD
#!!     nxtarg(cur) = cur + 1                      # .DEFARG
#!!     nxtwrk(cur) = cur + 2 + work[cur+1]        # .WORK
#!!     nxtrec(cur) = cur + (oldlen+recsz-1)/recsz # .Data File
     nutest(r_lit) = $isnumeric(r_lit)             # Test numeric
#
##############################################################################
####
####   BEGIN LOGIC
####
##############################################################################
#
 
 
  #***********************************************************
  if (argtyp==1)          #*** NUMERIC ***
   {
    return                # testing done.... Next.
   }
 
  #***********************************************************
  else if (argtyp==2)     #*** NUMERIC RANGE ***
   {
    if (arg1 < (int(defarg[3,arg])) | arg1 > (int(defarg[4,arg])))
     {
      j = arg1
	  call echov('Word #')
	  call echoib(scan2,2)
	  call echov(', "')
      call echoib(j,7)
	  call echov('" of the ')
	  call echohn(qfld, $$maxlit)
	  call echov(' field is NOT in the range')
      call echoib(int(defarg[3,arg]),7)
	  call echov(' to ')
	  call echoib(int(defarg[4,arg]),7)
      verr = verr + 1
     }
    return
   }
 
  #***********************************************************
  else if (argtyp==3)     #*** NUMERIC LIST ***
   {
    h = 0
    do k2 = 1, argn
     {if (arg1 == (int(defarg[2+k2,arg]))) h = h + 1
     }
    if (h == 0)
     {k = arg1
	  call echov('Word #')
      call echoib(scan2,2)
      call echov(', "')
	  call echoib(k,7)
	  call echov('" of the ')
	  call echohn(qfld,$$maxlit)
	  call echov(' field is NOT one of the following:')
      for (m=1; m<=argn; m=+1)
      	call echoib(int(defarg[2+m,arg]),7)
      call echor
      verr = verr + 1
     }
    return
   }
 
  #***********************************************************
  else if (argtyp==4)     #*** NUMERIC LAT ***
   {
    arg2 = irtn[scan+ptrcnt+1]
 
    e=0
    if (arg1 <  0) e = 1
    if (arg1 > 90) e = 1
 
    angle = arg1*100
 
    if (nutest(arg2))
     {
      if (arg2 < -59) e = 1
      else if (arg2 > 0)   e = 1
      else
       {
        if (arg1==90 & arg2!=0) e = 1
        angle = angle - arg2    #Minutes
        ptrcnt = ptrcnt + 1
        arg2 = irtn[scan+ptrcnt+1]
       }
     }
    if (nutest(arg2))
     {
      if (arg2 < -59) e = 1
      else if (arg2 > 0)   e = 1
      else
       {
        if (arg1==90 & arg2!=0) e = 1
        angle = angle - arg2/100      #Seconds
        ptrcnt = ptrcnt + 1
        arg2 = irtn[scan+ptrcnt+1]
       }
     }
    if ( ! nutest(arg2))
     {
      if (lcomp_v(arg2, "N ") == 0)
       {ptrcnt = ptrcnt + 1
       }
      else if (lcomp_v(arg2, "S ") == 0)
       {ptrcnt = ptrcnt + 1
        angle = - angle
       }
      else  e = 1
     }
 
    if (e == 0)
     {args[argcnt] = angle
     }
    else
     {
	  call echov('Word #')
	  call echoib(scan2,2)
	  call echov(' of the field "')
	  call echohn(qfld,$$maxlit)
	  call echov('" is NOT valid for a LATITUDE')
	  call echor
      call echov('The form is DD-MM-SSP where:'); call echor
      call echov('       DD = Degrees from 0 to 90, and'); call echor
      call echov('       MM = Minutes from 0 to 59, and'); call echor
      call echov('       SS = Seconds from 0 to 59, and'); call echor
      call echov('       P  = Pole- North or South'); call echor
      verr = verr + 1
     }
 
    return
   }
 
  #***********************************************************
  else if (argtyp==5)     #*** NUMERIC LONG ***
   {
    arg2 = irtn[scan+ptrcnt+1]
 
    e=0
    if (arg1 <  0) e = 1
    if (arg1 >180) e = 1
 
    angle = arg1*100
 
    if (nutest(arg2))
     {
      if (arg2 < -59) e = 1
      else if (arg2 > 0)   e = 1
      else
       {
        if (arg1==180 & arg2!=0) e = 1
        angle = angle - arg2    # Minutes
        ptrcnt = ptrcnt + 1
        arg2 = irtn[scan+ptrcnt+1]
       }
     }
    if (nutest(arg2))
     {
      if (arg2 < -59) e = 1
      else if (arg2 > 0)   e = 1
      else
       {
        if (arg1==180 & arg2!=0) e = 1
        angle = angle - arg2/100        # Seconds
        ptrcnt = ptrcnt + 1
        arg2 = irtn[scan+ptrcnt+1]
       }
     }
    if ( ! nutest(arg2))
     {
      if (lcomp_v(arg2, "E ") == 0)
       {ptrcnt = ptrcnt + 1
       }
      else if (lcomp_v(arg2, "W ") == 0)
       {ptrcnt = ptrcnt + 1
        angle = - angle
       }
      else  e = 1
     }
 
    if (e == 0)
     {args[argcnt] = angle
     }
    else
     {
	  call echov('Word #')
	  call echoib(scan2,2)
	  call echov(' of the field "')
	  call echohn(qfld,$$maxlit)
	  call echov('" is NOT valid for a LONGITUDE')
	  call echor
      call echov('The form is DDD-MM-SSH where:'); call echor
      call echov('       DDD= Degrees from 0 to 180, and'); call echor
      call echov('       MM = Minutes from 0 to 59, and'); call echor
      call echov('       SS = Seconds from 0 to 59, and'); call echor
      call echov('       H  = Hemisphere- East or West'); call echor
      verr = verr + 1
     }
 
    return
   }
  #***********************************************************
  else if (argtyp==6)     #*** ALPHA ***
   {
    if (arg1 == $BLANKLIT)                # check for BLANK entry...
     {l = arg1
	  call echov('Word #')
	  call echoib(scan2,2)
	  call echov(', "')
      call echoib(l,7)
	  call echov('" of the ')
	  call echoh(qfld,$$maxlit)
	  call echov(' field is NOT allowed to be BLANK.')
	  call echor
      verr = verr + 1
     }
    return
   }
 
  #***********************************************************
  else if (argtyp==9)     #*** ALPHA String
   {
    # if argn is == 0, this is filler, else it is string length
    if (argn == 0)
        {
%C      Move it into the ARGs element
        if (str_ptr > 0 & str_ptr < str_len)
            {
            str_ptr = str_ptr + 1
            args[argcnt] = sHold[str_ptr]
 
            if (str_ptr == str_len)
                {
                scan = scan + 40    # Force Ignore of rest of line...
                }
            }
 
        return
        }
 
    str_ptr = 0                         # Clear flags
    str_len = 0
    vHold = ""
 
    if (arg1 == $BLANKLIT)                # check for BLANK entry...
        {l = arg1
	    call echov('Word #')
	    call echoib(scan2,2)
	    call echov(', "')
        call echoib(l,7)
	    call echov('" of the ')
	    call echoh(qfld,$$maxlit)
	    call echov(' field is NOT allowed to be BLANK.')
	    call echor
        verr = verr + 1
        }
    else # Find the string in LINE, and rebuild the next N args
        {
%C      How many args to hold the string
        str_len = (argn+7)/8
 
%C      Find Original string
        m = 0; vArg1 = ""
        call vmovhn (arg1, $$maxLit, vArg1, m)
        k2 = index(U_line, vArg1[1:m])
 
%C      Move it into a Holding array
        vHold = R_line[k2:k2+argn-1]
 
%C      Need to check for valid string
        if (Is_Valid_Build_String (vHold, argn) == NO )
            {
			call echov('The string for the field "')
			call echohn(qfld,$$maxlit)
			call echov('" is NOT valid '); call echor
            call echov('       Only A-Z, a-z, 0-9, dash, (, ), and space.');      call echor
            call echov('       First word must be capitalized, all words must '); call echor
            call echov('       begin with a letter, single spaced.  Multiple ');  call echor
            call echov('       dashes or parens in a row are not allowed.');      call echor
            call echov('       This field is limited to ')
            call echoib(argn,2)
	        call echov(' characters.');                                           call echor
			call echor
            verr = verr + 1
            return
            }
 
%C      Move it into the ARGs element
        str_ptr = 1
        args[argcnt] = sHold[str_ptr]
        }
    return
   }
  #***********************************************************
  else if (argtyp==7)     #*** ALPHA RANGE ***
   {
    if (arg1 < defarg[3,arg] | arg1 > defarg[4,arg])
     {
	  call echov('Word #')
	  call echoib(scan2,2)
	  call echov(', "')
	  call echohn(arg1,$$maxlit)
	  call echov('" of the ')
	  call echohn(qfld,$$maxlit)
	  call echov(' field is NOT in the range ')
      call echohn(defarg[3,arg],$$maxlit)
	  call echov(' to')
	  call echohn(defarg[4,arg],$$maxlit)
	  call echor
      verr = verr + 1
     }
    return
   }
 
  #***********************************************************
  else if (argtyp==8)     #*** ALPHA LIST ***
   {h = 0
    do k2 = 1, argn
     {if (arg1 == defarg[2+k2,arg]) h = h + 1
     }
    if (h == 0)
     {
	  call echov('Word #')
	  call echoib(scan2,2)
	  call echov(', "')
	  call echohn(arg1,$$maxlit)
	  call echov('" of the ')
	  call echohn(qfld,$$maxlit)
	  call echov(' field is NOT one of the following:')
	  for (m=1; m<=argn; m=m+1)
	  	call echoh(defarg[2+m,arg], $$maxlit)
      call echor
      verr = verr + 1
     }
    return
   }
 
  return
 
  end
