####    FILE:   WGOPORD.rat

###     Subroutine oreful moved to wgopfuel.rat - joa 2/96 (E1467)
###     Subroutine Vector_unit_for_refuel moved to wgopfuel.rat - clk 2/96 (E1467)

#####   version 3.1  dated-  7apr81  


### mod to version 3.0          dated- 17mar81
###
### module          smn#    prog init   comments
### ======          ====    =========   ===========================
### obingo          002     dew         fixed bug in BINGO TO command
### ohando          002     dew         fixed bug in BINGO TO command
###

###
### mod to version 3.0          dated 18-feb-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 008 rjw     osubcs  added code to set field boy$Acoustic$i
### 002 rjw     omissn  added code to re-set reporting policy
###

###
### mod to version 3.0          dated 11-feb-1981
###
### smn prog    module  comments
### === ====    ======  ==================================================
### 002 rjw     oclify  References to DET table changed for RMT processing
###             ocover  References to DET table changed for RMT processing
###             odesig  References to DET table changed for RMT processing
###             odrop   References to DET table changed for RMT processing;
###                     Initial intercept computation added
###             oplotc  References to DET table changed for RMT processing;
###                     References to OWN table added
###             orbto   References to DET table changed for RMT processing;
###             osubcs  Now uses dyn$eq$type$c instead of dyn$eq$WbuoyName$c
###             otake   References to DET table changed for RMT processing;
###                     Initial intercept computation added
###             ichase  Removed -- replaced by array loaded by data statement
###             oxcir   References to DET table changed for RMT processing
###                     References to OWN table added
###             vector  New routine to perform initial intercept computation
###

###
### mod to version 3.0          dated 4-feb-1981
###
### smn prog    module  comments
### === ====    ======  =================================================
### 002 rae     oreprt  new routine to set reporting policy
###             orepon  new routine to set reporting policy
###             orepus  new routine to set reporting policy
###


#####   version 3.0  dated- 22dec80


#$%
#$%
#$%   Flowchart for file WGOPORD.RAT is found in file WGMAIN.HIR
#$%   ==========================================================





define (NOchain,)                                       #       7/17/84

include "macros.inc"         
include "bbctl.inc"         
include "bbcode.inc"         
include "bbagd.inc"         
include "bbaml.inc"                     # jb - for subr. oREFUL       7/1/87
include "bbbar.inc"                     # jb - for subr. oCOURS       10/1/90
include "bbasw.inc"                     # jb - for HandBarrier        6/18/90
include "bbbml.inc"                     # jb - for SmallBoat Handover 5/3/89
include "bbbom.inc"                     # clk 1/97 (E1731)
include "bbboy.inc"         
include "bbbtt.inc"                     # clk 6/95 (E1419)
include "bbcob.inc"         
include "bbird.inc"                     # jb - for DROP_EOIR          4/2/90
include "bbord.inc"         
include "bbnav.inc"         
include "bbshc.inc"         
include "bbacc.inc"         
include "bbcom.inc"         
include "bbrte.inc"         
include "bbrto.inc"         
include "bbown.inc"         
include "bbunt.inc"         
include "bbdeq.inc"                   # jb vice bbDYN      3/29/89
include "bbtor.inc"         
include "bbvue.inc"         
include "bbrvu.inc"         
include "bbplc.inc"         
include "bbmem.inc"         
include "bbmrk.inc"         
include "bbbmk.inc"         
include "bbson.inc"         
include "bbrmt.inc"         
include "bbpat.inc"         
include "bbrpm.inc"         
include "bbtrk.inc"                                             #       1/17/84
include "bbnuc.inc"                                             #       1/17/84
include "bbpim.inc"                     # clk 1/94 (E1085)
include "bbmc.inc"                      # E1304 SMM 6/95
include "bbl16.inc"                     # clk 12/95 (E1469)
include "orders.inc"         
include "plplay.inc"         
include "ascii.inc"         

define(BBImplicit, Implicit NONE)       # MJC 5/2/2000 (E-2145)

# Rather than having 1's and 2's running around (a couple
# which were backwards), use these constants when accessing
# and setting pair_to_take).
# clk 1/97 (E1649)
define ($pair_command_issued, 1)
define ($take_command_issued, 2)


Subroutine HandCRU(unt2$Pointer,unt2$View$i,unt$Name$C,iFOUND) 

########################################################
#$%
#$% Purpose:   HandCRU finds the unit to which a CRUISE-
#$%     MISSILE is being handed over; then changes the
#$%     missile's View to that of the new "owner"
#$%
#$% Called By: OHANDO
#$%
#$% Calls:     SEND
#$%
#$% Tables:    UNT
#$%
#$% Date        June l985
#$%
#$% Author:     J. Bryant
#$%
########################################################

BBCommon

integer IFOUND,IVIEW,litcmp, # jb litcmp, frm [aai01...mods]  1/23/01 
        IDUMMY,NOROOM,
        UNT$Pointer, OWN$Pointer,
        UNT2$View$I, UNT2$Pointer               # MJC 5/2/2000 (E2145)
literal CSTRIP8,
        UNT$Name$C                              # MJC 5/4/2000 (E2145)

iFOUND = $NO
for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT) #search
 {
  if(litcmp(XUNT$NAME$C, unt$Name$c) == 0)  #jb frm [aai01...mods]  1/23/01
   {
    IVIEW = XUNT$VIEW$I         #get view of receiver
    if((UNT2$VIEW$I < $FIRSTORANGE$VIEW &    #if blue and
               IVIEW < $FIRSTORANGE$VIEW &    #other is blue
         UNT2$VIEW$I != $Neutral$view) |        #and not control (or)
        (UNT2$VIEW$I > $LASTBLUE$VIEW &       #if orange and
               IVIEW > $LASTBLUE$VIEW))       #other is orange
     {
      iFOUND = IVIEW                    #               6/18/85
      PUTunt2$View$I (IVIEW)            # Set new View for CruiseMissile

      call FNDOWN(own$Pointer,unt2$Pointer$INDEX,idummy,noroom)#7/22/85
      if (noroom != $no) {}             # if no room ???#       7/22/85
      else if (Xown$Unit$i != 0)        # if OWN slot found,    7/22/85
         PUTown$View$i   (iview)        # set view      #       7/22/85

      BREAK
     }
   }   # End if names MATCH 
 }  # End of search thru UNT table for receiver's name
return
end     # End of Subroutine HandCRU


Subroutine OALTIT(IONUM, 
                  UNT$POINTER, 
                  IWORD, 
                  ILEX) 
########################################################
#$%
#$% Purpose:   OALTIT processes altitude commands
#$%            and generates a message for errors.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND
#$%            the_elevation     <lbelevation.rat>
#$%
#$% Tables:    UNT
#$%
#$% Date
#$%
#$% Author:
#$%
#$% Modified:  Jim Allen - 11/95 (E1422)
#$%            Added optional keyword RELATIVE to indicate
#$%            that the altitude is relative to terrain.
#$%
########################################################

BBCommon

integer  IWORD,JJ,ISTAT,IONUM,
         IS_TASK_ADDRESS,
         UNT$Type$I,
         UNT$Pointer,
         UNT$Orderedaltdepth$I,
         UNT$Altaboveground$I               # MJC 5/2/2000 (E2145)
literal  CSTRIP8                            # MJC 5/4/2000 (E2145)
literal  ILEX[iword]
Character msg[ARB]

integer  the_elevation    # function to obtain elevation

integer  alt_at_point, irelalt

#String msg "      cannot alter altitude.    "

UNT$Type$I = xUNT$Type$I
if (UNT$Type$I == $Air$Code | UNT$Type$I == $CruiseMissile$Code)
  {
   if (Iword == 2)   # if only ALTITUDE was entered - joa 11/95 (E1422)
     {
      UNT$OrderedAltDepth$I = ilex[2]
      putUNT$OrderedAltDepth$I
      UNT$AltAboveGround$I = 0
      putUNT$AltAboveGround$I
     }
   else if (ilex[3] == $lex$RELATIVE$)
     {
      alt_at_point = the_elevation (xUNT$TrueLatitude$F*$rad2deg,
                                    xUNT$TrueLongitude$F*$rad2deg)
      irelalt = ilex[2]
      irelalt = min (irelalt, $Hi_UNT$AltAboveGround$I)
      UNT$OrderedAltDepth$I = irelalt + alt_at_point
      putUNT$OrderedAltDepth$I
      UNT$AltAboveGround$I = irelalt
      putUNT$AltAboveGround$I
     }   # end of if RELATIVE altitude is desired
  }   # end of if the unit is an aircraft or a cruise missile
else   #$% otherwise set up & display "cannot get altitude" message
  {
   jj = 0
   call SMOVHN(XUNT$NAME$C,$$MaxLit,MSG,JJ)
   Call SMOVV(" cannot alter altitude. ",msg,jj)

   if (Is_Task_Address(istat) != YES) 
        call send_ (xunt$view$i,0,jj,msg)
  }

return
end        # End OALTIT



Subroutine OBINGO(IONUM,                        #recieve order number 
                  UNT$POINTER,                  #receive addressee pointer 
                  IWORD,                        #receive word count 
                  ILEX)                         #receive command string 
########################################################
#$%
#$% Purpose:   OBINGO processes bingo commands and
#$%            starts recovery of aircraft.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND       BINGO
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################
#  In OBINGO, UNT is a flight; UNT2 the recoverer    

BBcommon

integer IWORD,JJ,ISTAT,IONUM,litcmp, # jb frm [aai01...mods]  1/23/01
        IS_TASK_ADDRESS,
        UNT$View$I,
        UNT$Pointer,
        UNT$Recoverindx$I,
        UNT2$Pointer,
        UNT2$Type$I                             # MJC 5/2/2000 (E2145)
literal CSTRIP8                                 # MJC 5/4/2000 (E2145)
literal ILEX[iword]
Character msg[ARB]

#String msg "      cannot bingo  to          "

UNT$VIEW$I = XUNT$VIEW$I                        #get flight's view

#$% set up "cannot bingo to" message
jj = 0  
call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
Call SMOVV(" cannot bingo to ",msg,jj)
call SMOVHN(ilex[3],$$MaxLit,msg,jj)

if(XUNT$TYPE$I != $AIR$CODE)                    #if unit isn't aircraft
   {
    #$% display "cannot bingo to" message

    if (Is_Task_Address(istat) != YES) 
        call send_ (unt$view$i,0,jj,msg)

    return
   }

if(IWORD == 3)                          # E2231 joa 9/01
{
    if (ILEX[2] == $LEX$TO$)            #if recovery base specified
    {
        unt$RecoverIndx$i = 0                # jb  unt vice dyn    3/29/89

        for(unt2$pointer$first;unt2$pointer$ok;unt2$pointer$next) #search
        {        # # jb next line:  litcmp, frm [aai01...mods]  1/23/01 
            if(litcmp(xunt2$name$c, ilex[3]) == 0 & #if recovery base found and
               xunt2$view$i == unt$view$i)          #in the same view
            {
                if (xUNT$GhostedUnit$I == $yes)   # clk 12/93 - cannot
                {                               # Bingo to ghosted units
                    call smovv  (" - ", msg, jj)
                    call smovhn (ilex[3], $$MaxLit, msg, jj)
                    call smovv  (" is a ghosted unit.", msg, jj)
                    call send_   (UNT$View$I, 0, jj, msg)
                    return
                }     # end of attempting to handover to a ghost

                unt2$type$i = xunt2$type$i                  #get base type

                if (Xunt2$AirCapable$i == $YES)    # jb unt2    6/13/90
                {
                    #store recovery index:
                    unt$recoverindx$i =unt2$pointer$index  
                    putunt$recoverindx$i

                    break                           #exit the search
               }                                #end if valid recovery
           }                                    #end if base found
       }                                        #end search

        #$% if bingo platform for aircraft not listed
        if (unt$recoverindx$i == 0)                 
        {
            #$% display "cannot bingo to" message
            call send_ (unt$view$i,0,jj,msg)
            return
        }
   }                                            #end if recovery base called
}                                               # End nargs

call bingo(unt$pointer)             #recover the flight
                                    #pass flight unit pointer

putUNT$AltAboveGround$I  (0)        # joa 11/95 (E1422)

return
end        # End OBINGO




Subroutine ORBOC(IONUM,                        #receive order number 
                 UNT$POINTER,                  #receive addressee pointer 
                 IWORD,                        #receive word count 
                 ILEX)                         #receive command string 

BBcommon
integer IWORD,IONUM,UNT$Pointer                # MJC 5/2/2000 (E-2145)
literal ILEX[iword]

call trace

call OBLIP(IONUM,                              #receive order number
           UNT$POINTER,                        #receive addressee pointer
           IWORD,                              #receive word count
           ILEX)                               #receive command string


return
end    # End ORBOC





Subroutine OBLIP(IONUM,                              #receive order number 
                 UNT$POINTER,                        #receive addressee pointer 
                 IWORD,                              #receive word count 
                 ILEX)                               #receive command string 

########################################################
#$%
#$% Purpose:   OBLIP processes BLIP, RBOC and decep-
#$%            tion commands, to turn ON/OFF the
#$%            selected equipment.
#$%
#$% Called By: EXEORD     ORBOC
#$%
#$% Calls:     SMOVH      SEND
#$%
#$% Tables:    UNT        SHD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORD,JJ,N,ILEN,NFOUND,
        ISTAT,IS_TASK_ADDRESS,IONUM,
        UNT$Type$I, UNT$Pointer,
        DEQ$Pointer, DEQ$On$I                   # MJC 5/2/2000 (E2145)
literal CSTRIP8                                 # MJC 5/2/2000 (E2145)
literal ILEX[iword]
integer eqlist[5,ARB]
integer m
LitCharEquiv(lookup,3,3)

Character msg[ARB]

#           1234567890123456789012345678901234567890
#String msg "      has no      capability.   (not SURF)  "

# lookup data macro

define (Data$lookup_data, DATA (lookup [m,$use(Data_Count)],m=1,2))
define (Data$lookup_name, DATA lookupC [3,$use(Data_Count)])
define (Data$lookup,
     $incr(Data_Count)
     Data$lookup_data / @1, @2 /
     Data$lookup_name / @3 / 
)

$set(Data_Count,0)
DATA$LOOKUP($LEX$BLIP$,$BLIP$CODE,"BLIP")
DATA$LOOKUP($LEX$RBOC$,$RBOC$CODE,"RBOC")
DATA$LOOKUP($LEX$DECM$,$DECM$CODE,"DECM")

#$% get unit
UNT$TYPE$I = XUNT$TYPE$I

#$% set up unit in the message format for display
jj = 0 
call SMOVHN(Xunt$name$c,$$MaxLit,msg,jj)
Call SMOVV(" has no ",msg,jj)

#$% go through the lookup table
for (n=1; n <= 3; n = n + 1)            # jb    (=)    3/28/90
   {
    #$% when applicable name found in lookup table, break
    if (ilex[1] == lookup[1,n]) break
   }

#$% set up lookup table name in message format for display
call SMOVHN(lookup[3,n],4,msg,jj)
Call SMOVV(" capability.   (not SURF)  ",msg,jj)

#$% initialize ilen
ilen = 0

if(UNT$TYPE$I == $Surface$CODE       |          #if surface vessel or
#  UNT$TYPE$I == $SurfaceWithAc$code |          #<<<>>> SUB??? 12/7/85
   UNT$TYPE$I == $Sub$CODE )                    #if surface w/air
   {
    nfound = 0    # jb    Set 0 for non-iterative call        7/25/89
    call DEQGET(unt$pointer,  # vice SURGET     # send UNT pointer
	          int(lookup[2,n]),              # send ident code jb    5/18/89
                  nfound,                       # send/receive nbr items fnd
                  eqlist)                       # send/receive list of EQ
#----------------------------------------------------------------------
#          lines from DEQGET:
#    eqlist[1,nfound] = DEQ$Pointer$index       # save index of equipment
#    eqlist[2,nfound] = Xdeq$pntr$i             #   equipment pointer
#    eqlist[3,nfound] = deq$remaining$i         #   equipment count
#    eqlist[4,nfound] = 0                       #
#    eqlist[5,nfound] = 0                       #
#---------------------------------------------------------------------

    if (eqlist[1,1] != $NO)         #if equipment found
       {                      #  \/(use first example..)
        DEQ$Pointer$TO ( eqlist[1,1] ) # jb vice dyn$eq 3/30/89; 5/22/89

        if(ILEX[2] == $LEX$ON$) DEQ$ON$I = $YES  #turn equipment on
        else                    DEQ$ON$I = $NO   #assume equipment off

        putDEQ$ON$I    #store equipment status 
       }                                        #end if equipment found
    else
       {
        ilen = 32                                # no BLIP aboard
       }
   }                                            #end if surface
else
   {
    ilen = 44                                    # (not SURF)
   }

if (ilen != 0)
   {
    #$% send message for display as formatted 

    if (Is_Task_Address(istat) != YES) 
        call send_ (Xunt$view$i,0,ilen,msg)
   }

return
end        # End OBLIP



Subroutine OCLIFY(IONUM,                               #receive order number 
                  UNT$VIEW$I,                          #receive view of player 

                  IWORD,                               #receive word count 
                  ILEX)                                #receive command string 


#######################################################################
#$%
#$% Purpose:   OCLIFY processes CLASSIFY commands (WITHOUT addressees)
#$%            for classification of detected
#$%            track numbers.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     GTACT      SEND
#$%
#$% Tables:    RMT        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORD,IFLAG,IBONLY,
        JJ,IONUM,
        RMT$Pointer,
        UNT$View$I                          # MJC 5/2/2000 (E2145)
literal RMT$Userclass$C                     # MJC 5/4/2000 (E2145)
literal ILEX[iword]
Character msg[ARB]

#String msg "      cannot be classified. "

#$% initialize flag and track pointer
iflag = $no
rmt$pointer = 0

repeat
   {
    call gtact(unt$view$i,               #locate the track
               ILEX[2],                  #pass track number
               RMT$POINTER,              #receive detection pointer
               ibonly)

    if(rmt$POINTER != 0)                            #if track found
       {
        iflag = $yes
        RMT$USERCLASS$C = ILEX[3]                   #enter user classification

        if (RMT$USERCLASS$C == 'AUTO' |            # E2183 - Allow Removal of Classification
            RMT$USERCLASS$C == 'BLANK'  ) RMT$USERCLASS$C = 0

        PUTRMT$USERCLASS$C
        NEXT
       }

    else if (iflag == $no)    #$% else if track not found:
       {
        jj = 0
        
        #$% set up track # in message format for display
        call SMOVHN(ilex[2],$$MaxLit,msg,jj)
        Call SMOVV(" cannot be classified. ",msg,jj)
        #$% send message to view for display
        call send_ (unt$view$i,0,jj,msg)
       }
    break
   }

return
end        # End OCLIFY

Subroutine oISAR(IONUM,         #receive order number 
                 UNT2$VIEW$I,   #receive view of player 
                 IWORD,         #receive word count 
                 ILEX,          #receive command string 
                 unt2$pointer)  #receive Addressee 

####################################################################
#$% Purpose:   If a CLASSIFY command has an addressee, oISAR checks
#$%     track validity and whether addressee qualifies and holds
#$%     proper active track; also checks horizon distance and max.
#$%     ISAR range against the current range.  If all ok, SENDs the
#$%     CLASS of the target to the requesting View; otherwise demurs.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     GTACT      SEND    GETRB_M
#$%
#$% Tables:    RMT        UNT (detectee) & UNT2 (addressee)
#$%
#$% Date:      May 1987
#$%
#$% Author:    Joe Bryant
#$%
#$% Modified:  Carol Kropp - 4/28/92
#$%            Made the max classification range a
#$%            variable (rather than hard coded) &
#$%            made classification based on a random
#$%            number draw.
#$%
#$% Modified: Kirk Chang - 4/93
#$%           Changed keyword CLASSIFY to ISAR - when LABEL
#$%           option was added for PER #E1134, parser had
#$%           trouble with <classification> v. LABEL.
#$%           LABEL puts the classification on the geodisplay.
#$%
#$%           Carol Kropp - 9/95 (E1474)
#$%           Players were issuing ISAR commands to classify
#$%           sonar, MAD, and LIDAR  contacts.  Added checks
#$%           to make sure that the contact is radar or visual.
#$%           Also made sure if the contact is a submarine, 
#$%           then the sub is still visable.
#$%
#$%           Carol L. Kropp - 12/96 (E1727)
#$%           The UNT2$Name$C extraction was within the 
#$%           "if (xACC$ISAR$i != $YES)" check, so when
#$%           subsequent checks failed the variable was
#$%           the value of the memory location (set from
#$%           some other place).  Moved the extraction
#$%           outside of all checks and declared it.
#$%
########################################################
## UNT2 --> flight ordered to classify;
## UNT  --> ship/surfaced sub to be classified
BBcommon

integer   JJ,IFLAG,IBONLY,KLEN,
          ACC$Pointer,
          RMT$Pointer,
          RMT$Lastdettype$I,
          UNT$Pointer,
          UNT$Type$I,
          UNT2$Truealtdepth$I,
          SHC$Pointer                           # MJC 5/2/2000 (E2145)
real      HEIGHT,
          RANGE,
          BRG,
          SQ2,
          DUMMY,
          RANDOM                                # MJC 5/2/2000 (E2145)
literal   CSTRIP8,
          UNT$Name$C,
          SHC$Type$C,
          RMT$Userclass$C                       # MJC 5/4/2000 (E2145)
integer   ionum, UNT2$View$I, iword, UNT2$Pointer
literal   ilex[iword]

literal   UNT2$Name$C
Character msg[ARB]
real*8    random_number        # clk 4/28/92

# Notify user that this order has been automated.
jj = 0
Call SMOVV("ISAR order has been automated.  SHOW SURFACE (track astab).",msg,jj)
call send_ (unt2$view$i,0,jj,msg)
RETURN

if (Xunt2$TYPE$i != $AIR$code)  RETURN  # (Also, ORDERS won't allow..)

UNT2$Name$C = xUNT2$Name$C

ACC$pointer  = Xunt2$ACCpntr$I    # jb (start dyn-->unt)  3/30/89
if (xACC$ISAR$i != $YES)
   {
    jj = 0
    Call SMOVV("Addressee ",msg,jj)
    Call SMOVHN(Unt2$Name$c,$$MaxLit,msg,jj)
    Call SMOVV("not equipped to classify.",msg,jj)
    call send_ (unt2$view$i,0,jj,msg) # formerly msg3
    RETURN
   }

iflag = $no
rmt$pointer = 0

repeat
   {
    call gtact (UNT2$View$I, ilex[2], RMT$Pointer, ibonly)

    if ((RMT$Pointer$Ok) & (ibonly == $no))    # clk 9/95 (E1474)
      {
       RMT$LastDetType$I = xRMT$LastDetType$I
       if ( !(RMT$LastDetType$I == $Radar$Type |
              RMT$LastDetType$I == $Visual$Type) )
         break
      }
    else    # not a good RMT or the detection is passive
      {
       if (RMT$Pointer$Ok)
         {
          jj = 0
          call smovhn (UNT2$Name$C, $$MaxLit, msg, jj)
          call smovv  (" cannot classify passive track ", msg, jj)
          call smovhn (ilex[2], $$MaxLit, msg, jj)
          call send_   (UNT2$View$I, 0, jj, msg)
          return
         }
       else
          break
      }
               
    UNT$Pointer$To (xRMT$Detectee$I)
    UNT$Type$I = xUNT$Type$I
    if (UNT$Type$I == $Air$Code)
      {
       jj = 0
       call smovhn (UNT2$Name$C, $$MaxLit, msg, jj)
       call smovv  (" cannot classify air tracks", msg, jj)
       call send_   (UNT2$View$I, 0, jj, msg) 
       return 
      }
    else if (UNT$Type$I == $SubSurface$Code  &       # clk - 9/95 (E1474)
             xUNT$TrueAltDepth$i > Keel$Depth)
      {
       jj = 0
       call smovhn (UNT2$Name$C, $$MaxLit, msg, jj)
       call smovv  (" could not classify track ", msg, jj)
       call smovhn (ilex[2], $$MaxLit, msg, jj)
       call send_   (UNT2$View$I, 0, jj, msg)
       return 
      }
    else 
      {
       height = xUNT$AntennaHeight$I
      }

    call GETRB_M (UNT$Pointer, UNT2$Pointer, range, brg)

    Unt2$TrueAltDepth$i = xUnt2$TrueAltDepth$i    # jb        12/18/89
    SQ2 = float(Unt2$TrueAltDepth$i)              # jb        12/18/89
    SQ2 = SQRT(SQ2)                               # jb        12/18/89
    
    if( RANGE > ISAR$ID$MaxRange | RANGE > (SQRT(height) +SQ2) ) # jb 12/18/89
       {    # (Require range to be well WITHIN maximum LOS..            
        jj = 0
        call smovhn (ilex[2], $$MaxLit, msg, jj)
        call smovv  (" is beyond classification range of ", msg, jj)
        call smovhn (UNT2$Name$C, $$MaxLit, msg, jj)
        call send_   (UNT2$View$I, 0, jj, msg)
        RETURN
       }

    random_number = RANDOM (dummy)
    if (ISAR$ID$Probability < random_number)
      {
       jj = 0
       call smovhn (UNT2$Name$C, $$MaxLit, msg, jj)
       call smovv  (" could not classify track ", msg, jj)
       call smovhn (ilex[2], $$MaxLit, msg, jj)
       call send_   (UNT2$View$I, 0, jj, msg)
       return
      }

    UNT$Name$C = '?badptr' # in case pointer(s) invalid..    3/30/89
    if (UNT$Pointer$Valid)               # jb    unt          3/30/89
       {
        shc$pointer  = Xunt$SHCpntr$I      # jb    unt          3/30/89
        if(shc$pointer$VALID)
           {
            shc$Type$C = xSHC$Type$C
           }

        iflag = $yes

        klen = 0
        Call SMOVV("Track ",msg,klen)
        call SMOVHN(ilex[2],$$MaxLit,msg,klen)          # DEW 11/99 E2172
        Call SMOVV(" is ",msg,klen)
        call SMOVHN(shc$TYPE$C,$$MaxLit,msg,klen)
        Call SMOVV(" Class.",msg,klen)
        call send_ (unt2$view$i,0,klen,msg) # formerly msg6
        PUTrmt$Classified$i ($YES)      # jb            6/12/87
        PUTrmt$SHCpntr$I (shc$pointer)  # jb            8/5/88

        #$% An option to display the classification on the geo display
        if (iWORD == 3)     # E2231 joa 9/01
          {
            if(ilex[3] == $LEX$LABEL$)   # KHC 2/93 - E1134
              {
              RMT$USERCLASS$C = SHC$TYPE$C
              PUTrmt$UserClass$c
              }
          }
        RETURN
       }
    BREAK
   }

if (iflag == $no)
       {
        jj = 0
        call smovhn(ilex[2],$$MaxLit,msg,jj)
        call SMOVV(" was not found.",msg,jj)
        call send_ (unt2$view$i,0,jj,msg) # formerly msg0
       }

return
end        # End OISAR


Subroutine OCOURS(IONUM,                          #receive order number 
                  id,                             #receive order id
                  UNT$POINTER,                    #receive addressee pointer 
                  IWORD,                          #receive word count 
                  ILEX)                           #receive order string 

########################################################
#$%
#$% Purpose:   OCOURS processes course commands
#$%            for changing course data.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 5/96 (E1246/E1467)
#$%            Added call to clear_maneuver_all for
#$%            surface being refueled or in, 
#$%            breakaways happen correctly...waiting
#$%            to integrate for other platform types (clk).
#$%
#$%            Jim Allen - 12/97 (E1370)
#$%            Order id number added to argument list for
#$%            update call to clear_maneuver_all.
#$%
########################################################
##  
BBcommon

integer  IWORD,IONUM,
         XUNTVIEW$I,
         BOY$Pointer,
         BAR$Pointer,
         UNT$Status$I,
         UNT$Pointer,
         UNT$Assignedtarget$I,
         UNT$Type$I                         # MJC 5/2/2000 (E-2145)
real     UNT$Orderedcourse$F                # MJC 5/2/2000 (E-2145)
integer  id
literal  ILEX[iword], iaddr / 0 /
integer  indx

integer  ifound   # joa 12/97 (E1370)

UNT$Status$I = xUNT$Status$I 
if (unt$Status$i == $Sinking$Code     |
    unt$status$i == $DeadInWater$Code |
    unt$status$i == $UnderTow$Code     )
    {
    call wgoerr (xUNTview$i,iaddr,IONUM,IWORD,ILEX,"Not currently maneuverable.")
    return
    }

ifound = $no
if (xUNT$Type$I == $Surface$Code         &   # for moored units and
    (xUNT$HosesAllocatedFlag$I == $yes |     # emergency breakways  
      UNT$Status$I == $InPort$Code     ))
   {                                                # joa 12/97 (E1370)
    UNT$AssignedTarget$I = xUNT$AssignedTarget$I    # Save assigned target
    ifound = $yes
   }
call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)
if (ifound == $yes)
   putUNT$AssignedTarget$I                         # Restore assigned target

if (ilex[1] == $lex$course$)
    {
    #$% if unit is a smart torpedo      5/2/90 reh
    if ( xUNT$SuperType$i == $Torpedo$SuperCode )
        {
        if ( xUNT$WireGuide$i == $yes )
            {
            UNT$OrderedCourse$F = ILEX[2]/180. * $PI    #enter course order
            }
        else
            { 
            return
            }
        }
    else # else all other unit types
        {
        UNT$ORDEREDCOURSE$F = ILEX[2]/180. * $PI    #enter course order
        }
    }
else    # TURN command
    {
    UNT$ORDEREDCOURSE$F = XUNT$ORDEREDCOURSE$F + (ILEX[2]/180. * $PI)
    }

  UNT$Type$I = xUNT$Type$I
  if (UNT$Type$I == $Surface$Code         &   # for moored units and
      (xUNT$HosesAllocatedFlag$I == $yes |    # emergency breakways  
        UNT$Status$I == $InPort$Code     ))
    {   # clearing handled above
        continue
    }
  else
    {
     ##--------- jb - set FALLING for chaff barrier        10/1/90
     if (Xunt$HasBarrier$i != $NO)
        {
         indx = UNT$Pointer$Index
         for (boy$pointer$first; boy$pointer$ok; boy$pointer$next)
            {
             if (xBOY$OwnerIndx$i     != indx |
                 xBOY$Type$i     !=$CHAFF$code |    # jb vice RBOC 2/4/91
                 xboy$KillTime$f <=game$time ) NEXT
             putboy$KillTime$f (game$time)
             BAR$Pointer$TO    (BOY$Pointer$Index)
             putBAR$FALLING$i  ($YES)
             BREAK
            }
        }
     ##--------- jb - END set FALL time for chaff barrier    10/1/90

     if(unt$type$i == $cruisemissile$code)           #       7/17/85
             PUTunt$AssignedTarget$i ($NO)           #       6/13/85

     putUNT$STATUS$I ($PROCEEDING$CODE)

     if (UNT$TYPE$I == $AIR$CODE &
         Xunt$MarshallStatus$i == $Recovering$Code)
             PUTunt$MarshallStatus$i ($inflight$code)
    }   # end of if a unit other than a surface platform

$ang2PI(UNT$ORDEREDCOURSE$F)
PUTUNT$ORDEREDCOURSE$F

if (IWORD >= 4)                     # E2231 joa 9/01
{
    if (ILEX[3] == $lex$SPEED$)     # SPEED command too?  # 1/28/91 DEW
    {
        call ospeed (IONUM, UNT$POINTER, IWORD - 2, ILEX[3], id)    # joa 8/98 (E2021)
    }                                                           # missing param id
}

return
end        # End  OCOURS




Subroutine OCOVER(IONUM,                #Cover a track 
                  id,                   # Order id
                  UNT$POINTER,          #IONUM = order number (out) 
                  IWORD,                #UNT$POINTER = addressee pointer (out) 

                  ILEX)                 #IWORD = word count (out) 
                                        #ILEX = command string (out) 

#       AIR  can cover any active track
#       SURF can cover non-AIR active tracks
#       SUB  can cover non-AIR active tracks
#
#       If the track is AIR : cover at 1 mile
#                       SURF: cover at 10 miles
#                       SUB : cover at 2 miles

########################################################
#$%
#$% Purpose:   OCOVER processes commands to cover
#$%            any active tracks whether the track
#$%            is air, surface, or sub.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     GTACT      SEND       VECTOR
#$%
#$% Tables:    UNT        RMT        
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Jim Allen - 12/97 (E1370)
#$%            Order id number added to argument list for
#$%            call to clear_maneuver_all.
#$%
########################################################

BBcommon

integer IWORD,IBONLY,JJ,
        IONUM,IUNT,
        UNT2$Pointer,
        UNT2$Type$I,
        RMT$Pointer,
        RMT$Class$I,
        UNT$View$I,
        UNT$Pointer,
        UNT$Type$I,
        UNT$Attackindx$I,
        UNT$Status$I,
        UNT$Rulesofengage$I,
        UNT$Attacktrue$I                    # MJC 5/2/2000 (E2145)
real    UNT$Attackbearing$F,
        UNT$Attackrange$F                   # MJC 5/2/2000 (E2145)
literal CSTRIP8,
        UNT$Name$C                          # MJC 5/4/2000 (E2145)
literal ILEX[iword],ACT_AIR[5],ACT_SURF[5]
integer id
real    rcan

Character msg[ARB]

#String msg1 "      cannot cover invalid track number         "
#String msg2 "      cannot cover passive      track          "
#String msg3 "Ships cannot cover air tracks, so--"       #35     5/1/86
#String msg4 "--ship       cannot cover air track      ."#42     5/1/86
#String msg5 "      cannot intercept                        " # 10/16/85
#String msg8 "      cannot cover old track           "   #       5/5/83
#String msg9 "      cannot cover OTH track           "   #       4/19/90

#            x        1         2         3         4         5
data act_air /$lex$ACTIVATE$, $lex$AIR$    , 0, 0, 0/
data act_surf/$lex$ACTIVATE$, $lex$SURFACE$, 0, 0, 0/

# call OACTIV(Activate$Order,unt$pointer,2,act_Air)
# call OACTIV(Activate$Order,unt$pointer,2,act_Surf)

#$% get unit view
unt$view$i = xunt$view$i

#$% initialize track pointer
rmt$pointer = 0

call gtact (unt$view$i,                         #search for track
            ILEX[2],                            #pass track number
            RMT$POINTER,                        #receive pointer
            ibonly)

#$% if track is not valid
if (rmt$pointer == 0)
   {
    jj = 0
    #$% set unit in format for message 1
    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" cannot cover invalid track number ",msg,jj)
    #$% set track number in format for message 1
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)            # DEW 11/99 E2172

    #$% send message to view for display
    call send_(unt$view$i,0,jj,msg) # formerly msg1
    return
   }

else if (Xrmt$OverHoriz$i == $YES)  # else if track is OTH 4/19/90
   {
    jj = 0
    #$% set unit name in format for message 9
    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" cannot cover OTH track ",msg,jj)
    #$% set track number in format
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)            # DEW 11/99 E2172

    #$% send message to view for display
    call send_(unt$view$i,0,jj,msg) #formerly msg9
    return
   }

else if (ibonly == $yes)        # ELSE if track passive 5/5/83
   {
    jj = 0
    #$% set unit name in format for message 2
    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" cannot cover passive track ",msg,jj)
    #$% set track number in format for message 2
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)            # DEW 11/99 E2172

    #$% send message 2 to view for display
    call send_(unt$view$i,0,jj,msg) # formerly msg2
    return
   }
                                        # else if track is aged 5/5/83
else if( xrmt$LastDetTime$f +Minutes$to$Old  < game$time )
   {
    jj = 0
    call SMOVHN(UNT$NAME$C,$$maxLit,msg,jj)    #$% move data to msg8 for dsplay
    Call SMOVV(" cannot cover old track ",msg,jj)
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)            # DEW 11/99 E2172
    call send_(unt$view$i,0,jj,msg)     # formerly msg8
    return
   }

#$% set pointer to detectee
unt2$pointer$to xrmt$detectee$i

#$% get detector and detectee unit types
unt$type$i = xunt$type$i
unt2$type$i = xunt2$type$i

#$% if unit detector is not air & detectee is air or missile
if (UNT$TYPE$I != $AIR$CODE &
    (UNT2$TYPE$I == $AIR$CODE |
     UNT2$TYPE$I == $CRUISEMISSILE$CODE))
   {
    jj = 0                                              #       5/1/86
    Call SMOVV("Ships cannot cover air tracks, so--",msg,jj)
    call send_(unt$view$i,0,jj,msg) # send "ships can't cover AIR..(msg3)

    jj = 0
    Call SMOVV("--ship ",msg,jj)
    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)  #$% set unit name in msg
    Call SMOVV(" cannot cover air track ",msg,jj)
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)                # DEW 11/99 E2172
    call send_(unt$view$i,0,jj,msg) #$% send msg to view for display (msg4)

    return
   }

#$% see if intercept can be made
call VECTOR(unt$pointer,rmt$pointer,rcan)

#$% if intercept cannot be made
##if (rcan < 0 )          # Not CLOSE, & can't intcpt.    10/16/85
if (rcan < 0. & rcan != -3.) # jb Not CLOSE, & can't intcpt. 4/16/01
 {
    jj = 0
    #$% move unit name to 'cannot intercept' format for display
    call SMOVHN(Xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" cannot intercept ",msg,jj)
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)

    if ( rcan == -7)                               #    10/16/85
        call SMOVV(" within 12 hours.",msg,jj) #    10/16/85
    else                # rcan = -1                #    10/16/85
        call SMOVV("; I'm too slow.",msg,jj)   #    10/16/85

    #$% send msg to view for display
    call send_(UNT$View$i,0,jj,msg)   # formerly msg5          #       10/16/85
    RETURN
 }

call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)

iunt = unt$pointer

if (UNT2$TYPE$I == $AIR$CODE         |
    UNT2$TYPE$I == $CRUISEMISSILE$CODE) 
    {
    call OACTIV(COVER$Order,iunt,2,act_Air)     # COVER$order   2/15/84
#    PUTunt$coverflag$i  ($Yes)                  # <RG> 9/17/85 for update to
    }                                           # bogey tote board for TTGP.
else
    call OACTIV(COVER$Order,iunt,2,act_Surf)    # COVER$order   2/15/84

putUNT$CoverFlag$I ($yes)   # clk 1/94 - set the cover flag for all unit types,
                            # (E1085)      so that the ORDERS command may display COVER

UNT$ATTACKINDX$I = UNT2$POINTER$INDEX           # track as attack guide
PUTUNT$ATTACKINDX$I

PUTunt$AssignedTarget$i   (0)                   # <RG> 9/23/85 for bogey tote

UNT$Status$i = xUNT$Status$i                    # jb    8/18/89
if(UNT$Status$I !=$Sinking$Code & UNT$Status$I != $UnderTow$Code &
   UNT$Status$I !=$DeadinWater$Code) # jb 8/18/89;    /\  8/28/89
        putUNT$STATUS$I ($PROCEEDING$CODE)

if (UNT$TYPE$I == $AIR$CODE &
    Xunt$MarshallStatus$i == $Recovering$Code)
        PUTunt$MarshallStatus$i ($inflight$code)

UNT$RULESOFENGAGE$I = $IFATTACKED$CODE  #weapons tight
PUTUNT$RULESOFENGAGE$I

UNT$ATTACKBEARING$F = $PI               #from astern
PUTUNT$ATTACKBEARING$F

UNT$ATTACKTRUE$I = $NO                  #relative to the track
PUTUNT$ATTACKTRUE$I

rmt$class$i = xrmt$class$i

if      (iword       == 3        ) UNT$attackrange$f = ilex[3]  #specified rng
else if (rmt$class$i == $air$code) UNT$attackrange$f = 1.0
else if (rmt$class$i == $sub$code) UNT$attackrange$f = 2.0
else                               UNT$attackrange$f = 10.0
PUTUNT$ATTACKRANGE$F

return
end        # End  OCOVER





Subroutine ODEPTH(IONUM,                        #receive order number 
                  UNT$POINTER,                  #receive addressee pointer 
                  IWORD,                        #receive word count 
                  ILEX)                         #receive order string 

########################################################
#$%
#$% Purpose:   ODEPTH processes depth commands to
#$%            order submarine depth.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORD,IDEPTH,JJ,ISTAT,
        IS_TASK_ADDRESS,IONUM,
        UNT$Pointer,
        UNT$Orderedaltdepth$I,
        SHC$Pointer,
        SHC$Keeldepth$I, SHC$MaxDepth$i,
        SHC$Scopedepth$I                # MJC 5/2/2000 (E2145)
literal CSTRIP8                         # MJC 5/4/2000 (E2145)
literal ILEX[iword]

Character msg[ARB]

#String msg "      cannot alter depth.   "

#if(XUNT$TYPE$I == $SUB$CODE)   #if unit is a submarine
if(Xunt$SuperType$I  == $Submarine$SuperCode) #jb 2/12/91 
   {                            # jb NOT A FALSE TARGET!
    idepth = ILEX[2]                            #get depth order

    shc$pointer = Xunt$SHCPntr$i

    shc$KeelDepth$i  = Xshc$KeelDepth$i 
    shc$ScopeDepth$i = Xshc$ScopeDepth$i 

    if      (idepth < shc$KeelDepth$i) 
                                unt$OrderedAltDepth$I = shc$KeelDepth$i
    else if (idepth < shc$ScopeDepth$i) 
                                unt$OrderedAltDepth$I = shc$ScopeDepth$i 
    else                        
                                unt$OrderedAltDepth$I = idepth
    # joa 3/05 per_depth
    shc$MaxDepth$i = Xshc$MaxDepth$i
    if (idepth > Shc$MaxDepth$i)
    {
                                unt$OrderedAltDepth$I = shc$MaxDepth$i
    jj = 0
    #$% move unit name to msg format for display
    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" ordered to exceed max defined depth. Using max defined depth.",msg,jj)

    #$% send msg to view for display
    if (Is_Task_Address(istat) != YES) 
        call send_ (Xunt$view$i,0,jj,msg)

    }
    PUTunt$OrderedAltDepth$I
   }                                            #end if submarine
else
   {
    jj = 0
    #$% move unit name to msg format for display
    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" cannot alter depth.",msg,jj)

    #$% send msg to view for display
    if (Is_Task_Address(istat) != YES) 
        call send_ (Xunt$view$i,0,jj,msg)
   }

return
end        # End  ODEPTH





Subroutine ODESIG(IONUM, 
                  IVIEW, 
                  IWORD, 
                  ILEX) 

########################################################
#$%
#$% Purpose:   ODESIG processes designate commands
#$%            to designate target identification
#$%            as ENEMY, FRIENDLY, NEUTRAL or UN-
#$%            KNOWN.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND       GTACT
#$%
#$% Tables:    RMT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORD,JJ,IVIEW,N,
        IFLAG,IBONLY,IONUM,
        RMT$Userdesignated$I,
        RMT$Targetid$I,
        RMT$Pointer                     # MJC 5/2/2000 (E-2145)
literal ILEX[iword]

Character msg[ARB]

#String msg "      cannot be designated. "

RMT$UserDesignated$i = $Yes

#$% if designated as ALL
if      (ILEX[2] == $LEX$ALL$)
   {
    JJ = 0
    #$% move "ALL" to msg format for display
    Call SMOVV("ALL ",msg,jj)
    Call SMOVV(" cannot be designated.",msg,jj)
    #$% send msg to view for display
    call send_ (iview,0,jj,msg)
    return
   }
#$% else if designated enemy, friendly, neutral of unknown
else if (ILEX[2] == $LEX$ENEMY$)    RMT$TARGETID$I = $ENEMY$CODE
else if (ILEX[2] == $LEX$FRIENDLY$) RMT$TARGETID$I = $FRIENDLY$CODE
else if (ILEX[2] == $LEX$NEUTRAL$)  RMT$TARGETID$I = $NEUTRAL$CODE
else if (ILEX[2] == $LEX$UNKNOWN$)  RMT$TARGETID$I = $UNKNOWN$CODE

# If user designation entered, then it should supercede any automatic assignment
# unless user designation of UNKNOWN, then re-allow automatic assignment

if (RMT$TARGETID$I == $UNKNOWN$CODE) rmt$UserDesignated$i = $No # jb
                                                #    jb   =  4/6/91
#$% for word count
for (n=3; n<=iword; n=n+1)
   {
    #$% initialize flag and track pointer
    iflag = $no
    rmt$pointer = 0

    repeat
       {
        call gtact(iview,                           #search for track
                   ILEX[n],                         #pass track number
                   RMT$POINTER,                     #receive pointer
                   ibonly)

        if(rmt$POINTER != 0)                        #if track found
           {
            #$% set flag to YES and save target ID
            iflag = $yes
            PUTRMT$TARGETID$I
            PUTrmt$UserDesignated$i
            next
           }
        else if (iflag == $no)
           {
            jj = 0
            #$% move track # to msg format for display
            call SMOVHN(ilex[n],$$MaxLit,MSG,JJ)            # DEW 11/99 E2172
            Call SMOVV(" cannot be designated. ",msg,jj)
            #$% send msg to view for display
            call send_ (iview,0,jj,msg)
           }
        break
       }
   }

return 
end



Subroutine ODROP_RANGE (nord,iview,nargs,args) 

########################################################
#$%                     
#$% Purpose:   ODROP_RANGE processes a DROP RANGE command 
#$%            to drop a series of tracks from the RMT table.
#$%
#$% Called By: ODROP
#$%
#$% Calls:     SEND
#$%            Zero_RMT_Entry    <wgmdrem.rat>
#$%
#$% Tables:    RMT
#$%
#$% Date:      MARCH 83
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 12/95 (E1469)
#$%            Allow the player to drop received JTIDS
#$%            tracks (Jxxxx - x=0-8).
###
########################################################

BBcommon

integer         KK,JJ,
                IVUE,IVUE_1,IVUE_2,
                IDROP,ILAST,NUM,
                RMT$Pointer,
                RMT$Class$I,
                RVU$Pointer,NARGS               # MJC 5/4/2000 (E2145)
literal         RVU$Trackcode$C,
                CSTRIP                          # MJC 5/4/2000 (E2145)
literal         args[nargs], iaddr / 0 /
integer         iview, nord,
                lo, hi, ctoi, equal
real            MinOld
character       lo1[8], hi1[8], ctrack[8]

call smov (rvu$trackcode$c,ctrack,kk)   # get 1 char

if (JTIDS$Capable$Game == $yes)    # clk 12/95 (E1469)
  {
   jj = 0;   call smovh (args[3], 2, lo1, jj)
   jj = 0;   call smovh (args[4], 2, hi1, jj)
   if ((lo1[1] == $LETJ & hi1[1] == $LETJ) &    # if the track number follows
       ($DIG0 <= lo1[2] & lo1[2] <= $DIG8) &    # the JTIDS format - clk 12/95 (E1469)
       ($DIG0 <= hi1[2] & hi1[2] <= $DIG8) )
     {
      call ODrop_JTIDS (iview, nargs, args)
      return
     }   # end of if a JTIDS track range specified
  }   # end of if a JTIDS Capable Game

jj = 0; call smovh (args[3],2,lo1,jj); lo1[3] = EOS
jj = 0; call smovh (args[4],2,hi1,jj); hi1[3] = EOS

if (equal(lo1,hi1) != YES)
    {
    call wgoerr (iview,iaddr,nord,nargs,args,"Track codes not the same.")

    return
    }

jj = 3; lo = ctoi(args[3],jj)
jj = 3; hi = ctoi(args[4],jj)

if (lo > hi)
    {
    call wgoerr (iview,iaddr,nord,nargs,args,"Invalid Range.")
    return
    }

if (iview == $neutral$view)                   #if request from control
    {
    ivue_1 = $firstBlue$view
    ivue_2 = $LastOrange$view
    }
else
    {
    ivue_1 = iview
    ivue_2 = iview
    }

idrop = 0

for (ivue = ivue_1; ivue <= ivue_2; ivue = ivue + 1)
   {
    rvu$pointer$to ivue
    if (xrvu$lastrmtindx$i == 0) next # no tracks held by view

    rvu$trackcode$c = xrvu$trackcode$c
    kk = 0
    call smov (rvu$trackcode$c,ctrack,kk)       # get 1 char

    if (ctrack[1] != lo1[1]) next               # no match on trackcode

    rmt$pointer$to xrvu$lastrmtindx$i
    ilast = rmt$pointer                         # set up end index

    if (args[2] == $Lex$OLD$)   MinOld = Minutes$To$Yellow # now in seconds - JFR 11/4/93
    else                        MinOld = -69. 

    for (rmt$pointer$to xrvu$firstrmtindx$i; 
         rmt$pointer <= ilast; rmt$pointer$next)
       {
        if (xrmt$inuse$i == $no) next

        num = xrmt$tracknumber$i                # get track number
        if (num == 0) next
        if (num < lo | num > hi) next           # not in numeric range

        if (xrmt$LastDetTime$f + MinOld > game$time) next 

        rmt$class$i = xrmt$class$i
        if      (Xrmt$OverHoriz$i     == $YES)               ctrack[2] = 'O'
        else if (xrmt$detectiontype$i == $PassiveSonar$Code) ctrack[2] = 'P'
        else if ( rmt$class$i         == $Air$code)          ctrack[2] = 'A'
        else if ( rmt$class$i         == $Surface$code)      ctrack[2] = 'S'
        else if ( rmt$class$i         == $Sub$Code)          ctrack[2] = 'U'
        else                                                 ctrack[2] = 'E'
        
        if (ctrack[2] != lo1[2]) next           # not correct track type

        idrop = idrop + 1

        call Zero_RMT_Entry (RMT$Pointer)
       }        #  End 'for rmt$Pointer.. 
   }    #  End 'for ivue...

if (idrop == 0)
    {
    call wgoerr (iview,iaddr,nord,nargs,args,"None Dropped.")
    return
    }

return
end



Subroutine ODROP(IONUM, 
                 IVIEW, 
                 IWORD, 
                 ILEX) 
########################################################
#$%
#$% Purpose:   ODROP processes drop commands to drop
#$%            tracks from the RMT table.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     GTACT      SMOV       SMOVH
#$%            SEND
#$%            Zero_RMT_Entry    <wgmdrem.rat>
#$%
#$% Tables:    RMT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 12/95 (E1469)
#$%            Allow the player to drop received JTIDS
#$%            tracks (Jxxxx - x=0-8).
#$%
#$%            Carol Kropp - 10/96 (E1695)
#$%            Added commands to drop CEC track numbers
#$%            (DROP (track) CEC ...).
#$%
########################################################

BBcommon

integer   IWORD,IVIEW,IONUM,
          ILEN,I,IFLG,IBONLY,
          RMT$Pointer,
          L16$Pointer,
          L16$Tracknumber$I             # MJC 5/2/2000 (E-2145)
literal   ILEX[iword]
Character msg[ARB]
integer   drop_len

integer   int_track_number
literal   literal_track_number
character    char_track_number[8]
equivalence (char_track_number, literal_track_number)

#String msg[100] "Cannot drop      " # add 5 spaces for trk 6/3/86

if (ilex[2] == $lex$Range$ | ilex[2] == $lex$OLD$)
    {
    call ODROP_RANGE (IONUM,IVIEW,IWORD,ILEX)
    return
    }
else if (ilex[2] == $lex$EOIR$ )                # jb    4/2/90
    {
    call ODROP_EOIR(IONUM,IVIEW,IWORD,ILEX)
    return
    }

ilen = 0
Call SMOVV("Cannot drop ",msg,ilen)
drop_len = ilen

for (I=2; I <= IWORD; I=I+1)                    #do for all tracks
   {
    iflg = $no
    rmt$pointer = 0

    if (JTIDS$Capable$Game == $yes)    # clk 12/95 (E1469)
      {
       literal_track_number = ilex[i]
       if (char_track_number[1] == $LetJ &              # if the track number
           char_track_number[2] >= $Dig0 &              # follows the JTIDS format
           char_track_number[2] <= $Dig8 )
         {
          int_track_number = (char_track_number[2] - $dig0) * 1000 +
                             (char_track_number[3] - $dig0) * 100 +
                             (char_track_number[4] - $dig0) * 10 +
                             (char_track_number[5] - $dig0)
          for (L16$Pointer$First; L16$Pointer$Valid; L16$Pointer$Next)
            {
             L16$TrackNumber$I = xL16$TrackNumber$I
             if (L16$TrackNumber$I == int_track_number)
               {
                L16$Zero
                iflg = $yes
                break
               }   # end of track located
            }   # end of loop through the L16 table
         }   # end specified track is in the JTIDS format
      }   # end the game is JTIDS capable

    repeat
       {
        call gtact(iview,                           #look for track
                   ILEX[I],                         #pass track number
                   RMT$POINTER,                     #receive pointer
                   ibonly)

        if(rmt$POINTER != 0)                        #if track found
           {
            call Zero_RMT_Entry (RMT$Pointer)
            iflg = $yes
            next
           }
        #$% else if track not found
        else if (iflg == $no)
           {
            #$% move track # to msg format for display
            call SMOVHN(ilex[i],$$MaxLit,msg,ilen)          # DEW 11/99 E2172
           }

        break
       }
   }

if (ilen > drop_len)
   {
    call SMOVV(".",msg,ilen)  #$% end the sentence 
    call send_ (iview,0,ilen,msg) #$% send msg to view for display
   }

return
end



Subroutine ODROP_EOIR(nord,iview,nargs,args) 

########################################################
#$%                     
#$% Purpose:   ODROP_EOIR processes a DROP EOIR order
#$%            to drop all EOIR tracks held by a named
#$%            aircraft (or UAV)
#$%
#$% Called By: ODROP
#$%
#$% Calls:     SEND
#$%            Zero_IRD_Entry   <wgmdrem.rat>
#$%
#$% Tables:    IRD
#$%
#$% Date:      APRIL 1990
#$%
#$% Author:    Joe Bryant
#$%
#$% Modified:  Carol Kropp - Sept. 1994 (E1082)
#$%            Replaced IRD$Zero with a call to
#$%            Zero_IRD_Entry, so that the track
#$%            number may be used again w/out duplication.
#$%
########################################################

BBcommon

integer         NARGS,
                IDROP,
                IRD$Pointer                 # MJC 5/2/2000 (E2145)
literal         CSTRIP8                     # MJC 5/4/2000 (E2145)
literal         args[nargs], iaddr / 0 /
integer         iview, nord

idrop = 0

for (ird$pointer$FIRST; ird$pointer$VALID; ird$pointer$NEXT)
   {
    if (xird$inuse$i == $no)                           NEXT
    if (iview != $neutral$view & iview != Xird$View$i) NEXT
    if (args[3] != Xird$DetectorName$C)                NEXT

    call Zero_IRD_Entry (IRD$Pointer)    
    idrop = idrop + 1
   }    #  End 'for ird$pointer$FIRST ...

if (idrop == 0)
    {
    call wgoerr (iview,iaddr,nord,nargs,args,"None Dropped.")
    return
    }
return
end




Subroutine OENVEL(IONUM,                               #receive order number 
                  IVIEW,                               #receive view 
                  IWORDS,                              #receive number of words 

                  ILEX)                                #receive parameters 

BBcommon

integer IWORDS,
        VUE$Pointer,
        IVIEW,
        VUE$Envelopes$I,
        VUE$Envelopesource$I,
        VUE$Envradius$I,
        IONUM                       # MJC 5/2/2000 (E-2145)
literal ILEX[iwords]

VUE$POINTER$TO IVIEW                            #get vue pointer

VUE$ENVELOPES$I = $NO                           #indicate no envelops

if(ILEX[2] != $LEX$OFF$)                        #if envelopes are not off

   {
    if     (ILEX[2] == $LEX$ALL$)       VUE$ENVELOPESOURCE$I = $ALL$CODE
    else if(ILEX[2] == $LEX$SUBMARINE$) VUE$ENVELOPESOURCE$I = $SUB$CODE
    else if(ILEX[2] == $LEX$SURFACE$)   VUE$ENVELOPESOURCE$I = $SURFACE$CODE

    VUE$ENVRADIUS$I = ILEX[3]                   #enter radius
    PUTVUE$ENVRADIUS$I

    PUTVUE$ENVELOPESOURCE$I                     #store envelope source

    VUE$ENVELOPES$I = $YES                      #enable envelopes
   }                                            #endif envelopes are not off

PUTVUE$ENVELOPES$I                              #store envelope status

return

end


Subroutine OHANDO(IONUM,                        # receive order number 
                  UNT$POINTER,                  # receive unit pointer 
                  IWORD,                        # receive message length 
                  ILEX)                         # receive command text 

#######################################################
#$%
#$% Purpose:   OHANDO processes handover commands
#$%            to transfer aircraft from one unit
#$%            to another for control (view-to-
#$%            view).
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND     HAND_BARRIER    HANDCRU 
#$%            Change_view
#$%
#$% Tables:    ACD        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% NOTE:  The AML$OwnerIndx for a handed over aircraft
#$% isn't changed by this routine.   If this field is
#$% set at a later time, the DISPLAY UNIT command
#$% processing will need to be modified, as it relies on
#$% the knowledge that the launching platform is still
#$% stored in the AML$OwnerIndx field.
#$%
#$% Modified:  Susan Miller 
#$%            Added messages for CHOPped ghosted AEW,  9/95 (E1454)
#$%            AIRTANKER or STTANKER A/C.               9/95 (E1453)
#$%
#######################################################

BBcommon

integer IWORD,litcmp,     # jb litcmp, frm [aai01...mods]  1/23/01 
        IONUM,
        INDXADDEE,
        IFOUND,
        IVIEW,
        NEWOWNERIDX,
        BML$Pointer,
        UNT2$Pointer,
        UNT2$Type$I,
        UNT2$View$I,
        UNT2$Launchindx$I,
        UNT2$Recoverindx$I,
        UNT2$Hierarchyid$I,
        UNT$Pointer,
        UNT$View$I                          # MJC 5/4/2000 (E2145)
literal UNT$Name$C,
        CSTRIP8                             # MJC 5/4/2000 (E2145)
literal ILEX[iword]
Character msg[ARB]
integer jj

#String MSG1 "      does not control          "
#String MSG2 "      handover from         "
#String MSG3 "      not in View of       "       #       6/6/85
#String MSG4 "      not found on Side of       " #       6/6/84

if (ilex[2] == $LEX$BARRIER$)                   # check for handover barrier
    {                                           # order         6/17/86
    call hand_barrier(UNT$Pointer,ILEX[3])
    return
    }

# FOR <addressee> CHOP (to) [ [ BLUE | ORANGE ] (view) <view> | NEUTRAL];
if (ilex[1] == $LEX$CHOP$)
    {                   
     if ((xUNT$GhostedUnit$I != $YES) &  # if not ghosted and       
         (xUNT$Type$I == $AIR$code))     # it is an a/c, can't CHOP it
        {
         jj = 0 
         call smovv  ("Cannot CHOP an aircraft that is not a ghost.  ", msg, jj)
         call smovv  ("Use the HANDOVER command.  ", msg, jj)
         call send_   (UNT$View$I, 0, jj, msg)
        }
     else
       call change_view (UNT$Pointer,ILEX)
     return
    }

# FOR <addressee> HANDOVER <flight-name> (to) <force-name>
#                 ilex[1]  ilex[2]            ilex[3]
INDXaddee = UNT$POINTER$INDEX  # get launch index from pointer jb 5/3/89
UNT$NAME$C = XUNT$NAME$C                        # get name of addressee
UNT$VIEW$I = XUNT$VIEW$I                        # get unit view
IFOUND = $NO                                    # indicate match not made

for(UNT2$POINTER$FIRST;UNT2$POINTER$OK;UNT2$POINTER$NEXT) # search
    {   # jb next line: litcmp, frm [aai01...mods]  1/23/01 
    if(litcmp(XUNT2$NAME$C, ILEX[2]) == 0) # if name match
        {
        unt2$TYPE$i = Xunt2$TYPE$i             # jb            5/3/89
        if (unt2$TYPE$i == $CruiseMissile$Code)      # jb No X  5/3/89 
            {   # To change View of the CruiseMissile...
            unt2$View$i = Xunt2$View$i
            if (unt2$View$i != unt$View$i)
                {
                jj = 0 
                call SMOVHN(ilex[2],$$MaxLit,msg,jj)      # missile name
                Call SMOVV(" not in View of ",msg,jj)
                call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)   # sender name

                call send_(unt2$View$i,  # Sender's view index
                          0,            # 0 = status flag
                          jj,           # message length
                          MSG)         # formerly MSG3 
                }
            else        # no problem with transferor View..
                {    
                call HandCRU (unt2$Pointer,unt2$View$i,ILEX[3],IFOUND)
                if (IFOUND != $NO)
                    {
                    jj = 0 
                    call SMOVHN(ilex[2],$$MaxLit,msg,jj)      # missile name
                    Call SMOVV(" handover from ",msg,jj)
                    call SMOVHN(unt$name$c,$$MaxLit,msg,jj)   # transferor name

                    call send_(Ifound,           #message to rcvr 6//18/85
                               0,               #0 = status flag
                               jj,              #jj = message length
                               MSG)             # formerly msg2
                    }    # End if IFOUND..
                else # receiver not found on same side as missile
                    {
                    jj = 0 
                    call SMOVHN(ilex[3],$$MaxLit,msg,jj)     # receiver name
                    Call SMOVV(" not found on Side of ",msg,jj)
                    call SMOVHN(ilex[2],$$MaxLit,msg,jj)   # missile name

                    call send_(unt2$View$i, # Sender view index 6/18/85
                                0,              # 0 = status flag
                                jj,             # message length
                                MSG)           # formerly MSG4 
                    }   # End of receiver not found/on missile's side
                }       # End of else..call HandCRU

            RETURN
            }   # End if (unt2$TYPE$i == $CruiseMissile$Code)
     
        if(Xunt2$LAUNCHINDX$I == INDXaddee & #if flight launched by addee
             (unt2$type$i == $AIR$code | 
              Xunt2$SuperType$i == $SmallBoat$SuperCode )) #    DEW 5/1/90
           {
            for(UNT$POINTER$FIRST;UNT$POINTER$OK;UNT$POINTER$NEXT) #search
                {  # jb next line: litcmp, frm [aai01...mods]  1/23/01 
                if(litcmp(XUNT$NAME$C, ILEX[3]) == 0)  #if name match
                    {
                     if (xUNT$GhostedUnit$I == $yes)   # clk 12/93 - cannot
                       {                               # handover to ghosted units
                        jj = 0 
                        call smovv  ("Cannot handover ", msg, jj)
                        call smovhn (ilex[2], $$MaxLit, msg, jj)
                        call smovv  (" to ", msg, jj)
                        call smovhn (ilex[3], $$MaxLit, msg, jj)
                        call smovv  (" - ", msg, jj)
                        call smovhn (ilex[3], $$MaxLit, msg, jj)
                        call smovv  (" is a ghosted unit.", msg, jj)
                        call send_   (UNT$View$I, 0, jj, msg)
                        break
                       }     # end of attempting to handover to a ghost
                     else
                       {
                        IVIEW = XUNT$VIEW$I           #get view of receiver

                        if((UNT$VIEW$I < $FIRSTORANGE$VIEW &    #if blue and
                             IVIEW < $FIRSTORANGE$VIEW &    #other is blue
                             IVIEW != $Neutral$view) |        #and not control (or)
                             (UNT$VIEW$I > $LASTBLUE$VIEW &       #if orange and
                             IVIEW > $LASTBLUE$VIEW))       #other is orange
                           {
                            NewOWNERidx = UNT$POINTER$INDEX    # jb    5/3/89
                            unt2$LAUNCHINDX$I = NewOWNERidx    # jb    5/3/89
                            PUTunt2$LaunchIndx$I # jb - Insert This??? 5/3/89

                            unt2$RECOVERINDX$I =  NewOWNERidx # jb    5/3/89
                            PUTunt2$RECOVERINDX$I # jb /\ \/ unt2 vice dyn 3/30/89

                            UNT2$VIEW$I = XUNT$VIEW$I  #get new view
                            PUTUNT2$VIEW$I

                            UNT2$HierarchyId$i = XUNT$HierarchyId$i
                            PUTUNT2$HierarchyId$i

                            if(Xunt2$SuperType$i == $SmallBoat$SuperCode) # DEW 5/1/90
                             {
                              BML$Pointer$TO (Xunt2$BMLindx$i) # jb    5/3/89
                              putBML$OwnerIndx$i (NewOWNERidx) # jb    5/3/89
                             }

                            jj = 0              # SMM 8/99 E2141
                            call SMOVHN(ilex[2],$$MaxLit,msg,jj)      #enter flight name
                            Call SMOVV(" handover from ",msg,jj)
                            call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)#inter sender name

                            call send_(IVIEW,            #send message to rcvr
                                   0,                #IVIEW = player view index
                                   jj,               #0 = status flag
                                   MSG)              #jj = message length
                                                     #formerly msg2
                            IFOUND = $YES                       #flag found
                            break                               #exit the loop
                           }    # end of a valid side match for handover
                       }        # end of unit handling over to is a RESA owned unit
                    }           # end of a name match
                }               # end of search for unit to handover to
            if(IFOUND == $YES)                           #if handover ok
                {
                break                                     #exit the loop
                }
            else
                {
                jj = 0
                #$% move data to msg1 format for display
                call SMOVHN(ilex[3],$$MaxLit,msg,jj)
                Call SMOVV(" can not control ",msg,jj)
                call SMOVHN(ilex[2],$$MaxLit,msg,jj)

                #$% send msg to view for display
                call send_(UNT$VIEW$I,0,jj,MSG) # formerly msg1

                break
                }               # End of else.. IFOUND is NO
           }
        else
           {
            jj = 0
            #$% move data to msg1 format for display
            call SMOVHN(unt$name$c,$$MaxLit,msg,jj)
            Call SMOVV(" does not control ",msg,jj)
            call SMOVHN(ilex[2],$$MaxLit,msg,jj)

            #$% send msg to view for display
            call send_(UNT$VIEW$I,0,jj,MSG) # formerly msg1

            break
           }
        }    # End if Name Matches..
    }  # End For(unt2...
return
end        # End  OHANDO

Subroutine OSCUTTLE(IONUM,                        # receive order number 
                    UNT$POINTER,                  # receive unit pointer 
                    IWORD,                        # receive message length 
                    ILEX)                         # receive command text 

#######################################################
#$%
#$% Purpose:   OSCUTTLE processes scuttle command
#$%            which removes owned barriers
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND     
#$%
#$% Tables:    BOY        UNT
#$%
#$% Date:      July 10, 2006
#$%
#$% Author:    James O. Allen
#$%
#######################################################

BBcommon

BBDeclare (unt$pointer, boy$pointer, boy$Type$i)
integer IWORD,litcmp,  
        IONUM,
        IFOUND
literal CSTRIP8
literal ILEX[iword]
Character msg[ARB]
integer jj
integer indx

ifound = $no
indx = unt$pointer$index

for (boy$pointer$first; boy$pointer$ok; boy$pointer$next)
{
    boy$Type$i = Xboy$Type$i
    if (boy$Type$i != $ActiveBarrier$code &
        boy$Type$i != $PassiveBarrier$code) next

    if (Xboy$OwnerIndx$i == indx)
    {
        PUTboy$KillTime$f (1.0)     # Mark for deletion by remove_buoys
        ifound = $yes
        call clear_maneuver_all (barrier$order, -1, xUNT$View$I, UNT$Pointer)
    }
}    

if (ifound == $yes)
{
    jj = 0
    call SMOVHN(Xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" scuttled owned barriers.",msg,jj)
    #$% send msg to view for display
    call send_(XUNT$VIEW$I,0,jj,MSG) # formerly msg1
}

if (ifound == $no & iword != 0)     # iword is zero if called from bingo
{
    jj = 0
    call SMOVHN(Xunt$name$c,$$MaxLit,msg,jj)
    Call SMOVV(" does not own any barriers. No barriers scuttled. ",msg,jj)
    #$% send msg to view for display
    call send_(XUNT$VIEW$I,0,jj,MSG) # formerly msg1
}

return
end

Subroutine Hand_Barrier (UNT$Pointer,                   # Current Owner 
                         UNT2$Name$C)                   # New Owner 

########################################################################
#$%
#$% Purpose:   Hand_Barrier processes handover commands
#$%            to transfer monitoring of sonobuoy barriers from one 
#$%            aircraft to another.
#$%
#$% Called By: OHANDO
#$%
#$% Calls:     SEND     SMOV    SMOVH
#$%
#$% Tables:    UNT      BOY     ACC
#$%
#$% Date:      June 1986
#$%
#$% Author:    C. L. Farbstein
#$%
########################################################################

BBcommon
character msg[ARB]
integer   owner_index,receiver_index

integer   ILEN,litcmp,  # jb litcmp, frm [aai01...mods]  1/23/01
          IFOUND,
          UNT$Pointer,
          UNT$Aswindx$I,
          BOY$Pointer,
          BOY2$Pointer,
          ACC$Pointer,
          ACC$Cruisespeed$I,
          ASW$Pointer,
          UNT2$Pointer                  # MJC 5/2/2000 (E2145)
real      UNT2$Orderedspeed$F           # MJC 5/2/2000 (E2145)
literal   UNT2$Name$C,
          UNT$Name$C,
          CSTRIP8                       # MJC 5/4/2000 (E2145)

String MSG1 " does not control a barrier"
String MSG2 " handover from "
String MSG3 " not in View of "
String MSG4 " does not exist"
String MSG5 " can not control a barrier"
String MSG6 " can not control a barrier, it's a ghost"

ilen = 0
UNT$Name$C = xUNT$Name$C
if (xUNT$HasBarrier$I == $YES)
    {
    ifound = $NO
    for (UNT2$Pointer$First; UNT2$Pointer$OK; UNT2$Pointer$Next)
        {   # jb next line: litcmp, frm [aai01...mods]  1/23/01 
        if (litcmp(xUNT2$Name$C, UNT2$Name$C) == 0) # if name match
            {
            ifound = $YES
            if (xUNT2$GhostedUnit$I == $yes)
              {
                call smovhn (UNT2$Name$C, $$MaxLit, MSG, ilen) # receiver is a ghost
                call smovh (MSG6, ARB, MSG, ilen) 
              }
            else if (xUNT$View$I == xUNT2$View$I)
                {
                if (xUNT2$Type$I == $Air$Code)
                    {
                    receiver_index = UNT2$Pointer$Index
                    UNT2$Pointer$to receiver_index
                    owner_index = UNT$Pointer$Index                
                    boy2$pointer = 0
                    for (BOY$Pointer$First; BOY$Pointer$ok; BOY$Pointer$Next)
                        {
                        if (xBOY$OwnerIndx$I == owner_index &
                           (xBOY$Type$I == $ActiveBarrier$Code |
                            xBOY$Type$I == $PassiveBarrier$Code))
                            {
                            putBOY$OwnerIndx$I (receiver_index)
                            BOY2$Pointer = BOY$Pointer
                            }
                        }
                    UNT$ASWindx$i = xUNT$ASWindx$i        # jb    6/18/90
                    If(UNT$ASWindx$i != $NO)              # jb    6/18/90
                        {    # Release slot for next PERFORM ASW command..
                        putUNT$ASWindx$i ($NO)            # jb    6/18/90
                        ASW$Pointer$TO (UNT$ASWindx$i)    # jb    6/18/90
                        if(ASW$Pointer$VALID)    ASW$ZERO # jb    6/18/90
                        }
                    putUNT$HasBarrier$I ($NO)
                    if (boy2$pointer != 0)
                        {
                        putUNT2$HasBarrier$I ($YES)
                        ACC$Pointer = xUNT2$AccPntr$I
                        ACC$CruiseSpeed$I = xACC$CruiseSpeed$I  # get cruise speed
                        putUNT2$Status$I ($Proceeding$Code)
                        UNT2$OrderedSpeed$F = ACC$CruiseSpeed$I 
                        putUNT2$OrderedSpeed$F
                        putUNT2$OrderedAltDepth$I  (5000)   # climb to 5000 feet
                        putUNT2$OrderedLatitude$F  (xBOY2$AssumedLatitude$F)
                        putUNT2$OrderedLongitude$F (xBOY2$AssumedLongitude$F)
                        call smovhn (UNT2$Name$C,$$MaxLit,MSG,ilen) # valid handover
                        call smovh (MSG2,ARB,MSG,ilen)
                        call smovhn (UNT$Name$C,$$MaxLit,MSG,ilen)
                        }
                    else
                        {
                        call SMOVHN(UNT$Name$C,$$MaxLit,MSG,ilen)                  # Addressee does not 
                        call smovh (MSG1,ARB,MSG,ilen)                      # control a barrier
                        }
                    }
                else
                    {
                    call smovhn (UNT2$Name$C,$$MaxLit,MSG,ilen) # receiver not an
                    call smovh (MSG5,ARB,MSG,ilen)      # aircraft
                    }
                }
            else
                {
                call smovhn (UNT2$Name$C,$$MaxLit,MSG,ilen)     # owner and receiver
                call smovh (MSG3,ARB,MSG,ilen)          # not in same view
                call smovhn (UNT$Name$C,$$MaxLit,MSG,ilen)
                }
            break                                       # break the search loop
            }
        }
    if (ifound == $NO)
        {
        call smovhn (UNT2$Name$C,$$MaxLit,MSG,ilen)             # receiver not found
        call smovh (MSG4,ARB,MSG,ilen)
        }
    }
else
    {
    call SMOVHN(UNT$Name$C,$$MaxLit,MSG,ilen)                  # Addressee does not 
    call smovh (MSG1,ARB,MSG,ilen)                      # control a barrier
    }

call smov (EOS,MSG,ilen)
call send_(xUNT$View$I,0,ilen,MSG)

return
end        # End  HAND_BARRIER

 Subroutine OLABEL(IONUM,                              #receive order number 
                   IVIEW,                              #receive view 
                   IWORDS,                             #receive number of words 

                   ILEX)                               #receive parameters

 #######################################################
 #$%
 #$% Purpose:   OLABEL processes label commands
 #$%            by setting flags for YES/NO on
 #$%            displaying labels of units on
 #$%            PLOT display.
 #$%
 #$% Called By: EXEORD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    VUE
 #$%
 #$% Date:      APRIL 80
 #$%
 #$% Author:    Dana Wills
 #$%
 #######################################################

 BBcommon

 integer IWORDS,
         IVIEW,
         IONUM,
         VUE$Pointer,
         VUE$Label$I                    # MJC 5/2/2000 (E-2145)
 literal ILEX[iwords]

 VUE$POINTER$TO IVIEW                           #get view pointer

 VUE$LABEL$I = $NO                              #assume labels off

 if(ILEX[2] == $LEX$ALL$)                       #if all labels on

    {
     VUE$LABEL$I = $YES                         #turn labels on
    }                                           #endif all labels on

 PUTVUE$LABEL$I                                 #store label flag

 return

 end





Subroutine OLOB(IONUM,                          #receive order number 
                IVIEW,                          #receive view 
                IWORDS,                         #receive number of words 
                ILEX)                           #receive parameters 

########################################################
#$%
#$% Purpose:   OLOB processes LOB commands.  Flags
#$%            ON/OFF on displaying line-of-bearings
#$%            to be displayed by PLOT.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     UNTFND
#$%
#$% Tables:    VUE        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORDS,
        IONUM,
        IVIEW,
        UNT$Pointer,
        VUE$Pointer,
        VUE$Bearingsource$I                     # MJC 5/2/2000 (E-2145)
literal ILEX[iwords]

VUE$POINTER$TO IVIEW                            #get view pointer

if (ILEX[2] == $LEX$OFF$)                       #if bearings off
   {
    VUE$BEARINGSOURCE$I = 0
    PUTVUE$BEARINGSOURCE$I
   }
else if (ILEX[2] == $LEX$ALL$)                  #if bearings from all
   {
    VUE$BEARINGSOURCE$I = UNT$SLOTS+1
    PUTVUE$BEARINGSOURCE$I
   }
else if(ILEX[2] == $LEX$FORCE$)                 #if bearings from a force
   {
    call UNTFND(IVIEW,                          #locate the force
                ILEX[3],
                UNT$POINTER)                    #receive the force pointer

    if (unt$pointer != 0) VUE$BEARINGSOURCE$I = UNT$POINTER$INDEX
    else                  VUE$BEARINGSOURCE$I = 0
    PUTVUE$BEARINGSOURCE$I
   }

return
end






Subroutine OMISSN(IONUM, 
                  UNT$POINTER, 
                  IWORD, 
                  ILEX) 

########################################################
#$%
#$% Purpose:   OMISSN processes mission commands
#$%            for each unit.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     WHSIDE     SETURP
#$%            Lex_to_Mission_Code   <lbcommn.rat> 
#$%
#$% Tables:    RPM
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 10/94
#$%            Added call to Record_C2_Flight_Mission_Change
#$%            for update of the mission history data
#$%            (WPC C2 Interface).
#$%
#$%            Carol Kropp - 4/95 (E1393)
#$%            Moved if/else statements to determine
#$%            mission code to lbcommn.rat, so that
#$%            other programs could use the same code.
#$%
#$%            Carol Kropp - 12/96 (E1724)
#$%            Only call Record_C2_Flight_Mission_Change
#$%            if the unit is an aircraft.
#$%
#$%            Carol Kropp - 12/96 (E1726)
#$%            Record_C2_Flight_Mission_Change changed
#$%            to Record_Flight_Mission_Change.
#$%
########################################################

BBcommon

integer IWORD,
        ISIDE,
        IONUM,
        RPM$Pointer,
        UNT$Mission$I,
        UNT$Pointer                 # MJC 5/2/2000 (E-2145)
literal ILEX[iword]

#$% if misssion is valid input
call Lex_to_Mission_Code (ilex[2], UNT$Mission$I)
if (UNT$Mission$I == -1)
  UNT$Mission$I = xUNT$Mission$I

PUTUNT$MISSION$I

#$% get side for mission
call whside(xunt$view$i,iside)

#$% search through reporting policies
for (rpm$pointer$first;rpm$pointer$ok;rpm$pointer$next)
   {
    #$% find mission data
    if (xrpm$Side$i          != iside        )  next
    if (xrpm$AddresseeType$i != $mission$code)  next
    if (xrpm$Addressee$i     != unt$mission$i)  next
    break
   }

#$% if reporting policy pointer not in range, set pointer to zero
if (! rpm$pointer$ok) rpm$pointer = 0

call SETURP(unt$pointer,rpm$pointer)

#if (xUNT$Type$I == $Air$Code)
  call Record_Flight_Mission_Change (UNT$Pointer)

return
end





Subroutine OMODE(IONUM,                         #receive order number 
                 UNT$POINTER,                   #receive addressee pointer 
                 IWORD,                         #receive count 
                 ILEX)                          #receive command string 

########################################################
#$%
#$% Purpose:   OMODE processes MODE commands to
#$%            set the propulsion mode to diesel
#$%            or electric.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT        SHD
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Alex Vagus  9/94 PER E1328
#$%            Mode diesel order will be rejected when 
#$%            submarine is below periscope depth. 
#$%
#$%            Carol Kropp 10/94 (E1328)
#$%            Added check to make sure sub is diesel
#$%            type.  Also added extra error messages.
#$%
#$%            Susan Miller 7/96 (E1623)
#$%            Made the error message match the entered
#$%            order when a sub is nuclear.
#$%
########################################################
BBcommon

integer   IWORD,
          IONUM,
          SHC$Pointer,
          SHC$Nuclearpowered$I,               # MJC 4/2/2000 (E2145)
          UNT$Propulsionmode$I,
          UNT$Pointer
literal   UNT$Name$C,
          CSTRIP8                            # MJC 5/4/2000 (E2145)
literal   ilex[iword]

character msg[ARB]
integer   msg_len

  UNT$Name$C = xUNT$Name$C
  if (xUNT$Type$I == $Sub$Code)              # if submarine
    {
     SHC$Pointer = xUNT$SHCPntr$I            # get char pointer

     SHC$NuclearPowered$I = xSHC$NuclearPowered$I
     if (SHC$NuclearPowered$I == $yes)       # if sub is nuc (E1238)
       {
        msg_len = 0
        call smovhn (UNT$Name$C, $$MaxLit, msg, msg_len)
        if (ilex[2] == $LEX$ELECTRIC$)      # SMM 7/96 (E1623)
            call smovv  (" cannot switch to electric mode - ", msg, msg_len)
        else # if (ilex[2] == $LEX$DIESEL$)
            call smovv  (" cannot switch to diesel mode - ", msg, msg_len)
        call smovv  ("submarine is nuclear powered.", msg, msg_len)
        call smov   ($bell, msg, msg_len)       
        call send_   (xUNT$View$I, 0, msg_len, msg)
       }
     else
       {
        if (ilex[2] == $LEX$ELECTRIC$)          # if electric
          {
           UNT$PropulsionMode$I = $Electric$Code
           if (Xunt$PropulsionMode$I != $Electric$Code)
           {
               putUNT$PropulsionMode$I
               putUNT$PropulsionChangedFlag$I($yes)
           }
          }
        else if (ilex[2] == $LEX$DIESEL$)
          {
           if (xUNT$TrueAltDepth$I > xSHC$ScopeDepth$I)   # must be at periscope depth
             {                                            # or higher to diesel (E1328)
              msg_len = 0
              call smovhn (UNT$Name$C, $$MaxLit, msg, msg_len)
              call smovv  (" cannot switch to diesel mode - ", msg, msg_len)
              call smovv  ("submarine is below periscope depth.", msg, msg_len)
              call smov   ($bell, msg, msg_len)       
              call send_   (xUNT$View$I, 0, msg_len, msg)
             }   
           else
             {
              UNT$PropulsionMode$I = $Diesel$Code
              if (Xunt$PropulsionMode$I != $Diesel$Code)
              {
                   putUNT$PropulsionMode$I
                   putUNT$PropulsionChangedFlag$I($yes)
              }
              putUNT$PropulsionMode$I
             }   # end of is switch to diesel depth check
          }  # end of mode switch is to electric/diesel
       }   # end of unit is correct type nuclear/diesel
    }   # end of unit is a submarine

return
end        # End   OMODE





Subroutine OPLOT(IONUM,                         #receive order number 
                 IVIEW,                         #receive view 
                 IWORDS,                        #receive number of words 
                 ILEX)                          #receive parameters 

BBcommon

integer IWORDS,
        IPNT,
        ITYPE,
        ICAT,
        ICENTR,
        IONUM,
        IVIEW,
        VUE$Pointer,
        VUE$Plotradius$I,
        VUE$Plotmap$I,
        VUE$Plottype$I,
        VUE$Plotcategory$I              # MJC 5/2/2000 (E-2145)
literal ILEX[iwords]

String msg1 "ERASE commands are not implemented yet. "


VUE$POINTER$TO IVIEW                            #set VUE pointer

if (ilex[1] == $lex$Radius$)
   {
    vue$PlotRadius$i = ilex[2]
    PUTvue$PlotRadius$i

    VUE$PLOTMAP$I = $YES
    PUTVUE$PLOTMAP$I
   }
else if (ilex[1] == $lex$Erase$)
   {
    #$% send msg to view for display
    call send_ (iview,0,40,msg1)
   }
else if (ilex[1] == $lex$Center$)
   {
    ipnt = 2
    call oplotc (ipnt,iview,iwords,ilex)        # set up center point
   }

else if (ilex[1] == $lex$Plot$)
   {
    for (ipnt = 2; ipnt <= iwords; )
       {
        if     (ILEX[ipnt] == $LEX$ALL$     ) itype = $ALL$CODE
        else if(ILEX[ipnt] == $LEX$BLUE$    ) itype = $BLUE$CODE
        else if(ILEX[ipnt] == $LEX$ORANGE$  ) itype = $ORANGE$CODE
        else if(ILEX[ipnt] == $LEX$ENEMY$   ) itype = $ENEMY$CODE
        else if(ILEX[ipnt] == $LEX$FRIENDLY$) itype = $FRIENDLY$CODE
        else if(ILEX[ipnt] == $LEX$NEUTRAL$ ) itype = $NEUTRAL$CODE
        else if(ILEX[ipnt] == $LEX$OTHER$   ) itype = $OTHER$CODE
        else if(ILEX[ipnt] == $LEX$OWN$     ) itype = $OWN$CODE
        else if(ILEX[ipnt] == $LEX$UNKNOWN$ ) itype = $UNKNOWN$CODE
        else                                  itype = -1

        if (itype != -1)
           {
            ipnt = ipnt + 1

            if (ipnt <= iwords)
               {
                if     (ILEX[ipnt] == $LEX$AIR$      ) icat = $AIR$CODE
                else if(ILEX[ipnt] == $LEX$SUBMARINE$) icat = $SUB$CODE
                else if(ILEX[ipnt] == $LEX$SURFACE$  ) icat = $SURFACE$CODE
                else                                   icat = $ALL$CODE
               }
            else                                       icat = $ALL$CODE

            if (icat != $ALL$CODE) ipnt = ipnt + 1

            VUE$PLOTTYPE$I = itype
            PUTVUE$PLOTTYPE$I

            VUE$PLOTCATEGORY$I = icat
            PUTVUE$PLOTCATEGORY$I

            next
           }

        if     (ILEX[ipnt] == $LEX$FORCE$   ) icentr = $yes
        else if(ILEX[ipnt] == $LEX$POSITION$) icentr = $yes
        else if(ILEX[ipnt] == $LEX$TRACK$   ) icentr = $yes
        else                                  icentr = $no

        if (icentr == $yes)
           {
            call oplotc (ipnt,iview,iwords,ilex)        # set up center point

            vue$PlotRadius$i = ilex[ipnt]
            PUTvue$PlotRadius$i

            ipnt = ipnt + 1
            next
           }

        ipnt = ipnt + 1
       }

    VUE$PLOTMAP$I = $YES                        #flag new map
    PUTVUE$PLOTMAP$I
   }

return
end





Subroutine OPLOTC(ipnt,                     # set up center point 
                  IVIEW,                    #ipnt = pointer to FORCE/TRACK/POS 

                  IWORDS, 
                  ILEX) 

########################################################
#$%
#$% Purpose:   OPLOTC processes orders to locate
#$%            a unit and plot the center point.
#$%
#$% Called By: OPLOT
#$%
#$% Calls:     UNTFND     FNDOWN     SEND
#$%            GTACT
#$%
#$% Tables:    VUE        UNT        RMT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORDS,IVIEW,IPNT,JJ,
        IDUMMY,NOROOM,IBONLY,
        UNT$Pointer,
        OWN$Pointer,
        RMT$Pointer,
        VUE$Pointer,
        VUE$Plotmap$I,
        VUE$Plotsource$I,
        VUE$Plotsourcetype$I                # MJC 5/2/2000 (E-2145)
real    VUE$Latitude$F,
        VUE$Longitude$F,
        DMS2RAD                             # MJC 5/2/2000 (E-2145)
literal ILEX[iwords]
Character msg[ARB]

#String msg1 "      cannot be found for PLOT  "
#String msg2 "Can't center plot on passive track      "


#$% set vue pointer to current view
vue$pointer$to IVIEW
#$% get where plot originated
VUE$PLOTSOURCE$I = XVUE$PLOTSOURCE$I

#$% if input request is a force
if (ILEX[ipnt] == $LEX$FORCE$)
   {
    ipnt = ipnt + 1
    jj = 0   
    #$% move force into msg1 format for display
    call SMOVHN(ilex[ipnt],$$MaxLit,msg,jj)
    Call SMOVV(" cannot be found for PLOT ",msg,jj)
    
    call UNTFND(IVIEW,                          #locate the unit
                                          #IVIEW = the view (in)
                ILEX[ipnt],                     #pass the force name
                UNT$POINTER)                    #receive unit pointer or zero

    if (unt$pointer != 0 & iview != $Neutral$view)
       {
        call FNDOWN(own$pointer,                     #locate the unit
                    unt$pointer$index,
                    idummy,
                    noroom)

        if (noroom == $yes | Xown$Unit$i == 0) unt$pointer = 0
       }

    ipnt = ipnt + 1

    if(unt$pointer == 0)                        #if unit not found
       {
        #$% send msg1 to view for display
        call send_(iview,0,jj,msg)  # formerly msg1
        return
       }

    #$% if CONTROL view
    if (iview == $Neutral$view)
       {
        #$% get whatever unit and its pointer index
        vue$PlotSourceType$i = $True$code
        vue$PlotSource$i = unt$pointer$index
       }
    #$% else if a Blue/Orange player
    else
       {
        #$% can only get own pointer index
        vue$PlotSourceType$i = $OwnForce$code
        vue$PlotSource$i = own$pointer$index
       }
   }
#$% else if requested data is position
else if (ILEX[ipnt] == $LEX$POSITION$)
   {
    ipnt = ipnt + 1
    VUE$LATITUDE$F = DMS2rad(ILEX[ipnt])         #enter latitude
    PUTVUE$LATITUDE$F

    ipnt = ipnt + 1
    VUE$LONGITUDE$F = DMS2rad(ILEX[ipnt])        #enter longitude
    PUTVUE$LONGITUDE$F

    ipnt = ipnt + 1

    vue$PlotSourceType$I = $Null$code
   }
#$% else if data requested is a track
else if (ILEX[ipnt] == $LEX$TRACK$)
   {
    ipnt = ipnt + 1
    rmt$pointer = 0

    call gtact (iview,                          #locate track
                ILEX[ipnt],                     #pass track number
                RMT$POINTER,                    #receive detection pointer
                ibonly)

    if(rmt$POINTER == 0)                        #if track invalid for this vue
       {
        #$% send msg to view for display
        jj = 0
        Call SMOVHN(ilex,$$MaxLit,msg,jj)               # DEW   11/99 E2172
        Call SMOVV(" cannot be found for PLOT ",msg,jj)
        call send_(iview,0,jj,msg)
        return
       }

    if(ibonly == $yes)                          #if track passive
       {
        #$% send msg to view for display
        jj = 0
        Call SMOVV(" Can't center plot on passive track ",msg,jj)
        call SMOVHN(ilex,$$MaxLit,msg,jj)               # DEW 11/99 E2172
        call send_(iview,0,jj,msg)
        return
       }

    vue$PlotSourceType$i = $OtherForce$code

    vue$PlotSource$i = rmt$pointer$index
   }                                            #endif track centered

PUTvue$PlotSourceType$i
PUTvue$PlotSource$i

vue$PlotMap$i = $yes                            #flag new map
PUTvue$PlotMap$i

return
end        # End  OPLOTC





Subroutine OPROCE(IONUM, 
                  UNT$POINTER, 
                  Nargs, 
                  ILEX, 
                  ID) 

########################################################
#$%
#$% Purpose:   OPROCE processes proceed commands.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FNDORD     RRB2LL     FCOS
#$%
#$% Tables:    ORD        UNT
#$%            ACC
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  James Allen - 12/97 (E1370)
#$%            Added call to clear_maneuver_all after
#$%            command is validated.
#$%
#$%            James Allen - 10/02 (E2308)
#$%            Process Altitude keyword.
#$%            This will make order consistent with ATI.
#$% 
########################################################

BBcommon

integer   NARGS,IBLUE,IORANGE,INEUTRAL,
          ID,K,IONUM,NAMSLOT,IOKAY,JJ,IPNT,
          ORD$Pointer, ORD$Phase$I,
          UNT$Status$I, UNT$Pointer,
          ACC$Pointer, SHC$Pointer,
          RTE$Pointer, RTE$View$I,
          UNT$View$I, UNT$Rteindx$I,
          UNT$OrderedAltDepth$i,
          UNT$Routeinreverseflag$I,
          UNT$Type$I
integer   iseq,icnt,ilen,rseq,i, nord
real      UNT$Rangetonext$F,
          UNT$Orderedlatitude$F,
          UNT$Orderedlongitude$F,
          UNT$Orderedspeed$F,
          BRG,FCOS,DMS2RAD                  # MJC 5/2/2000 (E-2145)
literal   UNT$Name$C,
          CSTRIP8                           # MJC 5/4/2000 (E2145)
logical foundSpeed
integer idnum, ista
literal ILEX[nargs]
Literal iinp[$order$array$size]
character msg1[60]            # jb    12/21/89
BBDeclare (rto$wrd$$c, vue$pointer, rto$wrd$index, rto$pointer)    
#$% 11/22/89 Added for route sharing.
iblue = $no
iorange = $no
ineutral = $no                # reh, 2/4/91

unt$Status$i = Xunt$Status$i                    # jb            8/18/89
call fndord (id,ord$pointer)                    # find the order in ORD


if (ord$pointer != 0)                           # Is this a multi-phase order?
   {                                            #   YES
    ord$phase$i = Xord$phase$i 

    if (ord$phase$i == 0)                       # First time thru ??
       {
        k = xord$sequence$i - Xord$count$i      # is this the Nth of N commands

        if ( k != 0 ) PUTord$phase$i (1)        # No, so save this for awhile
       }
    else                                        # there yet?
       {
        if (unt$status$i == $OnStation$code) 
            {
            PUTord$phase$i (0)                  # Yes.....
            }

        return
       }
   }

if (ILEX[2] == $LEX$COURSE$)                    #if course, distance
   {
    call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)
    UNT$RANGETONEXT$F = ILEX[4]          #get range
    PUTUNT$RANGETONEXT$F

    BRG = ILEX[3] * ($PI/180.)                  #get course

    UNT$ORDEREDLATITUDE$F = XUNT$ASSUMEDLATITUDE$F   #get assumed lat

    UNT$ORDEREDLONGITUDE$F = XUNT$ASSUMEDLONGITUDE$F #get assumed lon

    FCOS = COS(UNT$ORDEREDLATITUDE$F)

    call RRB2LL(UNT$ORDEREDLATITUDE$F,          
                UNT$ORDEREDLONGITUDE$F,
                UNT$RANGETONEXT$F,
                BRG,
                0.0,
                FCOS)

   }

# end route logic
else                                            #if location
   {
    call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)

    UNT$ORDEREDLATITUDE$F = DMS2rad(ILEX[3])     #get latitude
    UNT$ORDEREDLONGITUDE$F = DMS2rad(ILEX[4])    #get longitude
   }


PUTUNT$ORDEREDLATITUDE$F
PUTUNT$ORDEREDLONGITUDE$F

unt$type$i  = Xunt$type$i

ipnt = 5
foundSpeed = .false.

while (nargs > ipnt)
{
    if (ILEX[ipnt] == $lex$SPEED$)                 # if speed specified...
    {
        foundSpeed = .true.
        unt$OrderedSpeed$f = ILEX[ipnt+1]                       # jb    3/30/89
        ipnt = ipnt + 2
    }
    else if (ILEX[ipnt] == $lex$ALTITUDE$)                 #
    {
        unt$OrderedAltDepth$I = ilex[ipnt+1]
        putUNT$OrderedAltDepth$I
        if (nargs >= ipnt + 2)
        {
            if (ilex[ipnt+2] == $lex$RELATIVE$)
            {
                putUNT$AltAboveGround$I  (unt$OrderedAltDepth$i)
                ipnt = ipnt + 1
            }
            else
                putUNT$AltAboveGround$I  (0)
        }
        ipnt = ipnt + 2
    }
    else                                # Unrecognized lex code
        ipnt = ipnt + 1
}

if (foundSpeed == .false.)
{
    #maintain current speed     tmb 4/18
    #if the speed is not exactly a whole number, then round up
    #unfortunately previous OrderedSpeed is no longer available, use truespeed
    unt$OrderedSpeed$f = Xunt$TrueSpeed$F
    if (( unt$OrderedSpeed$f - AINT( unt$OrderedSpeed$f ) ) > 0.0 )
    {
       unt$OrderedSpeed$f = NINT( unt$OrderedSpeed$f + 0.5 )
    }
    if (unt$OrderedSpeed$f <= 0.0 )
    {
       if (unt$type$i == $air$code)
       {
           acc$pointer = Xunt$accPntr$i                        # jb    3/30/89
           unt$OrderedSpeed$f = Xacc$CruiseSpeed$I             # jb    3/30/89
       }
       else
       {
            shc$pointer = Xunt$SHCPntr$i
            unt$OrderedSpeed$f = Xshc$CruiseSpeed$I    # staspd joa 2/05
       }
    }
}

PUTunt$OrderedSpeed$f                                    # jb    3/30/89

if(UNT$Status$I !=$Sinking$Code & UNT$Status$I != $UnderTow$Code &
   UNT$Status$I !=$DeadinWater$Code) # jb 8/18/89;    /\  8/28/89
        putUNT$STATUS$I ($PROCEEDING$CODE)

if (unt$type$i == $air$code &                     # jb    #    3/30/89
    Xunt$MarshallStatus$i == $Recovering$Code)
        PUTunt$MarshallStatus$i ($inflight$code)


return
end    # End  OPROCE






Subroutine ORECAL(IONUM, 
                  UNT$POINTER, 
                  IWORD, 
                  ILEX) 

########################################################
#$%
#$% Purpose:   ORECAL processes recall commands
#$%            to recall aircraft flights.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     BINGO
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORD,
        IONUM,
        UNT$Pointer,
        UNT2$Pointer,
        UNT2$Status$I,
        UNT2$Type$I,
        UNT2$Launchindx$I,
        UNT2$Supertype$I                  # MJC 5/2/2000 (E-2145)
literal ilex[iword], args[$max$args]      # args & nargs added for mooring boats (H1040)
integer nargs

if (ilex[2] == $lex$FLIGHT$)    # RECALL FLIGHT (missions)
{
    for(unt2$pointer$first;unt2$pointer$ok;unt2$pointer$next) # search for flight
    {
        unt2$status$i = xunt2$status$i
        unt2$type$i   = xunt2$type$i

        if (unt2$status$i == $beingdeleted$code | unt2$type$i != $air$code)  next

        unt2$launchindx$i = xunt2$launchindx$i                
        if (unt2$launchindx$i != unt$pointer$index) next      

        call bingo(unt2$pointer)                     #bingo the flight
    }
}
else if (ilex[2] == $lex$BOAT$) # RECALL BOAT (missions)    # H1040
{
    for (UNT2$Pointer$First; UNT2$Pointer$OK; UNT2$Pointer$Next)
    {
        UNT2$SuperType$I = xUNT2$SuperType$I
        if (UNT2$SuperType$I == $SmallBoat$SuperCode)
        {
            UNT2$Status$I = xUNT2$Status$I
            if (UNT2$Status$I != $BeingDeleted$Code)
            {
                UNT2$LaunchIndx$I = xUNT2$LaunchIndx$I
                if (UNT2$LaunchIndx$I == UNT$Pointer$Index)
                {   # set up the data required by subroutine omoor
                    nargs = 1
                    args[1] = $lex$MOOR$
                    call omoor (MOOR$Order, UNT2$Pointer, nargs, args, -1)
                }       # end of addressee launches the active BOAT
            }       # end of active unit
        }       # end of unit is a BOAT
    }       # end of loop through unit table
}       # end of FOR <addressee> RECALL BOAT (missions)

return
end        #  End ORECAL


Subroutine ORELOC(IONUM,                        #receive order number 
                  JVIEW,                        #receive view 
                  IWORDS,                       #receive number of words 
                  ILEX)                         #receive parameters 

########################################################
#$%
#$% Purpose:   ORELOC processes relocate commands
#$%            to relocate unit to specified lat-
#$%            itude/longitude.
#$%            Optional change to course/speed/altitude.
#$%
#$%
#$% Called By: EXEORD
#$%            the_elevation     <lbelevation.rat>
#$%
#$% Calls:     EXPORD     SEND       ANGPI
#$%            QCOS
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Jim Allen - 11/95 (E1422)
#$%            Update the unit's elevation when relocated.
#$%
#$% Modified:  Jim Allen - 8/98
#$%            The order id set to -1 because not available
#$%            in call to ospeed.
#$%
########################################################

BBcommon

integer IWORDS,ISNUMBER,ITASK,
        JJ,JVIEW,IVIEW,K,IPNT,
        IONUM,ICENTR,IDELTA,
        UNT2$Pointer, UNT3$Pointer,
        UNT$Pointer, UNT$Type$I,
        UNT$Truealtdepth$I, UNT$Status$I,
        UNT$Orderedaltdepth$I, UNT$Alspid$I             # MJC 5/2/2000 (E2145)
real    UNT$Truelatitude$F, UNT$Truelongitude$F,
        UNT$Costruelat$F, UNT$Assumedlatitude$F,
        UNT$Assumedlongitude$F, UNT$Orderedcourse$F,
        UNT$Orderedspeed$F,
        DELLAT,
        DELLON,
        DMS2RAD                                         # MJC 5/2/2000 (E2145)
literal CSTRIP8                                         # MJC 5/4/2000 (E2145)
integer the_elevation     # function to obtain elevation

real SLAT,SLON,SCOS,DLAT,DLON,DCOS
literal ILEX[iwords]
integer flga,                           # flag for collective groups
        cnta,                           # count of addressees
        stka[$Max$TaskGroup]            # stack of addressees
Character msg[ARB]

integer*4   new_altitude
integer*4   new_depth
integer*4   new_course
integer*4   new_speed

#String msg1 "      cannot be relocated!          not in group.   "
#String msg2 "      is a ghosted unit and cannot be relocated."

if($isnumeric(ilex[2]))
  {
   itask = YES
   jj = 0
   call smoviz(int(ilex[2]),4,msg,jj)    # set up message
   call smov($space,msg,jj)
  }
else
  {
   itask = NO
   jj = 0
   call smovhn(ilex[2],$$MaxLit,msg,jj)
  }
Call smovv(" cannot be relocated! ",msg,jj)

if (jview == $Neutral$view) iview = 0     # set up CONTROL as wildcard view
else                        iview = jview

#find the addressee(s)

call expord (iview,ilex[2],cnta,stka,flga,0)    # explode addressees

if (cnta == 0)                          # no addressee ???? (check for PIM)
    {
    call UNTFND(jview,                  # locate PIM unit
                ilex[2],
                stka[1])

    if (stka[1] == 0) cnta = 0
    else              cnta = 1
    }

if (cnta == 0)                          # no addressee ????
   {
    #$% send msg to view for display
    call send_ (jview,0,jj,msg)          # display error
    return
   }

DLAT = DMS2rad (ILEX[3])                    # set up dest lat/long
DLON = DMS2rad (ILEX[4])

DCOS = COS(DLAT)

icentr = $no
idelta = $no

if (iwords >= 6)        # E2231 joa 9/01                # check for center point
{
    if (ilex[5] == $lex$RELATIVE$)
    {
        k = 0

        for (ipnt = 1; ipnt <= cnta; ipnt = ipnt + 1)       # loop thru list
        {
            unt$pointer = stka[ipnt]
            if (xunt$name$c != ilex[6]) next                # not this one

            k = unt$pointer                                 # got it
            break
        }

        if (k != 0)
        {
            slat = Xunt$TrueLatitude$F
            slon = Xunt$TrueLongitude$F
            scos = COS(slat)
            icentr = $yes
            idelta = $no
        }
        else if (ilex[6] == 'TRUE' | ilex[6] == 'SELF')
        {
            icentr = $no
            idelta = $yes
        }
        else
        {
            #$% send msg to view for display
            Call smovv(" ",              msg,jj)
            call smovhn(ilex[6],$$maxlit,msg,jj)
            Call smovv(" not in group." ,msg,jj)

            call send_ (jview,0,jj,msg)                     # no match
            return
       }
   }            # End if relative
}               # End if nargs
#------------------------------------------------------------
# check for Altitude/Depth/Course/Speed options

new_altitude = -1       # flag as unspecified
new_depth    = -1
new_course   = -1
new_speed    = -1

for (ipnt = 5; ipnt <= IWORDS; ipnt = ipnt + 2) # jb    IWORDS 7/21/91
    {
    if      (ilex[ipnt] == $lex$altitude$) new_altitude = ipnt
    else if (ilex[ipnt] == $lex$depth$   ) new_depth    = ipnt
    else if (ilex[ipnt] == $lex$course$  ) new_course   = ipnt
    else if (ilex[ipnt] == $lex$speed$   ) new_speed    = ipnt
    }

#------------------------------------------------------------

for (ipnt = 1; ipnt <= cnta; ipnt = ipnt + 1)
   {
    unt$pointer = stka[ipnt]
    unt$type$i = xunt$type$i                              # jb    10/7/86

    if (xUNT$GhostedUnit$I == $yes)
      {
        #$% send a message that this just isn't allowed and return
       jj = 0
       call smovhn (xUNT$Name$C, $$MaxLit, msg, jj)
       call smovv  (" is a ghosted unit and cannot be relocated.", msg, jj)
       call send_   (jview, 0, jj, msg)
       next
      }

    if (unt$type$i == $shorebase$code & itask == YES)   NEXT # jb 12/14/82
    if (unt$type$i == $AIR$code &                         # jb    10/7/86
        Xunt$MarshallStatus$i == $Recovering$Code)
                PUTunt$MarshallStatus$i ($inflight$code)

    if (idelta == $yes)                 # check for delta change
       {
        unt$TrueLatitude$f  = Xunt$TrueLatitude$f  + dLat
        unt$TrueLongitude$f = Xunt$TrueLongitude$f + dLon
        unt$CosTrueLat$f    = COS(unt$TrueLatitude$f)
       }
    else if (icentr == $yes)            # check for center point
       {
        delLat = xunt$TrueLatitude$f - sLat

        delLon = xunt$TrueLongitude$f - sLon
        $angpi(delLon)

        unt$TrueLatitude$f = dLat + delLat

        unt$cosTrueLat$f = COS(unt$TrueLatitude$f)

        unt$TrueLongitude$f = dLon + delLon * _
              (scos + xunt$cosTrueLat$f) / (dcos + unt$cosTrueLat$f)
        $angpi(unt$TrueLongitude$f)
       }
    else
       {
        unt$TrueLatitude$f  = dLat
        unt$TrueLongitude$f = dLon
        unt$cosTrueLat$f    = dcos
       }

    putUNT$RelocatedFlag$I ($yes)   # clk 2/94 - flag unit as being relocated

    putunt$TrueLatitude$f

    PUTunt$TRUELONGITUDE$F

    PUTunt$COSTRUELAT$F

    unt$ASSUMEDLATITUDE$F = unt$TRUELATITUDE$F #enter assumed latitude
    PUTunt$ASSUMEDLATITUDE$F

    unt$ASSUMEDLONGITUDE$F = unt$TRUELONGITUDE$F #enter assumed longitude
    PUTunt$ASSUMEDLONGITUDE$F

    if (UNT$Type$I == $Shorebase$Code     |     # joa 11/95 (E1422)
        UNT$Type$I == $Surface$Code       |     # joa 3/04 RSOI04 remove sub
        UNT$Type$I == $SurfaceWithAC$Code |
        UNT$Type$I == $AirBase$Code       |
        UNT$Type$I == $PIM$Code           |
        UNT$Type$I == $LandingZone$Code)
      {
       UNT$TrueAltDepth$I = the_elevation (UNT$TrueLatitude$F*$rad2deg,
                                           UNT$TrueLongitude$F*$rad2deg)

       # Horizon formula does not handle bases below sea level
       UNT$TrueAltDepth$I = max (0, UNT$TrueAltDepth$I)
       putUNT$TrueAltDepth$I

       putUNT$OrderedAltDepth$I (UNT$TrueAltDepth$I)
      }

    UNT$STATUS$I = XUNT$STATUS$I
    if (UNT$STATUS$I == $ONGUIDE$CODE)
       {
        UNT$STATUS$I = $Proceeding$code
        PUTUNT$STATUS$I
       }

    #$% reset the hidden object's status when RELOCATE command is apply
    if (UNT$STATUS$I == $HIDING$CODE)             #KHC 9/92
       {
        putUnt$Status$I  ($Proceeding$code)    # reset unit status
        putUnt$HideStatus$I  ($NoHideStatus)

        putUnt$Orderedlatitude$F  ($pi)        # reset lon and lat order
        putUnt$Orderedlongitude$F (0)

        putUNT$HideSiteIndx$I  (0)             # reset the Hide Site Indx
       }

    #$% reset the hidden object's status when RELOCATE command is apply to it's hide site
    if (UNT$TYPE$I == $Site$Code & xUNT$SUBTYPE$I == $HideSite$SubCode)
       {
        For(unt2$Pointer$FIRST;unt2$Pointer$OK;unt2$Pointer$NEXT)
           {
            if (xUNT2$HideSiteIndx$I != 0)
               {
                #$% reset the hidden object's status when RELOCATE command is apply to it's hide site
                unt3$pointer$to xUNT2$HideSiteIndx$I
                if (UNT3$pointer == UNT$pointer)
                   {
                    putUnt2$Status$I  ($Proceeding$code)     # reset unit status
                    putUnt2$HideStatus$I  ($NoHideStatus)

                    putUnt2$Orderedlatitude$F  ($pi)         # reset lon and lat order
                    putUnt2$Orderedlongitude$F (0)

                    putUnt2$HideSiteIndx$I  (0)              # reset the Hide Site Indx
                   }
               }
           }
       }

    #------------------------------------------------------------
    if (new_altitude >= 0   & unt$type$i == $AIR$code )
        {
        call oaltit (9999, UNT$POINTER, 2, ilex[new_altitude])

        UNT$OrderedAltDepth$i   = xUNT$OrderedAltDepth$i

        putUNT$TrueAltDepth$i     (UNT$OrderedAltDepth$i)
        }

    if (new_depth    >= 0   & unt$type$i == $SUB$code )
        {
        call odepth (9999, UNT$POINTER, 2, ilex[new_depth])

        UNT$OrderedAltDepth$i   = xUNT$OrderedAltDepth$i

        putUNT$TrueAltDepth$i     (UNT$OrderedAltDepth$i)
        }

    if (new_course   >= 0)
        {
        call ocours(9999, -1, UNT$POINTER, 2, ilex[new_course])

        UNT$OrderedCourse$F   = xUNT$OrderedCourse$F

        putUNT$TrueCourse$F     (UNT$OrderedCourse$F)
        putUNT$AssumedCourse$F  (UNT$OrderedCourse$F)
        }

    if (new_speed   >= 0)
        {
        call ospeed (9999, UNT$POINTER, 2, ILEX[new_speed], -1)    # joa 8/98  (E2021)
        UNT$OrderedSpeed$F   = xUNT$OrderedSpeed$F

        putUNT$TrueSpeed$F     (UNT$OrderedSpeed$F)
        putUNT$AssumedSpeed$F  (UNT$OrderedSpeed$F)
        }

    # joa 10/01 Moved up inside unt loop  (E2240)
    UNT$ALSPid$I = xUNT$ALSPid$I
    if (UNT$ALSPid$I != 0)
        call alsp_update_dr_table (UNT$Pointer, UNT$ALSPid$I, 2)

    # joa 10/01 relocate order is used to position DIS entities (E2240)
    if (Xunt$GhostedDISUnit$i != 0)
        PUTunt$DISTimeChng$f (game$time)

   }



return
end        # End  ORELOC

 



Subroutine OREPRT(IVIEW, 
                  UNT$POINTER, 
                  NARGS, 
                  ARGS) 


########################################################
#$%
#$% Purpose:   OREPRT processes report commands
#$%            to assign a reporting policy.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     OREPON     OREPUS
#$%
#$% Tables:    UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer NARGS,IVIEW,
        UNT$Reportown$I,
        UNT$Pointer,
        UNT$Reportairtracks$I,
        UNT$Reportshiptracks$I,
        UNT$Reportesmtracks$I,
        UNT$Reportdamage$I,
        UNT$Reportreconn$I,
        UNT$Airtrackinterval$I,
        UNT$Esmtrackinterval$I,
        UNT$Owninterval$I,
        UNT$Shiptrackinterval$I             # MJC 5/2/2000 (E-2145)
literal ARGS[nargs]
integer rptype

#$% if category not specified, unit designated report all data once
#$% initialize all values to report all data
if(nargs == 1)
   {
    unt$ReportOwn$I = $Yes
    PUTunt$ReportOwn$I

    unt$ReportAirTracks$I = $Yes
    PUTunt$ReportAirTracks$I

    unt$ReportShipTracks$I = $Yes
    PUTunt$ReportShipTracks$I

    unt$ReportEsmTracks$I = $Yes
    PUTunt$ReportEsmTracks$I

    unt$ReportDamage$I = $Yes
    PUTunt$ReportDamage$I

    unt$ReportReconn$I = $Yes
    PUTunt$ReportReconn$I
   }
#$% else if category specified
else
   {
    #$% get category
    rptype = args[2]

    #$% if category is air
    if(rptype == $lex$air$)
       {
        #$% get air track reporting interval & save
        unt$AirTrackInterval$I = args[3]
        PUTunt$AirTrackInterval$I
       }
    #$% else if category is esm
    else if(rptype == $lex$esm$)
       {
        #$% get esm reporting interval & save
        unt$EsmTrackInterval$I = args[3]
        PUTunt$EsmTrackInterval$I
       }
    #$% else if category is position
    else if(rptype == $lex$position$)
       {
        #$% get own position reporting interval & save
        unt$OwnInterval$I = args[3]
        PUTunt$OwnInterval$I
       }
    #$% esle if category is surface track
    else if(rptype == $lex$surface$)
       {
        #$% get surface track reporting interval & save
        unt$ShipTrackInterval$I = args[3]
        PUTunt$ShipTrackInterval$I
       }
    #$% else if category is "report on..." 
    else if(rptype == $lex$on$)
       {
        #$% get reporting data on unit to report
        call OREPON(IVIEW,UNT$POINTER,ARGS)
       }
    #$% else if category is "using...<reporting policy>"
    else if(rptype == $lex$using$)
       {
        #$% get reporting data on specified reporting policy
        call OREPUS(IVIEW,UNT$POINTER,ARGS)
       }
   }

return
end





Subroutine OREPON(IVIEW, 
                  UNT$POINTER, 
                  ARGS) 
########################################################
#$%
#$% Purpose:   OREPON processes report ON orders
#$%            for assigning report circuit.
#$%
#$% Called By: OREPRT
#$%
#$% Calls:     WGOERR
#$%
#$% Tables:    UNT        PAT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

literal ARGS[$max$args]

integer IPATH1,
        IPATH2,
        IVIEW,
        UNT$Violateemcon$I,
        UNT$Makereports$I,
        UNT$Pointer,
        UNT$Commbypass$I,
        UNT$Path1pntr$I,
        UNT$Path2pntr$I,
        PAT$Pointer                 # MJC 5/2/2000 (E2145)
literal CRKT1,
        CRKT2,
        CSTRIP8                     # MJC 5/4/2000 (E2145)

#$% get circuit designators
crkt1 = args[3]
crkt2 = args[4]

#$% set emcon violate - yes or no
if(args[5] == $lex$yes$)   unt$ViolateEMCON$I = $yes
else                       unt$ViolateEMCON$I = $no

#$% if either ckt missing, make report now
if(crkt1 == 0 | crkt2 == 0)
   {
    unt$MakeReports$I = $Yes
    PUTunt$MakeReports$I

    unt$CommBypass$I = $Yes
    PUTunt$CommBypass$I

    PUTunt$ViolateEMCON$I

    return
   }

#$% initialize comm paths
ipath1 = 0
ipath2 = 0

#$% search for circuit path, ckt1
for(PAT$POINTER$FIRST;PAT$POINTER$OK;PAT$POINTER$NEXT)
   {
    if(Xpat$Circuit$I != crkt1) next
    ipath1 = pat$pointer
    break
   }
#$% search for circuit path, ckt2
for(PAT$POINTER$FIRST;PAT$POINTER$OK;PAT$POINTER$NEXT)
   {
    if(Xpat$Circuit$I != crkt2) next
    ipath2 = pat$pointer
    break
   }

#$% if either path missing
if(ipath1 == 0 | ipath2 == 0)
   {
    #$% call to indicate improper ckt number
    call wgoerr (iview,Xunt$name$c,0,5,args,"Improper Circuit Number")
   }
#$% else get data
else
   {
    unt$MakeReports$I = $Yes
    PUTunt$MakeReports$I

    unt$Path1Pntr$I = ipath1
    PUTunt$Path1Pntr$I

    unt$Path2Pntr$I = ipath2
    PUTunt$Path2Pntr$I

    unt$CommBypass$I = $no
    PUTunt$CommBypass$I

    PUTunt$ViolateEMCON$I
   }

return
end




Subroutine OREPUS(IVIEW, 
                  UNT$POINTER, 
                  ARGS) 



########################################################
#$%
#$% Purpose:   OREPUS processes "REPORT USING" orders
#$%            for assigning a stored policy to a unit.
#$%
#$% Called By: OREPRT
#$%
#$% Calls:     WHSIDE     SETURP     WGOERR
#$%
#$% Tables:    RPM        UNT
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

literal ARGS[$max$args], rptnam

integer ISIDE,
        IVIEW,
        RPM$Pointer,
        UNT$Pointer                 # MJC 5/2/2000 (E2145)
literal CSTRIP8                     # MJC 5/4/2000 (E2145)

#$% get reporting policy name
rptnam = args[3]

#$% get side
call whside(Xunt$View$i,iside)

#$% search for reporting policy by side and name
for(RPM$POINTER$FIRST;RPM$POINTER$OK;RPM$POINTER$NEXT)
   {
    if (Xrpm$side$i != iside ) next

    if (Xrpm$name$c != rptnam) next

    call SETURP(_
                UNT$POINTER,
                RPM$POINTER)
    return
   }

#$% if none found, send error message
call wgoerr (iview,Xunt$name$c,0,3,args,"Invalid Policy Name")

return
end



 Subroutine OSPEED(IONUM,                         #receive order number 
                   UNT$POINTER,                   #receive addressee pointer 
                   IWORD,                         #receive count 
                   ILEX,                          #receive command string 
                   ID)                            #receive order id

 #######################################################
 #$%
 #$% Purpose:   OSPEED processes speed commands
 #$%            to change speed for force units.
 #$%
 #$% Called By: EXEORD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT    ACC
 #$%
 #$% Date:      APRIL 80
 #$%
 #$% Author:    Dana Wills
 #$%
 #$% Modified:  Carol Kropp - 5/96 (E1467)
 #$%            Added call to clear_maneuver_all for
 #$%            surface platforms doing refueling, so
 #$%            breakaways happen correctly, or when
 #$%            they are in port.
 #$%
 #$%            Jim Allen - 8/98 (E2021)
 #$%            Add id argument and add arguments to clear_maneuver_all
 #$%
 #######################################################

 BBcommon

 integer IWORD,
         IONUM,
         ID,
         ACC$Pointer,
         UNT$Pointer, UNT3$pointer,
         UNT$Status$I,
         UNT$Attackindx$I,
         UNT$Guideindx$I                 # MJC 5/2/2000 (E-2145)
 integer guidelist[unt$slots], nlist, i, jj
 real    UNT$Orderedspeed$F              # MJC 5/2/2000 (E-2145)
 literal ILEX[iword], cstrip8
 Character msg[ARB]
 
 UNT$ORDEREDSPEED$F = ILEX[2]            #get ordered speed

 if(XUNT$TYPE$I == $AIR$CODE)                   #if aircraft
   {
    if(Xunt$MarshallStatus$i == $Recovering$Code)
    PUTunt$MarshallStatus$i ($inflight$code)

    ACC$POINTER = Xunt$ACCPNTR$I   #get flight characteristics 3/30/89

    if(ILEX[2] > XACC$MAXSPEED$I)               #if greater than max
      {
       unt$ORDEREDSPEED$F = FLOAT(XACC$MAXSPEED$I) #enter max (3/30/89
      }                                         #end if greater than max

   }                                            #end if aircraft
 else
   {
    if (xUNT$HosesAllocatedFlag$I == $yes |   # clk 5/96 (E1467) - for
        xUNT$Status$I == $InPort$Code     )   # for emergency breakways  
       call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)

    if(ILEX[2] > Xunt$SPEED$I)     #if speed greater than max    3/30/89
      {
       unt$ORDEREDSPEED$F = FLOAT(Xunt$SPEED$I) #enter max     3/30/89
      }                                         #end if greater than max

   }                                            #end else

 PUTUNT$ORDEREDSPEED$F                          #store speed order

 #$% cancel hiding          KHC 6/92
 if (xUNT$Status$I == $Hiding$Code | xUNT$HideStatus$I == $EnrouteToHide)
    {
     putunt$Status$I  ($Proceeding$code)      # reset unit status
     putUNT$HideStatus$I  ($NoHideStatus)

     putUnt$Orderedlatitude$F  ($pi)          # reset lon and lat order
     putUnt$Orderedlongitude$F (0)

     putUNT$HideSiteIndx$I  (0)               # reset the Hide Site Indx
    } 

 #$% if unit is stationed on a guide
 if(XUNT$STATUS$I == $ONGUIDE$CODE)
   {
    #$% reset unit status to proceeding 
    UNT$STATUS$I = $PROCEEDING$CODE
    PUTUNT$STATUS$I

    #$% set air guide index to no (no guide)
    UNT$ATTACKINDX$I = $NO
    PUTUNT$ATTACKINDX$I

    #$% set surface guide index to no (no guide)
    UNT$GUIDEINDX$I = $NO
    PUTUNT$GUIDEINDX$I
   }

# Warn player if guiding unit can not maintain station
call guidingList (unt$pointer, guidelist, nlist) 
for (i=1; i<=nlist; i=i+1)
{
    unt3$pointer = guidelist[i]
    if (Xunt3$type$i == $Surface$code)   # UFL05 joa 
    {
        if (Xunt3$Speed$i < unt$OrderedSpeed$f)
        {
            jj = 0
            call smovhn(Xunt3$name$c,$$MaxLit,msg,jj)            #enter unit name in message
            Call SMOVV(" cannot maintain station on guide ",msg,jj)
            call smovhn(Xunt$name$c,$$MaxLit,msg,jj)             # enter guide name
            Call SMOVV(" because guide ordered speed ",msg,jj)
            call smovi(int(unt$orderedSpeed$f), msg,jj)
            Call SMOVV(" exceeds max speed ",msg,jj)
            call smovi(Xunt3$Speed$i, msg,jj)
        
            call send_(Xunt$View$i,0,jj,msg)              #send error message
        } 
    }
}

 return
 end    #  End  OSPEED




Subroutine OFORMATION(IONUM,
                      JVIEW, 
                      UNT$POINTER, 
                      IWORD, 
                      ILEX, 
                      ID) 

########################################################
#$%
#$% Purpose:   OFORMATION transforms formation order into station order.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FNDORD     UNTFND     SEND
#$%
#$% Tables:    UNT        ORD
#$%            ACC
#$%
#$% Date:      JULY 03
#$%
#$% Author:    James O. Allen (E2350)
#$%
########################################################
#
#     1                 2                      3                       4
# FORMATION [ COLUMN | LINE | POINT ] [ | <distance> [ (units) | YARDS | NM ] ]
#
########################################################

BBcommon

integer     IWORD,ID,JJ,K,IONUM
BBDeclare   (ORD$Pointer,
            ORD$Addressee$C,
            UNT$Pointer,
            UNT2$Pointer)
literal     CSTRIP8                             # MJC 5/4/2000 (E2145)
literal     ILEX[iword],stalex[$stk$lastarg], bearing, spacing, units, guide
integer     iview, jview
integer     ipnt
integer flga,                           # flag for collective groups
        cnta,                           # count of addressees
        stka[$Max$TaskGroup]            # stack of addressees

integer     nargs, idord, numord, isnumber

Character msg[ARB]

if($isnumeric(ilex[2]))
  {
   jj = 0
   call smoviz(int(ilex[2]),4,msg,jj)    # set up message
   call smov($space,msg,jj)
  }
else
  {
   jj = 0
   call smovhn(ilex[2],$$MaxLit,msg,jj)
  }
Call smovv(" cannot be in a formation! ",msg,jj)

# Get list of all units in formation
if (jview == $Neutral$view) iview = 0     # set up CONTROL as wildcard view
else                        iview = jview

call fndord (id,ord$pointer)                    # find the order in ORD
ord$Addressee$C = Xord$Addressee$C

call expord (iview,ord$Addressee$C,cnta,stka,flga,0)    # explode addressees

if (cnta == 0)
{
    #$% send msg to view for display
    call send_ (jview,0,jj,msg)          # display error
    return
}

# Find this unit on list
for (ipnt = 1; ipnt <= cnta; ipnt = ipnt + 1)
{
    if (unt$pointer == stka[ipnt]) break
}

if (ipnt >  cnta)
{
    # This should never happen
    call send_ (jview,0,jj,msg)          # display error
    return
}

if (ipnt == 1) return                   # Guide unit

# If not first on list, station on first unit with range = spacing * list index

unt2$pointer = stka[1]
guide = Xunt2$name$C

call formation2station(guide, ipnt, ilex, iword, stalex, nargs)
# Call station order processing
idord = 0
numord = 0
call  ostati(numord, UNT$POINTER, nargs, STALEX, idord) 
return
end

Subroutine formation2station(guide,
                             ipnt,
                             ilex,
                             iword,
                             stalex,
                             nargs)
########################################################
#$%
#$% Purpose:   formation2staton transforms formation syntax into station syntax.
#$%
#$% Called By: oformation, glaunch_boat
#$%
#$% Calls:
#$%
#$% Tables:    UNT        ORD
#$%            ACC
#$%
#$% Date:      JULY 03
#$%
#$% Author:    James O. Allen (E2350)
#$%
########################################################

BBcommon

integer     IWORD, ipnt, nargs
BBDeclare   (UNT2$Pointer)
literal     CSTRIP8                             # MJC 5/4/2000 (E2145)
literal     ILEX[iword],stalex[$stk$lastarg], bearing, spacing, units, guide
integer     iview, jview


#   Make relative bearing 0 for point, 90 for line and 180 for column.
#    1       2        3           4              5
# STATION RELATIVE <degrees> <force-name> <distance-miles>
stalex[1] = $lex$STATION$
stalex[2] = $lex$RELATIVE$

if      (ilex[2] == $lex$POINT$)  bearing = 0.
else if (ilex[2] == $lex$LINE$)   bearing = 90.
else if (ilex[2] == $lex$COLUMN$) bearing = 180. 
stalex[3] = bearing

stalex[4] = guide

spacing = 100.                      # Default spacing is 100 yards

units = $lex$yards$                 #
if (iword >= 3) spacing = ilex[3]
if (ilex[2] == $lex$POINT$) spacing = 0.
if (iword >= 4) units = ilex[4]
if (units == $lex$YARDS$) stalex[5] = spacing / $Yds$Per$Mile
else                      stalex[5] = spacing
stalex[5] = stalex[5] * (ipnt-1)        # ipnt is position in formation

nargs = 5

return
end



Subroutine OSTATI(IONUM, 
                  UNT$POINTER, 
                  IWORD, 
                  ILEX, 
                  ID) 

########################################################
#$%
#$% Purpose:   OSTATI processes station commands.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     FNDORD     UNTFND     SEND
#$%
#$% Tables:    UNT        ORD
#$%            ACC
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp 4/92: Added cap information
#$%
#$%            James Allen - 3/96 (E1564)
#$%            Prevent circular guiding.
#$%
#$%            James Allen - 12/97 (E1370)
#$%            Avoid beaming by not setting new guide
#$%            index until after clear_maneuver_all call.
#$%
########################################################
#
# STATION (bearing) RELATIVE <degrees> (from guide) <force-name> 
#                                      (range) <distance-miles>
# STATION (bearing)          <degrees> (from guide) <force-name> 
#                                      (range) <distance-miles> 
#
# FORMATION [ COLUMN | LINE | POINT ]
#           (spacing) [ | <distance> [ (units) | YARDS | NM ] ]
#
########################################################

BBcommon

integer     IWORD,ID,JJ,K,IONUM,
            ORD$Pointer,
            ORD$Phase$I,
            ACC$Pointer,
            SHC$Pointer,
            SHC$Maxspeed$I,
            UNT2$Pointer,
            UNT$View$I,
            UNT$Pointer,
            UNT$Guideindx$I,
            UNT$Status$I,
            UNT$Guidetrue$I                     # MJC 5/2/2000 (E2145)
real        UNT$Guidebearing$F,
            UNT$Guiderange$F,
            UNT$Orderedspeed$F,
            UNT2$Orderedspeed$F                 # MJC 5/2/2000 (E2145)
literal     CSTRIP8                             # MJC 5/4/2000 (E2145)
literal     ILEX[iword], guide_name, bearing, range
integer     Guide_true
Character msg[ARB]

integer     GuideLevel    # function to provide nesting level

#String      MSG "      cannot station on       . It does not exist.  "
#String      MSG "      cannot station on       - currently assigned to CAP station."

if (ilex[2] == $LEX$RELATIVE$)
    {
    Guide_true  = $no
    bearing     = ilex[3]
    guide_name  = ilex[4]
    range       = ilex[5]
    }
else
    {
    Guide_true  = $Yes
    bearing     = ilex[2]
    guide_name  = ilex[3]
    range       = ilex[4]
    }

call fndord (id,ord$pointer)                    # find the order in ORD

UNT$VIEW$I = XUNT$VIEW$I                        #get view of player

call UNTFND(unt$View$i,                         #locate station guide
            guide_name,
            unt2$pointer)

if (UNT2$POINTER == 0)                          #if unit not found
   {
    jj = 0
    call smovhn(Xunt$name$c,$$MaxLit,msg,jj)            #enter unit name in message
    Call SMOVV(" cannot station on ",msg,jj)
    call smovhn(guide_name,$$MaxLit,msg,jj)             # enter guide name
    Call SMOVV(". It does not exist.  ",msg,jj)

    call send_(unt$View$i,0,jj,msg)              #send error message

    if (ord$pointer != 0)
      {
       ord$phase$i = 0
       PUTord$phase$i
      }

    return
   }
else if (xUNT$Type$I == $Air$Code)  # unit was found, is it an aircraft    clk 4/92
   {
    if (xUNT$AssignedCAP$I != $no)  # check to see if it is assigned to CAP
      {
       jj = 0
       call smovhn (xUNT$Name$C,$$MaxLit, msg, jj)     # enter unit name in message
       call smovv  (" cannot station on ", msg, jj)
       call smovhn (guide_name,$$MaxLit, msg, jj)      # enter guide name
       call smovv  (" - Must cancel CAP before going to new station.", msg, jj)
       call send_   (xUNT$View$I, 0, jj, msg)           # send error message

       if (ord$pointer != 0)
         putORD$Phase$I  (0)
       return
      }
   }

UNT$GuideIndx$I = xUNT$GuideIndx$I              # Save old guide
putUNT$GuideIndx$I  (UNT2$Pointer$Index)        # Store new guide
if (GuideLevel (UNT$Pointer) == $CircularGuideDefinition)    # joa 3/96 (E1564)
  {                                                          # prevent circular guiding
   jj = 0
   call smovhn (xUNT$Name$C,$$MaxLit, msg, jj)     # enter unit name in message
   call smovv  (" cannot station on ", msg, jj)
   call smovhn (guide_name,$$MaxLit, msg, jj)      # enter guide name
   call smovv  (" because will create circular stationing.", msg, jj)
   call send_   (xUNT$View$I, 0, jj, msg)           # send error message
   putUNT$GuideIndx$I                              # Restore old guide
   return
  }
putUNT$GuideIndx$I                              # Restore old guide - oa 12/97 (E1370)

if (ord$pointer != 0)                           # Is this a multi-phase order?
   {                                            #   YES
    if (Xord$phase$i == 0)
       {
        k = xord$sequence$i - Xord$count$i

        if (k == 0) ord$phase$i = 0
        else        ord$phase$i = 1             # First time thru

        PUTord$phase$i
       }
    else                                        # there yet?
       {
        if (xunt$AttackIndx$i != 0)             # No (playing around w/enemy
            return                              #     or tanker somewhere)

        if (xunt$status$i != $OnGuide$code)     # No, not yet
            return

        # else

        ord$phase$i = 0                         # Yes.....
        PUTord$phase$i                          # clear the order

        return
       }
   }

call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)
putUNT$GuideIndx$I  (UNT2$Pointer$Index)        # Store new guide

unt$Status$i = Xunt$status$i                    # jb    8/18/89
unt$GUIDEBEARING$F = bearing/180.* $PI  #enter bearing from guide
PUTunt$GUIDEBEARING$F

unt$GUIDERANGE$F = range                #enter range from guide
PUTunt$GUIDERANGE$F

unt$GUIDETRUE$I = Guide_true            #true bearing from guide
PUTunt$GUIDETRUE$I

if(UNT$Status$I !=$Sinking$Code & UNT$Status$I != $UnderTow$Code &
      UNT$Status$I !=$DeadinWater$Code) # jb 8/18/89;    /\  8/28/89
            putUNT$STATUS$I ($PROCEEDING$CODE)

# Warn player if guiding unit can not maintain station

if (Xunt$type$i == $Surface$code)   # KR08 joa 
{
    if (Xunt$Speed$i < Xunt2$OrderedSpeed$f)
    {
        jj = 0
        call smovhn(Xunt$name$c,$$MaxLit,msg,jj)            #enter unit name in message
        Call SMOVV(" cannot maintain station on guide ",msg,jj)
        call smovhn(Xunt2$name$c,$$MaxLit,msg,jj)             # enter guide name
        Call SMOVV(" because guide ordered speed ",msg,jj)
        call smovi(int(Xunt2$orderedSpeed$f), msg,jj)
        Call SMOVV(" exceeds max speed ",msg,jj)
        call smovi(Xunt$Speed$i, msg,jj)
        
        call send_(Xunt$View$i,0,jj,msg)              #send error message
    } 
}

#$% if platform is air
if (xUNT$type$i == $air$code)
   {
    if(Xunt$MarshallStatus$i == $Recovering$Code)
        PUTunt$MarshallStatus$i  ($Inflight$Code)

    #$% get air characteristics pointer
    acc$pointer = Xunt$accPntr$i

    #$% get cruise speed and save
    UNT$OrderedSpeed$f = Xacc$CruiseSpeed$I
    PUTUNT$OrderedSpeed$f
   }
#$% if platform is surface
else
    {
    UNT2$OrderedSpeed$F = xUNT2$OrderedSpeed$F  ## get current speed of guide

    shc$Pointer    = xUNT$ShcPntr$I             ## get units max speed
    shc$MaxSpeed$I = xshc$MaxSpeed$I            

    ## if guide speed is GE units max speed - 5knots
    if (unt2$OrderedSpeed$F >= shc$MaxSpeed$I-5) 
        {
        unt$OrderedSpeed$F = shc$MaxSpeed$I     ## put units max speed
        }
    ## else set unit speed to guide speed +5
    else
        {
        unt$OrderedSpeed$F = UNT2$OrderedSpeed$F + 5.0 ## add 5knots to unit
        }

    putunt$OrderedSpeed$F                       ## put units new speed
    }

 return
 end        # End  OSTATI





Subroutine OSUBCS(IONUM,                        #receive order number 
                  UNT$POINTER,                  #receive unit pointer 
                  IWORD,                        #receive word count 
                  ILEX)                         #receive command string 

########################################################
#$%
#$% Purpose:   OSUBCS processes deploy, mast and
#$%            retrieve commands for the deploy-
#$%            ment and retrieval of communication
#$%            buoys, masts and wires.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     DEQGET   SEND
#$%
#$% Tables:    UNT        SON
#$%            COB        BOY
#$%
#$% Date:      APRIL 80
#$%
#$% Author:    Dana Wills
#$%
########################################################

BBcommon

integer IWORD,NFOUND,NFLG,litcmp, # jb litcmp frm [aai01...mods] 1/23/01
        JJ,IUPI,IONUM,
        UNT$View$I, UNT$Pointer,
        UNT$Deploywire$I, UNT$Deploybuoy$I,
        UNT$Deploymast$I,
        DEQ$Pointer, DEQ$Ident$I,
        DEQ$Remaining$I,
        SON$Pointer, COB$Pointer,
        BOY$Pointer, BOY$Acoustic$I,
        BOY$Eqpntr$I, BOY$Ownerindx$I,
        BOY$Type$I, BOY$Nbrbuoys$I,
        BOY$Truedepth$I                             # MJC 5/2/2000 (E-2145)
real    BOY$Birthtime$F, BOY$Killtime$F,
        BOY$Truelatitude$F, BOY$Truelongitude$F,
        BOY$Costruelat$F,
        UNT$Timewire$F, UNT$Timebuoy$F,
        UNT$Timemast$F,
        PCNTUP,PCNTDN                               # MJC 5/2/2000 (E-2145)
literal BOY$Commname$C,
        CSTRIP8                                     # MJC 5/4/2000 (E2145)
literal ILEX[iword], iname1, iname2
##integer  NFIND[21,3]                # jb            3/31/89
integer  eqlist[5,ARB]                # jb            3/31/89
real left
Character msg[ARB]
    
#String msg1 "      has no        wire buoys.    "
#String msg2 "      has no wires. "
#String msg3 "      has no mast.  "
#String msg4 "      cannot retrieve anything.     "
#String msg5 "      cannot deploy anything.   "
#String msg6 "      cannot execute mast commands. "
#String msg7 "      has no        communication buoys.       "
#String msg8 "Buoy table full --        cannot deploy       buoy.     "


unt$view$i = xunt$view$i                        #get view index

if (xunt$type$i == $sub$code)                   #if unit is a submarine
   {
    if(ilex[1] == $lex$deploy$)                 #if deploy request
      {
       if (ilex[2] == $lex$wire$)               #if deploy wire
         {
##---------------------------------------------------------------------
          nfound = 0    # jb    Set 0 for non-iterative call   7/25/89
          call DEQGET(unt$pointer,  # vice SURGET     # send UNT pointer
                  $wire$code,                   # send ident code
                  nfound,                       # send/receive nbr items fnd
                  eqlist)                       # send/receive list of EQ
#----------------------------------------------------------------------
#          lines from DEQGET:
#    eqlist[1,nfound] = DEQ$Pointer$index       # save index of equipment
#    eqlist[2,nfound] = Xdeq$pntr$i             #   equipment pointer
#    eqlist[3,nfound] = deq$remaining$i         #   equipment count
#    eqlist[4,nfound] = 0                       #
#    eqlist[5,nfound] = 0                       #
#---------------------------------------------------------------------

          if (eqlist[1,1] != $NO)   # if any 'wire' found
##---------------------------------------------------------------------
#         call surget(shDYN$pointer,             #search for wire
#                     $wire$code,        #SHD$pointer = ship pointer (in)
#                     nfind)                   #$wire$code = wire code (in)
#                                              #nfind = results (out)
#         if(nfind[1,1] != 0 & nfind[2,3] != 0) #if wire found
##---------------------------------------------------------------------
            {
             if (xunt$deploywire$i == $no)
               {
                left = xunt$TimeWire$f - game$time

                if (left <= 0.) pcntdn = 1.0
                else           pcntdn = 1.0 - left/float(wire$retreive$time)

                unt$deploywire$i = $yes         #set deploy wire flag
                putunt$deploywire$i

                unt$TimeWire$f = game$time + wire$deploy$time * pcntdn
                putunt$TimeWire$f                  #enter wire deploy time
               }
            }
          else
            {
             jj = 0
             #$% move unit name to msg format for display
             call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
             Call SMOVV(" has no wires.",msg,jj)

             #$% send msg to view for display
             call send_(unt$view$i,                   #player view index
                       0,                            #status flag
                       jj,                           #message length
                       msg)                         #formerly msg2
            }
         }                                      #end if wire
       else                                     #else must be wire buoy
         {
          nflg = $no                            #indicate not found

       iUPI = UNT$Pointer$index        # jb                    3/31/89
       for_DEQ_CHAIN (iUPI)            # jb                    3/31/89
            {
              #$% get equipment ID
              deq$ident$i = Xdeq$ident$i                # jb    3/31/89
              if (deq$ident$i != $Wbuoy$code) next
              if (XDeq$Remaining$i <= 0) next
              if (XDeq$Type$c != ilex[3]) next
              nflg = Deq$Pointer$index                   # jb    3/31/89
              break
            }

          if (nflg == $no)                      #if buoy not found
             {
              jj = 0
              #$% move unit name to msg format for display
              call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
              Call SMOVV(" has no ",msg,jj)
              call smovhn(ilex[3],$$MaxLit,msg,jj)
              Call SMOVV(" wire buoys.",msg,jj)
              #$% send msg to view for display
              call send_(unt$view$i,             #player view index
                        0,                      #status flag
                        jj,                     #message length
                        msg)                   #formerly msg1
             }
          else if (xunt$deploybuoy$i == $no)
             {
              left = xunt$TimeBuoy$f - game$time

              if (left <= 0.) pcntdn = 1.0
              else           pcntdn = 1.0 - left/float(buoy$retreive$time)

              unt$deploybuoy$i = $yes   #flag deploy buoy
              putunt$deploybuoy$i

              unt$TimeBuoy$f = game$time + buoy$deploy$time * pcntdn
              putunt$TimeBuoy$f
             }
         }                                      #end if bouy found
      }                                         #end if deploy

    else if(ILEX[1] == $LEX$RETRIEVE$)          #if retrieve request
      {
       if(ILEX[2] == $LEX$WIRE$)                #if retrieve wire
         {
          if(XUNT$DEPLOYWIRE$I == $YES)         #if wire deployed
            {
             left = xunt$TimeWire$f - game$time

             if (left <= 0.)
                pcntup = 1.0
             else
                pcntup = 1.0 - left/float(wire$deploy$time)

             UNT$DEPLOYWIRE$I = $NO             #set wire in flag
             PUTUNT$DEPLOYWIRE$I

             unt$TimeWire$f = game$time + WIRE$RETREIVE$TIME * pcntup
             PUTunt$TimeWire$f                  #enter retrieve time
            }
         }                                      #end if retrieve wire
       else                                     #else retrieve wire buoy
         {
##----------------------------------------------------------------------
#         call SURGET(shDYN$POINTER,     #locate buoy
#                     $WBUOY$CODE,     #shDYN$POINTER = ship pointer (in)
#                     NFIND)           #$WBUOY$CODE = equipment type (in)
#                                      #receive results (out)
#         if(NFIND[1,1] != 0)                   #if buoy found
#           {
#            if (xunt$deploybuoy$i == $yes)
#               {
##----------------------------------------------------------------------
          call DEQGET(unt$pointer,  # vice SURGET       # send UNT pointer
#                 ident,                        # send ident code
                  $WBUOY$code,                  # send ident code
                  nfound,                       # send/receive nbr items fnd
                  eqlist)                       # send/receive list of EQ
#----------------------------------------------------------------------
#          lines from DEQGET:
#    eqlist[1,nfound] = DEQ$Pointer$index       # save index of equipment
#    eqlist[2,nfound] = Xdeq$pntr$i             #   equipment pointer
#    eqlist[3,nfound] = deq$remaining$i         #   equipment count
#    eqlist[4,nfound] = 0                       #
#    eqlist[5,nfound] = 0                       #
#---------------------------------------------------------------------
          if (eqlist[1,1] != $NO)                       #if equipment found
                {

                 left = xunt$TimeBuoy$f - game$time

                 if (left <= 0.)
                    pcntup = 1.0
                 else
                    pcntup = 1.0 - left/float(buoy$deploy$time)

                 UNT$DEPLOYBUOY$I = $NO             #set buoy in flag
                 PUTUNT$DEPLOYBUOY$I

                 unt$TimeBuoy$f = game$time + BUOY$RETREIVE$TIME * pcntup
                 PUTunt$TimeBuoy$f
                }
            #}    # debug..
          else
            {
             jj = 0
              #$% move data to msg format for display
              call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
              Call SMOVV(" has no ",msg,jj)
              call SMOVHN(ilex[3],$$MaxLit,msg,jj)
              Call SMOVV(" wire buoys.",msg,jj)
             #$% send msg to view for display
             call send_(UNT$VIEW$I,                #player view index
                       0,                         #status flag
                       jj,                        #message length
                       MSG)                      #formerly msg1
            }
         }                                      #end else
      }                                         #end if retrieve

    else if(ILEX[1] == $LEX$MAST$)              #if mast request
      {
       if(XUNT$MASTDESTROYED$I == $YES)         #if mast destroyed
         {
             jj = 0
             #$% move unit name to msg format for display
             call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
             Call SMOVV(" has no mast.",msg,jj)

          #$% send msg to view for display
          call send_(UNT$VIEW$I,                      #player view index
                    0,                               #status falg
                    jj,                              #message length
                    MSG)                            #formerly msg3
         }
       else
         {
          if(ILEX[2] == $LEX$UP$)                  #if mast up command
            {
             if(XUNT$DEPLOYMAST$I == $no)          #if mast is down
               {
                left = xunt$TimeMast$f - game$time

                if (left <= 0.)
                   pcntdn = 1.0
                else
                   pcntdn = 1.0 - left/float(mast$retreive$time)

                UNT$DEPLOYMAST$I = $YES            #flag mast going up
                PUTUNT$DEPLOYMAST$I

                unt$TimeMast$f = game$time + MAST$DEPLOY$TIME * pcntdn
                PUTunt$TimeMast$f
               }
            }
          else                                  #if mast down command
            {
             if(XUNT$DEPLOYMAST$I == $YES)         #if mast is up
               {
                left = xunt$TimeMast$f - game$time

                if (left <= 0)
                   pcntup = 1.0
                else
                   pcntup = 1.0 - left/float(mast$deploy$time)

                UNT$DEPLOYMAST$I = $NO             #flag mast going down
                PUTUNT$DEPLOYMAST$I

                unt$TimeMast$f = game$time + MAST$RETREIVE$TIME * pcntup
                PUTunt$TimeMast$f                  #enter time to retrieve
               }
            }
         }
      }                                         #end if mast request
   }                                            #end if submarine

 else
   {
    if (ilex[1] == $lex$mast$)                  #only subs can do mast orders
       {
        jj = 0
        #$% move unit name to msg format for display
        call smovhn(xunt$name$c,$$MaxLit,msg,jj)
        Call SMOVV(" cannot execute mast commands. ",msg,jj)

        #$% send msg to view for display
        call send_(unt$view$i,0,jj,msg)  # formerly msg6
       }
    else if (ilex[1] == $lex$retrieve$)         #only subs can retrieve
       {
        jj = 0
        #$% move unit name to msg format for display
        call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
        Call SMOVV(" cannot retrieve anything.",msg,jj)

        #$% send msg to view for display
        call send_(unt$view$i,0,jj,msg)  # formerly msg4
       }
    else if (ilex[1] == $lex$deploy$)           #if deploy
       {
        if (xunt$type$i == $air$code)           #if aircraft
           {
            iUPI = UNT$Pointer$index        # jb                    3/31/89
            for_DEQ_CHAIN (iUPI)            # jb                    3/31/89
               {
                #$% get equipment ID
                deq$ident$i = Xdeq$ident$i                # jb    3/31/89
                if (Deq$ident$i == $commbuoy$code &     #find requested
                    litcmp(xDeq$type$c, ilex[3])==0 & #jb [aai01...mods]1/23/01 
                    xDeq$remaining$i > 0)  break
               }

            if (Deq$Pointer$VALID)                #if desired buoy found
               {
                cob$pointer = xDeq$pntr$i

                for(boy$pointer$first;boy$pointer$valid;boy$pointer$next)
                   {
                    if (xboy$type$i == $null$code)  break   #find slot in
                   }                                        #  BOY table

                if (boy$pointer$valid)          #if slot available
                   {
                    Deq$remaining$i = xDeq$remaining$i - 1
                    putDeq$remaining$i

                    cob$pointer = xDeq$pntr$i

                    iname1 = xcob$comsuite1$c
                    iname2 = xcob$comsuite2$c

                    for (son$pointer$first;son$pointer$ok;son$pointer$next)
                       { # jb next 2 lines: litcmp, frm [aai01...mods]  1/23/01 
                       if (litcmp(xson$type$c, iname1) == 0 |  #see if buoy has
                           litcmp(xson$type$c, iname2) == 0 ) break # acoustic char
                       }

                    if (son$pointer$ok)
                       {
                        boy$Acoustic$i = $yes

                        boy$eqpntr$i = son$pointer
                        putboy$eqpntr$i
                       }
                    else
                       {
                        boy$Acoustic$i = $no
                       }
                    putboy$Acoustic$i

                    boy$commname$c = ilex[3]
                    putboy$commname$c

                    boy$ownerindx$i = unt$pointer$index
                    putboy$ownerindx$i

                    boy$type$i = $commbuoy$code
                    putboy$type$i

                    boy$nbrbuoys$i = 1
                    putboy$nbrbuoys$i

                    boy$BirthTime$f = game$time
                    putboy$BirthTime$f

                    boy$KillTime$f = game$time + xcob$life$i
                    putboy$KillTime$f

                    boy$truelatitude$f = xUNT$truelatitude$f
                    putboy$truelatitude$f

                    boy$truelongitude$f = xUNT$truelongitude$f
                    putboy$truelongitude$f

                    boy$costruelat$f = xUNT$costruelat$f
                    putboy$costruelat$f

                    boy$truedepth$i = 100
                    putboy$truedepth$i

                    if (!boy$pointer$ok)
                       {
                        boy$pointer$next
                        boy$last$to (boy$pointer - 1)
                       }
                   }

                else                            #if no room in buoy table
                   {
                    jj = 0
                    Call SMOVV("Buoy table full -- ",msg,jj)
                    #$% move unit name to msg format for display
                    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
                    Call SMOVV(" cannot deploy ",msg,jj)
                    call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
                    Call SMOVV(" buoy.",msg,jj)

                    #$% send msg to view for display
                    call send_(unt$view$i,0,jj,msg) # formerly msg8
                   }
               }                                #end if desired buoy found

            else                                #if buoy not found
               {
                jj = 0
                #$% move unit name to msg format for display
                call SMOVHN(xunt$name$c,$$MaxLit,msg,jj)
                Call SMOVV(" has no ",msg,jj)
                call SMOVHN(ilex[3],$$MaxLit,msg,jj)
                Call SMOVV(" communication buoys",msg,jj)

                #$% send msg to view for display
                call send_(unt$view$i,0,jj,msg) # formerly msg7
               }
           }                                    #end if aircraft

        else                                    #if not aircraft
           {
            jj = 0
            #$% move unit name to msg format for display
            call smovhn(xunt$name$c,$$MaxLit,msg,jj)
            Call SMOVV(" cannot deploy anything. ",msg,jj)

            #$% send msg to view for display
            call send_(unt$view$i,0,jj,msg) # formerly msg5
           }
       }
   }

 return
 end        # End OSUBSC





 Subroutine OSURF(IONUM,                            #receive order number 
                  UNT$POINTER,                      #receive addressee pointer 

                  IWORD,                            #receive count 
                  ILEX)                             #receive command string 
 
 #######################################################
 #$%
 #$% Purpose:   OSURF processes SURFACE and PERISCOPE commands
 #$%            for submarines to come up.
 #$%
 #$% Called By: EXEORD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT
 #$%
 #$% Date:      APRIL 80
 #$%
 #$% Author:    Dana Wills
 #$%
 #######################################################

 BBcommon

integer IWORD,
        IONUM,
        UNT$Pointer,
        UNT$Orderedaltdepth$I,
        SHC$Pointer,
        SHC$Keeldepth$I,
        SHC$Scopedepth$I                        # MJC 5/2/2000 (E-2145)
literal ILEX[iword]

#if(XUNT$TYPE$I == $SUB$CODE)                   #if submarine
if(Xunt$SuperType$I  == $Submarine$SuperCode) #jb 2/12/91 
    {                                         # (NOT FALSE CONTACT)
    shc$pointer = Xunt$SHCPntr$i               # jb            3/31/89

    shc$KeelDepth$i  = Xshc$KeelDepth$i 
    shc$ScopeDepth$i = Xshc$ScopeDepth$i 

    if (ilex[1] == $LEX$SURFACE$)
        UNT$OrderedAltDepth$I = shc$KeelDepth$i # jb            3/31/89 
    else # (must be PERISCOPE)
        UNT$OrderedAltDepth$I = shc$ScopeDepth$i # jb            3/31/89 

    PUTunt$OrderedAltDepth$I                     # jb            3/31/89
    }                                           #end if submarine

 return
 end        # End  OSURF


define (Take_common, 
    BBdeclare    (UNT$Name$C, UNT$View$I, UNT$Type$I)
    common /take/ UNT$Name$C, UNT$View$I, UNT$Type$I
    )
            
Subroutine OTAKE(IONUM,                              #receive order number 
                 id,                                 #receive order id
                 UNT$POINTER,                        #receive unit pointer 
                 IWORD,                              #receive word count 
                 ILEX)                               #receive command string 
#######################################################################
#$%
#$% Purpose:   OTAKE processes "TAKE" commands.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND        SMOVH
#$%            HAS_WEAPONS TAKE_BASE TAKE_TRACK
#$%            Take_using_SAM   FndORD
#$%
#$% Tables:    UNT
#$%
#$% Date:      April 85
#$%
#$% Author:    C. L. Farbstein
#$%
#$% Modified:  Susan Miller - 2/94 (Adv SAM Model)
#$%            Added call to Take_using_SAM
#$%
#$%            Carol Kropp - 7/95 (E1419)
#$%            Recoded handling of keyword locations, since optional
#$%            entry of BE and TIN at the end of "TAKE BASE" makes it
#$%            impossible to work from the end forward.
#$%
#$%            Carol Kropp - 10/96 (E1695)
#$%            Added branch for handling ENGAGE command for CEC Model.
#$%
#$%            James Allen - 12/97 (E1370)
#$%            Added order id to the argument list for passing
#$%            to take_base and take_track.
#$%
#$%            Susan Miller - 3/99 (E1969)
#$%            Added call to fndord for use in call to Take_using_SAM
#$%            Added second dummy2 variable to send as a parameter to 
#$%            Take_Track.
#$%
#######################################################################

# 1    2          3                          4                         5      6      7
# TAKE <track-no>
# TAKE <track-no> [ NUCLEAR | CONVENTIONAL ] 
# TAKE <track-no> [ NUCLEAR | CONVENTIONAL ] GUNS
# TAKE <track-no> GUNS
# TAKE BASE       <force-name>
# TAKE BASE       <force-name>               [ NUCLEAR | CONVENTIONAL]
# TAKE BASE       <force-name>               [ NUCLEAR | CONVENTIONAL] TARGET [type]
# TAKE BASE       <force-name>               [ NUCLEAR | CONVENTIONAL] GUNS
# TAKE BASE       <force-name>               [ NUCLEAR | CONVENTIONAL] GUNS   TARGET [type]
# TAKE BASE       <force-name>               GUNS
# TAKE BASE       <force-name>               GUNS                      TARGET [type]
# TAKE BASE       <force-name>               TARGET                    [type]

BBcommon
Take_common

integer ISBSCR,
        JJ,
        IONUM,
        NUCLEAR,
        IUSEGUNS,
        ORD$Pointer,
        UNT$Pointer                         # MJC 5/2/2000 (E-2145)
real    TARGET_LEX                          # MJC 5/2/2000 (E-2145)
literal CSTRIP8                             # MJC 5/4/2000 (E2145)
integer id
logical Has_Weapons
Character msg[ARB]
integer msg_len
integer dummy1,pair_or_take, iword
literal ILEX[iword]
integer dummy2      # SMM 3/99 (E1969)
            
integer  index        # variable index into command ilex array

#String msg9  "      cannot TAKE       ; has no weapons     " #  5/10/83
#String msg11 "       is not free to use nuclear weapons."
#String msg   "      cannot engage while in hiding" 

  dummy1 = 0
  dummy2 = 0    # SMM 3/99 (E1969)

  Nuclear  = $NO
  IuseGUNS = $NO                                    # jb    7/12/89
  target_lex = $NoTarget$TargetCode

  UNT$VIEW$I = XUNT$VIEW$I                    # get attacker view
  UNT$TYPE$I = XUNT$TYPE$I                    # get attacker type
  UNT$NAME$C = XUNT$NAME$C                    # get unit name

  if (xUNT$Status$I == $Hiding$Code)  # clk 4/95 (E1393)
    {
     msg_len = 0
     call smovhn (UNT$Name$C, $$MaxLit, msg, msg_len)
     call smovv  (" cannot engage while in hiding", msg, msg_len)
     call send_   (UNT$View$I, 0, msg_len, msg)
     return
    }

  if (ilex[IWORD] == $LEX$SAM$)  # smm 2/94
    { # get the ord$pointer for use in take_using_sam
     call fndord (id,ord$pointer)  # SMM 3/99 (E1969)
    
     call Take_using_SAM (UNT$Pointer, iword, ILEX, ORD$Pointer)
     return
    }

  if (ilex[2] == $lex$Base$)    # if command is "TAKE BASE <force-name>"
    index = 4                   # set the index after <force-name>
  else                          # else command is "TAKE <track-no>"
    index = 3                   # set the index after <track-no>

  # E2231 joa 9/01
  while (index <= iword)    # determine if command indicates the use of
    {                       # nuclear weapons or the use of guns
#     if (ilex[index] == $lex$Conventional$)
#       {
#        nuclear = $no
#        index = index + 1
#       }
#     else if (ilex[index] == $lex$Nuclear$)
#       {
#        nuclear = $yes
#        index = index + 1
#       }
     if (ilex[index] == $lex$Guns$)
       {
        iuseguns = $yes
        index = index + 1
       }
     else
       break     # jhm (E2251)  CT02, program loops without break
    }    # end of while loop

  if (xUNT$NucFree$I == $YES | Nuclear == $NO)
    {
     if ( Has_Weapons(UNT$Pointer) )             # jb              3/31/89
       {
        if(ILEX[2] == $LEX$BASE$)               # if take a base
           {
            call Take_Base (UNT$Pointer, id, ilex, iword, nuclear, iuseguns)
           }                                    # end if take BASE
        else                                    # else if take TRACK
           {
            pair_or_take = $take_command_issued
            call Take_Track (UNT$POINTER,id,ILEX,Nuclear,IuseGUNS,
                             dummy1,pair_or_take,iword,dummy2)
           }
        }
    else                                        # attacker has no weapons
       {
        putUNT$RulesOfEngage$I ($IfAttacked$Code)

        if (ilex[2] != $lex$BASE$) isbscr = 2          # jb (track)    6/22/89
        else                       isbscr = 3          # jb  (base)    6/22/89
        jj = 0
        call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
        call smovv  (" cannot take ", msg, jj)
        call smovhn (ilex[isbscr], $$MaxLit, msg, jj)
        call smovv  ("; has no weapons", msg, jj)
        call send_   (UNT$View$I, 0, jj, msg)
       }
   }
else                                            # scenario not nuclear
   {
    jj = 0
    call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
    call smovv  (" is not free to use nuclear weapons.", msg, jj)
    call send_   (UNT$View$I, 0, jj, msg)
   }

return
end        # End  OTAKE


logical function Has_Weapons (UNT$Pointer)    

 #######################################################
 #$%
 #$% Purpose:   HAS_WEAPONS determines whether a unit
 #$%            has any weapons available
 #$%
 #$% Called By: OTAKE
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT    DEQ
 #$%
 #$% Date:      April 85
 #$%
 #$% Author:    C. L. Farbstein
 #$%            (jb    3/31/89)
 #######################################################

BBcommon

integer IUPI,
        UNT$Pointer,
        DEQ$Pointer,
        DEQ$Ident$I                 # MJC 5/2/2000 (E-2145)

Has_Weapons = .FALSE.

iUPI = UNT$Pointer$index        # jb                    3/31/89
for_DEQ_CHAIN (iUPI)            # jb                    3/31/89
   {
    #$% get equipment ID
    deq$ident$i = Xdeq$ident$i                # jb    3/31/89
    if ((deq$ident$i == $AAM$Code  |
         deq$ident$i == $ASM$Code  |
         deq$ident$i == $SAM$Code  |
         deq$ident$i == $GUN$Code  |
         deq$ident$i == $BOMB$Code |
         deq$ident$i == $TORPEDO$Code |
         deq$ident$i == $CruiseMissile$Code) &
         Xdeq$remaining$i > 0 )
        {
        Has_Weapons = .TRUE.
        BREAK
        }
   }

return
end        # End (Function) HAS_WEAPONS

integer function Find_Unit (Name)

 #######################################################
 #$%
 #$% Purpose:   FIND_UNIT searches the UNT table to find
 #$%            the named unit.
 #$%
 #$% Called By: TAKE_BASE
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT
 #$%
 #$% Date:      April 85
 #$%
 #$% Author:    C. L. Farbstein
 #$%
 #######################################################

BBcommon
literal Name

integer UNT2$Pointer, litcmp # jb litcmp frm [aai01...mods] 1/23/01
literal CSTRIP8                     # MJC 5/4/2000 (E2145)

Find_Unit = 0

#$% search for name of unit to be taken
for (unt2$pointer$first; unt2$pointer$ok; unt2$pointer$next)
    {
    #$% if name of unit to be taken is found
    if (litcmp(xunt2$name$c, Name) == 0) # jb litcmp frm [aai01...mods] 1/23/01 
        {
        Find_Unit = UNT2$Pointer
        break
        }
    }

return
end

subroutine Take_Base (UNT$Pointer,  # in: unit order issued to
                      id,           # in: order id
                      ilex,         # in: command lex values
                      nargs,        # in: number of arguments in ilex
                      nuclear,      # in: yes/no flag
                      iuseguns)     # in: yes/no flag
#######################################################
#$% 
#$% Purpose:   TAKE_BASE validates and processes the
#$%            TAKE command if the target is a shore
#$%            base.
#$%
#$% Called By: OTAKE
#$%
#$% Calls:     SEND        SMOVH    FIND_UNIT
#$%
#$% Tables:    UNT         
#$%
#$% Date:      April 85
#$%
#$% Author:    C. L. Farbstein
#$%
#$% Modified:  Carol Kropp 11/94 (E1333)
#$%            Added for target priority specification.
#$%
#$%            Carol Kropp - 7/95 (E1419)
#$%            Removed target_lex from parameters
#$%            and added processing of TARGET, BE and
#$%            TIN information.
#$%
#$%            James Allen - 12/97 (E1370)
#$%            Added order id to the argument list for
#$%            call to clear_maneuver_all, but station
#$%            information is preserved.
#$%
#######################################################
BBCommon
Take_common

LitCharEquiv(C8spaces)
literal  ilex[20]
integer  nuclear, iuseguns
integer  UNT$Pointer, id
integer eqlist[5,ARB], number_eq

integer  target_priority_code    # integer function

integer  Find_Unit
logical  Has_Guns, ship_with_guns, sub_surfaced
real*4   bear
integer  index              # varaible index into ile array

integer JJ,MSG,ISIDE1,ISIDE2,IONUM,
        ITARGX,ITGTYP,MAXR,MINR,NARGS,
        UNT2$Pointer, UNT2$View$I,
        UNT$Status$I, UNT$Targettype$I              # MJC 5/2/2000 (E2145)
integer max_range, shortest_range, i, closest_shore_base_ptr

real    UNT$Attackrange$F,
        RANGE, bearing, standoff_range, closest_base_range

BBDeclare (shc$pointer, acc$pointer, unt3$pointer)
DATA    C8spacesC / "        " /

            #012345678901234567890123456789012345678901234567890
#String msg1 "      cannot take a base    "
#String msg2 "      is a submerged sub; cannot use guns"
#String msg3 "       cannot take friendly base        "
#String msg4 "       cannot take invalid base name            "

  ship_with_guns = .false.

  if (UNT$TYPE$I == $Surface$CODE |            # if surface unit to take base...
      UNT$TYPE$I == $Sub$CODE           )
    {
     IuseGUNS = $yes    # the only thing that can be used to take is GUNS  # clk 1/7/93
     ship_with_guns = Has_Guns(Unt$pointer)
     if (!ship_with_guns)                  # if no guns onboard 
       {                                 # can't take base ?   
        jj = 0
        call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)
        Call SMOVV(" cannot take a base ",msg,jj)

        call send_(UNT$VIEW$I,0,jj,msg) # formerly jj
        RETURN
       }
     if (unt$type$i == $sub$code & !sub_surfaced(unt$Pointer))
       {
        jj = 0
        call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)
        Call SMOVV(" is a submerged sub; cannot use guns",msg,jj)
        call send_(UNT$VIEW$I,0,jj,msg) # formerly msg2
        RETURN
       }
    }

  UNT2$Pointer = Find_Unit (ILEX[3])          # unit to be taken
  unt$Status$i = Xunt$Status$i                # jb    8/18/89
  #$% if unit to be taken is found and is a shorebase
  if (UNT2$Pointer ^= 0 & xUNT2$Type$I == $shorebase$code)
    {
     #$% get sides of units...
     unt2$view$i = xunt2$view$i
     call whside(unt$view$i,iside1)
     call whside(unt2$view$i,iside2)

     if (iside1 ^= iside2)     #$% if units on different sides
       {
        ionum = TAKE$order                   # retain stationing info
        call save_station (unt$pointer)      # but clear other orders - joa 12/97 (E1370)
        call clear_maneuver_all (ionum, id, Xunt$view$i, unt$pointer)
        call restore_station (unt$pointer)

        itargx = unt2$pointer$index
        itgtyp = $shorebase$code

        putUNT$AssignedTarget$I (itargx)    #make target assignment
        putUNT$AttackIndx$I (itargx)        #assign target as attack guide

        # make sure that the react flag is cleared
        putUNT$ReactFlag$I ($no)

        if(UNT$Status$I !=$Sinking$Code & UNT$Status$I != $UnderTow$Code &
           UNT$Status$I !=$DeadinWater$Code) # jb 8/18/89;    /\  8/28/89
                putUNT$STATUS$I ($PROCEEDING$CODE)

        standoff_range = 0.0
        index = 4        # position after "TAKE BASE <force_name>
        while (index <= nargs)
          {
           if (ilex[index] == $lex$Target$)
             {
              UNT$TargetType$I = target_priority_code (_
                                        INT(ilex[index+1]), $NoTarget$TargetCode)
              putUNT$TargetType$I
              index = index + 2
             }
           else if (ilex[index] == $lex$BE$)
             {
              if (ilex[index + 2] == $lex$TIN$)
                {
                 call Store_BE_Info (UNT$Pointer, ilex[index + 1], C8spaces)
                 index = index + 2          # jb E2144 send LITERAL  /\  8/2/00 
                }
              else              
                {
                 call Store_BE_Info (UNT$Pointer, ilex[index + 1], ilex[index + 2])
                 index = index + 3
                }
             }
           else if (ilex[index] == $lex$TIN$)
             {
              call Store_TIN_Info (UNT$Pointer, ilex[index + 1])
              index = index + 2
             }
           else if (ilex[index] == $lex$STANDOFF$)
             {
              standoff_range = ilex[index + 1]
              index = index + 2
             }
           else
              index = index + 1
          }   # end of loop through the ilex array

        if (standoff_range == 0.0)
        {
            if (unt$Type$i == $Air$code) 
            {
                acc$pointer = Xunt$ACCPntr$i
                standoff_range = Xacc$StandoffRange$f
            }
            else if (UNT$TYPE$I == $Surface$CODE |            # if surface unit to take base...
                     UNT$TYPE$I == $Sub$CODE           )
            {
                shc$pointer = Xunt$SHCPntr$i
                standoff_range = Xshc$StandoffRange$f
            }
        }
        if (unt$type$i == $surface$code | unt$type$i == $sub$code)
        {
            call gun_range(unt$pointer,maxr,minr)
            max_range = minr
            shortest_range = max_range
        }
        else if (unt$Type$i == $Air$code)
        {
            number_eq = 0     # initialize to zero equipment items located
            call DEQGET (UNT$Pointer, $ASM$code, number_eq, EqList)
            call DEQGET (UNT$pointer, $Bomb$code, number_eq, EqList)

            max_range = 0
            for (i=1; i <= number_eq; i = i + 1)
            {
                if (eqList[4,i] > max_range) max_range = eqList[4,i]
            }

            shortest_range = 1024
            for (i=1; i <= number_eq; i = i + 1)
            {
                if (eqList[4,i] < shortest_range) shortest_range = eqList[4,i]
            }
        }
        if (standoff_range == 0.0)
        {
            standoff_range = shortest_range
        }

        # Send warning message if standoff_range greater than max range weapon
        if (standoff_range > max_range)     # joa 2/04 per_sor
        {
            jj = 0
            call smovv ("WARNING: ",msg,jj)
            call smovh (UNT$Name$c,$$MaxLit,msg,jj)
            call smovv (" standoff range of ",msg,jj)
            call smovf (standoff_range, 501, msg, jj)
            call smovv (" nmi exceeds max weapon range of ",msg,jj)
            call smovi (max_range, msg, jj)
            call smovv (" nmi.",msg, jj)
            call send_(UNT$View$i,0,jj,msg)
        }

        standoff_range = standoff_range  - 0.01     # Handle imprecision
        putunt$ATTACKRANGE$F (standoff_range)       # joa 2/05 per_sor

        call rll2rb(xunt$truelatitude$f,xunt$truelongitude$f,
                       xunt$costruelat$f,
                       xunt2$truelatitude$f,xunt2$truelongitude$f,
                       xunt2$costruelat$f,
                       range,bear)
        bear = bear + $PI
        $ang2pi(bear)
        putunt$attackbearing$F (bear)

        # Assign base within view as guide, and calculate range and bearing
        #   to return to current position
        if (Xunt$GuideIndx$i == 0)
        {
            closest_shore_base_ptr = 0
            closest_base_range = 99999.
            for (UNT3$Pointer$First; UNT3$Pointer$OK; UNT3$Pointer$Next)
            {
                if (Xunt3$Type$i != $ShoreBase$code) next
                if (unt$View$i != Xunt3$View$i) next
                call GETRB_M (UNT$Pointer, UNT3$Pointer,
                                 range, bearing)

                if (range < closest_base_range)
                {
                    closest_shore_base_ptr = UNT3$Pointer
                    closest_base_range = range
                }                
            }            
            if (closest_shore_base_ptr != 0)
            {
                unt3$pointer = closest_shore_base_ptr
                call GETRB_M (UNT3$Pointer, UNT$Pointer,
                                 range, bearing)
                PUTunt$GuideIndx$i (unt3$pointer$index)
                PUTunt$GuideRange$f (range)
                PUTunt$GuideBearing$f (bearing)
                PUTunt$GuideTrue$i ($YES)                            
            }
        }
        putUNT$NucTake$I (Nuclear)
        if (Xunt$MarshallStatus$i == $Recovering$Code) 
        PUTunt$MarshallStatus$i ($inflight$code)  
        PUTunt$useGUNS$i (IuseGUNS)                # jb        7/26/89
        if (IuseGUNS == $YES)                      # jb        7/31/89
          call assign_guns(unt$pointer,unt2$pointer$index,$take$guncode,0.0)

       }
     else                                    # attacker and atackee on
       {                                     # same side
        jj = 0
        call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)
        Call SMOVV(" cannot take friendly base ",msg,jj)
        call SMOVHN(ilex[3],$$MaxLit,msg,jj)
        call send_(unt$view$i,0,jj,msg)  # formerly msg3
       }
    }
  else                                # Unit to be taken not found or
    {                                 # not a shorebase
     jj = 0
     call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)       
     Call SMOVV(" cannot take invalid base name ",msg,jj)
     call SMOVHN(ilex[3],$$MaxLit,msg,jj)
     call send_(unt$view$i,0,jj,msg) # formerly msg4
    }

return
end

subroutine Take_Track (UNT$POINTER,
                       id,
                       ILEX,            
                       Nuclear,IuseGUNS,            # 7/12/89 
                       RMT$Pointer,                 # return
                       pair_or_take,                # return
                       iword,                       # receive # of words in ILEX
                       has_SAMS)                    # receive flag
 #######################################################
 #$%
 #$% Purpose:   TAKE_TRACK validates and processes the
 #$%            TAKE command when the target is a track.
 #$%
 #$% Called By: OTAKE
 #$%
 #$% Calls:     SEND        SMOVH     GTACT
 #$%            GTTRK_TMA   ENGAGE_TRACK
 #$%
 #$% Tables:    UNT         RMT
 #$%
 #$% Date:      April 85
 #$%
 #$% Author:    C. L. Farbstein
 #$%
 #$% Modified:  Susan Miller 7/92
 #$%
 #$%            Susan Miller - 4/95 (E1304)
 #$%            Added parameter has_sams to indicate whether 
 #$%            call is for advanced or non-advanced SAMs.
 #$%
 #$%            James Allen - 12/97 (E1370)
 #$%            Added order id to the argument list for
 #$%            call to clear_maneuver_all, but station
 #$%            information is preserved.
 #$%
 #$%            Susan Miller - 4/99 (E1969)
 #$%            If id is 0, don't call routines that clear
 #$%            maneuver and station information.
 #######################################################

bbcommon
Take_common

integer ITARGX,
        IUSEGUNS,
        NUCLEAR,
        RMT$Pointer,
        RMT$Detectionage$I,
        RMT$Detectee$I,
        UNT2$Pointer,
        UNT2$Type$I,
        UNT$Pointer                         # MJC 5/2/2000 (E2145)
integer id
Character msg[ARB]
integer pair_or_take, target_type, bearing_only, message_sent,
        is_it_old, jj, save_RMT, iword, has_sams
Literal ILEX[iword]

RMT$Pointer  = 0             ### new logic inserted by tpa 10/19/83
message_sent = $no          
bearing_only = NO
is_it_old    = NO

## pass unit view & track code; receive RMT pntr & bear only
call GtAct(UNT$View$I,ilex[2],RMT$Pointer,bearing_only)

if (RMT$Pointer ^= 0)                   ## if track found
    {
    RMT$DetectionAge$I = xRMT$DetectionAge$I
    if (bearing_only == YES)            ## passive track
        {                                       
        save_RMT = RMT$Pointer          ## save RMT Pointer

        call GtTrk_TMA(ilex[2],RMT$Pointer,is_it_old) ## pass track code
                                                      ## rec pntr/old for TMA
        if (RMT$Pointer != 0) bearing_only = NO       ## pass TMA'd
        else             RMT$Pointer = save_RMT       ## old/bear only track
        }
    else if (RMT$DetectionAge$I == $Old$Code)   ## active track old
        {
        is_it_old = YES
        }

    if (is_it_old == YES)                       ## output old track
        {
        # "xxxxx cannot take/pair old track xxxxx"
        jj = 0
        call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj) 
        if (pair_or_take == $take_command_issued)
             Call SMOVV(" cannot take old track ",msg,jj)
        else Call SMOVV(" cannot pair old track ",msg,jj)
        call SMOVHN(ilex[2],$$MaxLit,msg,jj)
        call send_(unt$view$i,0,jj,msg)
        message_sent = $yes
        }
    else if (bearing_only == YES)               ## output passive track
        {
        # "xxxxx cannot take/pair passive track xxxxx"
        jj = 0
        call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)
        if (pair_or_take == $take_command_issued)
             Call SMOVV(" cannot take passive track ",msg,jj)
        else Call SMOVV(" cannot pair passive track ",msg,jj)
        call SMOVHN(ilex[2],$$MaxLit,msg,jj)
        call send_(unt$view$i,0,jj,msg)
        message_sent = $yes
        }
    else if (xrmt$targetid$i==$friendly$code)   ##output friendly trk
        {
        # "xxxxx cannot take/pair friendly track xxxxx"
        jj = 0
        call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)
        if (pair_or_take == $take_command_issued)
             Call SMOVV(" cannot take friendly track ",msg,jj)
        else Call SMOVV(" cannot pair friendly track ",msg,jj)
        call SMOVHN(ilex[2],$$MaxLit,msg,jj)
        call send_(unt$view$i,0,jj,msg)
        message_sent = $yes
        }
    else if (xrmt$OverHoriz$i == $YES)          ## output OTH track 4/19/90
        {
         # "xxxxx cannot take/pair OTH track xxxxx"
         jj = 0
         call SMOVHN(unt$name$c,$$MaxLit,msg,jj)
         if (pair_or_take == $take_command_issued)
                Call SMOVV(" cannot take OTH track ",msg,jj)
         else Call SMOVV(" cannot pair OTH track ",msg,jj)
         call SMOVHN(ilex[2],$$MaxLit,msg,jj) 
         call send_(unt$view$i,0,jj,msg) 
         message_sent = $yes
        }

    else # valid track number
        {
        rmt$detectee$i = xrmt$detectee$i                #       5/5/83
        #$% set pointer to detectee                     #       5/5/83
        unt2$pointer$to rmt$detectee$i                  #       5/5/83

        #$% get unit detected & class
        itargx = rmt$Detectee$i                         #       5/5/83
        target_type = xrmt$Class$i  # $air$Code or $surface$code
        if ((UNT$Type$i == $Air$code) & (pair_or_take == $pair_command_issued))
            {   # if the track is an air track and it's a pair order
            if (target_type == $Air$Code)
                {   
                UNT2$Type$i = xUNT2$Type$i
                if ((UNT2$Type$i == $CruiseMissile$Code) & 
                    (xUNT2$TrueSpeed$F > MaxCruiseMissile$Speed)) 
                    {
                    #"xxxxx can't pair on track xxxxx.  Track is moving too fast."
                    jj =  0
                    call smovhn (UNT$Name$c,$$MaxLit,msg,jj)
                    call smovv (" can't pair on track ",msg,jj)
                    call smovhn (ilex[2],$$MaxLit,msg,jj)
                    call smovv (".  Track is moving too fast.",msg,jj)
                    call send_ (UNT$View$i,0,jj,msg)
                    message_sent = $yes
                    return
                    }   # cruise missile track moving too fast
                else if ((UNT2$Type$I != $Air$Code) &
                         (UNT2$Type$i != $CruiseMissile$Code))
                    {
                    #"xxxxx can't pair on non-air track xxxxx."
                    jj =  0
                    call smovhn (UNT$Name$c,$$MaxLit,msg,jj)
                    call smovv (" can't pair on non-air track ",msg,jj)
                    call smovhn (ilex[2],$$MaxLit,msg,jj)
                    call send_ (UNT$View$i,0,jj,msg)
                    message_sent = $yes
                    return
                    } # not an air track or cruise missile
                }   # track class is air
            }   # attacker is an a/c
        else if ((UNT$Type$i == $Surface$Code) & 
                 (target_type == $Surface$Code) &   # clk 1/7/93
                 (ilex[3] != $LEX$SAM$)) # and this is not a SAM engagement
            {                  # the only thing that surface can take surface with is guns,
             IuseGuns = $yes   # this provides for if only TAKE was entered.
             # joa 3/05 per_sor
             #putUNT$GuideIndx$I ($no)   # clear previous guide assignment - consistent with TAKE BASE  # clk 1/7/93
            }

        # if this was a take using SAM order and unit doesn't have
        # any SAMs, send a message and return now  SMM 6/95
        if ((ilex[3] == $LEX$SAM$) & (has_sams != $yes))
            {
             if (target_type == $Surface$Code) # if the target is a surface
                {
                 jj =  0
                 call smovhn (UNT$Name$c,$$MaxLit,msg,jj)
                 call smovv (" can't take ",msg,jj)
                 call smovhn (ilex[2],$$MaxLit,msg,jj)
                 call smovv (" with a SAM.  ",msg,jj)
                 call send_ (UNT$View$i,0,jj,msg)
                 message_sent = $yes
                }
             if (message_sent == $yes) pair_or_take = $no
             else pair_or_take = $take_command_issued
             return
            }

        if (id != 0)  # SMM 4/99 (E1969)
            {
             call save_station (unt$pointer)     # retain station info - joa 12/97 (E1370)
             # changed uninitialized variable ionum to TAKE$order - SMM 7/98 (E1983) 
             call clear_maneuver_all (TAKE$order, id, xUNT$View$I, UNT$Pointer)
             call restore_station (unt$pointer)
            }
    
        call engage_track (UNT$POINTER,
                           RMT$Pointer,
                           UNT2$Pointer,
                           target_type,
                           ILEX,
                           Nuclear,
                           IuseGUNS,    # jb         7/12/89
                           pair_or_take,
                           message_sent, # 7/92
                           iword, # SMM 5/93
                           has_SAMs)# SMM 4/95
        }
    } # END of        else if take TRACK
else  # track not found
    { # output invalid track
    #"xxxxx cannot take/pair invalid track number xxxxx"
    jj = 0
    call SMOVHN(UNT$NAME$C,$$MaxLit,msg,jj)    
    if (pair_or_take == $take_command_issued)
         Call SMOVV(" cannot take ",msg,jj)
    else Call SMOVV(" cannot pair ",msg,jj)
    call smovv("invalid track number ",msg,jj)
    call SMOVHN(ilex[2],$$MaxLit,msg,jj)
    call send_(unt$view$i,0,jj,msg)
    }

# if this was a take using SAM order, return now  SMM 2/94
if (ilex[3] == $LEX$SAM$) 
    {
     if (message_sent == $yes) pair_or_take = $no
     else pair_or_take = $take_command_issued
     return
    }

return
end

subroutine engage_track (UNT$POINTER,    # send - Hunter 
                         RMT$Pointer,    # send
                         UNT2$Pointer,   # send - Target 
                         itgtyp, # send - $air$Code or $surface$code
                         ILEX,           # send
                         Nuclear,        # send
                         IuseGUNS,       # send
                         pair_or_take,   # send
                         message_sent,   # return
                         iword,          # receive # of words in ILEX SMM 5/93
                         has_SAMs)       # receive yes or no SMM 4/95
 #######################################################
 #$% 
 #$% Purpose:   ENGAGE_TRACK completes the validation
 #$%            and processing of the TAKE or PAIR command  jb 12/00
 #$%            when the target is a track.
 #$%
 #$% Called By: TAKE_TRACK
 #$%
 #$% Calls:     SEND        SMOVH     VECTOR    
 #$%            OACTIV  Longest_AAM_range   Check_CAP_intercept
 #$%            Vector_SPEED     RLL2RB
 #$%
 #$% Tables:    UNT         RMT
 #$%
 #$% Date:      April 85
 #$%
 #$% Author:    C. L. Farbstein
 #$%
 #$% Modified:  Susan Miller 7/92
 #$%
 #$%            Susan Miller - 6/95 (E1304)
 #$%            Added parameter has_SAMs, updated user
 #$%            i/o message, and removed commented out code.
 #$%
 #$%            Susan Miller - 12/11/96 (E1725)
 #$%            Initialize nfound to zero prior to call to
 #$%            DEQGET.
 #$%
 #$%            Carol Kropp - 1/97 (E1649)
 #$%            If a failure message was sent then the 
 #$%            "within 12 hours." and "I'm too slow."
 #$%            should not be sent.
 #$%
 #$%            Susan Miller - 7/98 (E1997)
 #$%            If unit given TAKE is a shorebase and it
 #$%            doesn't have guns, automatically assign
 #$%            SAMs as if this was a TAKE using SAM order.
 #$%
 #$%            Susan Miller - 4/99 (E2066)
 #$%            Rearranged code so that if there are no guns
 #$%            a check is done to see if the unit has SAMs
 #$%            that can be assigned rather than sending the
 #$%            "Ships w/o guns cannot take a/c..." 
 #$%            Removed the now invalid msg: "WARNING:  Weapons
 #$%            status must be FREE for..."
 #######################################################

bbcommon
Take_common

integer ITGTYP,JJ,IUNT,
        ITARGET,MLIMIT,NUCLEAR,IUSEGUNS,
        RMT$Pointer, MC$Pointer,
        UNT2$Type$I, UNT2$Pointer,
        UNT$Pointer, UNT$Status$I,
        UNT$Attacktrue$I, UNT$Useguns$I         # MJC 5/2/2000 (E2145)
BBDeclare (unt3$pointer, acc$pointer, shc$pointer)
real    standoff_range, closest_base_range, shortest_range
integer index, closest_shore_base_ptr, i, number_eq, max_range
real    RANGE                                   # MJC 5/2/2000 (E2145)
integer ichase[0:7],maxr,minr,
        pair_or_take, max_missile_range,
        dont_care, message_sent, iword 
Literal ILEX[iword], act_Air[5], act_surf[5]
integer has_sams, eqlist[5,30], nfound, n, max_SAM_range
logical Has_guns,guns_onboard,submerged,sub_surfaced
real*4  bear
real    rcan
Character msg[ARB]
real    intercept_posit(2), intercept_spd, range_to_next, bearing # SMM 5/18/93
real    spdmax          # jb For specified (PAIR) attacker speed  12/14/00

data ichase[$shorebase$code    ] / 0 /      # same as $AirBase$Code #7
data ichase[$surface$code      ] / 1 /      # same as $Samsite$Code #3
data ichase[$sub$code          ] / 1 /      # 2
data ichase[$air$code          ] / 4 /      # 1

data act_air /$lex$ACTIVATE$, $lex$AIR$    , 0, 0, 0/
data act_surf/$lex$ACTIVATE$, $lex$SURFACE$, 0, 0, 0/


  UNT2$Type$I = xUNT2$Type$I

  submerged = (unt2$type$i == $sub$code & !sub_surfaced(unt2$pointer))
  guns_onboard = (Has_Guns(unt$Pointer) & !submerged)

  rcan = YES                                 # flag for engaging

  if (ichase[UNT$Type$i] >= ichase[itgtyp])  # if capable of chasing target
    {
     # find the AAM with the longest range for the CAP a/c  
     call Longest_AAM_range (UNT$Pointer,      # send CAP a/c pointer
                             Max_missile_range,# receive longest range
                             dont_care)  # receive missile index, not used

     if (xUNT$AssignedCAP$I == $yes )
       {
        call Check_CAP_intercept (unt$Pointer, rmt$pointer, ILEX,
                                  max_missile_range, rcan, pair_or_take,
                                  message_sent, iword)
       }

     else   # Else attacker is NOT on a CAP-station..
     {
        spdmax = 0.0                # Assume No speed in order
        if (iword > 2)              # E2231 joa 9/01 
        {
            if (pair_or_take == $pair_command_issued &     # jb  12/14/00
                 ilex[3] == $lex$Speed$)  # jb  12/14/00
            {
                spdmax = MAX( REAL(ilex[4]), 0.0 )         # jb 12/19/00
            }
        }
        if (spdmax > 0.0)
            call VECTOR_speed (UNT$Pointer,RMT$Pointer,rcan,spdmax) # jb 12/00
        else   # else if TAKE (or, if no PAIR speed specified) jb 12/14/00
            call VECTOR(UNT$Pointer,RMT$Pointer,rcan)

     }   # end of if the attacker is NOT on an assigned CAP station

     if(message_sent == $yes) # jb now: IF so set by CHECK_CAP_Intercept,--
       return               #    or, by calling subroutine TAKE_Track...

    } # if capable of chasing target

  else if (!guns_onboard) # if can't chase it and it doesn't have guns...
    {
     nfound = 0     # SMM 12/11/96 (E1725) 
     # does it have SAMs? SMM 4/99 (E2066)
     call DEQGET (UNT$Pointer, $SAM$Code, nfound, eqlist)

     # if this is not a TAKE using SAM order for a shorebase, see if unit has
     # any kind of SAM that can be assigned for the TAKE command. SMM (E1997)
     # since if we are here, we have no guns, try a SAM - reworked if statement SMM (E2066)
     if ((has_sams != $yes) & (nfound != 0) &
         ((UNT$Type$I == $Shorebase$Code) | (ilex[3] != $lex$guns$))) 
        has_sams = $yes              
     if ((has_sams == $yes) |       # PER #E1304 SMM 4/95
         ((UNT$Type$I == $Shorebase$Code) & (nfound > 0))) # SMM 7/98 (E1997)
        {
         max_SAM_range = 0
         for (n=1; n <= nfound; n=n+1)
            {
             MC$Pointer  = eqlist[2,n]             # get MC pointer
             eqlist[4,n] = MAX (1,xMC$MaxRange$I)  # get max range of SAM

             max_SAM_range = MAX (max_SAM_range,eqlist[4,n]) 
            }
         if ((INT(xRMT$Range$F) > max_SAM_range) & (has_sams == $yes))
            {
             # "xxxxx cannot TAKE xxxxx, currently out of SAM range.  "
             jj = 0                          
             call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
             call smovv  (" cannot TAKE ", msg, jj)
             call smovhn (ilex[2], $$MaxLit, msg, jj)   
             call smovv  (", currently out of SAM range.  ", msg, jj)
             call send_ (UNT$View$i, 0, jj, msg)  
             message_sent = $yes
             return
            } 

         # "xxxxx assigning xxxxx as target for non-explicit SAM.  "
         # "WARNING:  Weapons status must be FREE for "
         # "engagement by non-explicit SAM.  "
         jj = 0                          
         call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
         call smovv  (" assigning ", msg, jj)
         call smovhn (ilex[2], $$MaxLit, msg, jj)   
         call smovv  (" as target for non-explicit SAM.", msg, jj)
         call send_   (UNT$View$i, 0, jj, msg)  

         # changed act_surf to act_air SMM 7/98 (E1997)
         call OACTIV(TAKE$Order,iunt,2,act_Air) 
         itarget = xRMT$Detectee$I
         putUNT$AssignedTarget$I (itarget)    # make target assignment
        }
     else 
        {
         #"Ships without guns cannot take aircraft; so--" 
         #"xxxxx cannot intercept xxxxx:"                 
         #"..just ensure weapon FREE and radar ON."       
         jj = 0                           # forget about it...
         Call smovv  ("Ships without guns cannot TAKE aircraft; so--", msg, jj)
         call send_   (UNT$View$i, 0, jj, msg)
         jj = 0                          
         call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
         call smovv  (" cannot intercept ", msg, jj)
         call smovhn (ilex[2], $$MaxLit, msg, jj)   
         call smovv  (":", msg, jj)
         call send_   (UNT$View$i, 0, jj, msg)
         jj = 0
         call smovv  ("..just ensure weapon FREE and radar ON.", msg, jj)
         call send_   (UNT$View$i, 0, jj, msg)
        }
     message_sent = $yes
     RETURN
    }    
  # jb (cTest) 6 lines sdded, to get RANGE for next IF  4/12/01
  call rll2rb(xunt$truelatitude$f,xunt$truelongitude$f,
                xunt$costruelat$f,
                xunt2$truelatitude$f,xunt2$truelongitude$f,
                xunt2$costruelat$f,
                RANGE,bear)
  $ang2pi(bear)

  if ( (rcan >= 0. | rcan == -3.0) | # able to intercept, or already 
       (Max_missile_range > RANGE) ) # jb within AAM range (CTest) 4/17/01
    {
     iunt = UNT$Pointer
     UNT2$Type$i = xUNT2$Type$i     

     if (UNT2$Type$I == $AIR$CODE         |
         UNT2$Type$I == $CRUISEMISSILE$CODE) 
       {
        # if attacking unit is a ship and we are here, it has guns on board, so need
        # to check to see if this is a SAM take command and process accordingly
        if (UNT$Type$I == $SURFACE$CODE)                # PER #E1304 SMM 6/95
            {
             if (has_sams == $yes)
                {
                 nfound = 0  # SMM 12/11/96 (E1725) 
                 call DEQGET (UNT$Pointer, $SAM$Code, nfound, eqlist)

                 max_SAM_range = 0
                 for (n=1; n <= nfound; n=n+1)
                    {
                     MC$Pointer  = eqlist[2,n]            # get MC pointer
                     eqlist[4,n] = MAX(1,xMC$MaxRange$I)  # get max range
                     eqlist[5,n] = xMC$NbrSimEngages$I    # Simult-Engmt limit
        
                     mlimit = mlimit + eqlist[5,n]        # sum limits

                     # save maximum SAM missile range
                     max_SAM_range = max(max_SAM_range,eqlist[4,n]) 

                     if (mlimit > 30) mlimit = 30
                    }
                 if (INT(xRMT$Range$F) > max_SAM_range)
                    {
                     # "xxxxx cannot TAKE xxxxx, currently out of SAM range.  "
                     jj = 0                          
                     call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
                     call smovv  (" cannot TAKE ", msg, jj)
                     call smovhn (ilex[2], $$MaxLit, msg, jj)   
                     call smovv  (", currently out of SAM range.  ", msg, jj)
                     call send_  (UNT$View$i, 0, jj, msg)  
                     message_sent = $yes
                     return
                    } 

                 # "xxxxx assigning xxxxx as target for non-explicit SAM.  "
                 # "WARNING:  Weapons status must be FREE for "
                 # "engagement by non-explicit SAM.  "
                 jj = 0                          
                 call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
                 Call smovv  (" assigning ", msg, jj)
                 call smovhn (ilex[2], $$MaxLit, msg, jj)   
                 Call smovv  (" as target for non-explicit SAM.  ", msg, jj)
                 call send_  (UNT$View$i, 0, jj, msg)
                 jj = 0
                 call smovv  ("WARNING:  Weapons status must be FREE for ", msg, jj)
                 call smovv  ("engagement by non-explicit SAM.  ", msg, jj)
                 call send_   (UNT$View$i, 0, jj, msg)
                 message_sent = $yes
                }
            }

        if (pair_or_take == $pair_command_issued)
            call OACTIV(Activate$Order,iunt,2,act_Air)
        else # it's a take
            call OACTIV(TAKE$Order,iunt,2,act_Air)              
       }
     else if (UNT$Type$i == $sub$code) # if attacker is sub, 
       {                           # & target NOT airborne
        if (!submerged)    # If so
          call OACTIV(TAKE$Order,iunt,2,act_Surf)
       }
     else
       call OACTIV(TAKE$Order,iunt,2,act_Surf)

     itarget = xRMT$Detectee$I

     putUNT$AssignedTarget$I (itarget)    # make target assignment
     putUNT$NucTake$I (Nuclear)
     putUNT$Coverflag$I  ($No)              

     UNT$Status$i = xUNT$Status$i                    # jb    8/18/89
     if(UNT$Status$I !=$Sinking$Code & UNT$Status$I != $UnderTow$Code &
        UNT$Status$I !=$DeadinWater$Code) # jb 8/18/89;    /\  8/28/89
            putUNT$STATUS$I ($PROCEEDING$CODE)

     if (unt$type$i == $AIR$code &
        Xunt$MarshallStatus$i == $Recovering$Code)
       PUTunt$MarshallStatus$i ($inflight$code) 

     bear = $PI
     minr = 0
     unt$attacktrue$i = $no
     if (guns_onboard & IuseGUNS == $YES)    # jb            7/31/89
       {
        call assign_guns(unt$pointer,unt2$pointer$index,$take$guncode,0.0)
       }
     if (ichase[UNT$Type$i] >= ichase[itgtyp])  # if capable of chasing target
       {
        standoff_range = 0.0
        index = 3        # position after "TAKE <track>
        while (index <= iword)
          {
           if (ilex[index] == $lex$STANDOFF$)
             {
              standoff_range = ilex[index + 1]
              index = index + 2
             }
           else
              index = index + 1
          }   # end of loop through the ilex array

        if (standoff_range == 0.0)
        {
            if (unt$Type$i == $Air$code) 
            {
                acc$pointer = Xunt$ACCPntr$i
                standoff_range = Xacc$StandoffRange$f
            }
            else if (UNT$TYPE$I == $Surface$CODE |            # if surface unit to take base...
                     UNT$TYPE$I == $Sub$CODE           )
            {
                shc$pointer = Xunt$SHCPntr$i
                standoff_range = Xshc$StandoffRange$f
            }
        }
        if (unt$type$i == $surface$code | unt$type$i == $sub$code)
        {
            call gun_range(unt$pointer,maxr,minr)
            max_range = minr
        }
        else if (unt$Type$i == $Air$code)
        {
            number_eq = 0     # initialize to zero equipment items located
            if (Xrmt$Class$i == $Air$code)  # Type of target
            {
                call DEQGET (UNT$pointer, $AAM$code, number_eq, EqList)
                call DEQGET (UNT$pointer, $Gun$code, number_eq, EqList)
            }
            else
            {
                call DEQGET (UNT$Pointer, $ASM$code, number_eq, EqList)
                call DEQGET (UNT$pointer, $Bomb$code, number_eq, EqList)
                call DEQGET (UNT$pointer, $Gun$code, number_eq, EqList)
            }
            max_range = 0
            for (i=1; i <= number_eq; i = i + 1)
            {
                if (eqList[4,i] > max_range) max_range = eqList[4,i]
            }

            shortest_range = 1024
            for (i=1; i <= number_eq; i = i + 1)
            {
                if (eqList[4,i] < shortest_range) shortest_range = eqList[4,i]
            }
        }
        if (standoff_range == 0.0)
        {
            standoff_range = shortest_range
        }
        # Send warning message if standoff_range greater than max range weapon
        if (standoff_range > max_range)     # joa 2/04 per_sor
        {
            jj = 0
            call smovv ("WARNING: ",msg,jj)
            call smovh (UNT$Name$c,$$MaxLit,msg,jj)
            call smovv (" standoff range of ",msg,jj)
            call smovf (standoff_range, 501, msg, jj)
            call smovv (" nmi exceeds max weapon range of ",msg,jj)
            call smovi (max_range, msg, jj)
            call smovv (" nmi.",msg, jj)
            call send_(UNT$View$i,0,jj,msg)
        }

        standoff_range = standoff_range - 0.01      # handle imprecision 
        putunt$ATTACKRANGE$F (standoff_range)       # joa 2/05 per_sor
        UNT$ATTACKTRUE$I = $YES                     # True brg standoff 
        PUTUNT$ATTACKTRUE$I                         # mad 7/06

        call getrb_m (unt2$pointer, unt$pointer, range, bear)
        $ang2pi(bear)
        putunt$attackbearing$F (bear)

        # Assign base within view as guide, and calculate range and bearing
        #   to return to current position
        if (Xunt$GuideIndx$i == 0)
        {
            closest_shore_base_ptr = 0
            closest_base_range = 99999.
            for (UNT3$Pointer$First; UNT3$Pointer$OK; UNT3$Pointer$Next)
            {
                if (Xunt3$Type$i != $ShoreBase$code) next
                if (unt$View$i != Xunt3$View$i) next
                call GETRB_M (UNT$Pointer, UNT3$Pointer,
                                 range, bearing)

                if (range < closest_base_range)
                {
                    closest_shore_base_ptr = UNT3$Pointer
                    closest_base_range = range
                }                
            }            
            # Return to position when take order given
            if (closest_shore_base_ptr != 0)
            {
                unt3$pointer = closest_shore_base_ptr
                call GETRB_M (UNT3$Pointer, UNT$Pointer,
                                 range, bearing)
                PUTunt$GuideIndx$i (unt3$pointer$index)
                PUTunt$GuideRange$f (range)
                PUTunt$GuideBearing$f (bearing)
                PUTunt$GuideTrue$i ($YES)                            
            }
        }

        UNT$UseGuns$i = $NO    # jb    Initialize        7/13/89
        putUNT$AttackIndx$I (itarget)      # assign target as attack guide
        putUNT$AttackTrue$I 
        if(IuseGUNS == $YES)              
          {
           UNT$UseGuns$i = ($YES)    # jb FLAG for gun_targets.. 7/13/89
           If(unt$type$i == $Air$Code )   # 7/12/89  
             {
              if(Xrmt$Class$i == $Air$Code)
                {
                 putUNT$Orderedaltdepth$i (Xunt2$TrueAltDepth$i)
                }
              ELSE # target is on the surface..
                {
                 putUNT$Orderedaltdepth$i (100)
                }
             }    # End if (hunter is Airborne)
          }    # End if (iUSEguns..
        putUNT$UseGuns$i                         # jb        7/13/89
       } # End if capable of chasing target
    }
  else  # Not close, & cannot intercept (rcan = -7 or -1) AND.10/16/85
    {                       # jb NOT presently in missile range  4/16/01
     if (message_sent == $no)    # don't send multiple messages
       {                         # clk 1/97 (E1649)
        # rcan = -7:  "XXXXX cannot intercept XXXXX within 12 hours."
        # rcan = -1:  "XXXXX cannot intercept XXXXX; I'm too slow."
        jj = 0
        call smovhn (UNT$Name$C, $$MaxLit, msg, jj)
        call smovv  (" cannot intercept ", msg, jj)
        call smovhn (ilex[2], $$MaxLit, msg, jj)

        if (rcan == -7.0) 
          call smovv (" within 12 hours.", msg, jj)
        else    # rcan = -1.0
          call smovv ("; I'm too slow.", msg, jj) 

        call send_(UNT$View$i,0,jj,msg)
        message_sent = $yes
       }   # end of if no failure message was sent before
    }

return
end        # End  ENGAGE_TRACK



 Subroutine OWEAPO(IONUM,                              #receive order number 
                   UNT$POINTER,                        #receive unit pointer 
                   IWORD,                              #receive word count 
                   ILEX)                               #receive command string 

 
 #######################################################
 #$%
 #$% Purpose:   OWEAPO processes weapons commands
 #$%            for the rules of engagement policy.
 #$%
 #$% Called By: EXEORD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    UNT
 #$%
 #$% Date:      APRIL 80
 #$%
 #$% Author:    Dana Wills
 #$%
 #$% Modified:  Susan Miller 4/99 (E2066)
 #$%            If given a weapons tight command, cancel
 #$%            an assignedtarget (so SAMs will stop firing).
 #######################################################

 BBcommon

 integer IWORD,INDX,
         NUCLEAR,IONUM,
         UNT$View$I,
         UNT$Pointer,
         UNT$Rulesofengage$I                # MJC 5/2/2000 (E-2145)
 literal ILEX[iword], iaddr / 0 /   # jb  for dew  2/12/01

 indx    = 3
 nuclear = $NO
 UNT$View$I = xUNT$View$I
 #$% set engagement category and save
 if     (ILEX[2]==$LEX$TIGHT$)    
    {
     UNT$RULESOFENGAGE$I=$IFATTACKED$CODE
     # clear out assignedtarget so SAMS will stop shooting SMM 4/99 (E2066)
     if (xUNT$AssignedTarget$I != $No) putUNT$AssignedTarget$I ($No)
    }
 else
    {
#    if (ilex[3] == $LEX$NUCLEAR$)
#        {
#        indx    = 4
#        nuclear = $YES
#        if (Nuclear$Capable == $NO)
#            {
#            call wgoerr (unt$View$i,iaddr,IONUM,IWORD,ilex,
#                        "Scenario not nuclear.")
#            return
#            }
#        }

#    else if (ilex[3] == $LEX$CONVENTIONAL$)
#        {
#        indx    = 4
#        nuclear = $NO
#        }

    if     (ILEX[indx]==$LEX$AIR$)      
                                UNT$RULESOFENGAGE$I=$AIRNONFRIENDLY$CODE
    else if(ILEX[indx]==$LEX$ALL$)      
                                UNT$RULESOFENGAGE$I=$ALLNONFRIENDLY$CODE
    else if(ILEX[indx]==$LEX$SURFACE$)  
                                UNT$RULESOFENGAGE$I=$SURFACENONFRIENDLY$CODE
    else if(ILEX[indx]==$LEX$SUBMARINE$)
                                UNT$RULESOFENGAGE$I=$SUBNONFRIENDLY$CODE
    else if(ILEX[indx+1]==$LEX$AIR$)      
                                UNT$RULESOFENGAGE$I=$AIRENEMY$CODE
    else if(ILEX[indx+1]==$LEX$ALL$)      
                                UNT$RULESOFENGAGE$I=$ALLENEMY$CODE
    else if(ILEX[indx+1]==$LEX$SURFACE$)  
                                UNT$RULESOFENGAGE$I=$SURFACEENEMY$CODE
    else if(ILEX[indx+1]==$LEX$SUBMARINE$)
                                UNT$RULESOFENGAGE$I=$SUBENEMY$CODE
    else                        UNT$RULESOFENGAGE$I=XUNT$RULESOFENGAGE$I
    }

 PUTUNT$RULESOFENGAGE$I
 putUNT$NucFree$I (nuclear)

 return
 end





 Subroutine OXCIR(IONUM,                              #receive order number 
                  PLC$VIEW$I,                         #receive view 
                  IWORDS,                             #receive number of words 
                  ILEX)                               #receive parameters 

 #######################################################
 #$%
 #$% Purpose:   OXCIR processes place and cancelx
 #$%            commands for the placement of circle
 #$%            or x-marks on plot.
 #$%
 #$% Called By: EXEORD
 #$%
 #$% Calls:     UNTFND     FNDOWN     SEND
 #$%
 #$% Tables:    UNT        OWN        PLC
 #$%            RMC
 #$%
 #$% Date:      APRIL 80
 #$%
 #$% Author:    Dana Wills
 #$%
 #######################################################

 BBcommon

 integer IWORDS,IDUMMY,NOROOM,
         JJ,IBONLY,IONUM,
         RMT$Pointer,
         UNT$Pointer, OWN$Pointer,
         NUC$Pointer, NUC$Radius$I,
         PLC$Referencetype$I, PLC$Reference$I,
         PLC$Pointer, PLC$Radius$I,
         PLC$Type$I, PLC$View$I                     # MJC 5/2/2000 (E-2145)
 real    PLC$Latitude$F, PLC$Longitude$F,
         DMS2RAD                                    # MJC 5/2/2000 (E-2145)
 literal ILEX[iwords]
 Character msg[ARB]

#String msg1 "      not found for circle or x-mark.   "
#String msg2 "Passive track        invalid for circle or x-mark.  "


 if(ILEX[2] == $LEX$XMARK$) PLC$TYPE$I = $XMARK$CODE
 else                       PLC$TYPE$I = $CIRCLE$CODE

 if (ILEX[3] == $LEX$FORCE$)
    {
     call UNTFND(PLC$VIEW$I,
                 ILEX[4],
                 UNT$POINTER)

#     if (unt$pointer != 0 & iview != $Neutral$view)
     if (unt$pointer != 0 & PLC$VIEW$I != $Neutral$view)
        {
         call FNDOWN(own$pointer,
                     unt$pointer$index,
                     idummy,
                     noroom)

         if (noroom == $yes | Xown$Unit$i == 0) unt$pointer = 0
        }

     if (UNT$POINTER == 0)                 #if force not found
        {
         jj = 0
         call SMOVHN(ilex[4],$$MaxLit,msg,jj)   
         Call SMOVV(" not found for circle or x-mark.",msg,jj)
         #$% send msg to view for display
         call send_(plc$view$i,0,jj,msg)  # formerly msg1
         return
        }

     if (PLC$VIEW$I == $Neutral$view)
        {
         plc$ReferenceType$i = $True$code
         plc$Reference$i = unt$pointer$index
        }
     else
        {
         plc$ReferenceType$i = $OwnForce$code
         plc$Reference$i = own$pointer$index
        }
    }

 else if (ILEX[3]  == $LEX$TRACK$)
    {
     rmt$pointer = 0

     call gtact(plc$view$i,
                ILEX[4],
                RMT$POINTER,
                ibonly)

     if (rmt$POINTER == 0)                 #if track not found
        {
         jj = 0
         call SMOVHN(ilex[4],$$MaxLit,msg,jj)       # DEW 11/99 E2172
         Call SMOVV(" not found for circle or x-mark.",msg,jj)
         #$% send msg to view for display
         call send_(plc$view$i,0,jj,msg) # formerly msg1
         return
        }

     if (ibonly == $yes)                   #if track passive
        {
         jj = 0
         Call SMOVV("Passive track ",msg,jj)
         call SMOVHN(ilex[4],$$MaxLit,msg,jj)       # DEW 11/99 E2172
         Call SMOVV(" invalid for circle or x-mark.",msg,jj)

         #$% send msg to view for display
         call send_(plc$view$i,0,jj,msg) # formerly msg2
         return
        }

     plc$ReferenceType$i = $OtherForce$code
     plc$Reference$i = rmt$pointer$index
    }

if (ilex[1] == $Lex$Cancel$)
   {
    if (Nuclear$Capable == $YES & 
        ILEX[2]         == $LEX$CIRCLE$ &
        ilex[3]         == $Lex$All$)   ## can all nuc circles
        {
        for (NUC$Pointer$First;NUC$Pointer$Valid;NUC$Pointer$Next) #search arry
            {
            NUC$Radius$I = xNUC$Radius$I

            if (NUC$Radius$I == 0) next

            NUC$ZERO
            }
        }
    for (PLC$POINTER$FIRST;PLC$POINTER$OK;PLC$POINTER$NEXT) #search arry
       {
        if (Xplc$view$i != plc$view$i |
            Xplc$type$i != plc$type$i ) next

        if (ilex[3] == $Lex$All$ |
            (Xplc$ReferenceType$i == plc$ReferenceType$i &
             Xplc$Reference$i == plc$Reference$i))
           {
            PLC$ZERO
           }
       }
   }

else
   {
    for (PLC$POINTER$FIRST;PLC$POINTER$VALID;PLC$POINTER$NEXT) #search array
        {
         if (XPLC$VIEW$I == 0)  break
        }

    if (!plc$pointer$valid)
       {
        ### send "no room" message
        return
       }

    if (ILEX[3] == $LEX$POSITION$)
       {
        PLC$LATITUDE$F = DMS2rad(ILEX[4])
        PUTPLC$LATITUDE$F

        PLC$LONGITUDE$F = DMS2rad(ILEX[5])
        PUTPLC$LONGITUDE$F

        PLC$RADIUS$I = ILEX[6]
        plc$ReferenceType$i = $null$code
       }
    else
       {
        PLC$RADIUS$I = ILEX[5]
       }
    if(plc$Radius$i < 1) plc$Radius$i = 1    # jb; Protect ATAN2 8/17/88

    PUTplc$Radius$i
    PUTplc$Type$i
    PUTplc$view$i
    PUTplc$Reference$i
    PUTplc$ReferenceType$i

    if (!plc$pointer$ok) plc$last$to (plc$pointer + plc$entry - 1)
   }

 return
 end



#   VECTOR.new2 = VECTOR.new reduced by deleting most entry_point code
Subroutine VECTOR(unt$pointer,rmt$pointer,rcan) 
#################################################################
#$%
#$% Purpose:   VECTOR computes intercept time, interceptor course,
#$%             range to intercept; and sets interceptor speed
#$% Called By: OCOVER    ENGAGE_TRACK    ORECON     SET_COURSE
#$%
#$% Calls:     RRB2LL     RLL2RB     ANGPI
#$%            QCOS       MIN_TO_TARGET
#$%
#$% Tables:    UNT        RMT
#$%            ACC        
#$%
#$% Dates:      APRIL 80        July 84
#$% Authors:    Ron Williams    Joe Bryant
#$%
#$% Modified:  Susan Miller 7/92
#$%            SMM 5/93 to fix entry points 
#$%
#$%            Carol Kropp - 4/96 (E1478)
#$%            Changed "can not pair xxxxx . Intercept time
#$%            (gm) exceeds tailchase (x)." to provide the
#$%            name of the unit command issued to, the
#$%            intercept time in zulu time and not send the
#$%            "can not pair xxxxx" twice.
#$%
#$%          James Allen - 7/96 (E1500)
#$%            Removed the pair_or_take variable and setting
#$%            it since the msg "xxxxx can not pair/take xxxxx."
#$%            changed to "xxxxx can not intercept xxxxx."  Also
#$%            extracted the unit's view when sending the
#$%            "can not intercept" and "exceeds tailchase limit"
#$%            messages (they were going to control).  Set can
#$%            to -7.0 followed by a return out of the routine
#$%            when the intercept time exceeds the tailchase limit.
#$%
#$%            Carol Kropp - 1/97 (E1649)
#$%            Changed can to -1.0 (no solution possible) from
#$%            -7.0 when tailchase limit is exceeded (the wrong
#$%            message was being sent by caller - 12 hours).
#$%
#$%             jb  1/01  entry VECTOR_ENTRY (and associated logic) removed.
#$%           Short entry VECTOR_SPEED added to accommodate those
#$%           PAIR commands that specify the interceptor speed.
##
#$%             jb 2/08/01: Generation 16 corrected a "called_by" line in this
#$%             subroutine--now rewritten with no such reference (jb for dew) 
#$%            Jim Allen - 12/02 (E2317)
#$%            RMIN_TO_TARGET result RTIM not truncated to integer
#$%
########################################################

BBcommon

integer NUMBER_OF_WORDS,
        IENGAGING,
        JTIM, LONGTIME,
        JJ, KQ, IQ1, IQ2, IQ3,
        RMT$Pointer, ACC$Pointer,
        UNT2$Pointer, UNT2$Type$I,
        UNT$Pointer,UNT$View$I,UNT$Type$I   # MJC 5/2/2000 (E-2145)
real    UNT$Intercepttime$F,UNT$Rangetonext$F,UNT$Orderedcourse$F,
        RMT$Lastdettime$F,
        TLAT, TLON, TCOS,
        FLAT, FLON, FCOS,
        TCRS, TRAVEL, tspd, ltime,
        RANGE, BRNG,
        RTIM,
        XLAT, XLON, XCOS,
        PRNG, TOGO, HDNG
literal CSTRIP8                                                   # MJC 5/4/2000 (E2145)
integer Game_DTG     # function to compute zulu time

character nmsg1[ARB]
integer   missile_rng
real    radius                # SMM 5/14/93
literal ILEX[$max$args]                 # clk 4/92
real    spdmax, spdINT         # jb 12/18/00 
real    rcan

    #$%  Set SPDMAX if unit type is $AIR$code   # jb 12/13/00
unt$Type$i = Xunt$Type$i                        # get unit type
if (unt$Type$i == $Air$code)                    # if unit type is air
   {
    acc$pointer = Xunt$AccPntr$i                # get aircraft pointer
    spdmax = float(Xacc$VectorSpeed$i)
    }

    #$% Set SPDMAX if an aircraft is reacting to a PAIR command # jb 12/13/00
repeat                                                          # jb 12/13/00
    {
    break      # jb  Note: spdINT input is a non_negative REAL..
    entry VECTOR_speed (unt$pointer,rmt$pointer,rcan,spdINT)     # jb 12/13/00
    spdmax = spdINT                                              # jb 12/18/00
    PUTUNT$USEORDSPEED$I ($YES)                       # jb  5/21/2001  
    acc$pointer = Xunt$AccPntr$i         # get aircraft characteristics pointer
    SPDMAX = MAX(SPDMAX,float(Xacc$LoiterSpeed$i) )   # jb  5/21/2001  
    SPDMAX = MIN(SPDMAX,float(Xacc$VectorSpeed$i) )
    }
#----------------------  entry_point removed  12/14/00
if (rcan == YES)                        ## for TAKE or PAIR
    {
    iengaging = YES
    }

#$% get units true position
flat = XUNT$TrueLatitude$f
flon = XUNT$TrueLongitude$f
fcos = XUNT$CosTrueLat$f

if (xRMT$TMAFlag$I == YES)                      ## if tma target 8/23/83 tpa
    {
    tlat = xRMT$TMALat$F                       ## get TMA position
    tlon = xRMT$TMALon$F
    tcos = COS(tlat)
    }
else                                            ## active/visual target
    {
    tlat = xRMT$ApparentLat$F                  ## get apparent position
    tlon = xRMT$ApparentLon$F
    tcos = COS(tlat)
    }

tcrs   = Xrmt$Course$i * ($pi/180.)             # get target course & speed
call ang2PI(tcrs)                               #<<<>>>         8/21/85
tspd   = Xrmt$Speed$i

rmt$LastDetTime$f = xrmt$LastDetTime$f 
ltime = Order$Minute - rmt$LastDetTime$f   # 8/16/84

if (ltime > 0. & ltime < Minutes$To$Old)               #   8/16/84
  {
   travel = (tspd*$Hours$Per$Minute) * ltime   #   8/16/84
   call RRB2LL(tlat,tlon,travel,0.0,tcrs,tcos)
  }

call RLL2RB( _                  #Rhumb line Lat/Lon to Range/Bearing
                   tlat,        #latitude of TARGET
                   tlon,        #longitude of TARGET
                   tcos,        #cos of lat of TARGET
                   flat,        #latitude of Interceptor
                   flon,        #longitude of Interceptor
                   fcos,        #cos of lat of Interceptor
                   RANGE,       #range (output)
                   BRNG)        #bearing (output) Tgt to Interceptor

call ang2PI(BRNG)                               # vice $ang2pi  8/21/85

unt$Type$i = Xunt$Type$i                        # get unit type
UNT2$Pointer$To  xRMT$Detectee$I                ## get target
UNT2$Type$I = xUNT2$Type$I                      # get target type

if (unt$Type$i != $Air$code)  # SPDMAX if unit type is NOT air jb new: 12/14/00
    {
    SPDMAX = Xunt$SPEED$I                       #get units max speed 

    if ((UNT2$Type$I == $SUB$Code) &            ## if target is a sub and
        (xUNT$Subtype$i != $Torpedo$SubCode))   ## attacker not a torpedo SMM 7/93 PER #E1176
        {
        if (iengaging == YES)                   ## and unit is engaging
            {                                   ## 11/23/83 tpa for wgmdmot
            SPDMAX = 15                         ## change units max speed
            iengaging = NO                      ## turn off engaging flag
            }                                   ## not to exceed 15 knots
        }
    }

###%%%%%%%%%%%%%% Revised intercept computation 7/31/84  %%%%%%%%%%%%%%%%%%%

# (0 aims at collision rather than weapons-range intercept)
RADIUS = 0.0

call RMIN_TO_TARGET(_
            RADIUS,             # Desig. intercept distance ( often, 0.)
            TCRS,               # (radians) course of TARGET        real
            TSPD,               # (knots)   speed  of TARGET        real
            SPDMAX,             # (knots)   speed  of INTERCEPTOR   real
            RANGE,              # (n.mi.) Initial rng between units real
            BRNG,               # (radians) init. brg FROM tgt TO INTERCEPTOR
            RTIM )    # RETURNED value (min.) elapsed time to reach RADIUS

longtime = 12           # 12 hrs for non-aircraft units...         12/9/86
if(RTIM > 2*$Minutes$Per$Hour & unt$Type$i==$Air$code) #a/c interceptor? 4/12/01
 {
  longtime =  2    #...but only 2 hr for aircraft           jb (Ctest)   4/12/01
  RTIM     = -7.0       #   Flag no intercept for longtime         12/9/86 
 }

rcan = RTIM     # -7, -3, -1, 0, OR minutes to intercept        2/24/86

if ( RTIM > model$interval ) # 1st typical case:  find Intercept Point; then Heading..
 {
  xlat = tlat                   # Target initial latitude
  xlon = tlon                   # Target initial longitude
  xcos = tcos                   # cos of tgt init. latitude

  prng = tspd * RTIM * $Hours$Per$Minute    # Tgt travel to intercept point
  call RRB2LL( _        # Find Lat/Long of the Intercept-Point
                   xlat,        #TGT latitude -> Intercept Latitude
                   xlon,        #TGT longitude -> Intercept Long.
                   prng,        #range (input) to Intercept Point
                   0.0,         #relative bearing (input)
                   tcrs,        #TGT heading (input)
                   xcos)        #cosine of TGT latitude (old and new)

  call RLL2RB( _        #Find Interceptor Heading & Distance TOGO
                   flat,        #latitude of INTERCEPTOR
                   flon,        #longitude of INTERCEPTOR
                   fcos,        #cos of lat of INTERCEPTOR
                   xlat,        #latitude of Intercept Point
                   xlon,        #longitude of Intercept Point
                   xcos,        #cos of lat of Intercept Point
                   TOGO,        #(output) range TOGO to intercept point
                   HDNG)        #(output) HDNG of Interceptor to "  "
  call ang2PI(HDNG)     #  adjust HDNG within 0 to 2PI/vice $ang2PI  8/21/85


###############################################################
## jb  Perhaps-to-be-removed also? (see IWORD, below..  12/14/00
##   (because the IWORD requirement would have prevented execution
##   unless the call had been to the (old) vector_ENTRY).
## jb BUT in view of remark below implying that this message used to be
##    "cannot TAKE"  OR  "cannot PAIR", then changed to "cannot INTERCEPT",
##  the logic stays and applies to both cases          # 12/18/00 

  if (UNT2$Type$I == $AIR$CODE         |
      UNT2$Type$I == $CRUISEMISSILE$CODE) 
    {
    unt$InterceptTime$f = game$time + MAX(0.,RTIM)

    # If aircraft too slow to get target, send message
    if (Tail$Chase + game$time < unt$InterceptTime$f) # jb      12/18/00
      {
      #"xxxxx can not intercept xxxxx."
      #"  Intercept time (xxxxxxZ) exceeds tailchase limit (xx min)."
      jj = 0
      call smovhn (xunt$Name$c,$$MaxLit,nmsg1,jj)
      call smovv (" can not intercept ",nmsg1,jj)   # was "can not take" or
      call smovhn (ILEX[2],$$MaxLit,nmsg1,jj)       # "can not pair" - joa 7/96 (E1500)
      call smovv (".",nmsg1,jj)
      call send_  (xUNT$View$I,0,jj,nmsg1)
      jj = 0
      call smovv  ("  Intercept time (",nmsg1,jj)
      call smoviz (Game_DTG(UNT$InterceptTime$F),6,nmsg1,jj)
      call smovv  ("Z) exceeds tailchase limit (",nmsg1,jj)
      call smovi  (Tail$Chase,nmsg1,jj)
      call smovv  (" min).",nmsg1,jj)
      call send_   (unt$View$i,0,jj,nmsg1)

      RETURN    # jb        12/18/00
      }     # end if (Tail$Chase + game$time <= unt$InterceptTime$f)
    }    # end if AIR or CRUISEMISSILE
##------ jb End of Perhaps-to-be-removed also? (see IWORD, above  12/14/00
#####################################################################

  UNT$RangeToNext$F   = TOGO
  UNT$OrderedCourse$F = HDNG
  PUTUNT$OrderedSpeed$F (SPDMAX) # Store interceptor speed /moved up 8/21/85
 }      # End of 1st typical case, with RTIM > 0

else if (RTIM == -1.0)  #(nb: CAN set above) 2nd typical case:NO INTERCEPT...
 {
  RETURN                #               Too SLOW to intercept.. 2/24/86
 }

else if (RTIM == -7.0)  #(nb: CAN set above) Marginal case; seldom to be seen..
 {
  kq = 0                                                #       12/9/86
  call smovv (" No Intercept in next ",nmsg1,kq)        #       12/9/86
  call smovi (longtime,nmsg1,kq)                        #       12/9/86
  call smovv (" hours.  Range is now ",nmsg1,kq)        #       12/9/86
  call smovi (INT(range),nmsg1,kq)                      #       12/9/86
  call smovv (" nmi.",nmsg1,kq)                         #       12/9/86
  call send_  (Xunt$VIEW$i,0,kq,nmsg1)                   #       12/9/86
  RETURN
 }  

else    # (RTIM = -3 or 0)<<<>>> Already within weapon range, or
 {      # within 30 seconds... Note: if IRADIUS=0, now NEAR! target..
  rcan = 0.              # RESET flag to indicate 0 minutes      2/24/86
  RTIM = 0.

  UNT$RangeToNext$f   = RANGE   # approximate it as current range
  UNT$OrderedCourse$f =  tcrs   # in CLOSE formation with tgt       8/21/85
  PUTUNT$OrderedSpeed$F (tspd) # match intrcptr speed to tgt<<<>>>  8/21/85
 }


unt$InterceptTime$f = game$time + MAX(0.,RTIM) # MAX       8/21/85 
PUTunt$InterceptTime$f

PUTUNT$RangeToNext$F            # As computed in cases above,
$ang2pi(UNT$OrderedCourse$F )   # jb                            1/2/01
PUTUNT$OrderedCourse$F          # wherein (RTIM > 0)  or  (RTIM = -3 or 0)

##Following message tentatively inserted 3/18/83:
kq = 0
call smovhn (xUNT$Name$C,$$MaxLit,nmsg1,kq)
call smovv (" Vector to ",nmsg1,kq)
iq1  = (UNT$OrderedCourse$F * Deg$Per$Rad) + 0.5
call smoviz (iq1,3,nmsg1,kq)

call smovv  (" SPD ",nmsg1,kq)
iq2 = max(SPDMAX, 2.0) +0.5                             #       7/31/84
call smovi  (iq2,nmsg1,kq)

call smovv (" to travel ",nmsg1,kq)
#iq3 = (UNT$RangeToNext$F -RADIUS)   + 0.5     
iq3 = max(0, int(UNT$RangeToNext$F + 0.5))  # SMM 6/4/93 range was not displayed
call smovi (iq3,nmsg1,kq)                   # correctly if radius >0 

call smovv (" NMI in ",nmsg1,kq)
JTIM = MAX(0.,RTIM)                                      #       8/21/85
call smovi  (JTIM,nmsg1,kq)                             #       8/21/85
call smovv  (" min.",nmsg1,kq)

call send_ (Xunt$VIEW$i,0, kq,nmsg1)

return
end




Subroutine OSPLIT (nord,        # Receive order number.
               unt2$pointer,    # Receive addressee pointer.
               iword,           # Receive word count.
               ilex,            # Receive command string.
               itimes,          # Receive count of flights.
               inumber,         # Receive count of a/c.
               iunit)           # Return new flight's UNT pointer.
################################################################################
#$%
#$% Purpose:    OSPLIT processes split commands to split airborne flights
#$%             into more than one flight.
#$%
#$% Called By:  EXEORD
#$%
#$% Calls:  MOVEXP_SPLIT
#$%
#$% Tables: ACC AML UNT
#$%
#$% Date:   March 24, 1992
#$%
#$% Author: Susan Miller Taken from AWSIMS code and 
#$%         modified for air-to-air enhancements
#$%
#$% Modified:  Carol Kropp - 10/94
#$%            Added call to Record_C2_Flight_Split
#$%            for update of the mission history data
#$%            (WPC C2 Interface).
#$%
#$%            Carol Kropp - 8/95 (E1481)
#$%            After the new unit's values are duplicated, need to clear
#$%            the ATTACK command fields (MultipleTarget & AttackedTarget).
#$%
#$%            Carol Kropp - 12/95 (E1469)
#$%            When the unt entry is duplicated, clear the sorn number.
#$%
#$%            Carol Kropp - 12/96 (E1726)
#$%            Record_C2_Flight_Split changed to Record_Flight_Split.
#$%
#$%            James O. Allen - 11/02 (E2313)
#$%            Change successful splitoff message to new flight side number is
#$%
################################################################################

BBCommon

integer INUMBER,ITIMES,NORD,IWORD,
        UNT2$Pointer, UNT2$View$I,
        UNT2$Nbractot$I, UNT2$Nbrac$I,
        UNT$Pointer, UNT$Amlindx$I,
        UNT$Origfltindx$I, UNT$Nbrac$I,
        UNT$Nbractot$I, AML$Pointer,
        AML2$Pointer, AML2$Nextindx$I,
        DEQ$Pointer, DEQ$Nextdeq$I,
        DEQ2$Pointer                            # MJC 5/2/2000 (E2145)
literal UNT2$Name$C,
        UNT$Name$C,
        CSTRIP8                                 # MJC 5/4/2000 (E2145)
literal ILEX[$stk$lastarg]

integer acrft_for_split,# nbr of a/c needed to perform split
        acrft_left,     # nbr of a/c left in old flight
        nbr_in_flt,     # nbr of a/c for each new flight
        iflights,       # nbr of new flights
        iopen,          # count of open slots in UNT
        icnt,           # count of a/c in AML
        iunit,          # holds UNT pointer to new flight
        Lunt[100],      # array containing UNT open slots, max of 100 flights
        jj,             # msg length
        k               # loop counter through nbr of new flights

real    Pcent       # percent of equipment remaining on old flight
Character msg[ARB]

# First make sure the unit is a flight of a/c and not awaiting launch
# or recovery.
unt2$Name$c = xunt2$Name$c
unt2$View$i = xunt2$View$i

If  (xunt2$Type$i != $Air$code)
    {
     #"XXXXX is not a flight.  Cannot perform split."
     jj = 0
     call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
     call smovv(" is not a flight.  ",msg,jj)
     call smovv("Cannot perform split.",msg,jj)
     call send_(unt2$View$i,0,jj,msg)    # formerly msg1
     return
    }

If  (xunt2$MarshallStatus$I != $InFlight$Code)
    {
     #"XXXXX cannot split.  Awaiting launch or recovering."
     jj = 0
     call smovhn (unt2$Name$c,$$MaxLit,msg,jj)
     call smovv  (" cannot split.  ", msg, jj)
     call smovv  ("Awaiting launch or recovering.",msg,jj)
     call send_   (unt2$View$i,0,jj,msg)    # formerly msg2
     return
    }

# If the flight is on a route and not reacting to attack (call made from 
# WGOP; inumber = 0), don't let him split.
If  (xunt2$RteIndx$i != 0 & inumber == 0)
    {
     #"XXXXX cannot split.  On a route."
     jj = 0
     call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
     call smovv(" cannot split.  On a route.",msg,jj)
     call send_(unt2$View$i,0,jj,msg)    # formerly msg9
     return
    }

acrft_for_split = 0
# If the call to this routine is from WGOP.rat, then inumber and itimes
# will both be zero.  If so, set nbr_in_flt and iFlights from the ILEX array.
if  (inumber == 0 & itimes == 0)
    {
    iFlights = ILEX[2]
    nbr_in_flt = ILEX[3]
    }
# else set nbr_in_flt and iFlights from iNumber and iTimes
else
    {
    iFlights = iTimes
    nbr_in_flt = iNumber
    }
# compute acrft_for_split.
acrft_for_split = nbr_in_flt * iFlights

# If acrft_for_split is zero, then a zero was entered on the order.  
# Display error message and return to calling routine.
If (acrft_for_split == 0)
    {
     #"XXXXX cannot split.  A zero was put in the order."
     jj = 0
     call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
     call smovv(" cannot split.  ",msg,jj)
     call smovv("A zero was put in the order.",msg,jj)
     call send_(unt2$View$i,0,jj,msg)    # formerly msg5
     return
    }

# Make sure that only 100 or less new flights were requested.
if  (iFlights > 100)
    {
     #"XXXXX cannot split off more than 100 flights."
     jj = 0
     call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
     call smovv(" cannot split off more than 100 flights.",msg,jj)
     call send_(unt2$View$i,0,jj,msg)  # formerly msg7
     return
    }

# Now, find out how many are in the flight and determine if it can be
# split the number of times requested.
unt2$NbrAcTot$i = xunt2$NbrAcTot$i  # number of a/c in attackers flight
if (unt2$NbrAcTot$i <= acrft_for_split)
    {
     #"XXXXX cannot split that # of times, not enough a/c in the flight."
     jj = 0
     call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
     call smovv(" cannot split that # of times, ",msg,jj)
     call smovv("not enough a/c in the flight.",msg,jj)
     call send_ (unt2$View$i,0,jj,msg)  # formerly msg3
     return
    }

# OK, we have enough aircraft.  Now make sure there's enough room in
# the UNT table.
iopen = 0
FOR_ALL_VALID (UNT)                     # loop through all the UNT entries
    {
     # if slot is not in use
     if (xunt$InUse$i == 0)
        {
         # Increment the number of open slots 
         iopen = iopen + 1
         # store the address in the Lunt array 
         Lunt[iopen] = unt$pointer
         # if the number of requested flights is greater than the number
         # of open slots in the unt table break out of loop
         if (iopen == iFlights) break  
        }   # end if unt slot in use
     }  # end of loop through unt table

# If iopen is less than iFlights, then we went thru the whole table
# without finding enough open slots.
if (iopen < iFlights)
   {
    #"XXXXX cannot split.  Not enough room in UNT."
    jj = 0  
    call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
    call smovv(" cannot split.  Not enough room in UNT.",msg,jj)
    call send_(unt2$View$i,0,jj,msg)   # formerly msg4
    return
   }

# if we are here, there are enough slots free for the number of requested a/c
# re-calculate unt$used
if (unt$last < unt$pointer)
   {
    # compute number used
    unt$used = unt$pointer$index * unt$entry
   }

# Now start splitting the flight.  The following code must
# be executed for each new flight.  
for (k=1; k <= iFlights; k=k+1)
    {
     unt$pointer = Lunt[k]  # get the unt pointer

     # duplicate entries in UNT table
     unt$duplicate$unt2

     # reset the AML pointers for the old flight and save the pointer 
     # to the new flight
     aml$pointer = 0            # initialize 
     aml2$pointer = 0
     aml2$NextIndx$i = xunt2$AmlIndx$i

     # calculate number left in old flight
     acrft_left = (xunt2$NbrAcTot$i - nbr_in_flt)

     # zero counter
     icnt = 0

     # Loop thru AML until we've got the right number of a/c left in the
     # old flight.
     while (aml2$NextIndx$i != 0)
           {
            # save last AML pointer
            aml$pointer = aml2$pointer                  

            # set next index
            aml2$pointer$to aml2$NextIndx$i
            aml2$NextIndx$i = Xaml2$NextIndx$i

            # increment counter
            icnt = icnt + 1

            if (icnt == acrft_left)
               {
                # this is the pointer to the new flight's leader
                aml$pointer$to aml2$nextindx$i

                # the old flight cuts off here now
                aml2$nextindx$i = 0
                putaml2$nextindx$i
               } # end if icnt == acrft_left
           } # end while aml2$NextIndx$i != 0

     # put callsign of lead a/c
     unt$Name$c = xaml$SideNumber$c
     putunt$Name$c

     # set first LCL index to zero
     putunt$FirstLclIndx$i (0)

     # set number of aircraft system failure to zero
     PUTunt$NbrAcSF$i ( 0 )

     # set under attack flag to zero for the call from AIR_REACT
     putunt$UnderAttack$i (0)

     # put AML index
     unt$AmlIndx$i = aml$pointer$index
     putunt$AmlIndx$i

     # save the original flight index for use in routine all_gone
     UNT$OrigFltIndx$I = unt2$pointer$index
     putUNT$OrigFltIndx$I

     putUNT$MultipleTarget$I ($no)      # clear the ATTACK command values,
     putUNT$AttackedTarget$I ($no)      # no command is in the orders queue
                                        # clk 8/95 (E1481)
     #$% ALSP            clk 6/2/92
     putUNT$ALSPid$I  (0)            # clear the ALSP id number of original fligh
     #$% end ALSP

     putUNT$JTIDSsorn$I (0)   # clk 12/95 (E1469)

     # reset nbr of equipment items, value gets set below SMM 4/12/93
     putUNT$NbrEQ$i (0)

     FOR_DEQ2_CHAIN               # need to build DEQ list for new flight
        {                         # it should be identical to original flight
         if ( xDEQ2$Ident$i != $null )
           {
            call get_deq_entry( Unt$pointer, DEQ$Pointer )

            if ( DEQ$Pointer == 0 ) break   # are we out of DEQ entries yet ??

            deq$NextDEQ$i = Xdeq$NextDEQ$i  # save DEQ link
            DEQ$Duplicate$DEQ2              # duplicate what we had 
                                            # NOTE: AIREXP will clean up Qtys
            PUTdeq$NextDEQ$i                # restore DEQ link
        
           } # end IF non-null ident
        } # end FOR DEQ2 Chain

     # compute percentage of equipment left on old flight
     Pcent = 1.0 - (nbr_in_flt * (1.0/xunt2$NbrAcTot$i))

     call MOVEXP_SPLIT (unt2$pointer,unt$pointer,pcent)

     # put number of a/c in flight
     unt$NbrAc$i = nbr_in_flt
     putunt$NbrAc$i

     # put nbr of a/c requested
     unt$NbrAcTot$i = nbr_in_flt
     putunt$NbrAcTot$i
     
     # set flag that flight has split
     putunt$SplitFlag$i ($yes) 
    
     # update old flight
     unt2$NbrAc$i = acrft_left
     putunt2$NbrAc$i
     unt2$NbrAcTot$i = acrft_left
     putunt2$NbrAcTot$i

     call Record_Flight_Split (UNT2$Pointer, nbr_in_flt, UNT$Pointer)

     #"XXXXX has been split.  New flight side number is XXXXX."
     jj = 0
     call smovhn(unt2$Name$c,$$MaxLit,msg,jj)
     call smovv(" has been split.  New flight side number is ",msg,jj)
     call smovhn(unt$Name$c,$$MaxLit,msg,jj)
     call smovv(".",msg,jj)
     call send_ (unt2$View$i,0,jj,msg)
    } # end for k <= iFlights

# If inumber is not equal to zero, the call was from AIR_REACT.
# Save unt$pointer in iunit and pass it back to Air_React.
if (inumber != 0) iunit = unt$pointer

return
end # end of OSPLIT


Subroutine OCAP (ionum,         # Receive order number.
                 unt$pointer,   # Receive addressee pointer.
                 nargs,         # Receive number of arguments.
                 ilex,          # Receive command string.
                 id)            # Receive order id number.
################################################################################
#$%
#$% Purpose:    OCAP processes FOR <addressee> CAP commands.
#$%
#$% Called By:  EXEORD
#$%
#$% Calls:      FNDORD          DMS2RAD
#$%
#$% Tables:     ACC     ORD     UNT
#$%
#$% Date:       March 1992
#$%
#$% Author:     Carol L. Krop
#$%             Modified AWSIM code
#$%             file: wgopord.rat  routine: ocap
#$%             Modified variable names to fit RESA tables,
#$%             added cancelling of previous station,
#$%             messages to i/o terminal and additional checks.
#$%
#$%             James Allen - 12/97 (E1370)
#$%             Added call to clear_maneuver_all (replacing clearing of
#$%             various maneuver fields and flags).
#$%
################################################################################
BBCommon

integer   NARGS,ID,K,JJ,IONUM,
          ORD$Phase$I,
          ACC$Pointer,
          UNT$Pointer,
          UNT$Mission$I,
          UNT$Capaltitude$I,
          UNT$Caprange$I                # MJC 5/2/2000 (E2145)
real      UNT$Orderedspeed$F,
          UNT$Caplatitude$F,
          UNT$Caplongitude$F,
          DMS2RAD                       # MJC 5/2/2000 (E2145)
literal   CSTRIP8                       # MJC 5/4/2000 (E2145)
literal   ILEX[nargs]
Character msg[ARB]
integer   ord$pointer

call FNDORD (id,ord$pointer)    # find the order

if (ord$pointer != 0)           # if a valid order
 {
   if (xord$Phase$i == 0)       # if a valid multi-phase
     {
      k = xord$Sequence$i - xord$Count$i
      if (k == 0)
        ord$Phase$i = 0
      else
        ord$Phase$i = 1

      putord$Phase$i
     }
   else
     {
      if (xUNT$Status$i != $OnStation$code)
        return

      putord$Phase$i (0)    # clear the order
      return
     }
  }

if (xUNT$Type$i != $Air$code)
  return

# Make sure the unit is a flight with a defensive mission
UNT$Mission$I = xUNT$Mission$I
if (UNT$Mission$I == $AirDefense$code | UNT$Mission$I == $Cap$Code   |
    UNT$Mission$I == $Escort$code     | UNT$Mission$I == $Sweep$code |
    UNT$Mission$I == $SurveillanceCap$code)
  {
   call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)

   putUNT$Status$I       ($Proceeding$Code)

   if (xUNT$MarshallStatus$I == $Recovering$Code)    # if a/c is recovering
     putUNT$MarshallStatus$I  ($Inflight$Code)       # mark as inflight

   putUNT$AssignedCap$I  ($yes)    # Set assigned CAP flag in unit table

   #$% Get the position the a/c will CAP to if they can
   UNT$CapLatitude$F = DMS2RAD(ILEX[3])
   putUNT$CapLatitude$F

   UNT$CapLongitude$F = DMS2RAD(ILEX[4])
   putUNT$CapLongitude$F

   putUNT$OrderedLatitude$F  (UNT$CapLatitude$F)
   putUNT$OrderedLongitude$F (UNT$CapLongitude$F)

   UNT$CapAltitude$I = ILEX[5]        # CAP altitude
   putUNT$CapAltitude$I
   putUNT$OrderedAltDepth$I (UNT$CapAltitude$I)

   UNT$CapRange$I = ILEX[6]           # CAP cover range
   putUNT$CapRange$I

   ACC$Pointer = xUNT$AccPntr$I          # Proceed at VCRU
   UNT$OrderedSpeed$F = xACC$CruiseSpeed$I
   putUNT$OrderedSpeed$F
  }
else   # the unit does not have a defensive mission and cannot CAP
  {
   jj = 0
   call smovhn (xUNT$Name$C, $$MaxLit, msg, jj)     # put unit name in message
   call smovv  (" does not have a defensive mission - ", msg, jj)
   call smovv  ("not proceeding to CAP.", msg, jj)
   call send_   (xUNT$View$I, 0, jj, msg)              # send error message
  }

return
end     # end of OCAP



Subroutine OPAIR (ionum,        # Receive order number.
                  unt$pointer,  # Receive addressee pointer.
                  iword,        # Receive word count.
                  ilex,         # Receive command string.
                  id)           # Receive order id number.
################################################################################
#$%
#$% Purpose:    OPAIR processes PAIR commands and generates error messages.
#$%
#$% Called By:  EXEORD
#$%
#$% Calls:  GTACT            GTTRK_TMA           OACTIV 
#$%         SEND             SMOVH               VECTOR
#$%         Has_weapons      Chase_Target        FNDORD
#$%
#$% Tables: RMT UNT
#$%
#$% Date:   APRIL 80
#$%
#$% Author: Dana Wills
#$%         
#$% Modified: April 1992 by Susan Miller for Air-to-air enhancements
#$%           Sept. 1993 - Carol Kropp:  Added call to ostrike_posit
#$%           April 1995 - Carol Kropp:  E1393 - Reject PAIR if in hiding.
#$%           June 1995  - Susan Miller:  E1304 - added parameter to Take_track
#$%                                               and removed unused variable ichase 
#$%
#$%           Carol Kropp - 1/97 (E1731)
#$%           Added branch call for processing new DROP MINE command.
#$%
################################################################################

BBCommon
Take_common

integer ID,JJ,K,IONUM,
        RMT$Pointer,
        ORD$Pointer, ORD$Phase$I,
        UNT$Pointer, UNT$Mission$I          # MJC 5/2/2000 (E2145)
real    UNT$Brokeintercepttime$F            # MJC 5/2/2000 (E2145)
literal CSTRIP8                             # MJC 5/4/2000 (E2145)
character msg[ARB]
integer   msg_len
integer nuclear, iuseguns,
        attacker_unt_index,
        pair_or_take, iword
literal ILEX[iword]
logical Has_weapons            # logical function      clk 3/92
integer  dummy

dummy = 0

# Get the order.
call FNDORD (id,ord$pointer)

if (xUNT$Status$I == $Hiding$Code)
  {
   msg_len = 0
   call smovhn (xUNT$Name$C, $$MaxLit, msg, msg_len)
   call smovv  (" cannot engage while in hiding", msg, msg_len)
   call send_   (xUNT$View$I, 0, msg_len, msg)
   return
  }

if (ilex[1] == $lex$Strike$)    # FOR <addressee> STRIKE POSITION command
  {
   call ostrike_posit (ORD$Pointer, UNT$Pointer, iword, ilex)
   return
  }

# Get attacker's name, type and view.
unt$Name$C = xunt$Name$C
unt$Type$i = xunt$Type$i
unt$View$i = xunt$View$i

if (UNT$Type$i != $Air$code)
    {
     #"XXXXX can't perform ordered pair; only aircraft can accept that command."
     jj = 0
     call smovhn(unt$Name$c,$$MaxLit,msg,jj)
     call smovv (" can't perform ordered pair;",msg,jj)
     call smovv (" only aircraft can accept that command.",msg,jj)
     call send_ (unt$View$i,0,jj,msg)

     return
    }

unt$Mission$i = xunt$Mission$i
# alft missions will not PAIR because they are just
# delivering equipment and are not fighters OR bombers!
if (xunt$mission$i == $airlift$code)
    {
     #"xxxxx can't perform ordered pair; mission is ALFT."
     jj = 0
     call smovhn(unt$Name$c,$$MaxLit,msg,jj)
     call smovv (" can't perform ordered pair; ",msg,jj)
     call smovv ("mission is ALFT.",msg,jj)
     call send_ (unt$View$i,0,jj,msg)

     if (ord$pointer != 0)         
        {                          
         #$% clear the order
         ord$Phase$i = 0
         putord$Phase$i 
        }

     return
    }

# If the attacker is a flight, he must have a defensive
# mission to take a manual pairing against an air track.
if (unt$Mission$i != $AirDefense$code & 
    unt$Mission$i != $CAP$code        &
    unt$Mission$i != $StrikeCAP$code  &
    unt$Mission$i != $Escort$code     & 
    unt$Mission$i != $Sweep$code      & 
    unt$Mission$i == $tasmo$code)
    {
     #"XXXXX can't accept manual pair; not on a defensive mission."
     jj =  0
     call smovhn(UNT$Name$c,$$MaxLit,msg,jj)
     call smovv (" can't accept manual pair; ", msg, jj)
     call smovv ("not on a defensive mission.", msg, jj)
     call send_ (UNT$View$i,0,jj,msg)
  
     #$% clear the order
     if (ord$pointer != 0)    
        {                     
         ord$Phase$i = 0
         putord$Phase$i 
        }
        
     return
    }

# The following block of code holds the order on the stack until
# completion if the order is part of a flight plan.
if (ord$pointer != 0)                           # Is this a multi-phase order?
   {                                            #   YES
    if (xord$Phase$i == 0)
       {
        k = xord$Sequence$i - xord$Count$i

        if (k == 0) ord$Phase$i = 0
        else        ord$Phase$i = 1             # First time thru

        putord$Phase$i
       }
    else                                        # there yet?
       {
        if (xunt$AssignedTarget$i != 0) return    # No

        ord$Phase$i = 0                                 # Yes.....
        putord$Phase$i                                  # clear the order

        return
       }
   }

# If the attacker is a flight, make sure he's ready to accept orders.
# If he broke intercept and is still reforming his flight, then don't
# allow orders yet.
if (unt$Type$i == $Air$code)
    {
    unt$BrokeInterceptTime$f = Xunt$BrokeInterceptTime$f
    if ((unt$BrokeInterceptTime$f > 0.) &
        (unt$BrokeInterceptTime$f + PSI$Hold  > game$time))
        {
        #"xxxxx can't accept pair, still reforming flight."
        jj = 0   
        call smovhn(unt$Name$c,$$MaxLit,msg,jj)
        call smovv (" can't accept pair, still reforming flight.",msg,jj)
        call send_  (unt$View$i,0,jj,msg)

        return
        }
    }

# in case the 'attacker' has NO WEAPONS.
if (!Has_weapons (UNT$Pointer))
    {
    putunt$RulesOfEngage$i ($IfAttacked$code)

    #"xxxxx can't perform ordered pair; out of weapons."
    jj = 0
    call smovhn(unt$Name$c,$$MaxLit,msg,jj)
    call smovv (" can't perform ordered pair; out of weapons.",msg,jj)
    call send_  (unt$View$i,0,jj,msg)

    return
    } # End of block of code for no weapons.

# Set attacker's UNT pointer and save UNT index.
attacker_unt_index = unt$pointer$index

pair_or_take = $pair_command_issued
Nuclear  = $NO
IuseGUNS = $NO  

call Take_track (UNT$Pointer, id, ILEX, Nuclear,IuseGUNS,
                 RMT$Pointer, pair_or_take, iword, dummy)

return
end # end of OPAIR


Subroutine Check_CAP_intercept(_
                          UNT$Pointer,  # Receive addressee pointer
                          RMT$Pointer,  # IN: to yield tgt UNT2 index
                          ILEX,         # Receive order
                          max_missile_range,    # receive
                          rcan,         # Receive flag for interceptable
                          pair_or_take, # Receive type of command
                          message_sent, # RETURN yes/no to Engage_Track
                          iword)        # Receive # of words in ILEX

# In this 11/9/00 version of CHECK_CAP_INTERCEPT, the message-sent argument
# could be eliminated.  It's hard-coded to YES by the calling program, and
# always returned here as YES (and Vector_Entry is no longer called here).
################################################################################
#$%
#$% Purpose: Check_CAP_intercept responds to TAKE and PAIR commands for a/c
#$%     assigned to CAPstation.  It computes what the minutes-to-intercept
#$%     would be, were the command to be accepted; then projects the target's
#$%     vector by those minutes, to see whether the intercept-point would be
#$%     within the CAP's arena (see NOTICE, below).  If not, the command is
#$%     rejected, with a suitable message.  If so, an acceptance message is
#$%     sent and a number of fields are inserted into the UNT table:
#$%    UNT$RangeToNext$F        UNT$OrderedCourse$F
#$%    UNT$OrderedSpeed$F       unt$InterceptTime$f
#$%    unt$assignedtarget$i     unt$attackindx$i    unt$OrderedAltDepth$I
#$%
#$%     NOTICE:  Here, the time-solution is 2-dimensional; that is, it doesn't
#$%     check to see whether it might take longer to climb/dive than it will
#$%     to reach geographic intercept.  This is mandatory in GET_CAP_TARGET;
#$%     but for simplicity here, the CAP's arena is restricted somewhat, to
#$%     reduce the chance that the interceptor may wander too far and be jerked
#$%     back by the logic in PROC_CAP.  jb  1/23/01
#$%
#$% Called By:  Engage_track
#$%
#$% Calls:      RRB2LL  RLL2RB  RMIN_TO_TARGET     # jb     11/9/00
#$%             SMOVV   SMOVH   SMOVHN  SMOVI   SMOVIZ  SEND
#$%
#$% Tables:     UNT RMT
#$%
#$% Author:     Susan Miller
#$%
#$% Date:       July 1992
#$%
#$%   (Reorganized 11/9/00 to eliminate VECTOR_ENTRY call)  jbryant
################################################################################
BBCommon
Take_common # (BBdeclare UNT$Name$c,UNT$View$I,UNT$Type$I)

integer   iword 
literal   ILEX[iword]
literal   CSTRIP8                       # MJC 5/4/2000 (E2145)
real      rcan  # This 'interceptible' input flag comes hardcoded to YES.
                # Logic here 'knows' this (implicitly)  # jb    11/9/00 
real      UNT$Rangetonext$F,    UNT$Intercepttime$F,
          UNT$Orderedcourse$F,  UNT$Orderedspeed$F,
          Rng_Center_to_Intcpt_Pt,                      # jb E2145    11/8/00
          RANGE_BTWN_CAP_TARGET, # jb nmi, TGT <--> CAP a/c  E2145    11/8/00 
          TGT_travel,  # jb (nmi) tgt travel to intercept pt E2145    11/8/00 
          dummy,         # jb  E2208 (for RLL2RB call)   9/27/00
        UNT2$TrueLatitude$F,UNT2$TrueLongitude$F,    # jb tgt   11/7/00
        UNT$TrueLatitude$F,UNT$TrueLongitude$F,   # jb intrcptor 11/7/00
        UNT$CAPLatitude$f, UNT$CAPLongitude$f  # jb CAPstation center 11/9/00 
real      xlat,  #TGT latitude -> Intercept Latitude # jb E2145 11/8/00
          xlon,  #TGT longitude -> Intercept Long.   # jb E2145 11/8/00
          intercept_lat, intercept_long, time_of_intercept,spdmax
real      UNT2$TrueCourse$F,UNT2$TrueSpeed$F         # jb 11/9/00
real      extension /0.0/  # jb (To add to UNT$CAPrange$I to define 'arena')
real      cos_lat                        # jb E2145  (for RRB@LL call) 02/5/01
integer   UNT$Pointer,UNT$CAPrange$I,
          UNT$USEORDSPEED$I, # jb AAI01: Specified-spd flag for INTCPT 5/22/01
          RMT$Pointer, RMT$Detectee$I, ACC$Pointer, # jb    12/27/00
          ACC$LoiterSpeed$I,ACC$VectorSpeed$I,      # jb    12/18/00
          pair_or_take, jj, max_missile_range,
          max_speed,    # Interceptor speed-to-be-assigned
          message_sent, int_course, int_time, int_range
REAL      tgt_to_CAP_BRG              # jb REAL   12/21/00
Integer   UNT2$Pointer                # jb    11/9/00       
character msg[ARB]

message_sent = $NO  # jb initialize to signal ENGAGE_TRACK to 
                    #      PROCEED w/ INTERCEPT   12/26/00
                    # (not mandatory: should be set to $YES below)
#########------------------------------------------------------
#$% Step 1: Get interceptor speed for call to RMIN_to_Target: jb 11/7/00

RMT$Detectee$I = xRMT$Detectee$I           # jb 12/27/00
UNT2$Pointer$TO (RMT$Detectee$I)           # jb 11/7/00
UNT2$TrueCourse$F = xUNT2$TrueCourse$F 
UNT2$TrueSpeed$F  = xUNT2$TrueSpeed$F 

#$% Vector_Entry's determination of speed: (but NOT loiter, unless a PAIR-
#$% specified speed is LESS than loiter).)
ACC$Pointer = xUNT$AccPntr$I                 # jb AAI01:  5/22/01

ACC$LoiterSpeed$I = xACC$LoiterSpeed$I      # jb  12/7/00
ACC$VectorSpeed$I = xACC$VectorSpeed$I      # jb  12/21/00
Unt$USEORDSPEED$I = $NO   # jb  Initialize to speed-NOT-specified  5/22/01

    #$%  Jb (If order was PAIR, a speed may have been specified:
spdmax = real(ACC$VectorSpeed$I)  # jb Replaces ELSE deleted below 11/9/00
if (iword > 2)
{
    if (ilex[3] == $lex$Speed$)
    {
        spdmax = MAX (real(ilex[4]), real(ACC$LoiterSpeed$I) ) # jb real 5/22/00
        spdmax = MIN (spdmax,   real(ACC$VectorSpeed$I) )   # jb      12/7/00
        Unt$USEORDSPEED$I = $YES   # jb Specified-speed Flag for INTCPT 5/22/01
    }      # jb at most, VECTOR vice MAX speed          # jb      12/7/00 
}               
#########------------------------------------------------------
#$% Step 2:  Get interceptor-to-tgt range & brg for RMIN_to_Target jb 11/7/00 

UNT2$TrueLatitude$F = xUNT2$TrueLatitude$F      # target 11/7/00
UNT2$TrueLongitude$F = xUNT2$TrueLongitude$F    # target 11/7/00

UNT$CAPrange$I      = xUNT$CAPrange$I       # frm station center
UNT$CAPLatitude$f   = xUNT$CAPLatitude$f    # Cap Station
UNT$CAPLongitude$f  = xUNT$CAPLongitude$f   # Cap Station
UNT$TrueLatitude$F  = xUNT$TrueLatitude$F   #   CAP
UNT$TrueLongitude$F = xUNT$TrueLongitude$F  #   CAP

Call RLL2RB( _                 #Rhumb line Lat/Lon to Range/Bearing
       UNT2$TrueLatitude$F,    #latitude of target
       UNT2$TrueLongitude$F,   #longitude of target
       COS(UNT2$TrueLatitude$F),    #cos of lat of target
       UNT$TrueLatitude$F,      # latitude of interceptor
       UNT$TrueLongitude$F,     #longitude of interceptor 
       COS(UNT$TrueLatitude$F),      # cos (lat of interceptor)
       RANGE_BTWN_CAP_TARGET,       #  (nmi)     (OUTPUT)
       tgt_to_CAP_BRG)              #  (radians) (OUTPUT)
    $ang2pi(tgt_to_CAP_BRG)                 # jb  12/21/00
#########------------------------------------------------------
#$% Step 3: Get # of minutes to intercept; sent msg if infeasible  jb  11/8/00

UNT$View$I = xUNT$View$I     # jb  11/8/00
unt$Name$c = Xunt$Name$c                # jb E2145      11/8/00

##   See computation of spdmax, above: now VectorSpeed; or, as ordered...

Call RMIN_TO_TARGET(_
       1.0,                       # intercept distance jb 0.5  1/11/01
       UNT2$TrueCourse$F,         # (radians) course of TARGET  real
       UNT2$TrueSpeed$F,          # (knots)   speed  of TARGET  real
       spdmax,              # (knots)   speed  of INTERCEPTOR   real
       RANGE_BTWN_CAP_TARGET, # (n.mi.) Initial rng between units real
       tgt_to_CAP_BRG,        # (radians) init. brg FROM tgt TO INTERCEPTOR
       time_of_intercept ) # RETURNED value: minutes to reach missile-range 

##  Flags to look for in returned value:
##    if time_of_intercept = -3.0  #  Flag; already within missile_range
##  # No solution if discriminant < 0.0:
##    if time_of_intercept = -1.0    # Return -1.0 as no-solution-flag
##    if time_of_intercept = -7.0    # Return -7.0 as long-long-time-flag

If (time_of_intercept == -1.0 | time_of_intercept == -7.0) # jb No intercept
    {                           # send a message
     #"xxxxx cannot PAIR/TAKE xxxxx.  Too far to intercept."
     jj = 0
     call smovhn (unt$Name$c,$$MaxLit,msg,jj)
     if (pair_or_take == $pair_command_issued)
     call smovv (" cannot pair ",msg,jj)
     else
         call smovv (" cannot take ",msg,jj)
     call smovhn (ILEX[2],$$MaxLit,msg,jj)
     call smovv (".  Too far to intercept.",msg,jj)
     call send_ (unt$View$i,0,jj,msg)    
     message_sent = $yes  # jb Signal ENGAGE_TRACK not to process.. 
     RETURN
    }

#########------------------------------------------------------
#$% Step 4: Compute Lat/Long of intercept point:              jb  11/8/00

If (time_of_intercept == -3.0)  # jb 12/26/00
    time_of_intercept = 0.0  

intercept_lat  = UNT2$TrueLatitude$F    # jb Momentarily, assume that
intercept_long = UNT2$TrueLongitude$F   #  TGT_travel is ZERO       jb 11/8/00

   #$% --but if TGT_Travel is NON-zero:
If (time_of_intercept > model$interval) # JOA 12/02 (E2317)
    {       ## compute NON-zero TGT_travel...                     jb 11/8/00  
    TGT_travel = (UNT2$TrueSpeed$F/60.0) * time_of_intercept # jb 11/8/00
    cos_lat =  COS(intercept_lat)                            # jb 02/5/01
    #$% ... And, compute new intercept_lat & _long           # jb 11/8/00
    call RRB2LL( _        # Find Lat/Long of the Intercept-Point
        intercept_lat,        #TGT latitude -> Intercept Latitude
        intercept_long,        #TGT longitude -> Intercept Long.
        TGT_travel,  # tgt's range (input) to Intercept Point
        0.0,         #relative bearing (input)
        UNT2$TrueCourse$F, #TGT heading (input)
        cos_lat )   #cos of latitude (Old, and New)  # jb   02/5/01
    }

#########------------------------------------------------------
#$% Step 5: Check intercept within 'arena':  send msg if not  jb 11/8/00

## At this point, we know the intercept position...But, is it perhaps
## outside the 'arena' of the CAP aircraft?  As of 11/9/00, we'll think
## of that arena as the circular area around the CAPstation center with
## radius equal to the CAPstation radius, extended by either:
## - MIN(max_missile-range,0.332 * CAPstation radius) (TAKE order; or,
##  -MIN(0.5 * max_missile-range,0.166 * CAPstation radius) (PAIR order)

#$%  Find the range from CAPstation center to the intercept point:
call RLL2RB (intercept_lat,  # send lat of intercept point  jb  11/8/00
    intercept_long,        # send long of intercept point
    COS(intercept_lat),
    UNT$CAPLatitude$f,    # send  CAPstation center latitude
    UNT$CAPLongitude$f,   # send  CAPstation center longitude
    COS(UNT$CAPLatitude$f),
    Rng_Center_to_Intcpt_Pt, # return range for check below
    dummy)                 # return bearing (not used?)      

#$% jb Noet: Extension reduced to allow for some climb time 1/23/01 
#$%  (Extension reduced by half for TAKE: & declared 0.0 for PAIR)
if (pair_or_take == $take_command_issued) 
    extension =    # jb (Assuming TAKE order)  12/21/00
         MIN ( 0.5 * Max_missile_range, 0.167 * UNT$CapRange$I)
 
IF(Rng_Center_to_Intcpt_Pt > (UNT$CapRange$I + extension)) # 11/9/00
    {
    #"xxxxx cannot PAIR/TAKE xxxxx.  Track not within CAP range."
    jj = 0
    call smovhn (unt$Name$c,$$MaxLit,msg,jj)
    if (pair_or_take == $pair_command_issued)
            call smovv (" cannot pair ",msg,jj)
    else 
            call smovv (" cannot take ",msg,jj)

    call smovhn (ILEX[2],$$MaxLit,msg,jj)
    call smovv (".  Track not within CAP range.",msg,jj)
    call send_ (unt$View$i,0,jj,msg)    
    message_sent = $yes  # Signal ENGAGE_TRACK not to process
    RETURN
    }

#########------------------------------------------------------
#$% Step 6: (Success) - (a) compute RANGEtoNEXT and ORDEREDcourse;
#$% then Put UNT variables. amd send intercept message 11/8/00

#$%  At this ELSE, intercept point is within the 'arena' and within the 
#$%  CAP aircraft's intercept capability

ELSE   # it is within the arena and can be intercepted
    {
        #$%  (a) Compute RANGEtoNEXT and ORDEREDcourse  jb 11/8/00
    Call RLL2RB( _          #Rhumb line Lat/Lon to Range/Bearing
        UNT$TrueLatitude$F,     #latitude of Interceptor
        UNT$TrueLongitude$F,    #longitude of Interceptor
        COS(UNT$TrueLatitude$F), #cos of lat of Interceptor
        intercept_lat,          # latitude of intercept point
        intercept_long,         # longitude of intercept point
        COS(intercept_lat),      # cos (lat of intercept point)
        UNT$RangeToNext$F,    #  (nmi)     (OUTPUT)
        UNT$OrderedCourse$F ) #  (radians) (OUTPUT)
    $ang2PI(UNT$OrderedCourse$F) # adjust if needed

        #$%  (b) Put UNT table fields:  jb 11/8/00
    putUNT$RangeToNext$F
    putUNT$OrderedCourse$F
    UNT$OrderedSpeed$F = spdmax
    putUNT$OrderedSpeed$F      # Store interceptor speed 
    unt$InterceptTime$f = game$time + MAX(0.,time_of_intercept)
    putunt$InterceptTime$f
    putunt$assignedtarget$i (RMT$Detectee$I)    # jb 12/27/00
    putunt$attackindx$i     (RMT$Detectee$I)    # jb 12/27/00
    putunt$OrderedAltDepth$I (Xunt2$TrueAltDepth$I) # jb 1/16/01
    PUTUNT$USEORDSPEED$I  # jb 0 or 1 (Flag for INTCPT)  5/22/01  

        #$% (c)  send intercept message:
        #"XXXXX vector to XXX SPD XXXX to travel XXX NMI in 
    jj = 0
    call smovhn (UNT$Name$C,$$MaxLit,msg,jj)
    call smovv (" Vector to ",msg,jj)
    int_course = int((UNT$OrderedCourse$F * Deg$Per$Rad) + 0.5)
    call smoviz (int_course,3,msg,jj)

    call smovv (" SPD ",msg,jj)
    max_speed = int(max(SPDMAX, 2.0) +0.5)
    call smovi (max_speed,msg,jj)

    call smovv (" to travel ",msg,jj)
    int_range = (UNT$RangeToNext$F - Max_missile_range) + 0.5
    int_range = max(0,int_range)                        
    call smovi (int_range,msg,jj)

    call smovv (" NMI in ",msg,jj)
    int_time = MAX(0.,time_of_intercept)
    call smovi  (int_time,msg,jj)                         
    call smovv  (" min.",msg,jj)

    call send_ (unt$VIEW$i,0,jj,msg)
    message_sent = $yes   # jb Signal Engage_Track NOT to RE-process..
    }                     #       since the job's done here..  

return
end  # of Check_CAP_intercept




Subroutine Change_view(_
                       UNT$Pointer,  # Receive addressee pointer
                       ILEX)         # Receive order
################################################################################
#$%
#$% Purpose:    Change_view changes the view of the addressee
#$%
#$% Called By:  OHANDO
#$%
#$% Calls:      
#$%
#$% Tables:     UNT 
#$%
#$% Author:     Susan Miller
#$%
#$% Date:       July 1992
#$%
#$% Modified:   Carol Kropp - 3/94
#$%             Check for a side change, in addition to the view change.
#$%
#$%             Susan Miller - 8/95 (E1454)
#$%             Allow for ghosted AEW a/c to be chopped to another view.
#$%             When a ghosted a/c is chopped it is flagged to make detections.
#$%
#$%             Susan Miller - 9/95 (E1453)
#$%             Allow for ghosted AIRTANKER or STTANKER to be chopped to 
#$%             another view in order to support airborne refuel.
#$%
################################################################################

BBCommon

character msg[ARB]
literal   ILEX[$max$args]
integer   jj, view, valid_view  
integer   old_side, new_side
integer   UNT$Mission$I

integer   UNT$Pointer,
          UNT$Ghostedunit$I,
          UNT$Sidechangedflag$I,
          UNT$Alspid$I,
          UNT$Alspchopped$I                 # MJC 4/2/2000 (E2145)
literal   UNT$Name$C,
          CSTRIP8                           # MJC 5/4/2000 (E2145)

view = 0
valid_view = $no
UNT$Name$C = xUNT$Name$C
UNT$GhostedUnit$I = xUNT$GhostedUnit$I
UNT$Mission$I = xUNT$Mission$I

if (ILEX[2] == $Lex$BLUE$)
    {   
     view = int(ILEX[3])
     view = view + $FirstBlue$View - 1
     # if view number is within valid ranges, then put it in table
     if (view >= $FirstBlue$View & view <= $LastBlue$View)
        valid_view = $yes
     new_side = $Blue$Code
    }
else if (ILEX[2] == $Lex$ORANGE$)
    {
     view = int(ILEX[3])
     view = view + $FirstOrange$View - 1
     # if view number is within valid ranges, then put it in table
     if (view >= $FirstOrange$View & view <= $LastOrange$View)
        valid_view = $yes
     new_side = $Orange$Code
    }
else # it must be $Lex$NEUTRAL$
    {
     # if view number is within valid ranges, then put it in table
     view = 1
     valid_view = $yes
     new_side = $Neutral$Code
    }
    
if (valid_view == $no)  # send a message to control
    {
     #"Cannot handover XXXXX to invalid BLUE/ORANGE view XX"
     jj = 0
     call smovv ("Cannot handover ",msg,jj)
     call smovhn (UNT$Name$C,$$MaxLit,msg,jj)
     if (ILEX[2] == $Lex$BLUE$)
         call smovv (" to invalid BLUE view ",msg,jj)
     else if (ILEX[2] == $Lex$ORANGE$)
         call smovv (" to invalid ORANGE view ",msg,jj)
     call smoviz (INT(ILEX[3]),2,msg,jj)
     call send_ ($Neutral$view,0,jj,msg)
    }
else # it is a valid view number for blue,orange or neutral
    {
     if (UNT$GhostedUnit$I != $Yes)   # if not a ghosted unit
        {
         call whside (xUNT$View$I, old_side)   # get the side the unit
         if (new_side != old_side)             # is currently on, and
           {                                   # if there is a change,
            UNT$SideChangedFlag$I = $yes       # flag it - clk 3/10/94
            putUNT$SideChangedFlag$I
    
            # NOTE:  This can be taken out when parital updates are completed - clk
            UNT$ALSPid$I = xUNT$ALSPid$I    # clk - 1/94
            if (UNT$ALSPid$I != 0)          # changing ownership is similar to a location
              {                             # change (update necessary)
#              $alsp_relocate_or_emitter_change = 2
               call alsp_update_dr_table (UNT$Pointer, UNT$ALSPid$I, 2)
              }
           }
        }   # end of if not a ghosted unit

     putUNT$View$I (view)
     #"Successful handover of XXXXX to BLUE X/ORANGE X/NEUTRAL"
     jj = 0
     call smovv ("Successful handover of ",msg,jj)
     if (UNT$GhostedUnit$I == $yes)       # SMM - 8/95 (E1454)
        {
         if (UNT$Mission$I == $AEW$Code)
             call smovv ("ghost AEW aircraft ",msg,jj)
         else if (UNT$Mission$I == $AirTanker$Code)
             call smovv ("ghost AIRTANKER aircraft ",msg,jj)
         else if (UNT$Mission$I == $STtanker$Code)
             call smovv ("ghost STTANKER aircraft ",msg,jj)
        }
     call smovhn (UNT$Name$C,$$MaxLit,msg,jj)
     call smovv (" to ",msg,jj)
     if (ILEX[2] == $Lex$BLUE$)
        {
         call smovv ("BLUE view ",msg,jj)
         call smoviz (INT(ILEX[3]),2,msg,jj)
        }    
     else if (ILEX[2] == $Lex$ORANGE$)
        {
         call smovv ("ORANGE view ",msg,jj)
         call smoviz (INT(ILEX[3]),2,msg,jj)
        }
     else 
        call smovv ("NEUTRAL",msg,jj)    
     call send_ ($Neutral$view,0,jj,msg)
     if (UNT$GhostedUnit$I == $yes)   # SMM - 8/95 (E1454)
        {
         UNT$ALSPChopped$I = $yes
         putUNT$ALSPChopped$I
         jj = 0
         if (UNT$Mission$I == $AEW$Code)
            {
             call smovv  ("Ghost AEW aircraft ",msg,jj)
             call smovhn (UNT$Name$C,$$MaxLit,msg,jj)
             call smovv  (" is now assigned to share track data.  ",msg,jj)
            }
         else 
            {
             if (UNT$Mission$I == $AirTanker$Code)
                 call smovv  ("Ghost AIRTANKER aircraft ",msg,jj)
             else if (UNT$Mission$I == $STtanker$Code)
                 call smovv  ("Ghost STTANKER aircraft ",msg,jj)
             call smovhn (UNT$Name$C,$$MaxLit,msg,jj)
             call smovv (" is now assigned to support",msg,jj)
             call smovv (" airborne refueling.  ",msg,jj)
            }
         call send_   (view, 0, jj, msg)
        } # ghosted units message
    }   # end of if/else a valid view number

return
end # of Change_view


Subroutine Ohide(IONUM, 
                 id,
                 UNT$POINTER, 
                 IWORD, 
                 ILEX) 
########################################################
#$%
#$% Purpose:   Ohide processes hide commands
#$%            and generates a message for errors.
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     SEND
#$%
#$% Tables:    UNT
#$%
#$% Date       6/92
#$%
#$% Author:    K. Chang
#$%
#$% Modified:  James Allen - 12/97 (E1370)
#$%            Added order id number to the argument
#$%            list for the clear_maneuer_all call.
#$%
########################################################
BBCommon

integer IWORD,JJ,IONUM,
        SHC$Pointer,
        UNT2$Pointer,
        UNT2$View$I,
        UNT$View$I,
        UNT$Pointer,
        UNT$Status$I,
        UNT$Hidestatus$I                    # MJC 5/2/2000 (E2145)
real    UNT$Orderedspeed$F,
        UNT$Orderedlatitude$F,
        UNT$Orderedlongitude$F              # MJC 5/2/2000 (E2145)
literal CSTRIP8                             # MJC 5/4/2000 (E2145)
integer id
literal ILEX[iword]
Character msg[ARB]
Integer Find_Unit
Integer ship_side, site_side

  unt$view$i = xunt$view$i
  if (unt$view$i < $FirstBlue$View)
    ship_side = $Neutral$Code
  else if (unt$view$i < $FirstOrange$View)
    ship_side = $Blue$Code
  else 
    ship_side = $Orange$Code

  unt2$pointer = Find_Unit (ilex[2])

  #$% If ilex[2] is in the UNT Table
  if (unt2$pointer != 0)
    {
     #$% If ilex[2] is a Hide Site
     if (xUNT2$SubType$I == $HideSite$SubCode)
       {
        unt2$view$i = xunt2$view$i
        if (unt2$view$i < $FirstBlue$View)
          site_side = $Neutral$Code
        else if (unt2$view$i < $FirstOrange$View)
          site_side = $Blue$Code
        else
          site_side = $Orange$Code

        #$% If the side of Hide Side is not same as the addressee
        if (ship_side ^= site_side)
          {
           jj = 0 
           call SMOVHN(ILEX[2],$$MaxLit,msg,jj)   
           Call SMOVV(" not found on Side of ",msg,jj)
           call SMOVHN(xUNT$NAME$C,$$MaxLit,msg,jj)   
           call SMOVV(".",msg,jj)
           call send_(unt$View$i,0,jj,msg)        
           return
          }

        unt$Status$I = xUNT$Status$I
        if (unt$Status$I != $Sinking$Code &
            unt$Status$I != $DeadInWater$Code &
            unt$Status$I != $UnderTow$Code)
          {
           call clear_maneuver_all (ionum, id, xUNT$View$I, UNT$Pointer)

           shc$pointer = Xunt$shcPntr$i
           UNT$OrderedSpeed$F = FLOAT(Xunt$Speed$i)  
           if (iword >= 4)              # E2231 joa 9/01
           {
               if (ilex[3] == $lex$speed$ & 
                   ilex[4] <= xUNT$Speed$I)              # set the given order speed
                 UNT$ORDEREDSPEED$F = ILEX[4]    
           }
           putUNT$OrderedSpeed$F   (UNT$OrderedSpeed$F)
           unt$orderedLatitude$F = xUNT2$TrueLatitude$F
           putUnt$orderedLatitude$F
           unt$orderedLongitude$F = xUNT2$TrueLongitude$F
           putUnt$orderedLongitude$F
           unt$HideStatus$i = $EnrouteToHide
           putUnt$HideStatus$i
           putUnt$HideSiteIndx$i (unt2$pointer$index)
          }
       }   # end of if (xUNT2$SubType$I == $HideSite$SubCode)
     else
       {
        #$% set up "ilex[2] is not a hide site" message
        jj = 0 
        call SMOVHN(ilex[2],$$MaxLit, msg,jj)
        call SMOVV(" is not a Hide Site.",msg,jj)
        call send_ (unt$view$i,0,jj,msg)
       }
    }    # end of if a valid hide unt2$pointer
  else
    {
     #$% set up "Cannot find ilex[2] on UNT Table" message
     jj = 0  
     Call SMOVV(" Cannot find ",msg,jj)
     call SMOVHN(ilex[2],$$MaxLit,msg,jj)
     call SMOVV(".",msg,jj)
     call send_ (unt$view$i,0,jj,msg)
    }

return
end        # End  Ohide


subroutine ostrike_posit (ORD$Pointer,  # in:  order ORD pointer
                          UNT$Pointer,  # in:  Unit UNT pointer
                          iword,        # in:  number of arguments of ilex
                          ilex)         # in:  order command string
################################################################################
#$%
#$% Purpose:     OStrike_Posit processes the STRIKE POSITION command.
#$%              This causes an aircraft to attack a position with ASMs
#$%              and Bombs - no damage is assessed within RESA.
#$%              FOR <addressee> STRIKE POSITION <lat> <long>
#$%                              [ | SPEED <knots> ]
#$%                              [ | TARGET target_type] ]
#$%                              [ | TIN <tin-number> |
#$%                                  BE  <be-number> [ | TIN <tin-number>] ]
#$%
#$% Called By:   OPair
#$%
#$% Calls:       FNDORD       SMOV..      SEND
#$%              DMS2RAD
#$%
#$% Tables:      UNT
#$%
#$% Date:        Sept. 9, 1993
#$%
#$% Author:      Carol L. Kropp
#$%
#$% Modified:    Carol Kropp - 2/94
#$%              Added optional entry of target specification for CBS.
#$%              The entered TARGET maps to 1-3 ALSP TARGET enumerations.
#$%
#$%              Carol Kropp - 9/94   (E1330)
#$%              The messages were being loaded into variables that were
#$%              never declared, causing the calls to smov.. to crash
#$%              occasionally.  Also changed routine arguments, so that
#$%              the caller sends in the ORD$Pointer, rather than the order
#$%              number and id.
#$%
#$%              Carol Kropp - 6/95 (E1419)
#$%              Added optional entry of BE and TIN information (TMS Interface).
#$%              Changed the way the subroutine looks at arguments after the
#$%              position entry to a loop (SPEED, TARGET, TIN, or BE).
#$%
#$%              James Allen - 12/97 (E1370)
#$%              Added call to clear_maneuver_all (replaces clearing of
#$%              various maneuver related flags and fiels in the UNT table).
#$%
################################################################################
BBCommon

integer  ORD$Pointer, UNT$Pointer, iword
literal  ilex[iword]

integer  target_priority_code    # integer function

integer    number_eq, eqlist[5,30]
integer    max_range, i, shortest_range
integer    minordlen
integer    find_agd_slot
real       range, bearing, prng
real       standoff_range, fcos
integer    current_arg_index       # index to current key-word argument of ilex
integer    msg_len
character  msg[ARB]
literal    blank_word

integer    K, kk,
           ORD$Phase$I,
           ACC$Pointer,
           UNT$Type$I,
           UNT$View$I,
           UNT$AGDIndex$i,
           UNT$Targettype$I,                        # MJC 5/2/2000 (E2145)
           UNT$EngageStatus$I 
real       UNT$Brokeintercepttime$F,
           UNT$Orderedlatitude$F,
           UNT$Orderedlongitude$F,
           UNT$Targetlatitude$F,
           UNT$Targetlongitude$F,
           UNT$Orderedspeed$F,
           UNT$Assumedlatitude$F,
           UNT$Assumedlongitude$F, DMS2RAD          # MJC 5/2/2000 (E2145)
literal    UNT$Name$C,
           CSTRIP8                                  # MJC 5/4/2000 (E2145)
BBDeclare  (agd$pointer,agd$alspid$i)

# Error messages
# "xxxxx cannot strike a position - mission is ALFT"
# "xxxxx cannot strike position - still reforming flight"
# "xxxxx has no ASM or BOMB weapons - cannot perform ordered strike"
# "xxxxx striking position xx-xx-xxh xxx-xx-xxh"

  UNT$Name$C = xUNT$Name$C
  UNT$Type$I = xUNT$Type$I
  UNT$View$I = xUNT$View$I

  if (xUNT$Mission$I == $AirLift$Code)
    {
     msg_len = 0
     call smovhn (UNT$Name$C, $$MaxLit, msg, msg_len)
     call smovv  (" cannot strike a position - mission is ALFT", msg, msg_len)
     call send_   (UNT$View$I, 0, msg_len, msg)

     ORD$Phase$I = 0           # clear the order
     putORD$Phase$I
    }
  else        # Aircraft does not have an Airlift mission
    {
     #$% Hold the order until completion if the order is part of a flight plan.
     if (ORD$Pointer != 0)
       {
        if (xORD$Phase$I == 0)
          {
           k = xORD$Sequence$I - xORD$Count$I
           if (k == 0)
             ORD$Phase$I = 0
           else # First time thru
             ORD$Phase$I = 1
           putORD$Phase$I
          }
        else   # the order phase is NON-Zero
          {
           # if the engagement is over, clear the ORD$Phase
           
           UNT$EngageStatus$I = xUNT$EngageStatus$I 
           if (UNT$EngageStatus$I == $EngagementOver$Code) 
                {
                # are we sure we are looking at the same engagement? ? 

                ORD$Phase$I = 0
                putORD$Phase$I 
                }                

           return
          }
       }

     if (UNT$Type$I == $Air$code)
       {
        unt$BrokeInterceptTime$f = xunt$BrokeInterceptTime$f
        if ((unt$BrokeInterceptTime$f > 0)  &
            (unt$BrokeInterceptTime$f + PSI$Hold > Game$Minute))
          {   # If broke intercept and is still reforming his flight
           msg_len = 0
           call smovhn (UNT$Name$C, $$MaxLit, msg, msg_len)
           call smovv  (" cannot strike position - ", msg, msg_len)
           call smovv  ("still reforming flight", msg, msg_len)
           call send_   (UNT$View$I, 0, msg_len, msg)
           return
          }
       }

     number_eq = 0     # initialize to zero equipment items located
     call DEQGET (UNT$Pointer, $ASM$code, number_eq, EqList)
     call DEQGET (UNT$pointer, $Bomb$code, number_eq, EqList)
     if (number_eq == 0)
       {
        putUNT$RulesOfEngage$I  ($IfAttacked$code)
        msg_len = 0
        call smovhn (UNT$Name$c, $$MaxLit, msg, msg_len)
        call smovv  (" has no ASM or BOMB weapons - ", msg, msg_len)
        call smovv  ("cannot perform ordered strike", msg, msg_len)
        call send_   (UNT$View$I, 0, msg_len, msg)
        return
       }
     
    max_range = 0
    for (i=1; i <= number_eq; i = i + 1)
    {
        if (eqList[4,i] > max_range) max_range = eqList[4,i]
    }

    shortest_range = 1024
    for (i=1; i <= number_eq; i = i + 1)
    {
        if (eqList[4,i] < shortest_range) shortest_range = eqList[4,i]
    }

     call clear_maneuver_all (xORD$Code$I, xORD$Id$I, xUNT$View$I, UNT$Pointer)

     ACC$Pointer = xUNT$ACCPntr$I               # the default STRIKE speed
     UNT$OrderedSpeed$F = xACC$CruiseSpeed$I    # is the aircrafts cruise speed

    if (ilex[2] == $lex$GROUND$)
    {
        minordlen = 3
        unt$agdindex$i = find_agd_slot(int(ilex[3]),$NO)
        AGD$Pointer$to unt$AGDIndex$i
        if (AGD$Pointer$Valid)
        {
            if (xAGD$AlspId$i == 0)    # ALSP id not found
            {
                msg_len = 0
                call smovhn (UNT$Name$c, $$MaxLit, msg, msg_len)
                call smovv  (" cannot perform ordered strike - ", msg, msg_len)
                call smovv  (" Ground target id not found.", msg, msg_len)
                call send_   (UNT$View$I, 0, msg_len, msg)
                return
            }
            else
            {
                PUTunt$AGDindex$i
                UNT$TargetLatitude$f = Xagd$TrueLatitude$f
                UNT$TargetLongitude$f = Xagd$TrueLongitude$f
            }
        }
        else            # AGD table full
        {
            msg_len = 0
            call smovhn (UNT$Name$c, $$MaxLit, msg, msg_len)
            call smovv  (" cannot perform ordered strike - ", msg, msg_len)
            call smovv  (" Ground target id not found.", msg, msg_len)
            call send_   (UNT$View$I, 0, msg_len, msg)
            return
        }
    }
    else        # $lex$POSITION$
    {
        minordlen = 4
        UNT$TargetLatitude$F = DMS2RAD (ILEX[3])
        UNT$TargetLongitude$F = DMS2RAD (ILEX[4])
    }

     UNT$TargetType$I = $NoTarget$TargetCode

     standoff_range = 0.0

     if (iword > minordlen)    # if anything after position or ground target
       {
        for (current_arg_index = minordlen+1; current_arg_index < iword;
             current_arg_index = current_arg_index  + 2)
          {
           if (ilex[current_arg_index] == $lex$Speed$)
              UNT$OrderedSpeed$F = ilex[current_arg_index+1]
           else if (ilex[current_arg_index] == $lex$Target$)
             {
              if (ilex[current_arg_index + 1] == $lex$Bridge$)
                {
                 UNT$TargetType$I = target_priority_code (_
                                       INT(ilex[current_arg_index + 1]),
                                       INT(ilex[current_arg_index + 2]))
                 current_arg_index = current_arg_index + 1  # since there were 2
                                                            # entries after key word
                }
              else 
                 UNT$TargetType$I = target_priority_code (_
                                       INT(ilex[current_arg_index + 1]),
                                       $NoTarget$TargetCode)
             }   # end of if a TARGET was entered in the command
           else if (ilex[current_arg_index] == $lex$BE$)
             {
              if (ilex[current_arg_index + 2] == $lex$TIN$)
                {
                 kk = 0; call smovv ("        ", blank_word, kk)
                 call Store_BE_Info (UNT$Pointer, 
                                     ilex[current_arg_index + 1],
                                     blank_word)
                }
              else 
                {    # if the second arg after BE is not TIN then
                     # two arguments are taken up by the BE number
                 call Store_BE_Info (UNT$Pointer, 
                                     ilex[current_arg_index + 1],
                                     ilex[current_arg_index + 2])
                 current_arg_index = current_arg_index + 1
                }
             }
           else if (ilex[current_arg_index] == $lex$STANDOFF$)
             {
              standoff_range = ilex[current_arg_index+1]
             }

           else #if (ilex[current_arg_index] == $lex$TIN$)
              call Store_TIN_Info (UNT$Pointer, ilex[current_arg_index + 1])
          }   # end of loop through remaining entries
       }   # end of if additional information entered after position

     # Standoff range priority is from order, aircraft char, and load
     if (standoff_range == 0.0) standoff_range = Xacc$StandoffRange$f
     if (standoff_range == 0.0) standoff_range = shortest_range
     
     putUNT$OrderedSpeed$F   # set above
     putUNT$TargetType$I     # set above
     putUNT$AssignedTarget$I (UNT$Engaging$Position)
     putUNT$Status$I         ($Proceeding$Code)
     putUNT$AttackRange$F    (0.0)

     UNT$AssumedLatitude$F = xUNT$AssumedLatitude$F
     UNT$AssumedLongitude$F = xUNT$AssumedLongitude$F
     putUNT$TargetLatitude$F
     putUNT$TargetLongitude$F
     
     call RLL2RB (UNT$AssumedLatitude$F, UNT$AssumedLongitude$F,
                  COS(UNT$AssumedLatitude$F),
                  UNT$TargetLatitude$F, UNT$TargetLongitude$F,
                  COS(UNT$TargetLatitude$F),
                  range, bearing)
     UNT$ORDEREDLATITUDE$F = UNT$ASSUMEDLATITUDE$F   #get assumed lat

     UNT$ORDEREDLONGITUDE$F = UNT$ASSUMEDLONGITUDE$F #get assumed lon

     FCOS = COS(UNT$ORDEREDLATITUDE$F)

     prng = range - standoff_range
     call RRB2LL(UNT$ORDEREDLATITUDE$F,          
                UNT$ORDEREDLONGITUDE$F,
                prng,
                bearing,
                0.0,
                FCOS)
     putUNT$OrderedLatitude$F
     putUNT$OrderedLongitude$F

     putUNT$RangeToNext$F (prng)
      

     putUNT$EngageStatus$I ($NoEngagements$Code)

     msg_len = 0
     call smovhn  (UNT$Name$C, $$MaxLit, msg, msg_len)
     if (ilex[2] == $lex$GROUND$)
     {
     call smovv   (" striking ground target with id ", msg, msg_len)
     call smovi   (xAGD$ALSPID$I, msg, msg_len)

     }
     else
     {
         call smovv   (" striking position ", msg, msg_len)
         call smovlls (DMS2RAD (ILEX[3]), "NS", msg, msg_len)
         call smovv   (" ", msg, msg_len)
         call smovlls (DMS2RAD (ILEX[4]), "EW", msg, msg_len)
     }
     call send_    (UNT$View$I, 0, msg_len, msg)

    # Send warning message if standoff_range greater than max range weapon
    if (standoff_range > max_range)     # joa 2/04 per_sor
       {
        msg_len = 0
        call smovv ("WARNING: ",msg,msg_len)
        call smovh (UNT$Name$c,$$MaxLit,msg,msg_len)
        call smovv (" standoff range of ",msg,msg_len)
        call smovf (standoff_range, 501, msg, msg_len)
        call smovv (" nmi exceeds max weapon range of ",msg,msg_len)
        call smovi (max_range, msg, msg_len)
        call smovv (" nmi.",msg,msg_len)
        call send_(UNT$View$i,0,msg_len,msg)
       }

    }    # end of aircraft having non-airlift mission
    
return
end


integer function target_priority_code (lex_value1, lex_value2)
###########################################################################
#$%
#$% Purpose:   Target_Priority_Code returns the target priority code
#$%            defined in table 7.4 (bbcode.def).
#$%
#$% Called By: 
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date       November 1994
#$%
#$% Author:    Carol Kropp
#$%
#$% Modified:  Susan Miller 5/97 (E1704)
#$%            Added aircraft and maintenance as target priorities.
#$%
###########################################################################

integer  lex_value1, lex_value2

integer  target_code

integer  I_SWITCH_1                 # MJC 5/3/2000 (E-2145)

  switch (lex_value1)
    {
     case $lex$Acq_Radar$:  target_code = $AcquisitionRadar$TargetCode
     case $lex$Aircraft$:   target_code = $Aircraft$TargetCode
     case $lex$AirDefense$: target_code = $AirDefense$TargetCode
     case $lex$Armor$:      target_code = $Armor$TargetCode
     case $lex$Artillery$:  target_code = $Artillery$TargetCode
     case $lex$Bridge$:
       {
        if (lex_value2 == $lex$Engineered$)
          target_code = $EngBridge$TargetCode
        else # lex_value2 == $lex$Fixed$
          target_code = $FixedBridge$TargetCode
       }
     case $lex$CIWS$:       target_code = $CIWS$TargetCode
     case $lex$Comm$:       target_code = $Comm$TargetCode
     case $lex$Flightline$: target_code = $FlightLine$TargetCode
     case $lex$Fuel$:       target_code = $Fuel$TargetCode
     case $lex$Generic$:    target_code = $Generic$TargetCode
     case $lex$Helicopters$:target_code = $Helicopters$TargetCode
     case $lex$Infantry$:   target_code = $Infantry$TargetCode
#     case $lex$Maintenance$:target_code = $Maintenance$TargetCode
     case $lex$Personnel$:  target_code = $Personnel$TargetCode
     case $lex$Radar$:      target_code = $Radar$TargetCode
     case $lex$Radars$:     target_code = $Radars$TargetCode
     case $lex$Road$:       target_code = $Road$TargetCode
     case $lex$Shelters$:   target_code = $Shelters$TargetCode
     case $lex$Stores$:     target_code = $Stores$TargetCode
     case $lex$Trucks$:     target_code = $Trucks$TargetCode
     case $lex$Weapons$:    target_code = $Weapons$TargetCode
     default:               target_code = $NoTarget$TargetCode
    }

return (target_code)
end


subroutine Store_BE_Info (UNT$Pointer,    # the unit pointer
                          be_part_1,      # the 1st 8 characters of the BE
                          be_part_2)      # the 2nd word of the BE
###########################################################################
#$%
#$% Purpose:   Store_BE_Info will check to see if the unit has a BTT
#$%            associated with it already.  If it does, then the BE will
#$%            be stored in BTT (BE and TIN Table).  If it doesn't, one
#$%            will be obtained and the info stored.
#$%
#$% Called By: Ostrike_posit
#$%
#$% Calls:     Obtain_BTT_Entry
#$%
#$% Tables:    BTT
#$%
#$% Date       June 1995
#$%
#$% Author:    Carol Kropp
#$%
###########################################################################
BBCommon

integer  UNT$Pointer
literal  be_part_1, be_part_2

integer    UNT$BTTIndx$I, UNT$View$I
integer    BTT$Pointer
integer    msg_len
character  msg[ARB]

literal    BTT$Benumber1$C,
           BTT$Benumber2$C,
           CSTRIP8                                      # MJC 5/4/2000 (E2145)

  UNT$BTTIndx$I = xUNT$BTTIndx$I
  if (UNT$BTTIndx$I == 0)  # if there isn't a BTT entry associated with the unit
    call Obtain_BTT_Entry (BTT$Pointer)
  else
    BTT$Pointer$To  UNT$BTTIndx$I

  if (BTT$Pointer$Valid)
    {
     UNT$BTTIndx$I = BTT$Pointer$Index
     putUNT$BTTIndx$I

     BTT$BEnumber1$C = be_part_1
     putBTT$BEnumber1$C
     BTT$BEnumber2$C = be_part_2
     putBTT$BEnumber2$C
    }
  else
    {
     UNT$View$I = xUNT$View$I
     msg_len = 0
     call smovhn  (xUNT$Name$C, $$MaxLit, msg, msg_len)
     call smovv   (" cannot attack entered BE -", msg, msg_len)
     call smovv   (" There is no room in the BE/TIN table.", msg, msg_len)
     call send_    (UNT$View$I, 0, msg_len, msg)
     msg_len = 0
     call smovv   ("The attack will be executed without", msg, msg_len)
     call smovv   (" the BE targeting information.", msg, msg_len)
     call send_    (UNT$View$I, 0, msg_len, msg)
    }

return
end


subroutine Store_TIN_Info (UNT$Pointer,    # the unit pointer
                           tin)            # the entered TIN value
###########################################################################
#$%
#$% Purpose:   Store_TIN_Info will check to see if the unit has a BTT
#$%            associated with it already.  If it does, then the TIN will
#$%            be stored in BTT (BE and TIN Table).  If it doesn't, one
#$%            will be obtained and the info stored.
#$%
#$% Called By: Ostrike_posit
#$%
#$% Calls:     Obtain_BTT_Entry
#$%
#$% Tables:    BTT
#$%
#$% Date       June 1995
#$%
#$% Author:    Carol Kropp
#$%
###########################################################################
BBCommon

integer  UNT$Pointer
literal  tin

integer    UNT$BTTIndx$I, UNT$View$I
integer    BTT$Pointer
integer    msg_len
character  msg[ARB]

literal    BTT$Tinnumber$C,
           CSTRIP8                              # MJC 5/4/2000 (E2145)

  UNT$BTTIndx$I = xUNT$BTTIndx$I
  if (UNT$BTTIndx$I == 0)  # if there isn't a BTT entry associated with the unit
    call Obtain_BTT_Entry (BTT$Pointer)
  else
    BTT$Pointer$To  UNT$BTTIndx$I

  if (BTT$Pointer$Valid)
    {
     UNT$BTTIndx$I = BTT$Pointer$Index
     putUNT$BTTIndx$I

     BTT$TINnumber$C = tin
     putBTT$TINnumber$C
    }
  else
    {
     UNT$View$I = xUNT$View$I
     msg_len = 0
     call smovhn  (xUNT$Name$C, $$MaxLit, msg, msg_len)
     call smovv   (" cannot attack entered TIN -", msg, msg_len)
     call smovv   (" There is no room in the BE/TIN table.", msg, msg_len)
     call send_    (UNT$View$I, 0, msg_len, msg)
     msg_len = 0
     call smovv   ("The attack will be executed without", msg, msg_len)
     call smovv   (" the TIN targeting information.", msg, msg_len)
     call send_    (UNT$View$I, 0, msg_len, msg)
    }

return
end


subroutine Obtain_BTT_Entry (BTT$Pointer)  # out:  the BTT entry pointer
###########################################################################
#$%
#$% Purpose:   Obtain_BTT_Entry will return the pointer to an available
#$%            BTT entry.  If no entries are available then the value
#$%            will not pass the BTT$Pointer$Valid test.
#$%
#$% Called By: Store_BE_Info
#$%            Store_TIN_Info
#$%
#$% Calls:     none
#$%
#$% Tables:    BTT
#$%
#$% Date       June 1995
#$%
#$% Author:    Carol Kropp
#$%
###########################################################################
BBCommon

integer  BTT$Pointer, kk

literal  blank_word
literal  value

literal  CSTRIP8                                # MJC 5/4/2000 (E2145)

kk = 0; call smovv ("        ", blank_word, kk)

  for (BTT$Pointer$First; BTT$Pointer$Valid; BTT$Pointer$Next)
    {
     value = xBTT$BEnumber1$C
     if (value == blank_word)   # if no BE entered,
       {                   # check the TIN
        value = xBTT$TINnumber$C
        if (value == blank_word)
          break
       }
    }  # end of loop through the BTT table

return
end


subroutine ODrop_JTIDS (view, nargs, args)
################################################################################
#$%
#$% Purpose:     ODrop_JTIDS is called from ODrop_Range when the specified
#$%              track range follows the JTIDS format Jxxxx (x=0-8).  Only
#$%              Blue holds these type of detections and they are available to
#$%              the whole side, not a particular view.
#$%
#$% Called By:   ODrop_Range
#$%
#$% Calls:       ctoi
#$%              wgoerr
#$%
#$% Tables:      L16
#$%
#$% Date:        December 1995
#$%
#$% Author:      Carol L. Kropp
#$%
################################################################################
BBCommon

integer  view, nargs
literal  args[nargs]

integer  ctoi     # convert literal to integer

integer  nbr_dropped
integer  lo, hi
real     track_age
integer  L16$Pointer
integer  L16$TrackNumber$I
real     L16$TimeOfReceipt$F

integer  JJ,IVIEW,NORD                                  # MJC 5/3/2000 (E-2145)
literal  iaddr / 0 /   # jb  for dew  2/12/01

  nbr_dropped = 0

  if (view <= $LastBlue$View)
    {          
     jj = 2;   lo = ctoi(args[3],jj)
     jj = 2;   hi = ctoi(args[4],jj)
     if (lo > hi)
       {
        call wgoerr (iview, iaddr, nord, nargs ,args, "Invalid Range.")
       }
     else
       {
        if (args[2] == $lex$Old$)
          track_age = Minutes$To$Yellow
        else
          track_age = -1.0

        for (L16$Pointer$First; L16$Pointer$Valid; L16$Pointer$Next)
          {
           if (xL16$InUse$I != $no)
             {
              L16$TrackNumber$I = xL16$TrackNumber$I
              if (lo <= L16$TrackNumber$I & L16$TrackNumber$I <= hi)
                {
                 L16$TimeOfReceipt$F = xL16$TimeOfReceipt$F
                 if (L16$TimeOfReceipt$F + track_age < Game$Time)
                   {
                    L16$Zero
                    nbr_dropped = nbr_dropped + 1
                   }   # end of if old enough to drop
                }   # end of if within the range
             }   # end of if slot is in use
          }   # end of loop through the L16 table
       }  # end of if range is good
    }   # end of if view can drop the tracks      

  if (nbr_dropped == 0)
    call wgoerr (iview, iaddr, nord, nargs, args, "None Dropped.")

return
end


subroutine oripple (UNT$Pointer,    # in:  Unit UNT pointer
                    nargs,          # in:  Number of command arguments
                    args)           # in:  Command arguments
################################################################################
#$%
#$% Purpose:    ORIPPLE processes the RIPPLE command.  
#$%             This allows specification of a less-than-full-drop of 
#$%             air-to-surface weapons on a target (with the STRIKE command)
#$%
#$%                 FOR <addressee> RIPPLE (totals for flight) 
#$%                                   [ ALL | <number> <name> ... ]
#$%
#$% Concept:    Names given will nop if not valid ASMs or BOMBs 
#$%             If ALL is specified, All DEQs of ASM and BOMB are reset.
#$%             If <name> specified, and the unit has none, is it an error? [NO]
#$%             if Unit has an ASM/Bomb, not specified, leave it alone.
#$%
#$% Tables:     UNT     DEQ
#$%
#$% Date:       October 2000 (E2206)
#$%
#$% Author:     Dane Wills
#$%
################################################################################

define ($Max_List, 16)

BBCommon

integer     UNT$Pointer, nargs, litcmp  # jb  litcmp frm [aai01...mods] 1/23/01 
literal     args[nargs]
literal     cstrip8   # function used extracting names from the blackboard

integer     msg_len
VMSchar     msg*ARB
literal     UNT$Name$C, change_name[$Max_List]
integer     change_cnt, change_qty[$Max_List], 
            ipnt, k_deq, deq$pointer, new_qty, old_qty,
            icnt, found_it[$Max_List], missing, 
            nfound, eqlist[5,30]

#--------------------------------------------------
#   Syntax:
#
#   FOR <addressee> RIPPLE (totals for flight) 
#                       [ ALL | <number> <name> ... ]
#
#       where <number> & <name> are repeated N times
#
#--------------------------------------------------

UNT$name$C = xUNT$name$C 


#------------------------------
# Look through the UNT's DEQ list, for ASMs and BOMBs

nfound = 0                              # init item count

call DEQGET (UNT$Pointer,$ASM$CODE,  nfound, eqlist)
call DEQGET (UNT$Pointer,$BOMB$CODE, nfound, eqlist)

#     eqlist[1,n] = DEQ$Pointer$Index

#------------------------------
# Process each <name> given 

missing    = $no
change_cnt = 0
icnt       = 0

for (ipnt = 2; ipnt <= nargs; ipnt = ipnt + 2)
    {
    icnt = icnt + 1
    found_it [icnt] = $no

    for (k_deq = 1; k_deq <= nfound; k_deq = k_deq + 1)
        {
        deq$pointer$to eqlist[1,k_deq]

        if (args[ipnt] == $lex$ALL$)
            {
            found_it [icnt] = $yes
            new_qty = 0
            }         # jb next line: litcmp, frm [aai01...mods]  1/23/01 
        else if (litcmp(args[ipnt+1], xDEQ$type$c) == 0)
            {
            found_it [icnt] = deq$pointer
            new_qty = args[ipnt]
            }
        else if (args[ipnt+1] == 'PERCENT')
            {
            found_it [icnt] = deq$pointer
            new_qty = args[ipnt] * xDEQ$Remaining$i / 100
            if (new_qty < 1) new_qty = 1
            }
        else    
            {
            next
            }

        old_qty = xDEQ$RippleQty$i
        PUTdeq$RippleQty$i (min(new_qty,$Hi_DEQ$RippleQty$I))

        if (change_cnt < $max_List)
            {
            change_cnt = change_cnt + 1
            change_name [change_cnt] = xDEQ$type$c
            change_qty  [change_cnt] = new_qty
            }
        } # end for all ASM/Bombs

    if (found_it [icnt] == $no) missing = $yes

    } # end for all Args

#------------------------------
# Tell the user...

msg     = ""
msg_len = 0

call vmovhn (UNT$Name$c, $$MaxLit, msg, msg_len)
call vmov   ($tab, msg, msg_len)
call vmov   (msg_len+1, msg, msg_len)
call vmovv  ("Ripple assignment: ", msg, msg_len)

if (args[2] == $lex$ALL$) call vmovv  (" ALL", msg, msg_len)

for (k_deq = 1; k_deq <= nfound; k_deq = k_deq + 1)
    {
    deq$pointer$to eqlist[1,k_deq]
    New_qty = xDEQ$RippleQty$i

    if (args[2] != $lex$ALL$) 
        {
        if (k_deq > 1) 
            call vmovv (",", msg, msg_len)

        call vmovv (" ", msg, msg_len)

        if (new_qty == 0) 
            call vmovv ("all", msg, msg_len)
        else
            call vmovi (new_qty, msg, msg_len)
        }

    call vmovv (" ", msg, msg_len)
    call vmovhn (xDEQ$Type$c, $$MaxLit, msg, msg_len)
    }

#------------------------------
if (missing == $yes)
    {
    call vmov ($return, msg, msg_len)
    call vmovv ("Could not change: ", msg, msg_len)
    icnt = 0

    for (ipnt = 2; ipnt <= nargs; ipnt = ipnt + 2)
        {
        icnt = icnt + 1
        if (found_it [icnt] != $no) next

        if (args[ipnt] == $lex$ALL$) 
            call vmovv ("Anything", msg, msg_len)
        else                
            call vmovhn ( args[ipnt + 1], $$MaxLit, msg, msg_len)

        call vmovv (" ", msg, msg_len)
        }    
    }

call send_V (xUNT$View$I, msg[1:msg_len])

return
end
