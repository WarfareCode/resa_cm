 
#################################################################
#$%
#$% Information on the programs and subroutines located in RGINPUT.RAT
#$% along with those that are called is provided in DOC.WHO.
#$%
######################################################################
define($IFF$Code,41)                               # cml 3/12/91
define ($BISTAT, #)
include "rgmain.inc"
 
define (bbimplicit, implicit none)

 
Subroutine inrfmsg
#######################################################################
###
###    Subroutine INRFMSG controls the subroutines that format RAINFORM
###    messages.
###
########################################################################
 
bbcommon
rgcommon
rfcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer k
 
igold = $no                             # not GOLD msgs
 
call inredunit                          # search for ship(oth) contacts
 
if (RGIntv$SEL != nomsg)
{
    if ((msg_minute - RGLastTime$SEL) >= RGIntv$SEL)
    {
        k = sendmsg
        RGLastTime$SEL = msg_minute
    }
    else
        k = nomsg
 
    if (k == sendmsg) call inselor (igold)   # search for SELOR contacts
}
if (RGIntv$SOS != nomsg)
   {
    if ((msg_minute - RGLastTime$SOS) >= RGIntv$SOS)
    {
        k = sendmsg
        RGLastTime$SOS = msg_minute
    }
    else
        k = nomsg
 
    if (k == sendmsg) call insosus (igold)   # search for SOSUS contacts
   }
if (RGIntv$HFD != nomsg)
   {
    if ((msg_minute - RGLastTime$HFD) >= RGIntv$HFD)
    {
        k = sendmsg
        RGLastTime$HFD = msg_minute
    }
    else
        k = nomsg
 
    if (k == sendmsg) call inhfdf  (igold)   # search for HFDF contacts
   }
 
 
return
end
 

 
Subroutine ingoldall
############################################################################
###
### Subroutine INGOLDALL searches all contact files (RADAR, SONAR, VISUAL,
### ESM, SOSUS, SWABS, IR, HFDF and SURVSAT) and puts them into GOLD message
### format.
###
#############################################################################
 
bbcommon
rgcommon
rfcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
irnd_gold = irnd_gold + 1
if (irnd_gold > 3) irnd_gold = 1
 
igold = $yes                     ## it is a gold message
 
#-------------------------------------------------------------------
#   If the interval for a GOLD type message is nomsg (999 set at
#   initialiation by user) there is no reason to call the subroutine
#   to generate a message.
#--------------------------------------------------------------------
if ((RGIntv$Golds  != nomsg) | (RGIntv$Golda  != nomsg) |
    (RGIntv$GROTHR != nomsg) |
    (RGIntv$GESMs  != nomsg) | (RGIntv$GESMa  != nomsg))
    {
    call ingldunit
    if (msg_minute - RGLastTime$GOLDs >= RGIntv$Golds)
       RGLastTime$GOLDs = msg_minute
    if (msg_minute - RGLastTime$GOLDa >= RGIntv$Golda)
       RGLastTime$GOLDa = msg_minute
    if (msg_minute - RGLastTime$GROTHR >= RGIntv$GROTHR)
       RGLastTime$GROTHR = msg_minute
    if (msg_minute - RGLastTime$GESMs >= RGIntv$GESMs)
       RGLastTime$GESMs = msg_minute
    if (msg_minute - RGLastTime$GESMa >= RGIntv$GESMa)
       RGLastTime$GESMa = msg_minute
    }
 
if ((RGIntv$GSELs != nomsg) | (RGIntv$GSELa != nomsg)) call inselor (igold)
 
if (RGIntv$GSOS  != nomsg)                             call insosus (igold)
 
if (RGIntv$GSWABS != nomsg)                            call inswabs (igold)
 
if (RGIntv$GHFD  != nomsg)                             call inhfdf  (igold)
 
if (RGIntv$GIR    != nomsg)                            call inir    (igold)
 
return
end
 

 
Subroutine inbflmsg (itype)
####################################################################
###
###  Collects Blue Force Locator message data for a delayed Rainform
###  messages.
###
### Modified:   Jim Allen  - 8/98 (E2027)
###             NAVNRU units are not part of blue force locator
###
### Modified:   John McCormick - 5/99 (E2083)
###             Output IFF mode 2 if equiment on and mode 2 set.
###             Jim Allen - 6/03 (E2344)
###             Allow neutral and orange units to report location information
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
integer iside, kindex, iloc, istype, itype, indexx, nosic
literal cstrip8
BBDeclare (UNT$Type$I, UNT$TrueAltDepth$I, DEQ$IFFMode2$I, DEQ$Pointer,
	   MSG$MsgType$I, MSG$UnitType$I, MSG$IFFMode2$I, MSG$Course$I,
	   MSG$Latitude$F, MSG$Longitude$F, MSG$TrueLat$F, MSG$TrueLong$F,
	   MSG$Speed$I, MSG$AltDepth$I, ACC$Category$I, UNT$Name$C,
	   MSG$DcteeName$C)
 
for (unt$pointer$first; unt$pointer$valid; unt$pointer$next)
   {
    # if empty slot, unit being deleted, or shore base, skip it
    if (xunt$inuse$i == 0 | xUNT$Status$I == $BeingDeleted$Code |
        xunt$type$i == $Shorebase$Code) next
 
# joa 5/22/03 (E2344) Allow Neutral and Orange to report Force Locator information
#    call whside(xunt$view$i,iside)                # determine side
#    if (iside != $blue$code ) next                # if not Blue, skip it
 
    unt$name$c = xunt$name$c
 
    #-------------------------------------------------------------------------
    #   DO NOT include units in the Blue Force Locator Messages if they are:
    #
    #      - Not in the RAINFORM Initialization File
    #      - Merchant, fisherman or unknown
    #------------------------------------------------------------------------
    kindex = unt$pointer$index
 
    # Do not include if nosic id is zero
    call get_nosic (kindex, nosic)
    if (nosic == 0) next
 
    call get_status (kindex, status)
    if (status == $mer$rship |
        status == $navnru$rship |       # joa 8/89 (E2027)
        status == $fsh$rship ) next                # if not a bfl naval ship,
 
    if (status == $unk$rship) next      # Do not report
 
    if ((RGPOST$OUT == $yes) & (status == $othnp$rship |
                                status == $navnp$rship |
                                status == $stsnp$rship)) next
    #-------------------------------------------------------------------------
    unt$type$i = xunt$type$i
 
    #--------------------------------------------------------------------------
    #   Put unit types in two catagories: 1) Surf/Sub and 2) Air.  The
    #   rest like bases, missiles, etc. are skipped.  Then generate BFLOC's
    #   dependent on whether surface/sub or air interval is called (itype).
    #--------------------------------------------------------------------------
    if (unt$type$i == $Sub$Code | unt$type$i == $Surface$Code |
        unt$type$i == $SurfaceWithAC$Code) istype = $Surf$RType
    else if (unt$type$i == $Air$Code)      istype = $Air$RType
 
    if      (itype == $AirSurf$RType) continue
    else if (itype != istype)          next
 
    unt$truealtdepth$i = xunt$truealtdepth$i
 
# clk 6/6/96 (E1606) - Removed the skipping of a/c below 500 ft.
#    if (unt$type$i == $air$code & unt$truealtdepth$i < 500) next
 
    index = 0
    call getslot (index, kindex)
    inslots = inslots + 1
 
    MSG$MsgType$I = $Special$RMsg
    putMSG$MsgType$I
 
    call get_msgtimes ($Spec$RDelay)
 
    MSG$DcteeName$C = unt$name$c
    putMSG$DcteeName$C
 
    if      (xunt$type$i == $Air$Code) MSG$UnitType$I = $Air$RType
    else if (xunt$type$i == $sub$Code) MSG$UnitType$I = $sub$RType
    else                               MSG$UnitType$I = $Surf$RType
    putMSG$UnitType$I
 
    MSG$Latitude$F = xunt$AssumedLatitude$F
    MSG$Longitude$F = xunt$AssumedLongitude$F
    putMSG$Latitude$F
    putMSG$Longitude$F
 
                      # does this unit have mode2 IFF active - JHM 5/99 (E2083)
    DEQ$IFFMode2$I = 0  # This block adds mode2 output to OTG
    for_DEQ_chain (UNT$Pointer$index)
     {
      if ((xDEQ$Ident$I == $IFF$Code) &
        (xDEQ$On$I == $yes))
        {
            DEQ$IFFMode2$i = xDEQ$IFFMode2$i
            if(DEQ$IFFMode2$i > 0)
              break
         }
      } # end of search through DEQ table
 
     if(DEQ$IFFMode2$I  > 0)    # track has iff mode 2
         {
          MSG$IFFMode2$i = DEQ$IFFMode2$I
          putMSG$IFFMode2$i
         }                           # JHM 5/99 end (E2083) block
 
 
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
    putMSG$TrueLat$F
    putMSG$TrueLong$F
 
    MSG$Course$I = int(xunt$AssumedCourse$F * 180/$pi + .5) # radians to degs.
    MSG$Speed$I = int(xunt$AssumedSpeed$F + .5)
    putMSG$Course$I
    putMSG$Speed$I
 
    if (MSG$UnitType$I == $Air$RType)
       {
        MSG$AltDepth$I = unt$truealtdepth$i/100   # clk 6/96 (E1607) - 100 vice 1000
 
        acc$pointer = xunt$accpntr$i
        acc$category$i = xacc$category$i
 
        call inaircat (acc$category$i)
       }
    else if (MSG$UnitType$I == $sub$RType)
        MSG$AltDepth$I = unt$truealtdepth$i       # clk 6/96 (E1609) - actual value
    else
        MSG$AltDepth$I = 0                        # clk 6/96 (E1609) - don't report
    putMSG$AltDepth$I
   }
 
return
end
 

 
Subroutine inredunit
######################################################################
###
### Collects RED message data for a delayed Rainform message.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
logical*1 esmrctc[UNT$slots, RAD$slots], indx[RMT$slots]
integer i, indxRMT, indxRAD, RVU$Pointer, ifirst, ilast
integer iRMT, iside, itime, iloc, k, l, m, imsg, iclass, idrad
integer iclassif
integer later /$no/
BBDeclare(RMT$FingerPrinted$I, RMT$Classified$I, RMT$DetectionType$I,
	  RMT$TargetID$I, MSG$FingerPrinted$I, MSG$MsgType$I, MSG$Classified$I,
	  RMT$FirstDetTime$F, RMT$LastDetTime$F,unt$type$i, unt$subtype$i)
 
if (later == $no)
   {
    for (i = 1; i <= RMT$slots; i = i + 1) indx[i] = $no
    later = $yes
   }
 
for (indxrmt = 1; indxrmt <= UNT$slots; indxrmt = indxrmt + 1)
   {
    for (indxrad = 1; indxrad <= RAD$slots; indxrad = indxrad + 1)
       {
        esmrctc[indxrmt, indxrad] = $no
       }
   }
 
rvu$pointer$to $firstblue$view
ifirst = xrvu$firstrmtindx$i
rvu$pointer$to $lastblue$view
ilast = xrvu$lastrmtindx$i
 
for (rmt$pointer$to ifirst; rmt$pointer$index <= ilast; rmt$pointer$next)
   {
    irmt = rmt$pointer$index
    if (irmt == 0) next
 
    if (xrmt$inuse$i == 0) next     # if empty slot, skip it
 
    if (xRMT$Detector$I == $no)     # there is no detector,
      next                          # skip this entry - clk 6/96 (E1608)
 
    idctor = xrmt$detector$i
    idctee = xrmt$detectee$i
 
    #----------------------------------------------------------------------
    #   Determine which side unit is on.  If BLUE, skip it.
    #---------------------------------------------------------------------
    unt$pointer$to idctee
 
    call whside(xunt$view$i,iside)
    if (iside == $blue$code ) next
 
    RMT$FingerPrinted$I = xRMT$FingerPrinted$I
    RMT$Classified$I = xRMT$Classified$I
    rmt$FirstDetTime$f = xrmt$FirstDetTime$f
    rmt$detectiontype$i = xrmt$detectiontype$i
    rmt$LastDetTime$f = xrmt$LastDetTime$f
    rmt$TargetID$i = xrmt$TargetID$i
 
    itime = msg_minute - time$step*2.  # Old track if more than twice time$step
    if (rmt$LastDetTime$f <= float(itime)) next # get only current active tracks
    if (xrmt$tracknumber$i == 0) next        # means data is garbage
 
    call get_status (idctor, status)
    if (status == $mer$rship | status == $fsh$rship   |
        status == $nav$rship | status == $unk$RShip ) next
 
    if ((RGPOST$OUT == $yes) & (status == $othnp$rship |
                                status == $navnp$rship |
                                status == $stsnp$rship)) next
 
    unt$pointer$to idctee
 
    unt$type$i = xunt$type$i
    unt$subtype$i = xunt$subtype$i
 
    # don't send any detections for torpedoes or countermeasures
    ### unt$type of $sub$code not enough to eliminate non-sub units
    ### because of unt$subtype...   # SMM 8/16/98 (E2039)
    if ((unt$type$i == $sub$code) & (unt$subtype$i != $standard$subcode))
        next
 
    if ((rmt$detectiontype$i == $PassiveSonar$Code) &
            (unt$type$i != $sub$code))  next
 
    if (unt$type$i == $air$code & xunt$truealtdepth$i < 1000) next
 
    #===============================================================
    #  RED and ESM msgs are generated when: 1) the interval set by the
    #  user has occured; 2) a target is picked up for the first time;
    #  of 3) a target has been classified.  The appropriate msg (RED,
    #  STS or ESM) is generated when l or k is 0 or imsg is YES.
    #================================================================
 
    if (RGIntv$ESM == 999 | RGIntv$ESM == 9999) k = 999
    else
    {
        if ((msg_minute - RGLastTime$ESM) >= RGIntv$ESM)
        {
            k = sendmsg
            RGLastTime$ESM = msg_minute
        }
        else
            k = nomsg
    }
 
    if (RGIntv$RED == 999 | RGIntv$RED == 9999) l = 999
    else
    {
        if ((msg_minute - RGLastTime$RED) >= RGIntv$RED)
        {
            l = sendmsg
            RGLastTime$RED = msg_minute
        }
        else
            l = nomsg
    }
 
    if (RGIntv$STS == 999 | RGIntv$STS == 9999) m = 999
    else
    {
        if ((msg_minute - RGLastTime$STS) >= RGIntv$STS)
        {
            m = sendmsg
#            RGLastTime$STSM = msg_minute
        }
        else
            m = nomsg
    }
 
    if (rmt$FirstDetTime$f == msg_minute) imsg = YES   #send msg on first det
    else                                   imsg = NO
 
    if (rmt$FirstDetTime$f > ioldmin &
        rmt$FirstDetTime$f <= msg_minute) imsg = YES
 
    iclass = rmt$classified$I
    if (iclass == $yes & indx[irmt] != $TRK_Class) # first time iclass is yes
       {
        imsg = YES
        indx[irmt] = $TRK_Class
       }
 
    else if (rmt$TargetID$I != $Unknown$Code & indx[irmt] == $TRK_No_Id)
       {                                            # first time for target ID
        imsg = YES
        indx[irmt] = $TRK_ID
       }
 
    if (iclass == $no & rmt$TargetID$I == $Unknown$Code)
      indx[irmt] = $TRK_No_ID
 
    if ((rmt$detectiontype$i == $ESM$code) &
        (imsg == YES | k == 0) & (k != 999))
       {
        rad$pointer = xrmt$emitterpntr$i
        idrad = rad$pointer$index
        if (idrad == 0) next                         # no radar
 
        if (esmrctc[idctee, idrad] == $yes) next      # if already reported
 
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        if (rmt$fingerprinted$i == $yes)  MSG$FingerPrinted$I = $yes
        else                              MSG$FingerPrinted$I = $no
 
        putMSG$FingerPrinted$I
 
        call delaycat
 
        call inesmmsg
        call put_trackid
        next
       }
    else if ((rmt$detectiontype$i == $ActiveVisual$Code   |
              rmt$detectiontype$i == $ActiveNonVisual$Code) &
              (imsg == YES | l == 0) & (l != 999))
       {
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        call delaycat
 
        MSG$MsgType$I  = $Red$RMsg
        putMSG$MsgType$I
 
        #---------------------------------------------------------------
        #   For iclassif, below...
        #   Has the contact been classified?  If the contact is:
        #      1. Not in the Initialization File --- No
        #      2. Classified Visually            --- YES
        #      3. On the Recognized Emitter List --- YES
        #      4. A passive sonar contact        --- YES
        #         (put sub type in name field of Initialization File)
        #      5. An active sonar contact        --- YES
        #         (put sub type in name field of Initialization File)
        #      6. None of the above              --- NO
        #---------------------------------------------------------------
        call get_status (idctee, status)
        if      (status == $unk$RShip) iclassif = $no    # 1
        else if (rmt$classified$i == $yes )    iclassif = $yes   # 2
        else if (rmt$detectiontype$i == $ActiveVisual$Code)
                                               iclassif = $yes   # 2
        else if ((rmt$detectiontype$i == $ActiveNonVisual$Code) &
                 (Xrmt$LastDetType$i == $Sonar$Type)) iclassif = $yes   # 5
        else                                   iclassif = $no    # 6
 
        MSG$Classified$I = iclassif
        putMSG$Classified$I
        putMSG$TargetId$I (RMT$TargetId$I)
 
        call inredmsg
        call put_trackid
       }
    else if (rmt$detectiontype$i == $PassiveSonar$Code)
       {
        #---------------------------------------------------------------------
        #   For STS (Surface Towed Array Sonar) contacts, both a RED Passive
        #   Sonar and a Special STS message are generated.
        #---------------------------------------------------------------------
        if ((status == $sts$rship) & (imsg == YES | m == 0) & (m != 999))
           {
            call getslot (idctor, idctee)
            inslots = inslots + 1
 
            call delaycat
 
            MSG$MsgType$I  = $Red$RMsg
            putMSG$MsgType$I
 
            call get_status (idctee, status)
            if      (status == $unk$RShip)         iclassif = $no
            else                                   iclassif = $yes
 
            MSG$Classified$I = iclassif
            putMSG$Classified$I
            putMSG$TargetId$I (RMT$TargetId$I)      # JOA UE01
 
            call inredmsg             # generate msg for surtass (uneval)
            call put_trackid
 
            call getslot (idctor, idctee)
            inslots = inslots + 1
 
            call get_msgtimes ($TASS$RDelay)
 
            MSG$MsgType$I  = $Sts$RMsg
            putMSG$MsgType$I
 
            call instsmsg             # generate msg for surtass (evaluated)
            call put_trackid
           }
        else if ((status == $oth$rship) & (imsg == YES | l == 0) & (l != 999))
           {
            call getslot (idctor, idctee)
            inslots = inslots + 1
 
            call delaycat
 
            MSG$MsgType$I  = $Red$RMsg
            putMSG$MsgType$I
 
            MSG$Classified$I = $no
            putMSG$Classified$I
            putMSG$TargetId$I (RMT$TargetId$I)      # JOA UE01
 
            call inredmsg             # generate msg for regular passive sonar
            call put_trackid
           }
       }
   }
 
return
end
 

 
Subroutine ingldunit
######################################################################
###
### Collects GOLD message data for a delayed Gold message.
###
### Modified:   Jim Allen 8/98 UFL E2027
###             Report blue units not participating in blue force locator
###
########################################################################
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status, ok_to_send
real oldtime[RMT$slots]
logical*1 esmgctc[UNT$slots, RAD$slots]
literal name1, name2
integer idcteetype, idctortype
literal cstrip8
integer indxRMT, indxRAD, ifirst, ilast, irmt, iside, iclassif
integer iloc, idrad, imsg, ilost, ihalftime, intv, idelaycat
BBDeclare(unt$type$i, unt$subtype$i,
	  RVU$Pointer, RMT$FingerPrinted$I, RMT$Classified$I,
	  RMT$DetectionType$I, RMT$TargetID$I, RMT$OverHoriz$I,
	  UNT$TrueAltDepth$I, UNT$HasBarrier$I, BOY$Pointer,
	  BOY$LineSeq$I, BOY$Type$I, MSG$Classified$I,
	  RMT$FirstDetTime$F, RMT$LastDetTime$F,
	  MSG$MsgType$I, MSG$FingerPrinted$I)
 
for (indxrmt = 1; indxrmt <= UNT$slots; indxrmt = indxrmt + 1)
   {
    for (indxrad = 1; indxrad <= RAD$slots; indxrad = indxrad + 1)
       {
        esmgctc[indxrmt, indxrad] = $no
       }
   }
 
rvu$pointer$to $firstblue$view
ifirst = xrvu$firstrmtindx$i
 
rvu$pointer$to $lastblue$view
ilast = xrvu$lastrmtindx$i
 
for (rmt$pointer$to ifirst; rmt$pointer$index <= ilast; rmt$pointer$next)
   {
    irmt = rmt$pointer$index
    if (irmt == 0) next
 
    if (xrmt$inuse$i == 0) next     # if empty slot, skip it
 
    if (xRMT$Detector$I == $no)     # there is no detector,
      next                          # skip this entry - clk 6/96 (E1608)
 
    idctor = xrmt$detector$i
    idctee = xrmt$detectee$i
 
    #----------------------------------------------------------------------
    #   Determine which side unit is on.  If BLUE, skip it.
    #---------------------------------------------------------------------
    unt$pointer$to idctee
 
    call whside(xunt$view$i,iside)
    if (iside == $blue$code )                # joa 8/98 (E2027)
        {
        call get_status (idctee, status)
        if (status == $nav$rship | status == $oth$rship   |
            status == $tom$rship | status == $navnp$rship |
            status == $othnp$rship | status == $sts$RShip |
            status == $stsnp$rship) next
        }
    if (xrmt$tracknumber$i == 0) next        # means data is garbage
 
    RMT$FingerPrinted$I = xRMT$FingerPrinted$I
    RMT$Classified$I = xRMT$Classified$I
    rmt$FirstDetTime$f = xrmt$FirstDetTime$f
    rmt$detectiontype$i = xrmt$detectiontype$i
    rmt$LastDetTime$f = xrmt$LastDetTime$f
    RMT$OverHoriz$I = xRMT$OverHoriz$I
    rmt$TargetID$i = xrmt$TargetID$i
 
    call get_status (idctor, status)
    if (status == $mer$rship | status == $fsh$rship   |
        status == $navnru$rship |            # joa 8/98 (E2027)
        status == $nav$rship | status == $unk$RShip) next
 
    if ((RGPOST$OUT == $yes) & (status == $othnp$rship |
                                status == $navnp$rship |
                                status == $stsnp$rship)) next
 
    if (status == $rth$rsta & RMT$OverHoriz$I ^= YES) next
 
    unt$truealtdepth$i = xunt$truealtdepth$i
 
    unt$type$i = xunt$type$i
    unt$subtype$i = xunt$subtype$i
 
    # don't send any detections for torpedoes or countermeasures
    ### unt$type of $sub$code not enough to eliminate non-sub units
    ### because of unt$subtype...   # SMM 8/16/98
    if ((unt$type$i == $sub$code) & (unt$subtype$i != $standard$subcode))
        next
 
    if ((rmt$detectiontype$i == $PassiveSonar$Code) &
            (unt$type$i != $sub$code))  next
 
    if (unt$type$i == $air$code & unt$truealtdepth$i < 1000) next
 
    #-----------------------------------------------
    #   Is the contact an ESM type
    #-----------------------------------------------
    if (rmt$detectiontype$i == $ESM$code)
       {
        rad$pointer = xrmt$emitterpntr$i
        idrad = rad$pointer$index
 
        if (idrad == 0) next                         # no radar
 
        if (esmgctc[idctee, idrad] == $yes) next      # if already reported
 
        #----------------------------------------------------------------------
        #   If this is a first/regained detection, or the detection is lost for
        #   5 minutes, or the next interval has come up, send a message.  The
        #   exception to interval messages is that if a first/regained detection
        #   occurs within 1/2 of the interval time, no interval message will be
        #   sent.  Otherwise...
        #   If the detectee (contact) type is air, check to see if the game
        #   minute is a multiple of the ESM air interval (RGIntv$GESMa).  If
        #   so, send a message.  Otherwise, go to the next contact.
        #   If the detectee (contact) type is surface, check to see if the game
        #   minute is a multiple of the ESM surface interval (RGIntv$GESMs).
        #   If so, send a message.
        #   If none of the above, go to the next contact.
        #----------------------------------------------------------------------
        imsg = nomsg
        ilost = $no
 
        if (unt$type$i == $air$code)
           {
            if (RGIntv$GESMa == nomsg) next
 
            if      (int(rmt$LastDetTime$f) == msg_minute & oldtime[irmt] == 0)
               {
                imsg = sendmsg
               }
            else if (rmt$LastDetTime$f + 5 <= msg_minute &
                     rmt$LastDetTime$f != oldtime[irmt])
               {
                imsg = sendmsg
                ilost = $yes
               }
 
            ihalftime = (RGIntv$GESMa * .5)
            if ((msg_minute - RGLastTime$GESMa) >= RGIntv$GESMa)
            {
                intv = sendmsg
                RGLastTime$GESMa = msg_minute
            }
            else
                intv = nomsg
 
            if (intv == sendmsg & int(rmt$LastDetTime$f) == msg_minute &
               (oldtime[irmt] + ihalftime) <= msg_minute)
               {
                imsg = sendmsg
               }
           }
        else if (unt$type$i == $Surface$Code |
                 unt$type$i == $SurfaceWithAC$Code |
                 unt$type$i == $sub$Code)
           {
            if (RGIntv$GESMs == nomsg) next
 
            if      (int(rmt$LastDetTime$f) == msg_minute & oldtime[irmt] == 0)
               {
                imsg = sendmsg
               }
            else if (rmt$LastDetTime$f + 5 <= msg_minute &
                     rmt$LastDetTime$f != oldtime[irmt])
               {
                imsg = sendmsg
                ilost = $yes
               }
 
            ihalftime = (RGIntv$GESMs * .5)
            if ((msg_minute - RGLastTime$GESMs) >= RGIntv$GESMs)
            {
                intv = sendmsg
                RGLastTime$GESMs = msg_minute
            }
            else
                intv = nomsg
 
 
            if (intv == sendmsg & int(rmt$LastDetTime$f) == msg_minute &
               (oldtime[irmt] + ihalftime) <= msg_minute)
               {
                imsg = sendmsg
               }
           }
 
        if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
 
        if (ilost == $yes) oldtime[irmt] = 0
        else               oldtime[irmt] = rmt$LastDetTime$f
 
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        unt$pointer$to idctor
        if (unt$type$i == $air$code) idelaycat = $GESMa$RDelay
        else                         idelaycat = $GESMs$RDelay
 
        call get_msgtimes (idelaycat)
 
        MSG$MsgType$I = $GESM$RMsg
        putMSG$MsgType$I
        esmgctc[idctee, idrad] = $yes  # has been reported
 
        if (rmt$fingerprinted$i == $yes)  msg$FingerPrinted$i = $yes
        else                              msg$FingerPrinted$i = $no
 
        putMSG$FingerPrinted$I
        putMSG$ROTHRtrk$I (RMT$OverHoriz$I)
       }
    else if (RMT$OverHoriz$I == $NO) # if not ESM type and not ROTHR, but...
       {
        #----------------------------------------------------------------------
        #   If this is a first/regained detection, or the detection is lost for
        #   5 minutes, or the next interval has come up, send a message.  The
        #   exception to interval messages is that if a first/regained detection
        #   occurs within 1/2 of the interval time, no interval message will be
        #   sent.  Otherwise...
        #   If the detectee (contact) type is air, check to see if the game
        #   minute is a multiple of the non-ESM air interval (RGIntv$GOLDa).
        #   If so, send a message.  Otherwise, go to the next contact.
        #   If the detectee (contact) type is surface, check to see if the game
        #   minute is a multiple of the non-ESM surface interval
        #   (RGIntv$GOLDs).
        #   If so, send a message.
        #   If none of the above, go to the next contact.
        #----------------------------------------------------------------------
        imsg = nomsg
        ilost = $no
 
        unt$pointer$to idctee
        unt$type$i = xunt$type$i
 
        if (unt$type$i == $air$code |
            unt$type$i == $samissile$code |
            unt$type$i == $CruiseMissile$Code)
            imsg = ok_to_send(RGLastTime$GOLDa,RGIntv$GOLDa,
                              rmt$LastDetTime$f,
                              oldtime[irmt],
                              ilost)
        else if (unt$type$i == $Surface$Code |
                 unt$type$i == $SurfaceWithAC$Code |
                 unt$type$i == $Sub$Code)
            imsg = ok_to_send(RGLastTime$GOLDs,RGIntv$GOLDs,
                              rmt$LastDetTime$f,
                              oldtime[irmt],
                              ilost)
 
        if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
        if (ilost == $yes) oldtime[irmt] = 0
        else               oldtime[irmt] = rmt$LastDetTime$f
 
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        unt$pointer$to idctor
        if (unt$type$i == $air$code |
            unt$type$i == $samissile$code |
            unt$type$i == $CruiseMissile$Code)  idelaycat = $GOLDa$RDelay
        else                                    idelaycat = $GOLDs$RDelay
 
        call get_msgtimes (idelaycat)
 
        unt$pointer$to idctee
        idcteetype = xunt$type$i
 
        unt$pointer$to idctor
        name1 = xunt$name$c
        idctortype = xunt$type$i
        unt$HasBarrier$i = xunt$HasBarrier$i
 
        #----------------------------------------------------------------
        #   Is the detector an aircraft and does he have a barrier in
        #   place?  If so, is the contact a sub and the sub is NOT on the
        #   surface, then he has a sonobuoy contact.
        #-----------------------------------------------------------------
        if (idctortype == $air$code & idcteetype == $sub$code)
          {
          if (unt$HasBarrier$i == YES)
            {
            for (boy$pointer$first;boy$pointer$ok;boy$pointer$next)
                {
                unt$pointer$to xboy$ownerindx$i	
                name2 = xunt$name$c
                if (name1 != name2) next
 
                BOY$LineSEQ$I = xBOY$LineSEQ$I
                if (BOY$LineSEQ$I != 1) next
 
                boy$type$i = xboy$type$i
 
                if      (boy$type$i == $activebarrier$code)
                   {
                    MSG$MsgType$I = $gsonba$rmsg   # DICASS
                   }
                else if (boy$type$i == $passivebarrier$code)
                   {
                    MSG$MsgType$I = $gsonbp$rmsg   # DIFAR
                   }
                else next                          # Not a buoy, skip it
                }
            }
          else if (xRMT$LastDetType$I == $Mad$Type)
            MSG$MsgType$I = $Gold$RMsg
          else if (xRMT$LastDetType$I == $Lidar$Type)
            MSG$MsgType$I = $Gold$RMsg
          }
 
        #-----------------------------------------------------------------
        #   Else the detector is not air nor has a barrier.  Then is it a ship
        #   with a passive sonar contact?
        #------------------------------------------------------------------
        else if (rmt$detectiontype$i == $PassiveSonar$Code)
           {
            if (status == $sts$rship) msg$msgtype$i = $gsontp$rmsg
            else                      msg$msgtype$i = $gsonp$rmsg
           }
        #--------------------------------------------------------------
        #  If it is a GOLD msg but not ESM or a sonar barrier, then it
        #  has to be a regular GOLD contact.
        #---------------------------------------------------------------
        else               MSG$MsgType$I = $Gold$RMsg
        putMSG$MsgType$I
 
        #---------------------------------------------------------------
        #   Has the non-ESM contact been classified?  If the contact is:
        #      1. Not in the Initialization File --- No
        #      2. Classified Visually            --- YES
        #      3. A passive sonar contact
        #           if CPX                       --- YES
        #              (put sub type in name field of Initialization File)
        #           else                         --- NO
        #      4. An active sonar contact
        #           if CPX                       --- YES
        #              (put sub type in name field of Initialization File)
        #           else                         --- NO
        #      5. None of the above              --- NO
        #---------------------------------------------------------------
        call get_status (idctee, status)
        if      (status == $unk$RShip)         iclassif = $no    # 1
        else if (rmt$classified$i == $yes )    iclassif = $yes   # 2
        else if (rmt$detectiontype$i == $PassiveSonar$Code)
           {
            if (RGCPX$Out == YES)             iclassif = $yes    # 3
            else                               iclassif = $no     # 3
           }
        else if (rmt$detectiontype$i == $ActiveVisual$Code)
                                               iclassif = $yes    # 2
        else if ((rmt$detectiontype$i == $ActiveNonVisual$Code) &
                (Xrmt$LastDetType$i == $Sonar$Type))
           {
            if (RGCPX$Out == YES)             iclassif = $yes    # 4
            else                               iclassif = $no     # 4
           }
        else                                   iclassif = $no     # 5
 
        MSG$Classified$I = iclassif
        putMSG$Classified$I
        putMSG$ROTHRtrk$I (RMT$OverHoriz$I)
        putMSG$TargetID$I (RMT$TargetID$I)
       }
 
    else    # (RMT$OverHoriz$I == $YES) # if  ROTHR, but...
        {
        #----------------------------------------------------------------------
        #   If this is a first/regained detection, or the detection is lost for
        #   5 minutes, or the next interval has come up, send a message.  The
        #   exception to interval messages is that if a first/regained detection
        #   occurs within 1/2 of the interval time, no interval message will be
        #   sent.  Otherwise...
        #   If the detectee (contact) type is air, check to see if the game
        #   minute is a multiple of the ROTHR interval (RGIntv$GROTHR).
        #   If so, send a message.  Otherwise, go to the next contact.
        #   If none of the above, go to the next contact.
        #----------------------------------------------------------------------
        imsg = nomsg
        ilost = $no
 
        unt$pointer$to idctee
        unt$type$i = xunt$type$i
 
        imsg = ok_to_send(RGLastTime$GROTHR,RGIntv$GROTHR,
                          rmt$LastDetTime$f,
                          oldtime[irmt],
                          ilost)
        if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
        if (ilost == $yes) oldtime[irmt] = 0
        else               oldtime[irmt] = rmt$LastDetTime$f
 
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        idelaycat = $GROTHR$RDelay
 
        call get_msgtimes (idelaycat)
 
        unt$pointer$to idctee
        idcteetype = xunt$type$i
 
        unt$pointer$to idctor
        name1 = xunt$name$c
        MSG$MsgType$I = $Gold$RMsg
        putMSG$MsgType$I
 
        iclassif = $no
 
        MSG$Classified$I = iclassif
        putMSG$Classified$I
        putMSG$ROTHRtrk$I (RMT$OverHoriz$I)
        putMSG$TargetID$I (RMT$TargetID$I)
        }
 
    call ingoldmsg
    call put_trackid
    next
  }
 
return
end
 

 
Subroutine put_trackid
##########################################################################
###
### This is Subroutine put BGTT track code and track number in MSG table.
###
###
###########################################################################
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer itrkview
literal cstrip
BBDeclare (MSG$TrackNo$I, MSG$TrackCode$C)
 
unt$pointer$to idctor
itrkview = xUNT$View$I
vue$pointer$to itrkview
msg$trackcode$c = xvue$trackcode$c
putmsg$trackcode$c
 
msg$trackno$i = xrmt$tracknumber$i
putmsg$trackno$i
 
return
end
 

 
Subroutine inredosis
######################################################################
###
### This is Subroutine inredosis which is used to search the Unit table
### for orange flag merchant and fishing contacts.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
integer iside, kindex, iloc, inxt, index
integer iround /0/
literal cstrip8
BBDeclare(MSG$Course$I, MSG$Speed$I,MSG$DcteeName$C,
	  MSG$Latitude$F, MSG$Longitude$F, MSG$TrueLat$F,
	  MSG$TrueLong$F)
 
#call remark_v ("Subroutine inredosis has been called")
 
iround = iround + 1
if (iround > 3) iround = 1
 
# search for UR flag merchant/fishing vessels
for (unt$pointer$first; unt$pointer$valid; unt$pointer$next)
   {
    call whside(xunt$view$i,iside)                # determine side
    if (iside != $orange$code ) next              # if not orange track, skip it
 
    kindex = unt$pointer$index
    call get_status (kindex, status)
    if (status == $unk$RShip) next
 
    if (xunt$type$i == $surfacewithac$code |      # need only surface tracks
        xunt$type$i == $surface$code)
       {
        call get_status (iloc, status)
        if (status == $mer$rship| status == $fsh$rship)
           {
            call splitlist (kindex, iround, inxt)
            if (inxt == $yes) next
 
            index = 0
            call getslot (index, kindex)
            inslots = inslots + 1
 
            putMSG$MsgType$I ($OSRed$RMsg)
 
            call get_msgtimes ($ROSIS$RDelay)
 
            msg$dcteename$c = xunt$name$c
            putmsg$dcteename$c
 
            MSG$Latitude$F = xunt$assumedlatitude$f
            MSG$Longitude$F = xunt$assumedlongitude$f
            putMSG$Latitude$F
            putMSG$Longitude$F
 
            MSG$TrueLat$F = xunt$TrueLatitude$F
            MSG$TrueLong$F = xunt$TrueLongitude$F
            putMSG$TrueLat$F
            putMSG$TrueLong$F
 
            MSG$Course$I = int(xunt$truecourse$f * 180/$pi + .5)
            MSG$Speed$I = int(xunt$truespeed$f + .5)
            putMSG$Course$I
            putMSG$Speed$I
           }
       }
   }
 
return
end
 

 
Subroutine inwhtosis
######################################################################
###
### This is Subroutine inwhtosis which is used to search the Unit table
### for non-communist flag merchant and fishing contacts.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
integer iside, kindex, iloc, inxt, index
integer iround /0/
literal cstrip8
BBDeclare(MSG$Course$I, MSG$Speed$I,MSG$DcteeName$C,
	  MSG$Latitude$F, MSG$Longitude$F, MSG$TrueLat$F, MSG$TrueLong$F)
 
#call remark_v ("Subroutine inwhtosis has been called")
 
iround = iround + 1
if (iround > 3) iround = 1
 
# search for non-UR flag merchant/fishing vessels
for (unt$pointer$first; unt$pointer$valid; unt$pointer$next)
   {
    call whside(xunt$view$i,iside)            # determine side
    if (iside == $orange$code ) next          # if an orange track, skip it
 
    kindex = unt$pointer$index
    call get_status (kindex, status)
    if (status == $unk$RShip) next
 
    if (xunt$type$i == $surfacewithac$code |  # need only surface tracks
        xunt$type$i == $surface$code)
       {
        call get_status (iloc, status)
        if (status == $mer$rship | status == $fsh$rship)
           {
            call splitlist (kindex, iround, inxt)
            if (inxt == $yes) next
 
            index = 0
            call getslot (index, kindex)
            inslots = inslots + 1
 
            putMSG$MsgType$I ($OSWht$RMsg)
 
            call get_msgtimes ($WOSIS$RDelay)
 
            msg$dcteename$c = xunt$name$c
            putmsg$dcteename$c
 
            MSG$Latitude$F = xunt$assumedlatitude$f
            MSG$Longitude$F = xunt$assumedlongitude$f
            putMSG$Latitude$F
            putMSG$Longitude$F
 
            MSG$TrueLat$F = xunt$TrueLatitude$F
            MSG$TrueLong$F = xunt$TrueLongitude$F
            putMSG$TrueLat$F
            putMSG$TrueLong$F
 
            MSG$Course$I = int(xunt$truecourse$f * 180/$pi + .5)
            MSG$Speed$I = int(xunt$truespeed$f + .5)
            putMSG$Course$I
            putMSG$Speed$I
           }
       }
   }
 
return
end
 

 
Subroutine inselor (igoldsel)
######################################################################
###
### Collects SELOR message data for a delayed Rainform/Gold message.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
real oldtime[SSR$slots]
integer   iside, isat, issr, igoldsel, imsg, ilost, ihalftime
integer   x, intv, idelay, itrkview # jb E2145 (x)  8/7/00
real       random2
literal   cstrip8, cstrip
BBDeclare(SSR$FingerPrinted$I, SSC$Pointer, MSG$SelRad$I,
	  UNT$Type$I, MSG$MsgType$I, MSG$FingerPrinted$I,
          SSR$DetectTime$F,SAT$SatelliteName$C,MSG$TrackCode$C,
	  MSG$TrackNo$I)
 
for (ssr$pointer$first; ssr$pointer$valid; ssr$pointer$next)
   {
    idctor = xssr$detectorindx$i	# save detector index
    idctee = xssr$detecteeindx$i	# save detectee index
    ssr$DetectTime$f = xssr$DetectTime$f
    ssr$FingerPrinted$I = xssr$FingerPrinted$I
 
    if (idctor == 0) next               # no detector
    if (idctee == 0) next               # no detectee
 
    unt$pointer$to idctee                        # determine side of satellite
    call whside (xunt$view$i, iside)             # target...if Blue target,
    if (iside == $blue$code) next                # skip it
 
    if (xssr$tracknumber$i == 0) next             # means data is garbage
 
    sat$pointer$to idctor                         # detector
    isat = sat$pointer$index
 
    SAT$SatelliteName$C = xSAT$SatelliteName$C
 
    ssc$pointer$to xsat$SscIndx$i
 
    issr = ssr$pointer$index
    if (issr == 0) next
 
    if (xssc$radarsensor$i == $yes)  msg$selrad$i = $yes
    else                             msg$selrad$i = $no
    putmsg$selrad$i
 
    if (igoldsel == YES)  # if a GOLD msg
       {
        #----------------------------------------------------------------------
        #   If this is a first/regained detection, or the detection is lost for
        #   5 minutes, or the next interval has come up, send a message.  The
        #   exception to interval messages is that if a first/regained detection
        #   occurs within 1/2 of the interval time, no interval message will be
        #   sent.  Otherwise...
        #   If the detectee (contact) type is air, check to see if the game
        #   minute is a multiple of the SELOR air interval (RGIntv$GSELa).  If
        #   so, send a message.  Otherwise, go to the next contact.
        #   If the detectee (contact) type is surface, check to see if the game
        #   minute is a multiple of the SELOR surface interval (RGIntv$GSELs).
        #   If so, send a message.
        #   If none of the above, go to the next contact.
        #----------------------------------------------------------------------
        imsg = nomsg
        ilost = $no
        unt$type$i = xunt$type$i
 
        if (unt$type$i == $air$code)
           {
            if (RGIntv$GSELa == nomsg) next
 
            if (int(ssr$DetectTime$f) == msg_minute & oldtime[issr] == 0)
               {
                imsg = sendmsg
               }
            else if (ssr$DetectTime$f + 5 <= msg_minute &
                     ssr$DetectTime$f != oldtime[issr])
               {
                imsg = sendmsg
                ilost = $yes
               }
 
            ihalftime = (RGIntv$GSELa * .5)
            if ((msg_minute - RGLastTime$GSELa) >= RGIntv$GSELa)
            {
                intv = sendmsg
                RGLastTime$GSELa = msg_minute
            }
            else
                intv = nomsg
 
 
            if (intv == sendmsg & int(ssr$DetectTime$f) == msg_minute &
               (oldtime[issr] + ihalftime) <= msg_minute)
               {
                imsg = sendmsg
               }
           }
        else if (unt$type$i == $Surface$Code |
                 unt$type$i == $SurfaceWithAC$Code |
                 unt$type$i == $sub$Code)
           {
            if (RGIntv$GSELs == nomsg) next
 
            if (int(ssr$DetectTime$f) == msg_minute & oldtime[issr] == 0)
               {
                imsg = sendmsg
               }
            else if (ssr$DetectTime$f + 5 <= msg_minute &
                     ssr$DetectTime$f != oldtime[issr])
               {
                imsg = sendmsg
                ilost = $yes
               }
 
            ihalftime = (RGIntv$GSELs * .5)
            if ((msg_minute - RGLastTime$GSELs) >= RGIntv$GSELs)
            {
                intv = sendmsg
                RGLastTime$GSELs = msg_minute
            }
            else
                intv = nomsg
 
 
            if (intv == sendmsg & int(ssr$DetectTime$f) == msg_minute &
               (oldtime[issr] + ihalftime) <= msg_minute)
               {
                imsg = sendmsg
               }
           }
 
        if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
 
        if (ilost == $yes) oldtime[issr] = 0
        else               oldtime[issr] = ssr$DetectTime$f
 
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        if (xssc$radarsensor$i == $yes)  msg$selrad$i = $yes
        else                             msg$selrad$i = $no
        putmsg$selrad$i
 
        putMSG$MsgType$I
 
        #---------------------------------------------------------------------
        #   GOLD messages...
        #
        #   For CPX, contact is ALWAYS fingerprinted.  Contacts will be
        #   designated WIZARD or SELOR depending on the CLASSWZRD value in
        #   the Init File.  Default is WIZARD 25% and SELOR 75%.
        #   Other than CPX, if message is WIZARD type, contacts will be
        #   BOTH DESIGNATED as WIZARD and FINGERPRINTED according to CLASSWZRD
        #   value in the Init File.  Default is WIZARD 25% and SELOR 75%
        #----------------------------------------------------------------------
        if (RGCPX$Out == YES)
           {
            MSG$FingerPrinted$I = $yes
 
            if (RGClass$Wzd <= 0) RGClass$Wzd = 25
 
            if (random2(x)*100 <= RGClass$Wzd) MSG$MsgType$I = $GWIZARD$RMsg
            else                              MSG$MsgType$I = $GSELOR$RMsg
           }
        else
           {
            if (RGClass$Wzd <= 0) RGClass$Wzd = 25
 
            if (random2(x)*100 <= RGClass$Wzd)
               {
                MSG$FingerPrinted$I = $yes
                MSG$MsgType$I = $GWIZARD$RMsg
                idelay = $GWIZ$RDelay
               }
            else
               {
                MSG$FingerPrinted$I = $no
                MSG$MsgType$I = $GSELOR$RMsg
                idelay = $GSEL$RDelay
               }
           }
        call get_msgtimes (idelay)
 
        putMSG$MsgType$I
        putMSG$FingerPrinted$I
 
        call ingoldmsg           # Make a GOLD msg
 
        itrkview = xssr$ReporteeView$i
        vue$pointer$to itrkview
        msg$trackcode$c = xvue$trackcode$c
        putmsg$trackcode$c
 
        msg$trackno$i = xssr$tracknumber$i
        putmsg$trackno$i
       }
    else                     # a SELOR RED message
       {
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        if (xssc$radarsensor$i == $yes)  msg$selrad$i = $yes
        else                             msg$selrad$i = $no
        putmsg$selrad$i
 
        MSG$MsgType$I = $SELOR$RMsg
        putMSG$MsgType$I
 
        call get_msgtimes ($SELOR$RDelay)
 
        if (SSR$FingerPrinted$I == $yes)  MSG$FingerPrinted$I = $yes
        else                              MSG$FingerPrinted$I = $no
 
        putMSG$FingerPrinted$I
 
        call inselmsg           # Make a SELOR RED msg
 
        itrkview = xssr$ReporteeView$i
        vue$pointer$to itrkview
        msg$trackcode$c = xvue$trackcode$c
        putmsg$trackcode$c
 
        msg$trackno$i = xssr$tracknumber$i
        putmsg$trackno$i
       }
   }
 
return
end
 

 
Subroutine insosus (igoldsos)
######################################################################
###
### Collects SOSUS message data for a delayed Rainform/Gold message.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
real oldtime[SOS$slots]
integer   isos, imsg, ilost, igoldsos, ihalftime, i, icutoffr, equal_hv
BBDeclare(UNT$SOPIndx$I, SOP$Pointer, MSG$SOSUSReg$I,
	  MSG$MsgType$I, MSG$TrackNo$I,SOS$LastDetTime$F,
	  MSG$TrackCode$C)
 
for (sos$pointer$first; sos$pointer$valid; sos$pointer$next)
   {
    if (imin == 0) next
 
    idctee = xsos$detectee$i 	# save detectee index
    if (idctee == 0) next       # no dectee
 
    unt$pointer$to idctee
    unt$SopIndx$I = xunt$SopIndx$I
    sop$pointer$to unt$SopIndx$I
 
    sosregion = xSOP$RegionId$I    # get SOSUS region
    if (sosregion == 0) next       # not a SOSUS region
 
    MSG$SosusReg$I = sosregion
    putMSG$SosusReg$I
 
    isos = sos$pointer$index
 
    sos$LastDetTime$f = xsos$LastDetTime$f
    #----------------------------------------------------------------------
    #   Generate a SOSUS msg on first sub detection and when detection is
    #   going to fade + 3 game minutes.  Otherwise, send message at SOS GOLD
    #   interval.
    #----------------------------------------------------------------------
    isos = sos$pointer$index
    imsg = nomsg
    ilost = $no
 
    if (igoldsos == $yes)                # if time for a GOLD msg
        {
         if (int(sos$LastDetTime$f) == msg_minute & oldtime[isos] == 0)
            {
             imsg = sendmsg
            }
         else if (sos$LastDetTime$f + 5 <= msg_minute &
                  sos$LastDetTime$f != oldtime[isos])
            {
             imsg = sendmsg
             ilost = $yes
            }
         else if (xunt$type$i == $Sub$Code)
            {
            ihalftime = (RGIntv$GSOS * .5)
            if ((msg_minute - RGLastTime$GSOS) >= RGIntv$GSOS)
            {
                imsg = sendmsg
                RGLastTime$GSOS = msg_minute
            }
            else
                imsg = nomsg
 
 
            if (imsg == sendmsg & int(sos$LastDetTime$f) == msg_minute &
               (oldtime[isos] + ihalftime) <= msg_minute)
               {
               }
            }
 
        if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
 
         if (ilost == $yes) oldtime[isos] = 0
         else               oldtime[isos] = sos$LastDetTime$f
 
         idctor = 0
         call getslot (idctor, idctee)
         inslots = inslots + 1
 
         MSG$MsgType$I = $GSOSUS$RMsg
         putMSG$MsgType$I
 
         call get_msgtimes ($GSOS$RDelay)
 
         call ingoldmsg           # Make a GOLD msg
 
         i = 0
         call smov ($Blue$Designator, msg$trackcode$c, i)
         putmsg$trackcode$c
 
         msg$trackno$i = xsos$sequencenmbr$i
         putmsg$trackno$i
 
         putMSG$SWABStrk$I ($NO)       # Not a swabs track
 
$BISTAT  putMSG$Bistatic$I (xSOS$BistaticDetection$I)
        }
    else
        {
         icutoffR = msg_minute - RGIntv$SOS
         if (oldtime[isos] == 0 & sos$LastDetTime$f < icutoffR)
           {
            oldtime[isos] = sos$LastDetTime$f
            next
           }
         else if (oldtime[isos] == sos$LastDetTime$f) next
         oldtime[isos] = sos$LastDetTime$f
 
         idctor = 0
         call getslot (idctor, idctee)
         inslots = inslots + 1
 
         msg$msgtype$i = $SOSUS$RMsg
         putMSG$MsgType$I
 
         call get_msgtimes ($SOSUS$RDelay)
 
         call insosmsg
 
         i = 0
         call smov ($Blue$Designator, msg$trackcode$c, i)
         putmsg$trackcode$c
 
         msg$trackno$i = xsos$sequencenmbr$i
         putmsg$trackno$i
        }
   }
 
return
end
 

 
Subroutine inhfdf (igoldhfd)
######################################################################
###
### Collects HFDF message data for a delayed Rainform/Gold message.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
real oldtime[HFD$slots]
integer	    iside, ihfd, imsg, igoldhfd, icutoffr, i
BBDeclare(MSG$MsgType$I, MSG$TrackNo$I, MSG$Classified$I,
          HFD$LastDetTime$F,MSG$TrackCode$C)
 
for (hfd$pointer$first; hfd$pointer$valid; hfd$pointer$next)
   {
    idctor = xhfd$detector1$i	
    idctee = xhfd$detectee$i	
    hfd$LastDetTime$f = xhfd$LastDetTime$f
 
    if (idctor == 0) next
    if (idctee == 0) next
 
    unt$pointer$to idctee
    call whside(xunt$view$i,iside)                # determine side
    if (iside == $blue$code ) next                # if Blue track, skip it
 
    if (imin == 0) next
 
    #----------------------------------------------------------------------
    #   Generate a HFDF msg on first detection. Since HFDF detections are of
    #   such short duration, generating messages when the signal fades or
    #   at intervals is not appropriate.
    #----------------------------------------------------------------------
    ihfd = hfd$pointer$index
    imsg = nomsg
 
    if (igoldhfd == $yes)
        {
         if      (oldtime[ihfd] == hfd$LastDetTime$f) next
         else if (int(hfd$LastDetTime$f) == msg_minute)
            {
             imsg = sendmsg
            }
 
         if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
         oldtime[ihfd] = hfd$LastDetTime$f
 
         call getslot (idctor, idctee)
         inslots = inslots + 1
 
         MSG$MsgType$I = $GHFDF$RMsg
         putMSG$MsgType$I
 
         call get_msgtimes ($GHFD$RDelay)
 
         call ingoldmsg                         # Make a GOLD msg
        }
    else
       {
        icutoffR = msg_minute - RGIntv$HFD
        if (oldtime[ihfd] == 0 & hfd$LastDetTime$f < icutoffR)
           {
            oldtime[ihfd] = hfd$LastDetTime$f
            next
           }
        else if (oldtime[ihfd] == hfd$LastDetTime$f) next
        oldtime[ihfd] = hfd$LastDetTime$f
 
        call getslot (idctor, idctee)
        inslots = inslots + 1
 
        MSG$MsgType$I = $HFDF$RMsg
        putMSG$MsgType$I
 
        call get_msgtimes ($HFDF$RDelay)
 
        call inhfdfms                         # Make a HFDF RED msg
       }
    i = 0
    call smov ($Blue$Designator, msg$trackcode$c, i)
    putmsg$trackcode$c
 
    msg$trackno$i = xhfd$sequencenmbr$i
    putmsg$trackno$i
 
    MSG$Classified$I = YES
    putMSG$Classified$I
   }
 
return
end
 

 
 
Subroutine getslot (index1, index2)
####################################################################
#
#  Finds a slot in the RAINFORM Msg table.
#
####################################################################
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer  index1, index2
BBDeclare(MSG$TblDctor$I, MSG$TblDctee$I)
 
for (msg$pointer$first; msg$pointer$valid; msg$pointer$next)
   {
    if (xMSG$MsgDTG$I == 0)  break    # if Msg slot empty, break loop
   }
 
if (!msg$pointer$valid)
   {
    call echor
    call echov ("RAINFORM Messages Lost -- DMDBase Full.")
 
    msg$pointer = 0
    return
   }
 
if (msg$pointer > msg$last)  msg$last$to msg$pointer + msg$entry - 1
 
if (index1 == 0) msg$tbldctor$i = notlisted
else             msg$tbldctor$i = index1
if (index2 == 0) msg$tbldctee$i = notlisted
else             msg$tbldctee$i = index2
 
putmsg$tbldctor$i
putmsg$tbldctee$i
 
return
end
 

 
Subroutine inredmsg
#####################################################################
#
#  Collects RED data for a delayed RAINFORM RED message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer idettype
 
call intype                      ## what type contact ie, air, sub, surface,
                                 ## then generate appropriate msg line
idettype = xrmt$detectiontype$i
if (idettype == $PassiveSonar$Code)
   {
    call inbrng
    call intime
   }
else call intmpos
 
return
end
 

 
Subroutine instsmsg
#####################################################################
#
#  Collects SURTASS data for a delayed RAINFORM RED SURTASS message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
call intype                      ## what type contact ie, air, sub, surface,
                                 ## then generate appropriate msg line
call inelip
call intime
 
return
end
 

 
Subroutine ingoldmsg
#####################################################################
#
#  Collects GOLD data for a delayed RAINFORM GOLD message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
BBDeclare(MSG$MsgType$I, MSG$SelRad$I)
 
unt$pointer$to idctee
 
call incontact
 
msg$msgtype$i = xmsg$msgtype$i
msg$selrad$i = xmsg$selrad$i
 
if (msg$msgtype$i == $gesm$rmsg)
   {
    call inrad
    call inlob
   }
else if ((msg$msgtype$i == $gselor$rmsg | msg$msgtype$i == $gwizard$rmsg) &
         (msg$selrad$i == $no))
   {
    call inrad
    call inpos
   }
else if (msg$msgtype$i == $gsonbp$rmsg | msg$msgtype$i == $gsonp$rmsg |
        (msg$msgtype$i == $ghfdf$rmsg & xMSG$ElpsExists$I == $no))
# N.B. MSG$ElpsExists$I set by subroutine incontact
   {
    call inlob
   }
else  call inpos
 
return
end
 

 
Subroutine inselmsg
####################################################################
#
#      Build SELOR Red message and sends via network
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
integer itype, i_switch_1, iloc
BBDeclare(MSG$MsgType$I)
 
MSG$MsgType$I = $SELOR$RMsg
putMSG$MsgType$I
 
unt$pointer$to idctee                        # determine side of satellite
itype = xunt$type$i
 
switch (itype)
   {
    case $air$code: {call inair}
    case $sub$code: {call insubs}
    case $surfacewithac$code, $surface$code:
       {
        call get_status (idctee, status)
        if (status == $mer$rship|
            status == $fsh$rship|
            status == $nav$rship|
            status == $sts$rship) call inship
        else                      call inunk
       }
    default: call inunk
   }
 
call inposel
 
if (xmsg$selrad$i == $no)  call inrad
 
return
end
 

 
Subroutine inesmmsg
#####################################################################
##
##     Builds Red-ESM message and sends via network
##
#####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
BBDeclare(MSG$MsgType$I)
 
idctor = xrmt$detector$i	#save detector index
idctee = xrmt$detectee$i	#save detectee index
 
MSG$MsgType$I = $ESM$RMsg
putMSG$MsgType$I
 
call intype
call inrad
call inbrng
call intime
 
return
end
 

 
Subroutine inhfdfms
####################################################################
#
#  Collects HFDF line data for a delayed Rainform/Gold message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
literal cstrip8
BBDeclare(MSG$MsgType$I, MSG$HFDFreq$I, MSG$ElpsExists$I,
	  MSG$DctorName$C,MSG$DcteeName$C)
 
idctor = xhfd$detector1$i	# save detector index
idctee = xhfd$detectee$i	# save detectee index
 
MSG$MsgType$I = $HFDF$RMsg
putMSG$MsgType$I
 
unt$pointer$to idctor        # detector
 
MSG$DctorName$C = xunt$name$c
putMSG$DctorName$C
 
unt$pointer$to idctee
MSG$DcteeName$C = xunt$name$c
putMSG$DcteeName$C
 
MSG$HFDFreq$I = xhfd$frequency$i
putMSG$HFDFreq$I
 
if (xhfd$elpsexists$i == 0)
   {
    call inlobs
    msg$elpsexists$i = $no
    putmsg$elpsexists$i
   }
else
   {
    call inelip
    msg$elpsexists$i = $yes
    putmsg$elpsexists$i
   }
 
return
end
 

 
Subroutine insosmsg
####################################################################
#
#  Collects SOSUS line data for a delayed Rainform/Gold message.
#
####################################################################
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
real   random2
Integer x                   # jb E2145 (x)  8/7/00
BBDeclare(MSG$Lines$I, MSG$MsgType$I)
 
idctee = xsos$detectee$i 	# save detectee index
 
msg$lines$i = $no
 
msg$msgtype$i = $SOSUS$RMsg
putMSG$MsgType$I
 
call insubs
 
if (random2(x) <= .50)
    {
     call inelip
     call intime
     msg$lines$i = $yes
    }
else call intmpos
 
putmsg$lines$i
 
return
end
 

 
Subroutine intype
###################################################################
#
#      This subroutine chooses the unit type (air, sub, surface)
#      that identifies the target.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
integer itype, iloc
 
idctor = xrmt$detector$i 	# save detector index
idctee = xrmt$detectee$i	# save detectee index
 
unt$pointer$to idctee           # detectee
 
itype = xunt$type$i
 
if      (itype == $air$code) call inair
else if (itype == $sub$code) call insubs
else if (itype == $surfacewithac$code | itype == $surface$code)
   {
    if (xmsg$classified$i == $no) call inunk
    else
       {
        call get_status (idctee, status)
        if (status == $mer$rship|
            status == $fsh$rship|
            status == $nav$rship) call inship
        else                      call inunk
       }
   }
else call inunk
 
return
end
 

 
Subroutine inair
####################################################################
#
#  Collects AIR line data for a delayed Rainform message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
literal cstrip8
BBDeclare(MSG$UnitType$I, MSG$Composition$I, MSG$AltDepth$I,
          UNT$Name$C,MSG$DcteeName$C, MSG$DctorName$C)
 
MSG$UnitType$I = $air$rtype
putMSG$UnitType$I
 
unt$pointer$to idctee
unt$name$c = xunt$name$c
 
MSG$DcteeName$C = unt$name$c
putMSG$DcteeName$C
 
if (xMSG$MsgType$I == $SELOR$RMsg)
   {
    sat$pointer$to idctor                         # detector
    msg$dctorname$c = xsat$satellitename$c
    putmsg$dctorname$c
   }
else
   {
    MSG$Composition$I = xrmt$composition$i
    putMSG$Composition$I
 
    unt$pointer$to idctee
    MSG$AltDepth$I = xunt$truealtdepth$i/100   # clk 6/96 (E1607) - 100 vice 1000
    putMSG$AltDepth$I
 
    unt$pointer$to idctor
    MSG$DctorName$C = xunt$name$c
    putMSG$DctorName$C
   }
 
return
end
 

 
Subroutine insubs
####################################################################
#
#  Collects SUB line data for a delayed Rainform message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer ictcnum
literal cstrip8
BBDeclare(MSG$UnitType$I, MSG$MsgType$I, SOS$PropulsionMode$I,
          MSG$PropMode$I, MSG$TmarkSeq$I, MSG$DcteeName$C,
	  MSG$DctorName$C)
 
MSG$UnitType$I = $sub$rtype
putMSG$UnitType$I
 
msg$msgtype$i = xmsg$msgtype$i
 
if (msg$msgtype$i == $SOSUS$RMsg)
   {
    unt$pointer$to xsos$detectee$i
    MSG$DcteeName$C = xunt$name$c
    putMSG$DcteeName$C
 
    sos$propulsionmode$i = xsos$propulsionmode$i
 
    if  (sos$propulsionmode$i==$electric$code |
         sos$propulsionmode$i==$nuclear$code)
          {
           msg$propmode$i = $nuclear$prop
          }
   else if (sos$propulsionmode$i==$diesel$code)
          {
           msg$propmode$i = $diesel$prop
          }
   else
          {
           msg$propmode$i = $unknown$prop
          }
    putmsg$propmode$i
   }
else if (MSG$MsgType$I == $SELOR$RMsg)
   {
    unt$pointer$to xssr$detecteeindx$i
 
    MSG$DcteeName$C = xunt$name$c
    putMSG$DcteeName$C
   }
else
   {
    idctee = xrmt$detectee$i
    idctor = xrmt$detector$i
 
    unt$pointer$to idctor
    MSG$DctorName$C = xunt$name$c
    putMSG$DctorName$C
 
    unt$pointer$to idctee
    MSG$DcteeName$C = xunt$name$c
    putMSG$DcteeName$C
 
    if (jcnt[idctor, idctee] == 0)
       {
        call contactnum (ictcnum)
        msg$tmarkseq$i = ictcnum
       }
    else msg$tmarkseq$i = jcnt[idctor, idctee]
    putMSG$TMarkSeq$I
 
    if (xunt$propulsionmode$i == $diesel$code)
       {
        msg$propmode$i = $diesel$prop
       }
    else if (xunt$propulsionmode$i == $nuclear$code |
            xunt$propulsionmode$i == $electric$code)
       {
        msg$propmode$i = $nuclear$prop
       }
    else
       {
        msg$propmode$i = $unknown$prop
       }
    putmsg$propmode$i
   }
 
return
end
 

 
Subroutine inship
####################################################################
#
#  Collects MER, FSH, NAV line data for a delayed Rainform message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
literal cstrip8
BBDeclare(MSG$DctorName$C, MSG$DcteeName$C, MSG$UnitType$I)
 
if (xMSG$MsgType$I == $SELOR$RMsg)
   {
    sat$pointer$to idctor                         # detector
    msg$dctorname$c = xsat$satellitename$c
    putmsg$dctorname$c
   }
else
   {
    unt$pointer$to idctor
    MSG$DctorName$C = xunt$name$c
    putMSG$DctorName$C
   }
unt$pointer$to idctee
 
MSG$DcteeName$C = xunt$name$c
putMSG$DcteeName$C
 
MSG$UnitType$I = xunt$type$i
putMSG$UnitType$I
 
return
end

 
Subroutine inunk
####################################################################
#
#  Collects UNK line data for a delayed Rainform message.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer idctortype, ictcnum, idettype
literal cstrip8
BBDeclare(MSG$UnitType$I, MSG$Sensor$I, RMT$Detectee$I,
	  MSG$TmarkSeq$I, MSG$DcteeName$C, MSG$DctorName$C)
 
MSG$UnitType$I = $unk$rtype
putMSG$UnitType$I
 
if (xmsg$msgtype$i == $SOSUS$RMsg)
   {
    unt$pointer$to xSOS$Detectee$I
    MSG$DcteeName$C = xunt$name$c
    putMSG$DcteeName$C
 
    MSG$Sensor$I = $SOSUS$RSens
    putMSG$Sensor$I
   }
else
   {
    unt$pointer$to xrmt$detector$i
    MSG$DctorName$C = xunt$name$c
    putMSG$DctorName$C
    idctortype = xunt$type$i
 
    rmt$detectee$i = xrmt$detectee$i
    unt$pointer$to rmt$detectee$i
    MSG$DcteeName$C = xunt$name$c
    putMSG$DcteeName$C
 
    idctee = xrmt$detectee$i
    idctor = xrmt$detector$i
 
    if (jcnt[idctor, idctee] == 0)
       {
        call contactnum (ictcnum)
        msg$tmarkseq$i = ictcnum
       }
    else msg$tmarkseq$i = jcnt[idctor, idctee]
    putMSG$TMarkSeq$I
 
    idettype = xrmt$detectiontype$i
    if      (idettype == $ESM$code)
       {
        if (idctortype == $air$code)         MSG$Sensor$I = $AESM$RSens
        else                                 MSG$Sensor$I = $ESM$RSens
       }
    else if (idettype == $ActiveVisual$Code) MSG$Sensor$I = $VISUAL$RSens
    else if (idettype == $ActiveNonVisual$Code)
       {
        if (Xrmt$LastDetType$i == $Radar$Type) MSG$Sensor$I = $RADAR$RSens
                                               # 2/1/91
        else                                   MSG$Sensor$I = $SONACT$RSens
       }
    else if (idettype == $PassiveSonar$Code)
       {
        if (xMSG$MsgType$I == $Sts$RMsg) MSG$Sensor$I = $TASS$RSens
        else                             MSG$Sensor$I = $SONPAS$RSens
       }
    putMSG$Sensor$I
   }
 
return
end
 
 

 
Subroutine incontact
####################################################################
#
#  Collects Contact line data for a delayed Gold Rainform message.
#
# Modified:    John McCormick - 5/99 (E2083)
#              Load IFF mode 2 field if equipment on and mode 2 set.
#
# Modified:    John McCormick - 5/99 (E2087)
#              Track classification (CTC field force) now based
#              on RESA track class, not track number.
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
literal cstrip8
integer ictcnum, idettype, itype, i_switch_1, ltype
BBDeclare(MSG$MsgType$I, UNT2$Pointer, MSG$ElpsExists$I, MSG$TmarkSeq$I,
          RMT$TargetId$I, ACC$Category$I, MSG$UnitType$I,
          MSG$PlatType$I, DEQ$IFFMode2$I, DEQ$Pointer, MSG$IFFMode2$I,
          MSG$DcteeName$C, MSG$DctorName$C, UNT$Name$C)
 
unt$pointer$to idctee
MSG$DcteeName$C = xunt$name$c
 
# In the case of a sosus or swabs message idctor = 0		clf 8/9/94
#    and the sosus/swabs region overlays the detector name
 
msg$msgtype$i = xmsg$msgtype$i
if (msg$msgtype$i == $Gselor$RMsg | msg$msgtype$i == $Gwizard$RMsg)
   {
    MSG$DctorName$C = xsat$satellitename$c
    putMSG$DctorName$C
   }
else if (msg$msgtype$i == $Ghfdf$RMsg)
   {
    unt2$pointer$to xHFD$Detector1$I
    MSG$DctorName$C = xunt2$name$c
    putMSG$DctorName$C
    MSG$ElpsExists$I = xHfd$ElpsExists$I
    putMSG$ElpsExists$I
   }
else if (msg$msgtype$i == $GIR$RMsg)
   {
    idctee = xIRD$Target$I
    unt$pointer$to idctee
    MSG$DcteeName$C = xUNT$Name$C
    idctor = xIRD$Detector$I
    unt2$pointer$to idctor
    MSG$DctorName$C = xUNT2$Name$C
    putMSG$DctorName$C
   }
else if (msg$msgtype$i ^= $Gsosus$RMsg & msg$msgtype$i ^= $Gswabs$RMsg)
   {
    UNT2$pointer$to idctor
    MSG$DctorName$C = xunt2$name$c
    putMSG$DctorName$C
 
# these should already be set!!!!!
    idctee = xrmt$detectee$i
    idctor = xrmt$detector$i
 
    if (jcnt[idctor, idctee] == 0)
       {
        call contactnum (ictcnum)
        msg$tmarkseq$i = ictcnum
       }
    else msg$tmarkseq$i = jcnt[idctor, idctee]
    putMSG$TMarkSeq$I
   }
putMSG$DcteeName$C
 
unt$name$c = xunt$name$c
 
idettype = xrmt$detectiontype$i     # where is this used???  clf 4/23/93
itype = xunt$type$i
 
RMT$TargetID$I = xRMT$TargetId$I     # JHM 5/99 (E2087) to implement CTC force field
putMSG$TargetID$I(RMT$TargetId$I)    # from RMT rather than trk #
 
switch (itype)
   {
    case $air$code:
        {
        acc$pointer = xunt$accpntr$i
        acc$category$i = xacc$category$i
        call inaircat (acc$category$i)
        msg$unittype$i = $air$rtype
        }
    case $sub$code:            {msg$unittype$i = $sub$rtype}
    case $surfacewithac$code:  {msg$unittype$i = $surfwac$rtype}
    case $surface$code:        {msg$unittype$i = $surf$rtype}
   }
 
if (idctor ^= 0)
    {
    unt2$pointer$to idctor
    ltype = xunt2$type$i
 
    switch (ltype)
       {
        case $air$code:            {msg$plattype$i = $air$rtype}
        case $sub$code:            {msg$plattype$i = $sub$rtype}
        case $surfacewithac$code:  {msg$plattype$i = $surfwac$rtype}
        case $surface$code:        {msg$plattype$i = $surf$rtype}
        case $ShoreBase$code:      {msg$plattype$i = $ROTHRsite$rtype}
       }
 
    if (ltype == $air$code & itype == $sub$code) msg$unittype$i = $airsub$rtype
    }
else msg$plattype$i = 0
 
putmsg$plattype$i
putmsg$unittype$i
 
 
if( (itype == $air$code) | (itype == $surface$code) )
    # does this unit have mode2 IFF active - JHM 5/99 (E2083)
   {   # if active, does it have mode2 set
    DEQ$IFFMode2$I = 0
    for_DEQ_chain (UNT$Pointer$index)
     {
      if ((xDEQ$Ident$I == $IFF$Code) &
        (xDEQ$On$I == $yes))
        {
            DEQ$IFFMode2$i = xDEQ$IFFMode2$i
            if(DEQ$IFFMode2$i > 0)
               break
         }
      } # end of search through DEQ table
 
     if(DEQ$IFFMode2$I > 0)    # track has iff mode 2
         {
          MSG$IFFMode2$i = DEQ$IFFMode2$I
          putMSG$IFFMode2$i
         }
   } #end if air or surface    end new iff block JHM 5/99 (E2083)
 
 
return
end

 
Subroutine delaycat
####################################################################
#
#  Enters the appropriate delay catagory for intype
#
####################################################################
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer itype, i_switch_1, idelaycat
 
unt$pointer$to idctor           # detector
 
itype = xunt$type$i
 
switch (itype)
   {
    case $air$code:                          {idelaycat = $Air$RDelay}
    case $sub$code:                          {idelaycat = $Sub$RDelay}
    case $surfacewithac$code, $surface$code: {idelaycat = $Ship$RDelay}
    default:                                 {idelaycat = $Unk$RDelay}
   }
 
call get_msgtimes (idelaycat)
 
return
end
 

 
Subroutine inrad
####################################################################
#
#  Collects RADID, RADPA & RAD line data for delayed RAINFORM and OTH-T
#  GOLD messages, respectively.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer iseqnum[max$unts]
integer indx
integer inum /0/
BBDeclare(MSG$MsgType$I, MSG$EmitPntrIndx$I, MSG$SeqCtcNbr$I)
 
msg$msgtype$i = xmsg$msgtype$i
if (msg$msgtype$i == $selor$RMsg |      # SELOR RED msg
    msg$msgtype$i == $Gselor$RMsg|      # SELOR Gold msg
    msg$msgtype$i == $Gwizard$RMsg|     # WIZARD Gold msg
    msg$msgtype$i == $Stelnt$RMsg|      # SELOR TACELINT msg
    msg$msgtype$i == $Stcpelnt$RMsg)    # SELOR TACREP msg
   {
    msg$emitpntrindx$I = xssr$emitterindx$i
    inum = inum + 1
    MSG$SeqCtcNbr$I = inum
   }
else
   {
    msg$emitpntrindx$I = xrmt$emitterpntr$i
    indx = xrmt$detector$i
    iseqnum(indx) = iseqnum(indx) + 1
    MSG$SeqCtcNbr$I = iseqnum(indx)
   }
 
putmsg$emitpntrindx$i
putMSG$SeqCtcNbr$I
 
return
end
 

 
Subroutine intmpos
####################################################################
#
#  Collects TMPOS line data for delayed RAINFORM messages.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer idctortype, idettype
BBDeclare(MSG$Sensor$I, MSG$Course$I, MSG$Speed$I,
    	  MSG$Latitude$F, MSG$Longitude$F)
 
unt$pointer$to xrmt$detector$i
idctortype = xunt$type$i
 
if (xmsg$msgtype$i == $sosus$rmsg)
    {
     MSG$Sensor$I = $SOSUS$RSens
 
     MSG$Latitude$F = xsos$offsetlat$f
     MSG$Longitude$F = xsos$offsetlon$f
 
     MSG$Course$I = xsos$course$i
     MSG$Speed$I = xsos$speed$i
    }
else
    {
     idettype = xrmt$detectiontype$i
     if      (idettype == $ESM$code)
       {
        if (idctortype == $air$code)          MSG$Sensor$I = $AESM$RSens
        else                                  MSG$Sensor$I = $ESM$RSens
       }
     else if (idettype == $ActiveVisual$Code) MSG$Sensor$I = $VISUAL$RSens
     else if (idettype == $ActiveNonVisual$Code)
        {
         if (Xrmt$LastDetType$i == $Radar$Type) MSG$Sensor$I = $RADAR$RSens  # 2/1/91
         else                                   MSG$Sensor$I = $SONACT$RSens
        }
     else if (idettype == $PassiveSonar$Code) MSG$Sensor$I = $SONPAS$RSens
 
     MSG$Latitude$F = xrmt$apparentlat$f
     MSG$Longitude$F = xrmt$apparentlon$f
 
     MSG$Course$I = xrmt$course$i
     MSG$Speed$I = xrmt$speed$i
    }
putMSG$Sensor$I
putMSG$Latitude$F
putMSG$Longitude$F
putMSG$Course$I
putMSG$Speed$I
 
return
end
 

 
Subroutine inposel
####################################################################
#
#  Collects POSEL line data for delayed RAINFORM messages.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
BBDeclare(MSG$Latitude$F, MSG$Longitude$F,
          MSG$Bearing$I, MSG$MajorAxis$I, MSG$MinorAxis$I)
 
unt$pointer$to idctee
 
MSG$Latitude$F = xunt$truelatitude$f
MSG$Longitude$F = xunt$truelongitude$f
 
MSG$Bearing$I = xssr$orientation$i	
MSG$MajorAxis$I = xssr$semimajoraxis$i
MSG$MinorAxis$I = xssr$semiminoraxis$i
 
putMSG$Latitude$F
putMSG$Longitude$F
putMSG$Bearing$I
putMSG$MajorAxis$I
putMSG$MinorAxis$I
 
return
end
 

 
Subroutine inpos
####################################################################
#
#  Collects POS line data for delayed OTH-T Gold messages.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer iimaj, iimin, idctortype
BBDeclare(MSG$MsgType$I, MSG$Sensor$I, MSG$Bearing$I, MSG$MajorAxis$I,
          MSG$MinorAxis$I, MSG$Course$I, MSG$Speed$I, MSG$AltDepth$I,
    	  RMT$DetectionType$I, MSG$Latitude$F, MSG$Longitude$F,
	  MSG$TrueLat$F, MSG$TrueLong$F)
 
putMSG$Bearing$I  (0)
putMSG$MajorAxis$I  (0)
putMSG$MinorAxis$I  (0)
putMSG$Course$I  (0)
putMSG$Speed$I  (0)
putMSG$AltDepth$I  (0)
putMSG$Sensor$I  (0)
 
msg$msgtype$i  = xmsg$msgtype$i
 
if (msg$msgtype$i == $gselor$rmsg | msg$msgtype$i == $gwizard$rmsg)
   {
    unt$pointer$to xssr$detecteeindx$i     # set unit pointer to survsat
 
    MSG$Sensor$I = $SELOR$RSens
    putMSG$Sensor$I
 
    MSG$Latitude$F = xssr$OffLatCenter$f
    MSG$Longitude$F = xssr$OffLonCenter$f
 
    MSG$Bearing$I = xssr$orientation$i
    putMSG$Bearing$I
    MSG$MajorAxis$I = xssr$semimajoraxis$i
    putMSG$MajorAxis$I
    MSG$MinorAxis$I = xssr$semiminoraxis$i
    putMSG$MinorAxis$I
 
    MSG$Course$I = int(xunt$truecourse$f * 180/$pi + .5)  # radians to degs.
    putMSG$Course$I
    MSG$Speed$I = int(xunt$truespeed$f + .5)           # floating point to int
    putMSG$Speed$I
 
    if (xunt$type$i == $air$code)
       {
        MSG$AltDepth$I = xunt$truealtdepth$i/100   # clk 6/96 (E1607) - 100 vice 1000
        putMSG$AltDepth$I
       }
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
   }
else if (msg$msgtype$i == $ghfdf$rmsg)
   {
    MSG$Sensor$I = $HFDF$RSens
    putMSG$Sensor$I
 
    MSG$Latitude$F = xhfd$ElpsOffSetLat$f
    MSG$Longitude$F = xhfd$ElpsOffSetLon$f
 
    iimaj = xHFD$ElpsSemiMajorAxis$I
    iimin = xHFD$ElpsSemiMinorAxis$I
 
    if (iabs(iimaj-iimin) != 0)       # if not a circle (an ellipse)
       {
        MSG$Bearing$I = xhfd$elpsorientation$i
        putMSG$Bearing$I
 
        if (iimaj < iimin)
           {
            MSG$MajorAxis$I = iimin
            MSG$MinorAxis$I = iimaj
           }
        else
           {
            MSG$MajorAxis$I = iimaj
            MSG$MinorAxis$I = iimin
           }
        putMSG$MajorAxis$I
        putMSG$MinorAxis$I
       }
    unt$pointer$to xHFD$Detectee$I
 
    MSG$AltDepth$I = xunt$truealtdepth$i
    putMSG$AltDepth$I
 
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
   }
else if (msg$msgtype$i == $gsosus$rmsg)
   {
    MSG$Sensor$I = $SOSUS$RSens
    putMSG$Sensor$I
 
    iimaj = xSOS$SemiMajorAxis$I
    iimin = xSOS$SemiMinorAxis$I
 
    if (iabs(iimaj-iimin) != 0)
        {
         MSG$Bearing$I = Xsos$orientation$i
         putMSG$Bearing$I
         MSG$MajorAxis$I = iimaj
         putMSG$MajorAxis$I
         MSG$MinorAxis$I = iimin
         putMSG$MinorAxis$I
        }
    MSG$Course$I = xsos$course$i
    putMSG$Course$I
    MSG$Speed$I = xsos$speed$i
    putMSG$Speed$I
 
    MSG$Latitude$F = xsos$offsetlat$f
    MSG$Longitude$F = xsos$offsetlon$f
 
    unt$pointer$to xSOS$Detectee$I
 
    MSG$AltDepth$I = xunt$truealtdepth$i
    putMSG$AltDepth$I
 
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
   }
else if (msg$msgtype$i == $gswabs$rmsg)
   {
    MSG$Sensor$I = $SWABS$RSens
    putMSG$Sensor$I
 
    iimaj = xSWD$SemiMajorAxis$I
    iimin = xSWD$SemiMinorAxis$I
 
    if (iabs(iimaj-iimin) != 0)
        {
         MSG$Bearing$I = XSWD$orientation$i
         putMSG$Bearing$I
         MSG$MajorAxis$I = iimaj
         putMSG$MajorAxis$I
         MSG$MinorAxis$I = iimin
         putMSG$MinorAxis$I
        }
    MSG$Course$I = xSWD$course$i
    putMSG$Course$I
    MSG$Speed$I = xSWD$speed$i
    putMSG$Speed$I
 
    MSG$Latitude$F = xSWD$offsetlat$f
    MSG$Longitude$F = xSWD$offsetlon$f
 
    unt$pointer$to xSWD$Detectee$I
 
    MSG$AltDepth$I = xunt$truealtdepth$i
    putMSG$AltDepth$I
 
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
    putMSG$MsgType$I ($gSOSUS$RMsg)
   }
else if (msg$msgtype$i == $GSONTP$RMsg)    # TASS
   {
    call stsell                            # get ellipse info
    unt$pointer$to idctee
 
    MSG$Latitude$F = xunt$AssumedLatitude$F
    MSG$Longitude$F = xunt$AssumedLongitude$F
 
    MSG$Course$I = int(xunt$truecourse$f * 180/$pi + .5)  # radians to degs.
    putMSG$Course$I
    MSG$Speed$I = int(xunt$truespeed$f + .5)           # floating point to int
    putMSG$Speed$I
 
    Msg$AltDepth$I = xunt$truealtdepth$i
    putMSG$AltDepth$I
 
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
   }
else if (msg$msgtype$i == $gsonba$rmsg)    # DICASS
   {
    unt$pointer$to idctee
 
    MSG$Latitude$F = xunt$AssumedLatitude$F
    MSG$Longitude$F = xunt$AssumedLongitude$F
 
    MSG$Course$I = int(xunt$AssumedCourse$f * 180/$pi + .5)  # radians to degs.
    putMSG$Course$I
    MSG$Speed$I = int(xunt$AssumedSpeed$f + .5)       # floating point to int
    putMSG$Speed$I
 
    if (xunt$type$i == $sub$code & xrmt$detectiontype$i == $SONAR$code)
       {
        Msg$AltDepth$I = xunt$truealtdepth$i
        putMSG$AltDepth$I
       }
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
   }
else if (msg$msgtype$i == $gold$rmsg)
   {
    rmt$detectiontype$i = xrmt$detectiontype$i
    #---------------------------------------------------------
    #   Get the appropriate sensor type
    #---------------------------------------------------------
    if (rmt$detectiontype$i == $ActiveVisual$Code)
       {
        MSG$Sensor$I = $Visual$RSens
       }
    else if (rmt$detectiontype$i == $ActiveNonVisual$Code)
       {
        if (Xrmt$LastDetType$i == $Radar$Type)
          MSG$Sensor$I = $RADAR$RSens                              # 2/1/91
        else if (Xrmt$LastDetType$i == $LIDAR$Type)
          MSG$Sensor$I = $LIDAR$RSens                              # 10/14/92
        else if (Xrmt$LastDetType$i == $MAD$Type)
          MSG$Sensor$I = $MAD$RSens                                # 10/14/92
        else if (Xrmt$LastDetType$i == $EOIR$Type)
          MSG$Sensor$I = $IR$RSens                                 # 10/14/92
        else
          MSG$Sensor$I = $SONACT$RSens
        }
    #--------------------------------------------------------------------
    #   If contact is passive sonar but not from an aircraft sonobuoy
    #   field.
    #---------------------------------------------------------------------
    else if (rmt$detectiontype$i == $PassiveSonar$Code)
       {
        MSG$Sensor$I = $SONPAS$RSens
        }
    else if (rmt$detectiontype$i == $ESM$code)
       {
        unt$pointer$to xrmt$detector$i
        idctortype = xunt$type$i
 
        if (idctortype == $air$code)          MSG$Sensor$I = $AESM$RSens
        else                                  MSG$Sensor$I = $ESM$RSens
       }
    putMSG$Sensor$I
 
    unt$pointer$to idctee
 
    MSG$Latitude$F = xunt$AssumedLatitude$F
    MSG$Longitude$F = xunt$AssumedLongitude$F
 
    MSG$Course$I = int(xunt$assumedcourse$f * 180/$pi + .5)  # radians to degs.
    putMSG$Course$I
    MSG$Speed$I = int(xunt$assumedspeed$f + .5)         # floating point to int
    putMSG$Speed$I
 
    if (xunt$type$i == $air$code)
       {
        MSG$AltDepth$I = xunt$truealtdepth$i/100   # clk 6/96 (E1607) - 100 vice 1000
        putMSG$AltDepth$I
       }
    else if (xunt$type$i == $sub$code & xrmt$detectiontype$i == $SONAR$code)
       {
        Msg$AltDepth$I = xunt$truealtdepth$i
        putMSG$AltDepth$I
       }
    MSG$TrueLat$F = xunt$TrueLatitude$F
    MSG$TrueLong$F = xunt$TrueLongitude$F
   }
 
else if (msg$msgtype$i == $gIR$rmsg)
    {
    MSG$Sensor$I = $IR$RSens
    putMSG$Sensor$I
 
    MSG$Latitude$F = xIRD$Latitude$F
    MSG$Longitude$F = xIRD$Longitude$F
 
    putMSG$MajorAxis$I (15)
    putMSG$MinorAxis$I (15)
 
    unt$pointer$to xIRD$Target$I
 
    MSG$AltDepth$I = 0   # xUNT$TrueAltDepth$I
    putMSG$AltDepth$I
 
    MSG$TrueLat$F  = xUNT$TrueLatitude$F
    MSG$TrueLong$F = xUNT$TrueLongitude$F
    }
 
putMSG$Latitude$F
putMSG$Longitude$F
putMSG$TrueLat$F
putMSG$TrueLong$F
 
return
end
 

 
Subroutine inlobs
#####################################################################
#
#  Collects LOBS line data for delayed RAINFORM messages.
#  (see INLOB for GOLD reports)
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
BBDeclare(MSG$Bearing$I, MSG$Latitude$F, MSG$Longitude$F,
          MSG$TrueLat$F, MSG$TrueLong$F)
 
MSG$Bearing$I = xhfd$appbearing$i
 
unt$pointer$to idctor     # detector
 
MSG$Latitude$F = xunt$AssumedLatitude$F
MSG$Longitude$F = xunt$AssumedLongitude$F
 
MSG$TrueLat$F = xunt$TrueLatitude$F
MSG$TrueLong$F = xunt$TrueLongitude$F
 
putMSG$Bearing$I
putMSG$Latitude$F
putMSG$Longitude$F
putMSG$TrueLat$F
putMSG$TrueLong$F
 
return
end
 

 
Subroutine inlob
#####################################################################
#
# Collects LOB line data for delayed RAINFORM Gold messages.
# (see LOBSLN for RED reports)
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer idctortype
BBDeclare(MSG$MsgType$I, MSG$Sensor$I, MSG$Bearing$I,
	  RMT$DetectionType$I,MSG$Latitude$F, MSG$Longitude$F,
	  MSG$TrueLat$F, MSG$TrueLong$F)
 
unt$pointer$to idctor     # detector
idctortype = xunt$type$i
 
MSG$Latitude$F = xunt$AssumedLatitude$F
MSG$Longitude$F = xunt$AssumedLongitude$F
 
MSG$TrueLat$F = xunt$TrueLatitude$F
MSG$TrueLong$F = xunt$TrueLongitude$F
 
MSG$MsgType$I = xMSG$MsgType$I
 
if (MSG$MsgType$I == $ghfdf$rmsg)
    {
    MSG$Sensor$I = $HFDF$RSens
    MSG$Bearing$I = xHFD$AppBearing$I
    }
else
    {
    MSG$Bearing$I = xrmt$bearing$i
    rmt$detectiontype$i = xrmt$detectiontype$i
 
    if (rmt$detectiontype$i == $PassiveSonar$Code)
        {
        if      (MSG$MsgType$I == $Sts$RMsg)    MSG$Sensor$I = $TASS$RSens
        else                                    MSG$Sensor$I = $SONPAS$RSens
        }
    else if (rmt$detectiontype$i == $ESM$code)
        {
        if (idctortype == $air$code)          MSG$Sensor$I = $AESM$RSens
        else                                  MSG$Sensor$I = $ESM$RSens
        }
    }
 
putMSG$Latitude$F
putMSG$Longitude$F
putMSG$TrueLat$F
putMSG$TrueLong$F
putMSG$Bearing$I
putMSG$Sensor$I
 
return
end
 

 
subroutine inbrng
####################################################################
#
#   Collects BRNG line data for delayed RAINFORM messages.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
BBDeclare(MSG$Bearing$I, MSG$RngRadius$I,
          MSG$Latitude$F, MSG$Longitude$F)
 
MSG$Bearing$I = xrmt$bearing$i	
 
unt$pointer$to idctor     # detector
 
MSG$Latitude$F = xunt$AssumedLatitude$F
MSG$Longitude$F = xunt$AssumedLongitude$F
 
MSG$RngRadius$I = Xrmt$range$f
 
putMSG$Bearing$I
putMSG$Latitude$F
putMSG$Longitude$F
putMSG$RngRadius$I
 
return
end
 

 
Subroutine intime
####################################################################
#
#  Collects TIME line data for delayed RAINFORM messages
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer status
integer idctortype, iloc
BBDeclare(MSG$MsgType$I, RMT$DetectionType$I, MSG$Sensor$I,
          MSG$Course$I, MSG$Speed$I, RMT$Detectee$I)
 
MSG$MsgType$I = xMSG$MsgType$I
rmt$detectiontype$i = xrmt$detectiontype$i
 
if (MSG$MsgType$I == $Red$RMsg)
   {
    if (rmt$detectiontype$i == $ActiveVisual$Code)
       {
        MSG$Sensor$I = $Visual$RSens
       }
    else if (rmt$detectiontype$i == $ActiveNonVisual$Code)
       {
        if (Xrmt$LastDetType$i == $Radar$Type) MSG$Sensor$I = $RADAR$RSens  # 2/1/91
        else                                   MSG$Sensor$I = $SONACT$RSens
        }
    else if (rmt$detectiontype$i == $ESM$Code)
       {
        unt$pointer$to xrmt$detector$i
        idctortype = xunt$type$i
 
        if (idctortype == $air$code) MSG$Sensor$I = $AESM$RSens
        else                         MSG$Sensor$I = $ESM$RSens
       }
    else if (rmt$detectiontype$i == $PassiveSonar$Code)
       {
        call get_status (idctor, status)
        if (status == $sts$rship |
            status == $stsnp$rship) MSG$Sensor$I = $TASS$RSens
        else                        MSG$Sensor$I = $SONPAS$RSens
       }
    else
       {
        MSG$Sensor$I = $Other$RSens
       }
    msg$course$i = xrmt$course$i					
    msg$speed$i = xrmt$speed$i
   }
else if (MSG$MsgType$I == $STS$RMsg)
   {
    MSG$Sensor$I = $TASS$RSens
    msg$course$i = xrmt$course$i					
    msg$speed$i = xrmt$speed$i
   }
else if (MSG$MsgType$I == $ESM$RMsg)
   {
    unt$pointer$to xrmt$detector$i
    idctortype = xunt$type$i
 
    if (idctortype == $air$code) MSG$Sensor$I = $AESM$RSens
    else                         MSG$Sensor$I = $ESM$RSens
   }
else if (MSG$MsgType$I == $SOSUS$RMsg)
   {
    MSG$Sensor$I = $SOSUS$RSens
 
    msg$course$i = xsos$course$i					
    msg$speed$i = xsos$speed$i
   }
else
   {
    MSG$Sensor$I = $Other$RSens
    rmt$detectee$i = xrmt$detectee$i
    unt$pointer$to rmt$detectee$i
 
    msg$course$i = xrmt$course$i					
    msg$speed$i = xrmt$speed$i
   }
 
putmsg$sensor$i
putmsg$course$i
putmsg$speed$i
 
return
end
 

 
Subroutine inelip
####################################################################
#
#  Collects ELLIP line data for delayed RAINFORM messages.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer iputin, iimaj, iimin, isquare, iarea, isqr
BBDeclare(MSG$MsgType$I, MSG$Bearing$I, MSG$MajorAxis$I,
          MSG$MinorAxis$I, MSG$RngRadius$I,
          MSG$Latitude$F, MSG$Longitude$F)
 
MSG$MsgType$I = xMSG$MsgType$I
 
iputin = YES
 
if (MSG$MsgType$I == $HFDF$RMsg)
    {
     MSG$Latitude$F = xhfd$elpsoffsetlat$f
     MSG$Longitude$F = xhfd$elpsoffsetlon$f
 
     iimaj = xHFD$ElpsSemiMajorAxis$I
     iimin = xHFD$ElpsSemiMinorAxis$I
 
     if (iabs(iimaj-iimin) != 0)         # if not a circle
        {
         MSG$Bearing$I = xhfd$elpsorientation$i
         MSG$MajorAxis$I = iimaj
         MSG$MinorAxis$I = iimin
         isquare = iarea (iimaj,iimin)
         if (isquare > 4095) isquare = 4095
         MSG$RngRadius$I = isquare
        }
     else                                # a circle
        {
         MSG$Bearing$I = 0
         MSG$MajorAxis$I = 0
         MSG$MinorAxis$I = 0
         MSG$RngRadius$I = iimaj
        }
    }
else if (MSG$MsgType$I == $SOSUS$RMsg)
   {
    MSG$Latitude$F = xsos$offsetlat$f
    MSG$Longitude$F = xsos$offsetlon$f
 
    iimaj = xSOS$SemiMajorAxis$I
    iimin = xSOS$SemiMinorAxis$I
 
    if (iabs(iimaj-iimin) != 0)
        {
         MSG$Bearing$I = Xsos$orientation$i
         MSG$MajorAxis$I = xSOS$SemiMajorAxis$I
         MSG$MinorAxis$I = xSOS$SemiMinorAxis$I
 
         isqr = iarea(iimaj,iimin)                      # 5-digit
 
         MSG$RngRadius$I = isqr
        }
    else
        {
         MSG$Bearing$I = 0
         MSG$MajorAxis$I = 0
         MSG$MinorAxis$I = 0
         MSG$RngRadius$I = iimaj
         }
    }
else if (MSG$MsgType$I  == $Sts$RMsg)
   {
    call stsell
    iputin = NO
   }
else
   {
    MSG$Latitude$F = xrmt$apparentlat$f
    MSG$Longitude$F = xrmt$apparentlon$f
 
    MSG$Bearing$I = xrmt$bearing$i
   }
 
if (iputin == YES)
   {
    putMSG$Latitude$F
    putMSG$Longitude$F
    putMSG$Bearing$I
    putMSG$MajorAxis$I
    putMSG$MinorAxis$I
    putMSG$RngRadius$I
   }
 
return
end
 

 
 Subroutine STSELL
#######################################################
#$%
#$% Purpose:   STSELL generates an ellipse that has been
#$%            evaluated from SURTASS and other data by
#$%            Commander Ocean Surveillence, Pacific (COSP).
#$%
#$% Date:      Aug 1987
#$%
#$% Author:    Jim Kvederis
#$%
#######################################################
BBcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
REAL fmean, stddev, randn2      # jb E2145 (REAL)   8/7/00
real    RNOne, RNTwo, random2
Integer x                       # jb E2145 (x)  8/7/00
BBDeclare(MSG$MajorAxis$I, MSG$MinorAxis$I, MSG$Bearing$I,
          MSG$Latitude$F, MSG$Longitude$F, MSG$TrueLat$F,
	  MSG$TrueLong$F)
 
FMean = RGSTS$Mean
StdDev = RGSTS$StDev
 
repeat
  {
   RNOne = RANDN2(FMean,StdDev)
  }
until (RNOne > 0.0)
 
repeat
  {
   RNTwo = RANDN2(FMean,StdDev)
  }
until (RNTwo > 0.0)
 
RNone = RNone + 1.0
RNtwo = RNtwo + 1.0
 
if (RNOne >= RNTwo)
   {
    MSG$MajorAxis$I = RNOne
    MSG$MinorAxis$I = RNTwo
   }
else
   {
    MSG$MajorAxis$I = RNTwo
    MSG$MinorAxis$I = RNOne
   }
putMSG$MajorAxis$I
putMSG$MinorAxis$I
 
MSG$Bearing$I = 180*random2(x)
putMSG$Bearing$I
 
unt$pointer$to idctor                    # detector
 
call ELLOFF(float(MSG$majoraxis$i),     #call ellipse center offset routine
	     float(MSG$minoraxis$i),
	     ($pi/180.)*MSG$Bearing$I,
	     xunt$truelatitude$f,
	     xunt$truelongitude$f,
	     xunt$costruelat$f,
	     MSG$Latitude$F,            #latitude of ellipse center
	     MSG$Longitude$F)           #longitude of ellipse center
 
 MSG$TrueLat$F = xunt$TrueLatitude$F
 MSG$TrueLong$F = xunt$TrueLongitude$F
 
 putMSG$Latitude$F
 putMSG$Longitude$F
 putMSG$TrueLat$F
 putMSG$TrueLong$F
 
 return
 end
 

 
 define ($mi$to$rad,($pi/(180.*60.)))
 
 Subroutine ELLOFF(semima,   #ellps cntr offset rout - semi-major ax lngth (in)
		   semimi,               #semi-minor axis length (in)
		   theta,                #orientation of major axis (in)
		   tgtlat,               #true latitude of target (in)
		   tgtlon,               #true longitude of target (in)
		   tgtcos,               #cos of target latitude (in)
		   eclat,                #latitude of ellipse center (out)
		   eclon)                #longitude of ellipse center (out)
 
#######################################################
 #$%
 #$% Purpose:   ELLOFF generates ellipse center offset.
 #$%
 #$% Date:      APRIL 81
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 implicit none
 real sdsize/2.0/                        #number of std devs for ellipse
 
 real theta         # jb E2145  (REAL)  8/7/00
 real    fcos, fsin, offmaj, offmin, randn2
 real    semima, semimi, eclat, tgtlat, eclon
 real    tgtlon, tgtcos
 
 fcos = cos(theta)
 fsin = sin(theta)
 
 #$% compute offset major axis
 offmaj = randn2(0.0,semima/sdsize)
 #$% compute offset minor axis
 offmin = randn2(0.0,semimi/sdsize)
 
 #$% compute latitude of ellipse center
 eclat = tgtlat - $mi$to$rad * (offmaj * fcos + offmin * fsin)
 #$% compute longitude of ellipse center
 eclon = tgtlon - $mi$to$rad * (offmaj * fsin - offmin * fcos) / tgtcos
 $angpi(eclon)
 
 return
 end
 

 
Subroutine inaircat (acc$category$i)
####################################################################
#
# Gets catagory of aircraft (Prop, Helo or Jet)
#
####################################################################
 
bbcommon
rfcommon
rgcommon
ptr2common
ptr1common
 
BBDeclare(ACC$Category$I, MSG$AirType$I)
 
if      (acc$category$i == $helo$code) msg$airtype$i = $helo$acc
else if (acc$category$i == $prop$code) msg$airtype$i = $prop$acc
else if (acc$category$i == $jet$code)  msg$airtype$i = $jet$acc
else                                   msg$airtype$i = $unknown$acc
 
putmsg$airtype$i
 
return
end
 

 
Subroutine splitlist (indxuntptr, iround, inxt)
####################################################################
#
# Splits a list of units into three parts by index number.
#
####################################################################
 
bbcommon
rfcommon
rgcommon
 
integer iround, ithrees, indxuntptr, inxt, itwos
 
if (iround == 1)
   {
    ithrees = mod(indxuntptr, 3)
    if (ithrees != 0) inxt = $yes
    else              inxt = $no
   }
else if (iround == 2)
   {
    itwos = mod(indxuntptr, 2)
    ithrees = mod(indxuntptr, 3)
    if (ithrees == 0 | itwos != 0) inxt = $yes
    else                           inxt = $no
   }
else if (iround == 3)
   {
    itwos = mod(indxuntptr, 2)
    ithrees = mod(indxuntptr, 3)
    if (ithrees == 0 | itwos == 0) inxt = $yes
    else                           inxt = $no
   }
 
return
end
 

 
Subroutine contactnum (ictcnum)
#########################################################################
#
#   Purpose:  Provides a unique number for each contact that a particular
#             detectee has detected.  The unique number will be the next
#             consecutive number available that has not yet been assigned.
#
#   Author:  Jim Kvederis
#
#   Date:  Sept 1985
#
#########################################################################
bbcommon
rfcommon
rgcommon
whocommon
 
integer idcnt[UNT$slots]
integer ictcnum
 
idcnt[idctor] = idcnt[idctor] + 1
jcnt[idctor, idctee] = idcnt[idctor]
 
ictcnum = idcnt[idctor]
 
return
end
 

 
 
Subroutine get_msgtimes (idelaycat)
#######################################################################
###
###  Determines amount of delays for each message based on random numbers
###  using a Poisson distribution.
###
########################################################################
bbcommon
rfcommon
rgcommon
msgcommon
ptr1common
ptr2common
 
literal cnumber, tnumber, cdelay, tdelay
integer i_switch_1, idelaycat
integer x, cmean, tmean         # jb E2145  (x) 8/7/00
 
real    random2
BBDeclare(MSG$SensTime$I, MSG$MsgDTG$I, MSG$MsgTOR$I)
 
switch (idelaycat)
   {
    case $Air$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$Air
        tmean = RGTMean$Air
       }
    case $Sub$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$Sub
        tmean = RGTMean$Sub
       }
    case $Ship$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$Shp
        tmean = RGTMean$Shp
       }
    case $HFDF$RDelay:
       {
        msg$senstime$i = xhfd$LastDetTime$f
        cmean = RGCMean$Hfd
        tmean = RGTMean$Hfd
       }
    case $SOSUS$RDelay:
       {
        msg$senstime$i = xsos$LastDetTime$f
        cmean = RGCMean$Sos
        tmean = RGTMean$Sos
       }
    case $SELOR$RDelay:
       {
        msg$senstime$i = xssr$DetectTime$f
        cmean = RGCMean$Sel
        tmean = RGTMean$Sel
       }
    case $ROSIS$RDelay:
       {
        msg$senstime$i = msg_minute
        cmean = RGCMean$Ros
        tmean = RGTMean$Ros
       }
    case $WOSIS$RDelay:
       {
        msg$senstime$i = msg_minute
        cmean = RGCMean$Wos
        tmean = RGTMean$Wos
       }
    case $Spec$RDelay:
       {
        msg$senstime$i = msg_minute
        cmean = RGCMean$Bfl
        tmean = RGTMean$Bfl
       }
    case $GoldA$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$Glda
        tmean = RGTMean$Glda
       }
    case $GoldS$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$Glds
        tmean = RGTMean$Glds
       }
    case $GESMA$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$GESMa
        tmean = RGTMean$GESMa
       }
    case $GESMS$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$GESMs
        tmean = RGTMean$GESMs
       }
    case $GSEL$RDelay:
       {
        msg$senstime$i = xssr$DetectTime$f
        cmean = RGCMean$GSEL
        tmean = RGTMean$GSEL
       }
    case $GWIZ$RDelay:
       {
        msg$senstime$i = xssr$DetectTime$f
        cmean = RGCMean$GWIZ
        tmean = RGTMean$GWIZ
       }
    case $GSOS$RDelay:
       {
        msg$senstime$i = xsos$LastDetTime$f
        cmean = RGCMean$GSOS
        tmean = RGTMean$GSOS
       }
    case $GHFD$RDelay:
       {
        msg$senstime$i = xhfd$LastDetTime$f
        cmean = RGCMean$GHFD
        tmean = RGTMean$GHFD
       }
    case $TASS$RDelay:
       {
        msg$senstime$i = xrmt$LastDetTime$f
        cmean = RGCMean$Sts
        tmean = RGTMean$Sts
       }
    case $GSWB$RDelay:
       {
        MSG$SensTime$I = xswd$DetectionTime$f
        cmean = RGCMean$GSWB
        tmean = RGTMean$GSWB
       }
    case $GROTHR$RDelay:
       {
        MSG$SensTime$I = xrmt$LastDetTime$f
        cmean = RGCMean$GRTH
        tmean = RGTMean$GRTH
       }
    case $GIR$RDelay:
       {
        MSG$SensTime$I = xird$Time$f
        cmean = RGCMean$GIR
        tmean = RGTMean$GIR
       }
    default:
       {
        msg$senstime$i = msg_minute            # sensor contact time
        cmean = 0
        tmean = 0
       }
   }
 
cnumber = random2(X)                   # random nbr in a uniform distribution
cdelay = ABS(cmean * LOG(cnumber))  # random nbr in a Poisson distribution
 
tnumber = random2(X)                   # random nbr in a uniform distribution
tdelay = ABS(tmean * LOG(tnumber))  # random nbr in a Poisson distribution
 
msg$msgdtg$i = msg_minute + (cdelay + .5)       # msg dtg
msg$msgtor$i = msg$msgdtg$i + (tdelay + .5)      # msg tor
 
putmsg$senstime$i
putmsg$msgdtg$i
putmsg$msgtor$i
 
return
end
 

 
Subroutine inswabs (igoldswb)
######################################################################
###
### Collects SWABS message data for a delayed Gold message.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
real oldtime[SWD$slots]
integer   iswb, imsg, ilost, igoldswb, ihalftime, i, equal_hv
BBDeclare(SWD$DetectorSide$I, UNT$SWBIndx$I, MSG$MsgType$I,
	  MSG$TrackNo$I, SWD$DetectionTime$F,MSG$TrackCode$C)
 
for (swd$pointer$first; swd$pointer$valid; swd$pointer$next)
    {
    if (imin == 0) next
 
    idctee = xswd$detectee$i 	# save detectee index
    if (idctee == 0) next       # no dectee
 
    SWD$DetectorSide$I = xSWD$DetectorSide$I
    if (SWD$DetectorSide$I ^= $Blue$Code) next      # only process blue
 
    unt$pointer$to idctee
    unt$SWBIndx$I = xunt$SWBIndx$I
    SWB$pointer$to unt$SWBIndx$I
 
    swbregion = xSWB$RegionNumber$I    # get SWABS region
    if (swbregion == 0) next       # not a SWABS region
    putMSG$SWABSReg$I (swbregion)
 
    swd$DetectionTime$f = xswd$DetectionTime$f
    #----------------------------------------------------------------------
    #   Generate a SWABS msg on first sub detection and when detection is
    #   going to fade + 3 game minutes.  Otherwise, send message at SWB GOLD
    #   interval.
    #----------------------------------------------------------------------
    iswb = SWD$pointer$index
    imsg = nomsg
    ilost = $no
 
    if (igoldswb == $yes)                # if time for a GOLD msg
         {
         if (int(swd$DetectionTime$f) == msg_minute & oldtime[iswb] == 0)
             {
             imsg = sendmsg
             }
         else if (swd$DetectionTime$f + 5 <= msg_minute &
                  swd$DetectionTime$f != oldtime[iswb])
             {
             imsg = sendmsg
             ilost = $yes
             }
         else if (xunt$type$i == $Sub$Code)
             {
             ihalftime = (RGIntv$GSWABS * .5)
            if ((msg_minute - RGLastTime$GSWABS) >= RGIntv$GSWABS)
            {
                imsg = sendmsg
                RGLastTime$GSWABS = msg_minute
            }
            else
                imsg = nomsg
 
 
             if (imsg == sendmsg & int(swd$DetectionTime$f) == msg_minute &
                (oldtime[iswb] + ihalftime) <= msg_minute)
                {
                }
             }
 
         if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
         if (ilost == $yes) oldtime[iswb] = 0
         else               oldtime[iswb] = swd$DetectionTime$f
 
         idctor = 0
         call getslot (idctor, idctee)
         inslots = inslots + 1
 
         MSG$MsgType$I = $GSWABS$RMsg   # Use SWABS Message Type
         putMSG$MsgType$I
 
         call get_msgtimes ($GSWB$RDelay)
 
         call ingoldmsg           # Make a GOLD msg
 
         i = 0
         call smov ($Blue$Designator, msg$trackcode$c, i)
         putmsg$trackcode$c
 
         MSG$TrackNo$I = xSWD$SequenceNmbr$I
         putMSG$TrackNo$I
 
         putMSG$SWABStrk$I ($YES)     # Indicate SWABS track
         }
    }
 
return
end
 

 
integer function ok_to_send(LastTimeSent, intv, det_time, old_time, ilost)
######################################################################
###
### Determines if it is now time to send a particular message
###
########################################################################
 
BBcommon
RFcommon
real LastTimeSent, det_time, old_time
integer intv, ilost, ihalftime, intvx
 
ok_to_send = nomsg
if (intv == nomsg) return
 
if (det_time != old_time)		# Track has updated since last time sent
{
	# If reporting interval or new/lost track, send message
	if (mod(msg_minute,intv) == 0 | old_time == 0.0)
	{
		ok_to_send = sendmsg
		if (det_time + 5 <= msg_minute) ilost = $yes
	}
}
 
return
end

 
Subroutine inir (igoldir)
######################################################################
###
### Collects IR message data for a delayed Gold message.
###
########################################################################
 
bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common
 
integer   status
real oldtime[IRD$slots]
integer   imsg, ilost, igoldir, iloc, iir, ihalftime, i
real      IRD$Time$F
BBDeclare(MSG$TrackCode$C, MSG$MsgType$I, MSG$TrackNo$I)
 
 
for (ird$pointer$first; ird$pointer$valid; ird$pointer$next)
    {
    if (imin == 0) next
    if (xIRD$InUse$I == $NO) next
    if (xIRD$View$I < $FirstBlue$View | xUNT$View$I > $LastBlue$View) next
 
    imsg = nomsg
    ilost = $no
 
    if (igoldir == $yes)                # if time for a GOLD msg
         {
         idctor = xIRD$Detector$I
         call get_status (idctor, status)
         if (status == $oth$rship | status == $othnp$rship)
             {
             ird$Time$f = xird$Time$f
             iir = IRD$Pointer$Index
             if (int(ird$Time$f) == msg_minute & oldtime[iir] == 0)
                 {
                 imsg = sendmsg
                 }
             else if (ird$Time$f + 5 <= msg_minute &
                      ird$Time$f != oldtime[iir])
                 {
                 imsg = sendmsg
                 ilost = $yes
                 }
             else
                 {
                 ihalftime = (RGIntv$GIR * .5)
                 # for VTS it is assumed that reports are emitted on integer minute boundary - JFR 1/13/94
                 imsg = mod (msg_minute, RGIntv$GIR)
                if ((msg_minute - RGLastTime$GIR) >= RGIntv$GIR)
                {
                    imsg = sendmsg
                    RGLastTime$GIR = msg_minute
                }
                else
                    imsg = nomsg
 
                 if (imsg == sendmsg & int(ird$Time$f) == msg_minute &
                    (oldtime[iir] + ihalftime) <= msg_minute)
                     {
                     }
                 }
             }
 
         if (imsg != sendmsg) next           # else send a msg  (sendmsg = 0)
 
 
         if (ilost == $yes) oldtime[iir] = 0
         else               oldtime[iir] = ird$Time$f
 
         idctee = xIRD$Target$I
         call getslot (idctor, idctee)
         inslots = inslots + 1
 
         MSG$MsgType$I = $GIR$RMsg   # Use IR Message Type
         putMSG$MsgType$I
 
         call get_msgtimes ($GIR$RDelay)
 
         call ingoldmsg           # Make a GOLD msg
 
         i = 0
         call smov ($Blue$Designator, msg$trackcode$c, i)
         putmsg$trackcode$c
 
         MSG$TrackNo$I = xIRD$TrackSeq$I
         putMSG$TrackNo$I
         putMSG$Classified$I (xIRD$Recognized$I)
         putMSG$FingerPrinted$I (xIRD$Identified$I)
         }
    }
 
return
end
 
