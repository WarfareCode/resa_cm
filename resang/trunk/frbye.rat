###
###
### Modification of WES Version 3.1 to the VAX 11/780
###
###
###
### number prog   module      comments
### ====== ====   ======      =========================================
###                           VAX Conversion started 23 December 81 --
###                           completed 28 February 82
###
###
###
###
###
###
###
###
###
 
#####   version 3.1  dated-  7apr81
 
 
#####   version 3.0  dated- 22dec80
 
 
#$%      MODULE                      UTILITY                    DATA
#$%    SUBROUTINE                  SUBROUTINES                 TABLES
#$%    ==========                  ===========                 ======
#$%
#$%      FVRMEM                      ECHOR                     MEMBER
#$%      FVRPAT                      ECHOH                     NAME
#$%      FVREMT                      ECHOI                     AIR
#$%      FVRSOS                      ECHOHN                    FORCE
#$%      FVRHFD                      FGTASK                    PATH
#$%      FVRSST                      FDOPEN                    NODE
#$%      FVRWET                      FDCLOS                    EMITTER
#$%      FVRLIDAR                    FGETR                     SHORE
#$%      FVRAIR                      FPUTR                     EMCON
#$%      FVRG                        FSMOVE                    SOS
#$%      FSAVEC                                                HFD
#$%      FSAVFC                                                SST
#$%      FSAVPT                                                WET
#$%      FSAVEM                                                AML
#$%      FSAVEP                                                BML
#$%      FSAVWT                                                LDR
#$%      FSAVHF                                                SOS
#$%      FSAVSO                                                BIS
#$%      FSAVLDR
#$%      FSAVBPAIR
#$%      FSAVAL
#$%      FSAVSS
#$%      FSAVMB
#$%      FSAVOR
#$%      FSAVPN
#$%      FSAVSR
#$%      FSAVBML
#$%      FSAVSWABS
#$%      FVRBOAT
#$%
#$%
#$%    NOTES
#$%    =====
#$%
#$%    1.  <FILENAME> INDICATES WHERE SUBROUTINE IS LOCATED.
#$%
#$%    2.  UTILITY SUBROUTINES NOT SHOWN ON FLOWCHART.
#$%
#$%    3.  * INDICATES NO OTHER SUBROUTINES CALLED.
#$%
#$%
#$%
#$%    FLOWCHART FOR FILE FBYE
#$%    =======================
#$%
#$%    FORCE - ORDPRC - EXEORD - FRBYE - FBYEVR - FVRMEM*
#$%                                             - FVRPAT*
#$%                                             - FVREMT*
#$%                                             - FVRSOS*
#$%                                             - FVRSWABS*
#$%                                             - FVRHFD*
#$%                                             - FVRSST*
#$%                                             - FVRWET*
#$%                                             - FVRLIDAR*
#$%                                             - FVRAIR*
#$%                                             - FVRBOAT*
#$%                                    - FBYEGN - FVRG  *
#$%                                             - FSAVEC*
#$%                                             - FSAVFC*
#$%                                             - FSAVPT*
#$%                                             - FSAVEM*
#$%                                             - FSAVEP*
#$%                                             - FSAVWT*
#$%                                             - FSVHF *
#$%                                             - FSAVSO*
#$%                                             - FSAVBPAIR*
#$%                                             - FSAVLDR*
#$%                                             - FSAVAL*
#$%                                             - FSAVSS*
#$%                                             - FSAVMB*
#$%                                             - FSAVOR*
#$%                                             - FSAVPN*
#$%                                             - FSAVBML*
#$%                                    - FBYESR - FSAVSR*
 
 
# 
 
include "bbcode.inc"
include "plplay.inc"
include "frmain.inc"
include "ascii.inc"
 
define (ForceImplicit, Implicit None)                  # MJC 6/9/2K (E2145)
 
 
subroutine fvrmem (istat)
 
#########################################################################
#$%
#$% Purpose:   FVRMEM verifies data associated with the communication
#$%            path membership matrix.
#$%
#$% Called By: FBYEVR
#$%
#$% Calls:     ECHOR      ECHOH
#$%
#$% Tables:    MEMBER     NAME       AIR
#$%            FORCE
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#########################################################################
 
ForceCommon
integer ISTAT,
        KMEMBR,
        NF,
        INC,
        ILIMIT,
        KMEMNM,
        KAIR,
        KCLASS,
        KFORCE,
        MSIDE,
        NSIDE,
        KORG                                        # MJC 6/9/2K (E2145)
integer lcomp_v
 
literal name
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Members......")
 
for (member$index = 1; member$index <= nmembr; member$index=member$index+inc)
   {
    #$% set name force to zero
    nf = 0
    inc = member$len
    ilimit = inc - 2
    name = member$path
    #$% loop through each name entry
    for (name$index=1; name$index<=ilimit; name$index=name$index+1)
       {
        #$% loop through each air index
        for (air$index=1; air$index<=nair; air$index=air$index+1)
           {
            #$% if members name is air name, break loop
            if (member$name == air$name) break
           }
        #$% if index is less, get next entry
        if (air$index<=nair) next
 
        #$% loop through each class index, added 4/91, reh
        for (class$index=1; class$index<=nclass; class$index=class$index+1)
            {
            if ( lcomp_v(Class$Type, "BOAT") != 0) next
 
            #$% if members name is class name, break loop
            if (member$name == class$name) break
            }
 
        #$% if the member was a small boat
        if (class$index<=nclass) next       # get mext member
 
        #$% loop through each force entry
        for (force$index = 1; force$index <= nforce; force$index = force$index + 1)
           {
            #$% if member name is not force name, get next entry
            if (member$name != force$name) next
            if (nf == 0)
               {
                #$% set member side, break loop
                if (force$task <= 9999) mside = (force$task/1000  - 1) / 4
                else                    mside = (force$task/10000 - 1) / 4
                            #                        blue=0, orange=1, neutral=2
                break       #Task Organisation Nos. = 1 - 4   5 - 8     9
               }
 
            #$% set name side, break loop
            if (force$task <= 9999) nside = (force$task/1000  - 1) / 4
            else                    nside = (force$task/10000 - 1) / 4
 
            break         #Task Oranization Nos. =  1 - 4   5 - 8     9
           }
 
        #$% loop through each organization entry
        for (org$index = 1; org$index <= norg; org$index = org$index + 1)
           {
            #$% if member name is not org name, get next entry
            if (member$name != org$name) next
            if (nf == 0)
               {
                #$% set member side, break loop
                if (org$task <= 9999) mside = (org$task/1000  - 1) / 4
                else                    mside = (org$task/10000 - 1) / 4
                            #                        blue=0, orange=1, neutral=2
                break       #Task Organisation Nos. = 1 - 4   5 - 8     9
               }
 
            #$% set name side, break loop
            if (org$task <= 9999) nside = (org$task/1000  - 1) / 4
            else                    nside = (org$task/10000 - 1) / 4
 
            break         #Task Oranization Nos. =  1 - 4   5 - 8     9
           }
 
        #$% if force index is greater than the force
        #$% AND if org index greater than org then  --- JFR 12/5/91
        #$% > nforce or norg means it exited normally, without finding it
        if ((force$index > nforce) & (org$index > norg))
           {
            #$% send message that not all members can be found
            call echor
            call echov ("Not all members of the Commpath ")
            call echohN (name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
            call echov (" can be found.")
            #$% set status to NO and get next
            istat = $no
            next
           }
 
        #$% if name force is not valid
        if (nf==0)
           {
            #$% set name force to one and get next
            nf = 1
            next
           }
 
        #$% if member side is not name side
        if (mside != nside)
           {
            #$% send message that not all members are on the same side
            call echor
            call echov ("Not all members of the Commpath ")
            call echohN (name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
            call echov (" are on the same side (Blue/Orange).")
            #$% set status to NO and get next
            istat = $no
            next
           }
       }
   }
 
return
end

 
subroutine fvrpat (istat)
 
##########################################################################
#$%
#$% Purpose:   FVRPAT verifies data associated with communication paths.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##########################################################################
 
ForceCommon
integer ISTAT,
        KPATH,
        KNODE                                       # MJC 6/9/2K (E2145)
integer xerr,xcat,xmu,xrho,xend,xeq
 
#$% set status flag to YES (no errors)
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Commpaths....")
 
#$% loop through each path entry
for (path$index=1; path$index<=npaths; path$index= path$index+1)
   {
    #$% if path nodes are less than two
    if (path$nodes < 2)
       {
        #$% display path message
        call echor
        call echov ("Path ")
        call echohN (Path$name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
        call echov (" has only ")
        call echoi (Path$nodes)
        call echov (" nodes.")
        #$% set status to NO (indicates error)
        istat = $no
       }
 
    #$% loop through each node entry
    for (node$index=1; node$index<=path$nodes; node$index= node$index+1)
       {
        #$% initialize flags
        xerr = $no
        xcat = $no
        xmu  = $no
        xrho = $no
        xend = $no
        xeq  = $no
 
        #$% if node index is greater than one and less than path
        if (node$index > 1 & node$index < path$nodes & path$cat == $BLANKLIT)
           {
            #$% set error flags
            istat = $no
            xerr = $yes
            xcat = $yes
           }
 
        #$% if path mu is not valid
        if (path$mu == 0)
           {
            #$% set error flags
            istat = $no
            xerr = $yes
            xmu  = $yes
           }
 
        #$% if path rho is less than 0
        if (path$rho <= 0)
           {
            #$% set error flags
            xerr = $yes
            xrho = $yes
           }
 
        #$% if node index is not "end"
        if (node$index == path$nodes & path$pair != 'END')
           {
            #$% set error flags
            istat = $no
            xerr = $yes
            xend = $yes
           }
        #$% else if path pair is blank
        else if (path$pair == $BLANKLIT)
           {
            #$% set error flags
            istat = $no
            xerr = $yes
            xeq = $yes
           }
 
        #$% if no error, get next display
        if (xerr == $no) next
 
        #$% display path error message
        call echor
        call echov ("Path ")
        call echohn (Path$name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
        call echov (" node # ")
        call echoi (node$index)
        call echov (" requires:")
 
 
        #$% check flags to send display where error is located
        if (xcat == $yes) call echov ("  Category")
        if (xmu  == $yes) call echov ("  MU")
        if (xrho == $yes) call echov ("  (RHO-Warning)")
        if (xend == $yes) call echov ("  END (last node)")
        if (xeq  == $yes) call echov ("  Commpair")
       }
 
# ???? add the stuff in here or up one notch ???  trs 12/6/90
 
   }
 
return
end

 
subroutine fvremt (istat)
 
#############################################################################
#$%
#$% Purpose:   FVREMT verifies data associated with fingerprinted emitters.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################################
 
ForceCommon
integer ISTAT,
        KEMITR,
        JSTAT,
        KFORCE                                      # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Fingerprinted Emitters.....")
 
#$% loop through each emitter index
for (emitter$index=1; emitter$index <= nemit; emitter$index=emitter$index+1)
   {
        #$% set status to NO
        jstat = $no
        #$% loop through each force entry
        for (force$index=1; force$index<=nforce; force$index=force$index+1)
       {
        #$% if force name is not same platform, get next name
        if (force$name != emitter$plat) next
        #$% set status to YES
        jstat = $yes
        #$% break loop
        break
       }
 
    #$% if emitter found, get next emitter
    if (jstat == $yes) next
 
    #$% send emitter message
    call echor
    call echov ("Ship ")
    call echohN (emitter$plat,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
    call echov (" (with ")
    call echohn (emitter$name,$$MaxName)  # jb E2141 8-char.names 12/29/99
    call echov (") is not present.")
 
    #$% set status flag to NO
    istat = $no
   }
 
return
end

 
subroutine FVRsos (istat)
 
######################################################################
#$%
#$% Purpose:   FVRSOS verifies data associated with SOSUS regions.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
######################################################################
 
ForceCommon
integer ISTAT,
        KSOS,
        KSOSA,
        I                                               # MJC 6/9/2K (E2145)
 
#$% set status flag to yes
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Sosus Data.....")
 
 
#$% set sos pointer to first map
sos$pointer$first
sos$map
#$% loop through each SOSUS entry
for (i=1; i<=nsos; i=i+1)
   {
    #$% if SOSUS region was not previously defined
    if (sos$regdefined == 0)
       {
        #$% send warning message
        call echor
        call echov (" Warning---sub data entered for undefined region # ")
        call echoi (sos$regnumber)
       }
 
    if (SOS$RegDefined == $no & SOS$BIS$RegionArea != 0)
       {
        #$% send warning message
        call echor
        call echov (" Warning---bistatic data entered for undefined region # ")
        call echoi (SOS$RegNumber)
       }
 
    #$% set sos pointer to next map
    sos$pointer$next
    sos$map
   }
 
return
end

 
subroutine FVRSWABS (istat)
 
######################################################################
#$%
#$% Purpose:   FVRSWABS verifies data associated with SWABS regions.
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
######################################################################
ForceCommon
integer KSWB,
        KSWBA                                       # MJC 6/9/2K (E2145)
integer istat
 
  #$% set status flag to yes
  istat = $yes
 
  #$% send verification message
  call echor
  call echov ("Verifying SWABS Data.....")
 
  #$% loop through each SWABS entry
  for (SWB$pointer$first; SWB$pointer$valid; SWB$pointer$next)
    {
     SWB$map
 
     if (swb$InUse == $no)
       next
 
     #$% if SWABS region was not previously defined
     #$% but sub classes have been defined
     if ((swb$regdefined == $no) & (swb$numberofsets != 0))
       {
        #$% send warning message
        call echor
        call echov (" Warning---sub data entered for undefined ")
        if (swb$regnumber <= $SWABS$Orange$offset)
          {
           call echov ("Blue region # ")
           call echoi (SWB$regnumber)
          }
        else   # an Orange SWABS region
          {
           call echov ("Orange region # ")
           call echoi (SWB$regnumber - $SWABS$Orange$offset)
          }
       }
    }
 
return
end

 
subroutine FVRton (istat)
 
######################################################################
#$%
#$% Purpose:   FVRTON verifies data associated with Sonar Tonal values.
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
######################################################################
 
ForceCommon
integer ISTAT                                           # MJC 6/9/2K (E2145)
#$% set status flag to yes
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Sonar Tonals...")
 
# This space available for possible future verification requirements
 
return
end
 

 
subroutine FVRson (istat)
 
######################################################################
#$%
#$% Note: This subroutine is currently a stub and is retained for possible
#$%       future use.
#$%
#$% Purpose:   FVRSON verifies data associated with Sonar Environment
#$%            Regions.
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    J. P.  KVEDERIS
#$%
######################################################################
 
ForceCommon
integer ISTAT                                           # MJC 6/9/2K (E2145)
#$% set status flag to yes
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Sonar Environment Region.....")
 
#$% set SON pointer to map
#son$pointer$first
#son$map
##$% if slot not in use
#    if (son$InUse == $no)
#      {
#       #$% send warning message to user
#       call echor
#       call echov ("Default Sonar Environment Region is not present")
#       #$% set status flag to no
#       istat = $no
#      }
 
return
end
 

 
 
subroutine FVRhfd (istat)
 
######################################################################
#$%
#$% Purpose:   FVRHFD verifies data associated with HFDF shorebase
#$%            installations.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
######################################################################
 
ForceCommon
integer ISTAT,
        KHFD,
        KHFDA,
        I,
        KSHORE                                      # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Hfdf Data......")
 
#$% set hfd pointer to first map
hfd$pointer$first
hfd$map
#$% loop through each hfdf entry
for (i=1; i<=nhfdf; i=i+1)
   {
     #$% loop through each shore entry
     for (shore$index=1; shore$index<=nshore; shore$index = shore$index+1)
       {
        #$% if HFD base name is shore name, break loop
        if (hfd$basename == shore$name) break
       }
 
    #$% if shore index is greater than number of shore names
    if (shore$index > nshore)
       {
        #$% send warning message
        call echor
        call echov (" Warning---hfdf data entered for undefined base ")
        call echohn (hfd$basename,$$MAXname) # 8 jb E2141 8-char.names 12/29/99
       }
    #$% set HFD pointer to next map
    hfd$pointer$next
    hfd$map
   }
 
return
end

 
 
subroutine FVRsst (istat)
 
#########################################################################
#$%
#$% Purpose:   FVRSST verifies surveillance satellite data associated
#$%            with shorebases.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#########################################################################
 
ForceCommon
integer ISTAT,
        KSST,
        KSSTA,
        I,
        KSHORE                                      # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Survsat Data...")
 
#$% set sst pointer
sst$pointer$first
sst$map
#$% for each surveillance satellite entry
for (i=1; i<=nssts; i=i+1)
   {
    #$% for each shore entry
    for (shore$index=1; shore$index<=nshore; shore$index = shore$index+1)
       {
        #$% if sst ground station is shore name, break loop
        if (sst$groundstation == shore$name) break
       }
 
    #$% if shore index is greater than nshore
    if (shore$index > nshore)
       {
        #$% send warning message
        call echor
        call echov (" Survsat data entered for undefined base ")
        call echohN (sst$groundstation,$$MAXname) # 5 jb E2141 8-char 12/29/99
        #$% set status flag to NO
        istat = $no
       }
 
    #$% set sst pointer to next map
    sst$pointer$next
    sst$map
   }
 
return
end

 
subroutine FVRwet (istat)               # verify default weather region
 
################################################################
#$%
#$% Purpose:   FVRWET verifies that a default weather region
#$%            has been defined.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
################################################################
 
ForceCommon
integer ISTAT,
        KWET,
        KWETA                                       # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Default Weather Region.....")
 
#$% set WET pointer to map
wet$pointer$first
wet$map
#$% if slot not in use
    if (wet$InUse == $no)
      {
       #$% send warning message to user
       call echor
       call echov ("Default weather region is not present")
       #$% set status flag to no
       istat = $no
      }
 
return
end

 
subroutine FVRLIDAR (istat)               # verify default LIDAR region
 
################################################################
#$%
#$% Purpose:   FVRLIDAR verifies the LIDAR regions.
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
################################################################
ForceCommon
integer ISTAT                                       # MJC 6/9/2K (E2145)
#$% set status flag to YES
  istat = $yes
 
  #$% send verification message
  call echor
  call echov ("Verifying LIDAR Regions.....")
 
  # This space available for possible future verification requirements
 
return
end

 
subroutine FVRair (istat)               # verify air maintenance log
 
###############################################################
#$%
#$% Purpose:   FVRAIR verifies air maintenance log entries.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
ForceCommon
integer ISTAT,
        K,
        KAML,
        KAMLA,
        KAIR,
        KFORCE,
        IT_DUPS_FORCE,
        IT_DUPS_BOAT                             # MJC 6/9/2K (E2145)
logical itf,ibf
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Air Maintenance Log........")
 
#$% for each air maintenance log entry
for (k=1; k<=naml; k=k+1)
   {
    #$% set AML pointer to map
    aml$pointer$to k
    aml$map
    #$% if slot not in use, get next
    if (aml$InUse == $no) next
    itf = .true.
    #$% for each air entry
    for (air$index=1; air$index<=nair; air$index=air$index+1)
       {
        #$% if type is air name
        if (aml$type == air$name)
           {
            itf = .false.
            break
           }
       }
 
    ibf = .true.
    #$% for each force entry
    for (force$index=1; force$index<=nforce; force$index=force$index+1)
       {
        #$% if base name is force name
        if (aml$basename == force$name)
           {
            ibf = .false.
            break
           }
       }
 
    call check_force_name ( AML$SideNumber, it_Dups_force )   # DEW 4/2/90
    call check_bml_name   ( AML$SideNumber, it_Dups_boat )    # DEW 4/2/90
 
    if (itf | ibf | it_dups_force == $yes | it_dups_boat == $yes )
       {
        istat = $no             # cause a reject
 
        call echor
        call echohn (aml$sidenumber,5)
 
        if (itf | ibf )
            {
            if (itf)
               {
                call echov (" type ")
                call echohn (aml$type,$$MAXname) # 5 jb E2141 8-char 12/29/99
               }
            if (ibf)
               {
                call echov (" base ")
                call echohn (aml$basename,$$MAXname) # 5 jb E2141 8-ch 12/29/99
               }
 
            call echov (" not present.")
            }
 
        if (it_dups_force == $yes)
            {
            call echov (" Duplicates a force name.")
            }
 
        if (it_dups_boat == $yes )
            {
            call echov (" Duplicates a boat name.")
            }
       }
 
   } # end for each AML entry
 
return
end

 
subroutine fvrg (istat)                 # verify guide
 
##############################################################
#$%
#$% Purpose:   FVRG verifies guide entries.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
ForceCommon
integer ISTAT,
        KFORCE,
        JSTAT,
        NSTAT,
        K                                       # MJC 6/9/2K (E2145)
literal taskn
integer iview1, iview2
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Guides.......")
 
#$% for each force entry
for (force$index=1; force$index<=nforce; force$index=force$index+1)
   {
    #$% if guide is not specified, get next force element
    if (force$guide == 0) next                  # skip non-guided forces
 
    #$% set status flags to NO
    jstat = $no
    nstat = $no
 
    if (force$task <= 9999) iview1 = force$task/100
    else                    iview1 = force$task/1000
 
    #$% for each entry
    for (k=1; k<=nforce; k=k+1)
       {
        #$% if entry is index, get next
        if (k == force$index) next
 
        iview2 = wiforce[1,1,k]/1000
 
        #$% if guide
        if (force$guide    != wrforce[2,k] )  # name match
            {
            nstat = $yes   # or added 5/21/90,reh
            }
 
        if (iview1         != iview2          |                 # view &
            force$guide    != wrforce[2,k]     ) next           # name match
 
        #$% set status to YES
        jstat = $yes
        #$% break
        break
       }
 
    #$% if status is yes, get next
    if (jstat == $yes) next
 
    #$% send message
    call fgtask (force$task,taskn)
    call echor
    call echohN (taskn,$$MAXlit)  # 8 jb E2141 8-char.names 12/29/99
    call echov  (" ")
    call echohN (force$name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
    call echov (" is guiding on ")
    call echohN (force$guide,$$MAXname) # 5 jb E2141 8-char.names 12/29/99
    call echov (", which is not present.")
 
    #$% if status is yes
    if (nstat == $yes)
       {
        #$% send guide message
        call echor
        call echov ("          (Guide must be in the same view)")
       }
 
    #$% set status to NO
    istat = $no
   }
 
return
end
 

 
subroutine FVReph (istat)
 
######################################################################
#$%
#$% Purpose:   FVREPH verifies data associated with Engagement
#$%            Probabilities of Hit.
#$%
#$% Date:      November 1983
#$%
#$% Author:    Jim Kvederis
#$%
######################################################################
 
ForceCommon
integer ISTAT,
        I,
        KEPH,
        KEPHA,
        KFORCE,
        KAIR,
        KCRUIS,
        KWEAP                                       # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Probabilities of Hit Data......")
 
#$% loop through each Prob of Hit entry for targets
for (i = 1; i <= neph; i = i + 1)
   {
    eph$pointer$to i            # set eph pointer
    eph$map
 
    #$% search for ship or sub in force file
    for (force$index=1; force$index<=nforce; force$index=force$index+1)
       {
        #$% if target is a class of ship in scenerio
        if (eph$target == force$class)  next 2
       }
 
    for (air$index=1; air$index<=nair; air$index=air$index+1)
       {
        #$% if target is an air name in scenerio
        if (eph$target == air$name)  next 2
       }
 
    for (cruise$index=1; cruise$index<=ncruis; cruise$index=cruise$index+1)
       {
        #$% if target is an air name in scenerio
        if (eph$target == cruise$name) next 2
       }
 
     call echor
     call echov  (" Warning: Undefined target type: ")
     call echohn (eph$target, $$MAXlit)  # 8 jb E2141 8-char.names 12/29/99
 
#     istat = $no       #
    }
 
#$% loop through each Prob of Hit entry for weapons
for (i = 1; i <= neph; i = i + 1)
   {
    eph$pointer$to i            # set eph pointer
    eph$map
 
    for (cruise$index=1; cruise$index<=ncruis; cruise$index=cruise$index+1)
       {
        #$% if target is an air name in scenerio
        if (eph$target == cruise$name) next 2
       }
 
    for (weapon$index=1; weapon$index<=nweap; weapon$index=weapon$index+1)
       {
        #$% if weapon is in the scenerio
        if (eph$weapon == weapon$name) next 2
       }
 
     call echor
     call echov  (" Warning: Undefined Weapon type named: ")
     call echohn (eph$weapon, $$MAXname)  # 8 jb E2141 8-char.names 12/29/99
     call echov  (" Vs ")
     call echohn (eph$target, $$MAXname)  # 8 jb E2141 8-char.names 12/29/99
 
     #$% set status flag to NO
#    istat = $no
    }
 
return
end
 

 
subroutine FVRatt (istat)
 
######################################################################
#$%
#$% Purpose:   FVRATT verifies data associated with Attrition
#$%            coefficient table
#$%
#$% Date:      May 1991
#$%
#$% Author:    J. Richardson
#$%
######################################################################
 
ForceCommon
integer ISTAT,
        I,
        KATT,
        KATTA,
        KGROUNDUNIT                                     # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message for FWL Coef. table #1
call echor
call echov ("Verifying Attrition coefficient data....")
 
#$% loop through each att entry for attackers
for (i = 1; i <= natt; i = i + 1)
   {
    att$pointer$to i		# set att pointer
    att$map
 
    #$% search for ground unit in force file
    for (groundunit$index=1; groundunit$index<=ngroundunit; groundunit$index=groundunit$index+1)
       {
	#$% if attacker is a groundunit in the scenerio
	if (att$attacker == groundunit$name)  next 2
       }
 
    call echor
    call echov  (" ATT table : Undefined attacker : ")
    call echohn (att$attacker, $$MAXname)  # 5 jb E2141 8-char.names 12/29/99
 
    #$% set status flag to NO
    istat = $no	
   }
 
#$% loop through each att entry for defenders
for (i = 1; i <= natt; i = i + 1)
   {
    att$pointer$to i		# set att pointer
    att$map
 
    #$% search for ground unit in force file
    for (groundunit$index=1; groundunit$index<=ngroundunit; groundunit$index=groundunit$index+1)
       {
	#$% if defender is a groundunit in the scenerio
	if (att$defender == groundunit$name)  next 2
       }
 
    call echor
    call echov  (" ATT table : Undefined defender : ")
    call echohn (att$defender, $$MAXname)  # 5 jb E2141 8-char.names 12/29/99
 
    #$% set status flag to NO
    istat = $no	
   }
 
return
end
 

 
subroutine fsavec (nchar,wchar,opt,title)
 
###########################################################################
#$%
#$% Purpose:   FSAVEC takes specified system characteristics data from
#$%            the equipment file and loads it into the scenario file.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FPUTR      FGETR
#$%            FDCLOS
#$%
#$% Tables:    None
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###########################################################################
 
Forcecommon
integer K,
        K5,
        LFCS,
        ISTAT,
        NREC,
        LFCB,
        KREC                                     # MJC 6/9/2K (E2145)
integer nchar,wichar[$intrealmatch,5,$weapons]   #jb 180 vice 140    2/2/89
literal wchar[5,$weapons],wrchar[5,$weapons] #jb 180 vice 140
equivalence (wrchar,wichar)
VMSchar*(*) opt,title
 
for (k = 1; k <= nchar; k=k+1)                  # move to local array with
   {                                            # integer and real overlay
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wrchar[k5,k] = wchar[k5,k]
       }
   }
#$% open scenario file
call FDopen ($write,scenario$name,$lits,opt,32*4,lfcS,istat)
 
#$% set record counter
nrec = 2
 
#$% if runtype is update
if (typrun == 'UPDAT')                          # if update run... save old
   {
    #$% read current record file
    read (lfcS,rec=1,err=8010) nrec      #     get old rec count
    #$% set record file to next slot
    nrec = nrec + 1                             #     set next addr to write
   }
 
8010 continue
 
#$% open build file
call FDopen ($read,build$name,$litC,opt,32*4,lfcB,istat)
 
#$% for each entry
for (k = 1; k <= nchar; k= k + 1)
   {
    #$% convert long word integer to quad word
    krec = wichar[$halfquad,2,k]
 
    #$% if record is zero, get next
    if (krec == 0) next                          # skip old records
 
    #$% get build data
    call fgetr (lfcB,krec,16,rrec)               # get from BUILD
 
    #$% put data in scenario file
    call fputr (lfcS,nrec,16,rrec)               # put to SCENARIO
   }
#$% decrement record count
nrec = nrec - 1
#$% update record count
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close files
#$% close build file
call FDclos (lfcB)
 
for (k = 1; k <= nchar; k=k+1)                  # move to call array from
   {                                            # integer and real overlay
    for (k5 = 1; k5 <= 5; k5=k5+1)
       {
        wchar[k5,k] = wrchar[k5,k]
       }
   }
 
return
end
 

 
subroutine fsavFC                                       # save force file
 
#################################################################
#$%
#$% Purpose:   FSAVFC stores force data on the scenario file.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     ECHOR      FDCLOS
#$%            FGTASK     ECHOH
#$%
#$% Tables:    FORCE
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#$% Modified:  James Allen - 12/97 (E1827)
#$%            Removed the saving of the ground task
#$%            organizations since the gorund unit development
#$%            was never completed.
#$%
#################################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KFORCE,
        M                                           # MJC 6/9/2K (E2145)
literal taskn,forcdata[12]  #JFR 6/3/91 -orgdata[21]
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,force$file,24*4,lfcS,istat)   # khc 6/2/92
#$% set record pointer
nrec = 2
 
#$% for each force entry
for (force$index=1; force$index<=nforce; force$index=force$index+1)
   {
    #$% if force guide is specified, get next force element
    if (force$guide != 0) next                  # skip guided forces
 
    #$% generate task number and send message.
    call fgtask (force$task,taskn)
    call echor
    call echoh (taskn,10)
    call echohN (force$name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
    call echov ("...")
 
    forcdata[1] = force$task
    forcdata[2] = force$name
    forcdata[3] = force$class
    forcdata[4] = force$lat
    forcdata[5] = force$long
    forcdata[6] = force$course
    forcdata[7] = force$speed
    forcdata[8] = force$guide
    forcdata[9] = force$range
    forcdata[10]= force$bearing
    forcdata[11]= force$depth
    forcdata[12]= force$indicator      #KHC 6/2/92
 
    #$% save data on scenario file JFR 5/10/91 (28 vice 11)
    write (lfcS,rec=nrec) (forcdata[m],m=1,12)    # put to SCENARIO       #KHC 6/2/92
    #$% set record pointer to next slot
    nrec = nrec + 1
   }
 
for (force$index=1; force$index<=nforce; force$index=force$index+1)
   {
    if (force$guide == 0) next                  # only guided forces
 
    call fgtask (force$task,taskn)
    call echor
    call echoh (taskn,10)
    call echohN (force$name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
    call echov ("...")
 
    forcdata[1] = force$task
    forcdata[2] = force$name
    forcdata[3] = force$class
    forcdata[4] = force$lat
    forcdata[5] = force$long
    forcdata[6] = force$course
    forcdata[7] = force$speed
    forcdata[8] = force$guide
    forcdata[9] = force$range
    forcdata[10]= force$bearing
    forcdata[11]= force$depth
    forcdata[12]= force$indicator      #KHC 6/2/92
 
    #$% save data on scenario file
    write (lfcS,rec=nrec) (forcdata[m],m=1,12)    # put to SCENARIO       #KHC 6/2/92
 
    #$% set record pointer to next slot
    nrec = nrec + 1
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store data on scenaio file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close files
 
return
end
 

 
subroutine fsavPT                                       # save Commpaths
 
#############################################################
#$%
#$% Purpose:   FSAVPT writes communication path data to
#$%            disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     ECHOH      ECHOR
#$%            FDCLOS
#$%
#$% Tables:    PATH       NODE
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KPATH,
        KNODE,
        M                                           # MJC 6/9/2K (E2145)
literal pathdata[6]
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,path$file,12*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% for each path index
for (path$index=1; path$index<=npaths; path$index=path$index+1)
   {
    #$% send path name
    call echor
    call echohN (path$name,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
    call echov ("...")
 
    #$% set node$index to 1
    node$index = 1
 
    #$% load path data
    pathdata[1]= path$name
    pathdata[2]= path$nodes
    pathdata[3]= path$rho
    pathdata[4]= path$mu
    pathdata[5]= path$pair
    pathdata[6]= path$ckt
 
    #$% save record on scenario file
    write (lfcS,rec=nrec) (pathdata[m],m=1,6)
    #$% set record pointer to next slot
    nrec = nrec + 1
 
    #$% for each node entry
    for (node$index=2; node$index<=path$nodes; node$index=node$index+1)
       {
         #$% load path data
         pathdata[1]= path$cat
         pathdata[2]= path$class
         pathdata[3]= path$rho
         pathdata[4]= path$mu
         pathdata[5]= path$pair
         pathdata[6]= path$roger
         write (lfcS,rec=nrec) (pathdata[m],m=1,6)
         nrec = nrec + 1
       }
   }
 
#$% write path count
write (lfcS,rec=1) $count_w_fingerprint(npaths)  # write record count
 
#$% close scenario file
call FDclos (lfcS)
 
return
end

 
subroutine fsavEM                                       # save emitters
 
#############################################################
#$%
#$% Purpose:   FSAVEM writes fingerprinted emitter list to
#$%            disk for storage.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC                                        # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,emitter$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = nemit*2 + 1
 
#$% move data to working array
call fsmove (wremit,rrec[2],nemit*2)
 
#$% put current emitter record on scenario file
call fputr (lfcS,nrec,16,rrec)
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavEP                                       # save emcon plans
 
#############################################################
#$%
#$% Purpose:   FSAVEP writes emission control plan data to
#$%            disk for storage.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
#############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KEMCON,
        KEMCOX                                      # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,emcon$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = 10 + 1
 
#$% for each EMCON entry
for (emcon$index = 1 ;emcon$index <= nemcon; emcon$index = emcon$index + 1)
   {
    #$% save side, and save plan name
    rrec[2] = emcon$side
    rrec[3] = emcon$name
 
    #$% for each EMCON option
    for (emcon$option$index = 1 ;emcon$option$index <= 8;
         emcon$option$index = emcon$option$index + 1)
       {
        #$% if EMCON option is on set option to "YES"
        if (emcon$option == $on) rrec[3+emcon$option$index] = 'YES'
        #$% else set option to "NO"
        else                     rrec[3+emcon$option$index] = 'NO'
       }
 
    #$% put current EMCON record on scenario file
    call fputr (lfcS,nrec,16,rrec)
   }
 
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavWT                                       # save weather
 
##################################################################
#$%
#$% Purpose:   FSAVWT writes weather data to disk for storage.
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
##################################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KWET,
        KWETA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,wet$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = 10 + 1
nweath = 0
 
#$% for each weather entry
for (wet$pointer$first; wet$pointer$valid; wet$pointer$next)
   {
    wet$map
    #$% if slot not in use, get next slot
    if (wet$InUse == $no) next
 
    #$% increment pointer
    nweath = nweath + 1
 
    #$% save weather region data
    rrec[2]  = wet$pointer$index - 1            # region number (index)
    rrec[3]  = wet$waveheight
    rrec[4]  = wet$wavedirection
    rrec[5]  = wet$windspeed
    rrec[6]  = wet$winddirection
    rrec[7]  = wet$cloudcover
    rrec[8]  = wet$ceiling
    rrec[9]  = wet$clouddepth
    rrec[10] = wet$visibility
    rrec[11] = wet$category
 
    #$% put current weather record on scenario file
    call fputr (lfcS,nrec,16,rrec)               # write weather record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavHF                                       # save hfdf data
 
###############################################################
#$%
#$% Purpose:   FSAVHF writes HFDF data to disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FDCLOS     FPUTR
#$%
#$% Tables:    HFD
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KHFD,
        KHFDA,
        I,
        K,
        KHFDX                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,hfd$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec[1] = 101 + 1
 
#$% set HFD pointer to first map
hfd$pointer$first
hfd$map
#$% for each entry
for (i=1; i<=nhfdf; i=i+1)
   {
    #$% save base name and record
    rrec[2]  = hfd$basename              # base name
    for (k=1; k<=100; k=k+1)
       {
        hfd$index = k
        rrec[k+2] = hfd$prob
       }
 
    #$% put current HFDF record on scenario file
    call fputr (lfcS,nrec,16,rrec)               # write hfdf record
    #$% set HFD pointer to next map
    hfd$pointer$next
    hfd$map
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavSO                                       # save sosus data
 
###############################################################
#$%
#$% Purpose:   FSAVSO writes SOSUS data to disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FDCLOS     FPUTR
#$%
#$% Tables:    SOS
#$%
#$% Date:      FEBRUARY 82
#$%
#$% Author:    R. KLEIMAN/J. KVEDERIS
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KSOS,
        KSOSA,
        I,
        KSOSX1,
        KSOSX2,
        IX,
        KSOSX3                                      # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,sos$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#rrec [1] = sos$entry + 1
 
#$% for each SOSUS entry
for (k = 1; k <= nsos; k = k + 1)
   {
    #$% set SOS pointer to map
    sos$pointer$to k
    sos$map
    #$% if not in use get next slot
    if (sos$InUse == $no) next
 
    #$% save SOSUS data
    rrec[1] = 1 + 6 + sos$pos$slots*2 + 3
    rrec[2] = 'REG'
    rrec[3] = sos$regnumber
    rrec[4] = sos$meanaxislength
    rrec[5] = sos$sigmalength
    rrec[6] = sos$boundarydepth
    rrec[7] = sos$numberofsets
 
    #$% save bistatic region data
    rrec[8] = sos$bis$regionarea
    rrec[9] = sos$bis$nodedensity
    rrec[10] = sos$bis$range
 
    i = 11
    #$% for each SOSUS position entry
    for (sos$pos$index = 1; sos$pos$index <= sos$pos$slots;
         sos$pos$index = sos$pos$index + 1)
       {
        #$% save position latitude
        rrec[i] = sos$pos$lat
        #$% save position longitude
        rrec[i+1] = sos$pos$lon
        i = i + 2
       }
 
    #$% put SOSUS region record on scenario file
    call fputr (lfcS,nrec,16,rrec)               # write sosus region record
 
    #$% for each number of sets entry
    for (i=1; i<=sos$numberofsets; i=i+1)
       {
        #$% set sub index
        sos$sub$index = i
 
        #$% save sub records
        rrec[1] = 1 + 5 + sos$det$slots
        rrec[2] = 'SUB'
        rrec[3] = sos$regnumber
        rrec[4] = sos$sub$class
        rrec[5] = sos$sub$depth                  # shallow or deep
        rrec[6] = sos$sub$propmode
 
        ix = 7
        #$% for each SOSUS detection entry
        for (sos$det$index = 1; sos$det$index <= sos$det$slots;
             sos$det$index = sos$det$index + 1)
           {
            #$% save sub detection record
            rrec[ix] = sos$sub$det$prob
            ix = ix + 1
           }
 
        #$% put current sub record on scenario file
        call fputr (lfcS,nrec,16,rrec)           # write sosus record
       }
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavBPAIR                            # save bistatic pair data
 
###############################################################
#$%
#$% Purpose:   FSAVBPAIR writes bistatic pair data to disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FDCLOS     FPUTR
#$%
#$% Tables:    BIS
#$%
#$% Date:      June 91
#$%
#$% Author:    C. Leaf
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KBIS,
        KBISA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write, scenario$name, $lits, bis$file, 32*4, lfcS, istat)
 
#$% set record pointer
nrec = 2
 
#$% for each bistatic pair entry
for (k = 1; k <= nbis; k = k + 1)
   {
    #$% set BIS pointer to map
    BIS$Pointer$To k
    BIS$map
 
    #$% if not in use get next slot
    if (BIS$ActiveSource == $no)
      next
 
    #$% save bistatic pair data
    rrec[1] = 1 + 2
    rrec[2] = BIS$ActiveSource
    rrec[3] = BIS$PassiveReceiver
 
    #$% put bistatic pair record on scenario file
    call fputr (lfcS, nrec, 16, rrec)           # write bistatic pair record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavSWABS                            # save SWABS data
 
###############################################################
#$%
#$% Purpose:   FSAVSWABS writes SWABS data to disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FDCLOS     FPUTR
#$%
#$% Tables:    SWB
#$%
#$% Date:      February 1991
#$%
#$% Author:    Carol Kropp and Susan Miller
#$%
###############################################################
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KSWB,
        KSWBA,
        KSWBX1,
        KSWBX2,
        KSWBX3                                      # MJC 6/9/2K (E2145)
integer  i
 
  #$% open scenario file
  call FDopen ($write, scenario$name, $lits, swb$file, 32*4, lfcS, istat)
 
  #$% set record pointer
  nrec = 2
 
  #$% for each SWABS entry
  for (SWB$pointer$first; SWB$pointer$valid; SWB$pointer$next)
    {
     swb$map
     #$% if not in use get next slot
     if (swb$InUse == $no)
       next
 
     #$% save SWABS data
     rrec[1] = 1 + 6 + SWB$pos$slots*2
     rrec[2] = 'REG'
     rrec[3] = SWB$regnumber
     rrec[4] = SWB$regdefined
     rrec[5] = SWB$locationerror
     rrec[6] = SWB$sigma
     rrec[7] = SWB$numberofsets
 
     i = 8
     #$% for each SWABS position entry
     for (swb$pos$index = 1; swb$pos$index <= swb$pos$slots;
                                    swb$pos$index = swb$pos$index + 1)
       {
        #$% save position latitude
        rrec[i] = swb$pos$lat
        #$% save position longitude
        rrec[i+1] = swb$pos$lon
        i = i + 2
       }
 
     #$% put SWABS region record on scenario file
     call fputr (lfcS, nrec, 16, rrec)         # write SWABS region record
 
     #$% for each number of sets entry
     for (swb$sub$index = 1; swb$sub$index <= swb$numberofsets;
                             swb$sub$index  = swb$sub$index + 1)
       {
        #$% save sub records
        rrec[1] = 1 + 3 + swb$det$slots
        rrec[2] = 'SUB'
        rrec[3] = swb$regnumber
        rrec[4] = swb$sub$class
 
        i = 5
        #$% for each SWABS detection entry
        for (swb$det$index = 1; swb$det$index <= swb$det$slots;
                                    swb$det$index = swb$det$index + 1)
          {
           #$% save sub detection record
           rrec[i] = swb$sub$det$prob
           i = i + 1
          }
 
        #$% put current sub record on scenario file
        call fputr (lfcS, nrec, 16, rrec)        # write SWABS sub record
       }
    }
 
  #$% decrement record pointer
  nrec = nrec - 1
 
  #$% store record count on scenario file
  write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
  #$% close scenario file
  call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavSN                                # save sosus data
 
############################################################################
#$%
#$% Purpose:   FSAVSN writes Sonar Environment Region data to disk for storage.
#$%
#$% Date:      June 1983
#$%
#$% Author:    J. P. KVEDERIS
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KSON,
        KSONA,
        I,
        KSONX1                                      # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,son$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% for each Sonar Environment Region entry
for (k = 1; k <= nson; k = k + 1)
   {
    #$% set SON pointer to the Sonar Environment Region
    son$pointer$to k
    son$map
    #$% if not in use get next slot
    if (son$InUse == $no) next
 
    #$% save Sonar Environent Region data
    rrec[1] = 1 + 6 + son$pos$slots*2
    rrec[2] = 'SNRREG'
    rrec[3] = son$regnumber
    rrec[4] = son$sonarenv
 
    i = 5
    #$% for each Sonar Environment Region entry
    for (son$pos$index = 1; son$pos$index <= son$pos$slots;
         son$pos$index = son$pos$index + 1)
       {
        #$% save position latitude
        rrec[i] = son$pos$lat
        #$% save position longitude
        rrec[i+1] = son$pos$lon
        i = i + 2
       }
 
    #$% put Sonar Environment Region record on scenario file
    call fputr (lfcS,nrec,16,rrec)               # write sosus region record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

subroutine fsavLDR                              # save LIDAR region data
 
############################################################################
#$%
#$% Purpose:   FSAVLDR writes LIDAR Region data to disk for storage.
#$%
#$% Date:      February 1991
#$%
#$% Author:    Susan Miller and Carol Kropp
#$%
###########################################################################
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KLDR,
        KLDRA,
        KLDRX1                                      # MJC 6/9/2K (E2145)
integer  i
 
  #$% open scenario file
  call FDopen ($write, scenario$name, $lits, ldr$file, 32*4, lfcS, istat)
  #$% set record pointer
  nrec = 2
 
  #$% for each LIDAR Region
  for (ldr$pointer$first; ldr$pointer$valid; ldr$pointer$next)
    {
     ldr$map
     #$% if not in use get next slot
     if (ldr$InUse == $no) next
 
     #$% save LIDAR Region data
     rrec[1] = 1 + 3 + ldr$pos$slots*2
     rrec[2] = 'LDRREG'
     rrec[3] = ldr$regnumber
     rrec[4] = ldr$Kvalue
 
     i = 5
     #$% for each LIDAR Region entry
     for (ldr$pos$index = 1; ldr$pos$index <= ldr$pos$slots;
          ldr$pos$index = ldr$pos$index + 1)
       {
        #$% save position latitude
        rrec[i] = ldr$pos$lat
        #$% save position longitude
        rrec[i+1] = ldr$pos$lon
        i = i + 2
       }
 
     #$% put LIDAR Region record on scenario file
     call fputr (lfcS ,nrec, 16, rrec)           # write LIDAR region record
    }
 
  #$% decrement record pointer
  nrec = nrec - 1
  #$% store record count on scenario file
  write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
  #$% close scenario file
  call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavAL                                       # save aml data
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KAML,
        KAMLA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,aml$file,16*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec[1] = aml$entry + 1
 
#$% for each air maintenance log entry
for (k = 1; k <= naml; k = k + 1)
   {
    #$% set AML pointer to map
    aml$pointer$to k
    aml$map
 
    #$% save AML data
    rrec[2]  = aml$sidenumber
    rrec[3]  = aml$type
    rrec[4]  = aml$basename
    rrec[5]  = aml$timeflown
    rrec[6]  = aml$timeup
    rrec[7]  = aml$sqdindx
    rrec[8]  = aml$defaultmission
 
    #$% put current AML record on scenario file
    call fputr (lfcS,nrec,8,rrec)                # write aml record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavSS                                       # save survsat data
 
############################################################################
#$%
#$% Purpose:   FSAVSN writes Surviellence Satelite data to disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FDCLOS     FPUTR
#$%
#$% Tables:    SON
#$%
#$% Date:      February 1983
#$%
#$% Author:    R. KLIEMAN / J. P. KVEDERIS
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KSST,
        KSSTA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,sst$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = sst$entry + 1
 
#$% for each surveillance satellite entry
for (k = 1; k <= nssts; k = k + 1)
   {
    #$% set SST pointer to map
    sst$pointer$to k
    sst$map
 
    #$% save surveillance satellite data
    rrec[2]  = sst$name
    rrec[3]  = sst$type
    rrec[4]  = sst$period
    rrec[5]  = sst$altitude
    rrec[6]  = sst$inclination
    rrec[7]  = sst$xtime
    rrec[8]  = sst$xlongitude
    rrec[9]  = sst$dutycycle
    rrec[10] = sst$groundstation
    rrec[11] = sst$latitude
    rrec[12] = sst$longitude
    rrec[13] = sst$orbit
 
 
 
    #$% put current SST record on scenario file
    call fputr (lfcS,nrec,16,rrec)                # write survsat record
 
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavTN                                       # save Tonal values
 
############################################################################
#$%
#$% Purpose:   FSAVTN writes Sonar Tonal values to disk for storage.
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KTON,
        KTONA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,ton$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = ton$entry + 1
 
#$% for each sonar tonal entry
for (k = 1; k <= nton; k = k + 1)
   {
    #$% set TON pointer to map
    ton$pointer$to k
    ton$map
 
    #$% save TONAL data
    rrec[2] = ton$name
    rrec[3]  = ton$classification1
    rrec[4]  = ton$classification2 # save 2nd classification name - JFR 5/7/93 (E1142)
    rrec[5]  = ton$classification3 # save 3rd classification name - JFR 5/7/93
    rrec[6]  = ton$classification4 # save 4th classification name - JFR 5/7/93
 
    #$% put current TON record on scenario file
    call fputr (lfcS,nrec,16,rrec)                # write tonal record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
subroutine fsavPH                                       # save PROBHIT values
 
############################################################################
#$%
#$% Purpose:   FSAVPH writes Probability of Hit values to disk for storage.
#$%
#$% Date:      NOVEMBER 83
#$%
#$% Author:    Jim Kvederis
#$%
#############################################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KEPH,
        KEPHA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,eph$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = eph$entry + 1
 
#$% for each prob of hit entry
for (k = 1; k <= neph; k = k + 1)
   {
    #$% set EPH pointer to map
    eph$pointer$to k
    eph$map
 
    #$% save PROB OF HIT data
    rrec[2] = eph$target
    rrec[3] = eph$weapon
    rrec[4] = eph$percent
 
    #$% put current PROB OF HIT record on scenario file
    call fputr (lfcS,nrec,16,rrec)                # write PROBHIT record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavMB                                       # save members
 
############################################################################
#$%
#$% Purpose:   FSAVMB writes Commpath Member data to disk for storage.
#$%
#$% Date:      February 1982
#$%
#$% Author:    R. KLIEMAN / J. P. KVEDERIS
#$%
###############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC                                        # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,member$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec [1] = nmembr + 1
#$% move data to working array
call fsmove (wrmembr,rrec[2],nmembr)
 
#$% put current member record on scenario file
call fputr (lfcS,nrec,16,rrec)
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavOR                                       # save orders
 
Forcecommon
integer LFCS,
        ISTAT,
        K,
        NREC,
        M                                               # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,orders$file,$ParserRecLen*2*4,lfcS,istat)
 
#$% for each prestored order entry
for (k=1; k<= norder; k=k+1)
   {
    #$% increment record pointer
    nrec = k + 1
    #$% write order data on scenario file
    write (lfcS,rec=nrec) (wrorder[m,k],m=1,$ParserRecLen)
   }
 
 
#$% store order record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(norder)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavPN                                       # save plans
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        ISIZE,
        J,
        M                                               # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,plans$file,$ParserRecLen*2*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% for each plan entry
for (k=1; k<= nplans; k=k+1)
   {
    #$% set contingency plan size
    isize = wiplan[$halfquad,3,1,k]
 
    #$% for each size entry
    for (j=1; j<= isize; j=j+1)
       {
        #$% write plan data on scenario file
        write (lfcS,rec=nrec) (wrplan[m,j,k],m=1,$ParserRecLen)
        #$% increment record pointer
        nrec = nrec + 1
       }
   }
 
 
#$% store plan count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nplans)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end

 
subroutine fsavSR                                       # save search
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        ISIZE,
        J,
        M                                               # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,search$file,$ParserRecLen*2*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% for each search plan entry
for (k=1; k<= nsearc; k=k+1)
   {
    #$% set search plan size
    isize = wisearc[$halfquad,3,1,k]
 
    #$% for each search plan size
    for (j=1; j<= isize; j=j+1)
       {
        #$% write plan data on scenario file
        write (lfcS,rec=nrec) (wrsearc[m,j,k],m=1,$ParserRecLen)
        #$% increment record pointer
        nrec = nrec + 1
       }
   }
 
 
#$% store search plan count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nsearc)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
subroutine fsavAC                                       # save action
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        ISIZE,
        J,
        M                                               # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,action$file,$ParserRecLen*2*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% for each action plan entry
for (k=1; k<= nact; k=k+1)
   {
    #$% set action plan size
    isize = wiact[$halfquad,3,1,k]
 
    #$% for each action plan size
    for (j=1; j<= isize; j=j+1)
       {
        #$% write plan data on scenario file
        write (lfcS,rec=nrec) (wract[m,j,k],m=1,$ParserRecLen)
        #$% increment record pointer
        nrec = nrec + 1
       }
   }
 
 
#$% store action plan count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nact)   # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

 
subroutine fsavbml     # save bml data to disk
 
#############################################################
#$%
#$% Purpose:   FSAVBML writes boat maintenance log data to
#$%            disk for storage.
#$%
#$% Called By: FBYEGN
#$%
#$% Calls:     FDOPEN     FPUTR      FDCLOS
#$%
#$% Tables:    BML
#$%
#$% Date:      MAY 1989
#$%
#$% Author:    Robert E. Hundt
#$%
#############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        K,
        KBML,
        KBMLA                                       # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,bml$file,8*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
rrec[1] = bml$entry + 1
 
#$% for each air maintenance log entry
for (k = 1; k <= nbml; k = k + 1)
   {
    #$% set bml pointer to map
    bml$pointer$to k
    bml$map
 
    #$% save bml data
    rrec[2]  = bml$name
    rrec[3]  = bml$class
    rrec[4]  = bml$basename
 
    #$% put current bml record on scenario file
    call fputr (lfcS,nrec,6,rrec)                # write bml record
   }
 
#$% decrement record pointer
nrec = nrec - 1
#$% store record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 
 

 
subroutine FVRboat (istat)               # verify boat maintenance log
 
###############################################################
#$%
#$% Purpose:   FVRBOAT verifies boat maintenance log entries.
#$%
#$% Called By: FBYEVR
#$%
#$% Calls:     ECHOH      ECHOR      ECHOHN
#$%
#$% Tables:    BML
#$%
#$% Date:      MAY 1989
#$%
#$% Author:    R.E. Hundt
#$%
###############################################################
 
ForceCommon
integer ISTAT,
        K,
        KBML,
        KBMLA,
        KCLASS,
        KFORCE,
        IT_DUPS_FORCE,
        IT_DUPS_AIR                                     # MJC 6/9/2K (E2145)
logical    ibase_not_found
logical    iclass_not_found
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Boat Maintenance Log........")
 
#$% for each boat maintenance log entry
for (k=1; k<=nbml; k=k+1)
   {
    #$% set bml pointer to map
    bml$pointer$to k
    bml$map
    #$% if slot not in use, get next
    if (bml$InUse == $no) next
 
    iclass_not_found = .true.
 
    #$% for each ship characteristics entry
    for (class$index=1; class$index<=nclass; class$index=class$index+1)
       {
        #$% if ship characteristics class is boat name
        if (bml$class == class$name)
           {
            iclass_not_found = .false.
            break
           }
       }
 
    ibase_not_found = .true.
 
    #$% for each force entry
    for (force$index=1; force$index<=nforce; force$index=force$index+1)
       {
        #$% if base name is force name,
        if (bml$basename == force$name)
           {
            ibase_not_found = .false.
            break
           }
       }
 
    call check_force_name ( bml$name, it_Dups_force )   # DEW 4/2/90
    call check_aml_name   ( bml$name, it_Dups_air   )   # DEW 4/2/90
 
 
    # error condition
    if (iclass_not_found | ibase_not_found |
        it_dups_force == $yes | it_dups_air == $yes )
       {
        #$% set status flag to NO
        istat = $no
        #$% send boat name
        call echor
        call echov ("  Warning: ")
        call echohn (bml$name ,$$MAXname)  # 5 jb E2141 8-char.names 12/29/99
        if (iclass_not_found | ibase_not_found )
            {
            if (iclass_not_found)
               {
                #$% send type
                call echov (" class ")
                call echohn (bml$class,$$MAXname) # 5 jb E2141 8-char. 12/29/99
               }
            if (ibase_not_found)
               {
                #$% send base name
                call echov (" base ")
                call echohn (bml$basename,$$MAXname) #5 jb E2141 8-ch 12/29/99
               }
            #$% send not present message
            call echov (" not present.")
            }
 
        if (it_dups_force == $yes)
            {
            call echov (" Duplicates a force name.")
            }
 
        if (it_dups_air == $yes )
            {
            call echov (" Duplicates an aircraft name.")
            }
       }
   }
 
return
end
 

subroutine FVRuvp (istat)
 
######################################################################
#$%
#$% Purpose:   FVRUVP verifies data associated with UAV
#$%            Probability data.
#$%
#$% Date:      2/2/90
#$%
#$% Author:    R. Hundt
#$%
######################################################################
 
ForceCommon
logical iorder_err
integer ISTAT,
        KUVP                                        # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying UAV Probability Data......")
 
#$% loop through each UAV Probability data record
for (uvp$Index = 1; uvp$Index <= nuvp; uvp$Index = uvp$Index + 1)
    {
    iorder_err = $no
 
    FOR (UVP$NumRanges = 1; UVP$NumRanges <= $UAV$NumRangesPerType;
         UVP$NumRanges = UVP$NumRanges + 1)
        {
        #$% if probabilities not entered in decreasing value (within same range)
        IF (UVP$IdentPb > UVP$RecognitionPb |
            UVP$IdentPb > UVP$DetectPb |
            UVP$RecognitionPb > UVP$DetectPb)
            {
            iorder_err = $yes
            }
        }
 
    IF ( iorder_err == $yes )
        {
        call echor
        call echov(" Warning: Probabilities not entered in decreasing value for ")
        call echov("target type index ")
        call echoi (UVP$TargTypeIndex)
        call echor
        }
    }
return
end
 

subroutine fsavuvp              # save UAV PROBABILITY values
 
############################################################################
#$%
#$% Purpose:   FSAVUVP writes UAV Probability data to disk for storage.
#$%
#$% Date:      2/6/90
#$%
#$% Author:    R. Hundt
#$%
#$% Note:      For those not familiar with the FORCE program, the following
#$%             is offerred.
#$%
#$%            Two types of records are used in the program.
#$%             1) Scenario Record : an array of literal type (real*8)
#$%             which contains data relevant to specific scenario data.
#$%             Element number one contains the number (in Longwords) of
#$%             Scenario record elements which will be transferred to disk,
#$%             ie. the scenario record length.
#$%             In this routine, the scenario record will contain
#$%             the length of data which must be written to disk followed by
#$%             data pertaining to a single Target Type Index.
#$%
#$%             2) Disk Record: Force uses a relative record format for it's
#$%             scenario data storage. The record length is specified in
#$%             the call to the FDOPEN subroutine, in Longwords (4 Bytes).
#$%             The call to fputr passes the logical file count (LFC),
#$%             nrec, Disk record size (in Quadwords), and the scenario
#$%             record. FPUTR will write chunks of the scenario record to disk
#$%             until the length specified in the first element of scenario
#$%             record is transferred. The field nrec (corresponding to total
#$%             number of disk records for this file, minus the header rec)
#$%             is updated in FPUTR.
#$%
#############################################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KUVP                                        # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,uvp$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% record length to number of longwords in scenario record
rrec [1] = $UVPLen*2 + 1
 
#$% for each prob of hit entry
for (UVP$Index = 1; UVP$Index <= nuvp; UVP$Index = UVP$Index + 1)
    {
    #$% save PROB OF HIT data
    rrec[2] = uvp$targTypeIndex
    rrec[3] = uvp$Type
 
    #$% for all integer range values
    FOR (UVP$NumRanges = 1; UVP$NumRanges <= $UAV$NumRangesPerType;
         UVP$NumRanges = UVP$NumRanges + 1)
        {
        rrec[(UVP$NumRanges*4)] = UVP$Range
        rrec[(UVP$NumRanges*4)+1] = UVP$DetectPb
        rrec[(UVP$NumRanges*4)+2] = UVP$RecognitionPb
        rrec[(UVP$NumRanges*4)+3] = UVP$IdentPb
        }
 
    #$% put current PROB OF HIT record on scenario file
    call fputr (lfcS,nrec,16,rrec)                # write UAV PROB record
    }
 
#$% decrement record counter (it is modified in the routine fputr)
#$% nrec is the total number of records used in the scenario, excluding the
#$% header record.
nrec = nrec - 1
#$% store record count on scenario file header
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 
 

subroutine fsavmdr
############################################################################
#$%
#$% Purpose:   FSAVMDR writes sonobuoy mean detection range data to disk
#$%             for storage.
#$%
#$% Date:      6/90
#$%
#$% Author:    R. Hundt
#$%
#############################################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KMDR                                        # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,mdr$file,32*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% record length to number of longwords in scenario record
rrec [1] = $MDRLen*2 + 1
 
#$% for each prob of hit entry
for (MDR$Index = 1; MDR$Index <= nmdr; MDR$Index = MDR$Index + 1)
    {
    #$% save PROB OF HIT data
    rrec[2] = mdr$SonobuoyName
    rrec[3] = mdr$SubClass
    rrec[4] = MDR$GoodENVDetectRange
    rrec[5] = MDR$FairENVDetectRange
    rrec[6] = MDR$PoorENVDetectRange
    rrec[7] = MDR$DefaultENVDetectRange
 
    #$% put current mean detection range record on scenario file
    call fputr (lfcS,nrec,16,rrec)                # write UAV PROB record
    }
 
#$% decrement record counter (it is modified in the routine fputr)
#$% nrec is the total number of records used in the scenario, excluding the
#$% header record.
nrec = nrec - 1
#$% store record count on scenario file header
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 
 

subroutine FVRmdr (istat)
######################################################################
#$%
#$% Purpose:   FVRMDR verifies data associated with Sonobuoy
#$%            Median Detection Range data.
#$%
#$% Date:      6/90
#$%
#$% Author:    R. Hundt
#$%
######################################################################
ForceCommon
integer ISTAT,
        KSONOB,
        INEW_LINE,
        KCLASS,
        MDR_FOUND,
        KMDR                                        # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Sonobuoy Detection Data  ......")
 
#$% if scenario does not use sonobuoy median detection ranges
if (nmdr == 0) return
 
for (sonob$Index = 1; sonob$Index <= nsonob; sonob$Index = sonob$Index + 1)
    {
    inew_line = $yes
 
    #$% for all ship/sub classes
    for (class$index=1; class$index<=nclass; class$index=class$index+1)
        {
        #$% if class type is a submarine
        if ( Class$Type == 'NSUB' | Class$Type == 'DSUB' )
            {
            MDR_found = $no
 
            #$% for all sonobuoy detection ranges
            for (MDR$Index = 1; MDR$Index <= nmdr; MDR$Index = MDR$Index + 1)
                {
                #$% if
                if (MDR$SubClass == Class$Name &
                    MDR$SonobuoyName == Sonob$Name)
                    {
                    MDR_Found = $yes
                    next 2                  # get next ship/sub class
                    }
                } # end for all MDRs
 
            # if MDR entry not found for sonobuoy/submarine pair
            if ( MDR_found == $no )
                {
                if (inew_line == $yes)
                    {
                    inew_line = $no
                    call echor
                    call echov("Warning: Sonobuoy ")
                    call echohn(Sonob$Name,$$MaxLit)
                    call echov(" has no MDR data for Sub Class:")
                    }
                call echov(" ")
                call echohn(Class$Name,$$MaxLit)
#                istat = $no
                } # end if MDR entry no found for sonobuoy/submarine pair
            }# end if class type is a submarine
        }# end for all ship/sub classes
 
    }# end for all sonobuoys
return
end

subroutine FVRIntra (istat)
######################################################################
#$%
#$% Purpose:   FVRINTRA verifies data associated with Intra platform
#$%            EMI data.
#$%
#$% Date:      8/90
#$%
#$% Author:    hfisher - CSC
#$%
######################################################################
ForceCommon
Logical*1 Class_found,Air_Found
integer   ISTAT,
          KINTRA,
          INEW_LINE,
          KCLASS,
          KAIR                                   # MJC 6/9/2K (E2145)
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Intra platform EMI Data  ......")
 
#$% if scenario does not use intra platform EMI data
if (nintra == 0) return
 
for (Intra$Index = 1; Intra$Index <= nintra; Intra$Index = Intra$Index + 1)
    {
    inew_line = $yes
    Class_Found = .False.
    for (class$index=1; class$index<=nclass; class$index=class$index+1)
        {
        IF  ( Class$Name == INTRA$Class)
            {
            Class_Found = .True.
            BREAK
            }
        }
    IF  ( ! Class_found )
        {
        Air_Found = .False.
        FOR  (Air$index=1; Air$index<=nair; Air$index=Air$index+1)
            {
            IF  ( Air$Name == INTRA$Class)
                {
                Air_Found = .True.
                BREAK
                }
            }
        }
    IF  (!Class_Found & ! Air_Found)
        {
        IF  (inew_line == $yes)
            {
            inew_line = $no
            call echor
            call echov("Warning: Intra EMI Class ")
            call echohn(INTRA$Class,$$MaxLit)
            call echov(" has no active platform class ")
            }
        }
    } # end for emi data
 
return
end

subroutine FsavIntra
############################################################################
#$%
#$% Purpose:   FsavIntra writes Intra platform EMI data to disk
#$%             for storage.
#$%
#$% Date:      8/90
#$%
#$% Author:    hfisher - CSC
#$%
#############################################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KINTRA                                     # MJC 6/9/2K (E2145)
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,INTRA$file,12*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% record length to number of longwords in scenario record
rrec [1] = $INTRALen*2 + 1
 
#$% for each prob of hit entry
for (INTRA$Index = 1; INTRA$Index <= nintra; INTRA$Index = INTRA$Index + 1)
    {
    #$% save INTRA EMI data
    rrec[2] = INTRA$Class
    rrec[3] = INTRA$Victim
    rrec[4] = INTRA$Percent
    rrec[5] = INTRA$Culprit
 
    #$% put current mean detection range record on scenario file
    call fputr (lfcS,nrec,6,rrec)                # write Intra EMI rec
    }
 
#$% decrement record counter (it is modified in the routine fputr)
#$% nrec is the total number of records used in the scenario, excluding the
#$% header record.
nrec = nrec - 1
#$% store record count on scenario file header
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 
#$% save frequency omission plans
subroutine fsavFOM
 
#############################################################
#$%
#$% Purpose:   FSAVFOM writes frequency omission plan data to
#$%            disk for storage.
#$%
#$% Date:      6/91
#$%
#$% Author:    hundt
#$%
#############################################################
 
Forcecommon
integer LFCS,
        ISTAT,
        NREC,
        KFREQ_OMISSION,
        KFREQ_OMISSION_ITEM,
        M                                           # MJC 6/9/2K (E2145)
literal FOMdata[23]
 
#$% open scenario file
call FDopen ($write,scenario$name,$lits,freq_omission$file,46*4,lfcS,istat)
#$% set record pointer
nrec = 2
 
#$% length in quadwords not including variable length indicator
FOMData[1] = $fomplanlen*2 - 2
 
#$% for each freq_omission index
for (freq_omission$index = 1;
     freq_omission$index <= nfom;
     freq_omission$index = freq_omission$index+1)
    {
    #$% send freq_omission name
#    call echor
#    call echoh (freq_omission$Plan_name,5)
#    call echov ("...")
 
    #$% load freq_omission data
    FOMdata[2]= freq_omission$plan_name
    FOMdata[3]= freq_omission$path_name
 
    for (freq_omission$item_index = 1;
         freq_omission$item_index <= $maxFomItems;
         freq_omission$item_index = freq_omission$item_index + 1)
        {
        FOMdata [2 + freq_omission$item_index*2 ] = freq_omission$LowFreq
        FOMdata [3 + freq_omission$item_index*2 ] = freq_omission$HiFreq
        }
 
    #$% save record on scenario file
    write (lfcS,rec=nrec) (FOMdata[m],m=1,23)
 
    #$% set record pointer to next slot
    nrec = nrec + 1
    }
 
nrec = nrec - 1
 
#$% store FOM type record count on scenario file
write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
 
#$% close scenario file
call FDclos (lfcS)                              # close file
 
return
end
 

subroutine fvrfom (istat)
 
#########################################################################
#$%
#$% Purpose:   FVRFOM verifies data associated with the frequency
#$%            omission data
#$%
#$% Called By: FBYEVR
#$%
#$% Calls:     ECHOR      ECHOH
#$%
#$% Tables:
#$%
#$% Date:      6/91
#$%
#$% Author:    R. Hundt
#$%
#########################################################################
 
ForceCommon
integer ISTAT,
        KFREQ_OMISSION,
        IPATH_FOUND,
        KFREQ_OMISSION_ITEM,
        KPATH                                       # MJC 6/9/2K (E2145)
logical*1  frequency_entered
 
#$% set status flag to YES
istat = $yes
 
#$% send verification message
call echor
call echov ("Verifying Freq Omission......")
 
for (freq_omission$index = 1;
     freq_omission$index <= nfom;
     freq_omission$index=freq_omission$index + 1)
    {
    ipath_found = $no
 
    frequency_entered = $no
 
    for (freq_omission$item_index = 1;
         freq_omission$item_index <= $maxFomItems;
         freq_omission$item_index = freq_omission$item_index + 1)
        {
        if ( freq_omission$LowFreq != 0 &
             freq_omission$HiFreq != 0 )
            {
            frequency_entered = $yes
            break
            }
        }
 
    #$% if no frequency bounds entered
    if ( frequency_entered == $no )
        {
        istat = $no
 
        call echor
        call echov ("Commpath ")
        call echohn (freq_omission$path_name,$$MaxLit)
        call echov (" must have at least one frequency boundary.")
        }
 
    #$% if this plan is not yet assigned, we are thinking that a future
    #$% frequency hopping radar system may use this entry
    if (freq_omission$path_name == $BLANKLIT)
        {
        next
        }
 
    for (path$index=1; path$index <= npaths; path$index = path$index + 1 )
        {
        if (path$name == freq_omission$path_name)
            {
            ipath_found = $yes
            break
            }
        } # end for all commpath entries
 
    if ( ipath_found == $no )
        {
        istat = $no
 
        call echor
        call echov ("Commpath ")
        call echohn (freq_omission$path_name,$$MaxLit)
        call echov (" not found for frequency omission plan ")
        call echohn (freq_omission$plan_name,$$MaxLit)
        }
 
    }# end for all freq omission entries
 
return
end

 
subroutine fsave_squadrons
#########################################################################
#$%
#$% Purpose:   fsave_squadrons stores the aircraft squadron name info.
#$%
#$% Called By: fbyegen    <frmain.rat>
#$%
#$% Calls:     fdopen
#$%            fputr
#$%            write
#$%            fdclos
#$%
#$% Tables:    SQD
#$%
#$% Date:      April 1995
#$%
#$% Author:    Carol L. Kropp
#$%
#########################################################################
ForceCommon
integer LFCS,
        ISTAT,
        NREC,
        KSQD,
        KSQDA                                       # MJC 6/9/2K (E2145)
integer  i
 
  call FDopen ($write, scenario$name, $lits, sqd$file,
               8*4,     lfcS,          istat)
  nrec = 2
  rrec[1] = sqd$entry + 1
 
  for (i = 1; i <= nsquadrons; i = i + 1)
    {
     SQD$Pointer$To i
     SQD$Map
 
     rrec[2]  = SQD$SquadronName
     call fputr (lfcS, nrec, 4, rrec)            # write sqd record
    }
 
  nrec = nrec - 1
 
  write (lfcS,rec=1) $count_w_fingerprint(nrec)  # write record count
  call FDclos (lfcS)                             # close file
 
return
end      # end fsave_squadrons
