#####   VAX conversion  dated- 20oct81
 
 
#####   version 3.1  dated-  7apr81
 
 
#####   version 3.0  dated- 22dec80
 
 
 
# 
 
 
 
#$%      MODULE                       UTILITY                    DATA
#$%    SUBROUTINES                  SUBROUTINES                 TABLES
#$%    ===========                  ===========                 ======
#$%
#$%      NLTEST                        NONE                      NONE
#$%      RANDN
#$%      RANDOM
#$%      APPLL
#$%      RPRJCT2                  jb          11/00
#$%      ADJUST
#$%      SN
#$%      CS
#$%      ANG2PI
#$%      ANGPI
#$%      IN_ELLIPSE                # jb        7/24/91
#$%      ATAN2
#$%
#$%
#$%
#$%    NOTES
#$%    =====
#$%
#$%    1.  These MATH routines are called by many subroutines
#$%        throughout each major process.
 
 define ($debug,)
 
 include "bbcode.inc"
 include "macros.inc"
 
###########################################################################
                                     #                                    #
define ($yes,1)                      #   These lines must eventually      #
                                     #                                    #
define ($no,0)                       #      be replaced by the two        #
                                     #                                    #
define ($pi,3.1415926)               #      includes described in the     #
                                     #                                    #
###########################################################################

 
define($EndSTDNL,30)                # added 12/90, reh
 
define(NL$common,
    real              STDNL[0:$EndSTDNL]    # table of standard normal distribution
    common / NLTABL / STDNL
    )
 
Block data NLDATA                 #NormaL distribution table DATA
 
NL$common
 
integer     I
data (STDNL[I],I=0,$EndSTDNL) / .5000, .5398, .5793, .6179, .6554, .6915, .7257,
                                .7580, .7881, .8159, .8413, .8643, .8849, .9032,
                                .9192, .9332, .9452, .9554, .9641, .9713, .9773,
                                .9821, .9861, .9893, .9918, .9938, .9953, .9965,
                                .9974, .9981, .9987 /
 
 end
 
 

 
 Subroutine ADJUST( _                   #ADJUST angle
                   X,                   #angle to adjust (input)
                   Z,                   #adjusted angle (output)
                   FLAG)                #array of flags (output)
 
 
#####################################################
 #$%
 #$% Purpose:   ADJUST receives the angle to adjust
 #$%            and outputs the adjusted angle for
 #$%            the QCOS, QSIN, and QTRIG routines.
 #$%
 #$% Called By: QKCOS       QKSIN       QKTRIG
 #$%
 #$% Invokes:   ANGPI
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  Z, X
 
 logical FLAG[3]
 
 Z = X                                  #copy input
 
 $angPI(Z)                          #insure between -pi & pi
 
 if(Z < 0.0)                            #if 3rd or 4th quadrant
 
    {
     Z = - Z                            #reflect across x-axis
 
     FLAG[1] = .TRUE.                   #set flag 1
    }                                   #endif
 
 else                                   #otherwise
 
     FLAG[1] = .FALSE.                  #don't set flag 1
 
 if(Z > $PI /2.)                        #if result in 2nd quadrant
 
    {
     Z = $PI - Z                        #replace with supplement
 
     FLAG[2] = .TRUE.                   #set flag 2
    }                                   #endif
 
 else                                   #otherwise
 
     FLAG[2] = .FALSE.                  #don't set flag 2
 
 if(Z > $PI / 4.)                       #if result in (pi/4,pi/2]
 
    {
     Z = ($PI / 2.) - Z                 #replace with complement
 
     FLAG[3] = .TRUE.                   #set flag 3
    }                                   #endif
 
 else                                   #otherwise
 
     FLAG[3] = .FALSE.                  #don't set flag 3
 
 return
 end
 

 
 Function SN(X)                         #approximate SiNe for [0,pi/4]
 
 #####################################################
 #$%
 #$% Purpose:   SN is a quick sine routine.
 #$%
 #$% Called By: QKCOS       QKSIN       QKTRIG
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  X, SN, A, B, C, D, E
 
 data A,B,C,D,E / -.0972322, 1.0126784, #coefficients for quadratic
       -.2768931, 1.1523443, -.0271407/ #    polynomial approximations
 
 if (X <= ($PI/8.))                     #if between 0 and pi/8
 
     SN = X*(A*X + B)                   #use this approximation
 
 else                                   #if between pi/8 and pi/4
 
     SN = (C*X + D)*X + E               #use this approximation
 
 return
 end
 

 
 Function CS(X)                         #approximate CoSine for [0,pi/4]
 
 #####################################################
 #$%
 #$% Purpose:   CS is a quick cosine routine.
 #$%
 #$% Called By: QKCOS       QKSIN       QKTRIG
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  X, CS, A, B, C, D, E
 
 data A,B,C,D,E / -.4936074, 1.0,       #coefficients for quadratic
       -.4143993, -.0638046, 1.0128411/ #    polynomial approximations
 
 if (X <= ($PI/8.))                     #if between 0 and pi/8
 
     CS = A*X*X + B                     #use this approximation
 
 else                                   #if between pi/8 and pi/4
 
     CS = (C*X + D)*X + E               #use this approximation
 
 return
 end
 

 
 Function QKATN2(X,Y)                   #Quick ArcTANgent with 2 arguments
 
 
 #####################################################
 #$%
 #$% Purpose:   QKATN2 computes a quick arctangent
 #$%            with two arguments.
 #$%
 #$% Called By: HFDCMP     PROXIM     RLL2RB
 #$%            SLRANG     TAPREP
 #$%
 #$% Invokes:   ABS
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  X, Y, QKATN2, Z, A, B
 #result lies in the range [0,2*pi)
 
 logical CFLAG
 
 data A,B / -.2730256, 1.0584237 /
 
 if(X == 0. & Y == 0.)                  #when undefined, arbitrarily
 
     QKATN2 = 0.                        #  choose 0 as output value
 
 else                                   #otherwise
 
    {
     if(ABS(X) < ABS(Y))                #guarantees looking at arctan
 
       {
        Z = ABS(X / Y)                  #   of value in [0,1]
 
        CFLAG = .TRUE.                  #set complement flag
       }                                #endif
 
     else                               #guarantees looking at arctan
 
       {
        Z = ABS(Y / X)                  #   of value in [0,1]
 
        CFLAG = .FALSE.                 #don't set complement flag
       }                                #endelse
 
     QKATN2 = Z * (A * Z + B)           #approximation to arctan for
                                        #     values in [0,1]
 
     if(CFLAG)                          #if complement flag set
 
        QKATN2 = ($PI / 2.) - QKATN2    #replace with complement
 
     if(X < 0.)                         #if X negative
 
        QKATN2 = $PI - QKATN2           #replace with supplement
 
     if(Y < 0.)                         #if Y negative
 
        QKATN2 = (2. * $PI) - QKATN2    #reflect across x-axis
 
    }                                   #endelse
 
 return
 end
 

 
 Subroutine ANG2PI(_                    #find equiv ANGle between 0 & 2*PI
                   X)                   #angle (input & output)
 
 #####################################################
 #$%
 #$% Purpose:   ANG2PI finds an equivalent angle in
 #$%            the range 0 to 2 PI.
 #$%
 #$% Called By: CRSCHG     GUIMAN     HFDDET
 #$%            HFDFP1     INTCPT     REPASD
 #$%            REPESM     REPPSD     REPRAD
 #$%            SSELPS     TAPREP     VECTOR
 #$%            VISMOD
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      JUN 83
 #$%
 #$% Author:    T.D. BURZETTE
 #$%
 #####################################################
 implicit none
 real*4  X
 integer N
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 $debug  if (ABS(X) > 6.* $PI)
 $debug     {
 $debug      N = (180./$PI) * X
 $debug      call echov ('ANG2PI: Bad angle = ')
 $debug      call echoi(N)
 $debug      call echov (' degrees')
 $debug      call echor
 $debug      call trace
 $debug      return
 $debug     }
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
######################################################################
 
while (X < 0.)
    {
    X = X + (2. * $PI)
    }
 
while (X >= 2. * $PI)
    {
    X = X - (2. * $PI)
    }
 
return
end
 

 
 Subroutine ANGPI(_                     #find equiv ANGle between + & - PI
                  X)                    #angle (input & output)
 
 #####################################################
 #$%
 #$% Purpose:   ANGPI finds an equivalent angle in
 #$%            the range minus PI to plus PI.
 #$%
 #$% Called By: ACNOIS     ADJUST     APPLL
 #$%            CHAFF      CHFLST     CHKLNK
 #$%            CKSWAT     CMFIND     CRSCHG
 #$%            DAYTST     DRNAV      ELLOFF
 #$%            ERRPOS     GUIMAN     INOUT
 #$%            INTCPT     NONDR      OCHAF1
 #$%            ORELOC     PASDET     PREREJ
 #$%            PROXIM     RADDET     RLL2RB
 #$%            RRB2LL     SATENT     SATTRK
 #$%            SLRANG     TAPREP     TCA
 #$%            VECTOR     WEAENT
 #$%
 #$% Calls:     None
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      JUN 83
 #$%
 #$% Author:    T.D. BURZETTE
 #$%
 #####################################################
 implicit none
 real*4  X
 integer N
 
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 $debug  if (ABS(X) > 6.* $PI)
 $debug     {
 $debug      N = (180./$PI) * X
 $debug      call echov ('ANGPI: Bad angle = ')
 $debug      call echoi(N)
 $debug      call echov (' degrees')
 $debug      call echor
 $debug      call trace
 $debug      return
 $debug     }
 # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
######################################################################
 
while (X > $PI)                         # While x is greater than
    {                                   # pi, subtract 2pi
    X = X - (2. * $PI)
    }
 
while (X <= -$PI)                       # While x is less than or
    {                                   # equal to pi, add 2pi
    X = X + (2. * $PI)
    }
 
return
end             # End of Subroutine ANGPI

#################################################################
Subroutine IN_ELLIPSE (_
                       FLATe,    # Lat. of Ellipse Center, Radians
                       FLONe,    # Long. of Ellipse Center, Radians
                       orient,    # Orientation of ellipse, Radians
                       a,            # Semi-Major Axis, N.Miles (Real)
                       b,            # Semi-Minor Axis, N.Miles (Real)
                       TgtLAT,    # Lat. of Tgt. or Point, Radians
                       TgtLON,    #Long. of Tgt. or Point, Radians
                     INSIDE   ) # (OUT): $YES if Inside Ellipse
                                #        $NO  if OUTSIDE (Integer)
##############################################################################
# IN_ELLIPSE determines whether a point at [TgtLAT,TgtLON] is within (or on
# the boundary of) an ellipse described by the first five arguments.  If
# so, INSIDE is set to $YES; otherwise, to $NO.
#    NOTES ON PROCESSING OF INPUTS:
#- ORIENT is the bearing from the ellipse center to one of the ends of the
#   semi-major axis.
#- To avoid zeroes, the minimum semimajor axis is 1.0 n.mi., as is also the
#   minimum semiminor axis.
#- The axis lengths are checked to insure the semi-minor axis is NOT LARGER
#   than the semi-major axis (they are reversed if necessary).
#- INSIDE will be returned as $NO, without comment, if:
#    (a) Absolute value of an input longitude exceeds $PI radians (180 deg.)
#    (b) Absolute value of an input latitude exceeds 1.4 radians (80.2 deg.)
#
# Called By: Bistatic_Routine (in WGMDBISTATIC.rat)
#
# Calls/Invokes:  RRL2RB    RRB2LL   COS()
#
# Date:        July l991
#
# Author:      Joe Bryant
##########################################################
implicit none
integer INSIDE
real*4  FLATE, TGTLAT, FLONE, TGTLON
real*4  B, A, AAA, COSLATE, COSLATTGT
real*4  RANGE, BRNG, FOCDIST, RELBRG
real*4  ORIENT, FLAT1, FLON1, COSLAT1
real*4  DISORIENT, FLAT2, FLON2, COSLAT2
real*4  RANGE1, RANGE2
 
INSIDE = $NO # Initialize to default to OUTSIDE the ellipse
 
If( ABS(FLATe) > 1.4 | ABS(TgtLAT) > 1.4 |    # FAIL if any LAT or
    ABS(FLONe) > $PI | ABS(TgtLON) > $PI   )  #  LON is out-of-bounds
        RETURN
 
if(b > a) # Insure semiMAJOR axis NOT smaller than semiMINOR
   {
    aaa = a; a = b; b = aaa
   }
 
COSLATe   = COS(FLATe)    # COSINEs of the Latitudes of the center of
COSLATtgt = COS(TGTlat)   # the ellipse and of the target point..
 
# Compute n.miles from tgt point to center of ellipse:
call RLL2RB( _        #Rhumb line Lat/Lon to Range/Bearing
                   FLATe,            #latitude of center  (input)
                   FLONe,            #longitude of center (input)
                   COSLATe,          #cos(lat of center)  (input)
                   TGTlat,           #latitude of  Tgt    (input
                   TGTlon,           #longitude of Tgt    (input)
                   COSLATtgt,        #cos(LAT of Tgt)     (input)
                   RANGE,        # range, Center to Tgt (OUTPUT)
                   BRNG   )      # bearing              (OUTPUT)
 
#    Culling for trivial cases:
if ( RANGE > a ) # If target point is more distant than the length
   {             #  of the semi-major axis, it's OUTSIDE..
    RETURN       # Note that this eliminates cases in which the
   }             # ellipse is a CIRCLE and the tgt is OUTSIDE..
Else if (RANGE <= b)
   {                # ...and this takes care of all cases in which
    INSIDE = $YES    # ellipse is a CIRCLE and the tgt is INSIDE..
    RETURN            # (as well as other cases when range <= b)..
   }                   # So, we need no special culling for circles.
 
#    Culling completed: commence general solution:
a = max(a,1.0)    # Precaution against division by zero
b = max(b,1.0)    # Avoid zero-length lines...
 
# Determine the Focal Distance (FOCDIST) -
    #    Notes:
    # aSQ = a*a    # Square of the semi-major axis
    # bSQ = b*b    # Square of the semi-minor axis
    #     e = SQRT(aSQ - bSQ) / a      # Eccentricity of the ellipse
    # FOCDIST = a * e = SQRT(aSQ - bSQ) # Focal distance from center
FOCDIST = SQRT(a*a - b*b)     # Distance from center to either focus
 
RELBRG = 0.0    # (For use in calls to RRB2LL and RRL2RB)
 
##Determine the POSITION of one focus, as FLAT1,FLON1:
                          # (Also, COS(FLAT1), as COSLAT1)
 
$ANG2PI(Orient)    # (<= TWOPI, in case not so as received)
FLAT1 = FLATe            # (Set the origin to the
FLON1 = FLONe            #               Center position)
COSLAT1 = COSLATe
 
Call RRB2LL( _            #Rhumb line Range/Bearing to Lat/Lon
                   FLAT1,          #latitude (input & output)
                   FLON1,          #longitude (input & output)
                   FOCDIST,      # set range (input) to focal distance
                   RELBRG,       #relative bearing (input)
                   Orient,       #course (input)
                   COSLAT1)        #cosine of latitude (input & output)
 
##Determine the POSITION of the second focus, as FLAT2,FLON2:
                                # (Also, COS(FLAT2), as COSLAT2)
DISorient = Orient + $PI  # Bearing from center to the 2nd focus
$ANG2PI(DISorient)
FLAT2 = FLATe            # (Reset the origin to the
FLON2 = FLONe            #               Center position)
COSLAT2 = COSLATe
Call RRB2LL( _            #Rhumb line Range/Bearing to Lat/Lon
                   FLAT2,        #latitude (input & output)
                   FLON2,        #longitude (input & output)
                   FOCDIST,      # set range (input) to focal distance
                   RELBRG,       #relative bearing (input)
                   DISorient,    #course (input)
                   COSLAT2)      #cosine of latitude (input & output)
#########################################################
 
##Determine the DISTANCE from tgt point to first focus, as RANGE1:
call RLL2RB( _        #Rhumb line Lat/Lon to Range/Bearing
                   TgtLAT,            #latitude of tgt   (input)
                   TgtLON,            #longitude of tgt (input)
                   COSLATtgt,          #cos of lat of tgt (input)
                   FLAT1,            #latitude of 1st focus (input
                   FLON1,            #longitude of 1st focus(input)
                   COSLAT1,           #cos of lat of 1st focus(input)
                   RANGE1,   # range   (OUTPUT) (tgt to the
                   BRNG  )   # bearing (OUTPUT)        first focus)
 
##Determine the DISTANCE from tgt point to second focus, as RANGE2:
call RLL2RB( _        #Rhumb line Lat/Lon to Range/Bearing
                   TgtLAT,            #latitude of tgt   (input)
                   TgtLON,            #longitude of tgt (input)
                   COSLATtgt,         #cos of lat of tgt (input)
                   FLAT2,            #latitude of 2nd focus (input
                   FLON2,            #longitude of 2nd focus(input)
                   COSLAT2,          #cos of lat of 2nd focus(input)
                   RANGE2,   # range   (OUTPUT)    (tgt to the
                   BRNG  )   # bearing (OUTPUT)        second focus)
 
#$% Test for tgt inside the Ellipse or on the boundary:
if(RANGE1 + RANGE2 <= 2.0 * a)    # (Per ellipse definition as locus)
    INSIDE = $YES
 
Return
End

 
######################################################################
 
 Subroutine CPA(_
            KDIST,_             # Returned: CPA distance (naut. miles)
            CSE1,_                         # (radians):course of object-1
            SPD1,_                         # (knots  ):speed  of object-1
            CSE2,_                         # (radians) course of object-2
            SPD2,_                         # (knots  ) speed  of object-2
            IRNG,_                         # Initial range between objects
            BRG,_                          #(radians) init. brg from OBJ1 to 2
            KTIM )              # Returned: (min.) -elapsed time
 
 ##############################################################################
 # CPA is a stand-alone subroutine to compute CPA distance and elapsed time,
 # given present range, bearing and course vectors.  If the range begween
 # the units isn't decreasing, -7 is returned as KTIM, meaning CPA was at least
 # as close as present range.  If no CPA will occur within 12 hours, 0 is
 # returned as KTIM.  Otherwise, 2 positive integers (KDIST, nautical miles;
 # and KTIM, elapsed minutes before CPA) are returned.
 #
 # Called By:   PL_CPA (in wslocal.rat)
 #
 # Invokes:     SIN()        COS()
 #
 # Date:        July l984
 #
 # Author:      Joe Bryant
 # Author-Mafia Note:  If I'm available and you messa this teeny bitsa
 #              code without talka me, I breaka you contac' lens!
 #                              Sincerely,        Joe
 ##########################################################
 implicit none
 integer IRNG, KTIM, KDIST
 real*4  RX1, BRG, RX2, RV1
 real*4  SPD2, CSE2, SPD1, CSE1
 real*4  RV2, XDOTV, RA, RB
 real*4  BABS, RABS, FCPA
 
# if(IRNG <= KDIST)                        # If range already within KDIST,
#   { KTIM = 0                             #  Set elapsed time to 0
#     return                               #  Return control to calling prog.
#   }
 
 RX1 = IRNG * COS(BRG)                     # Compute distance components,
 RX2 = IRNG * SIN(BRG)                     #   For XDOTV computation
 
 RV1 = SPD2 *COS(CSE2) -SPD1 * COS(CSE1)   # Compute the speed components,
 RV2 = SPD2 *SIN(CSE2) -SPD1 * SIN(CSE1)   #   For XDOTV computation
 
 XDOTV = RX1 *RV1 + RX2 *RV2               # Compute XDOTV for vector solution
 
# TYPE 111, RV1
# TYPE 111, RV2
# TYPE 111, RX1
# TYPE 111, RX2
# TYPE 111, XDOTV
 
 if(XDOTV >= 0)                            #Dot-product indicates no closure
    {KTIM = -7                             # Return negative value as flag
     return
    }
 
 #     Commence generalized quadratic solution:
 
 RA = RV1 * RV1 + RV2 * RV2                # Compute the traditional A,
 
 RB = 2 * XDOTV                            #  B ,
 
 BABS = ABS(RB)
 RABS = ABS(RA)
 if (RABS < 0.0001 | BABS > 24.*RABS )
  {
   KTIM = -12   # Flag CPA more than 12 hrs hence (-12 vice 0 6/14/89)
   RETURN
  }
##########################################################################
#RC = IRNG * IRNG - KDIST * KDIST          #      C ,  and
#RDISC = RB * RB - 4.0 * RA * RC           #    Discriminant
#if(RDISC < 0)                             # No solution if discriminant < 0
#   { KTIM = -1                            # Return negative value as flag
#    return                                # Control back to calling program
#   }
## ----------------------------------------------------------------------
##              Derivation of solution for square of FCPA:
##  RDISC = 0 = RB*RB - (4.0 * RA) * RC
##              RB*RB / (4.0 * RA) = RC = IRNG*IRNG - FCPA*FCPA
##              FCPA*FCPA = IRNG*IRNG - (RB*RB/4.0 * RA)
##########################################################################
 FCPA = IRNG*IRNG - (RB*RB / (4.0 * RA) )  # (Solved for float of KDIST)
 if (FCPA <= 0) FCPA = 0             # jb Flag coincidence?    6/14/89
 ELSE           FCPA = SQRT (FCPA)
 
 KDIST = (FCPA + 0.5)
 
#KTIM = 60.0 * (-RB -SQRT(RDISC)) /(2.0 * RA) + 0.5  # (if RDISC not 0)
 KTIM = (60.0 *(-RB /(2.0 * RA)) ) + 0.5  # ( with RDISC set to zero )
 
# 111 FORMAT('0',T15,F12.3)
 
 return                                    # Control back to calling program.
 end            # End of Subroutine CPA
############################################################################

 
######################################################################
 
 Subroutine Rcpa(_
            RDIST,_             # Returned: CPA distance (naut. miles)
            CSE1,_                         # (radians):course of object-1
            SPD1,_                         # (knots  ):speed  of object-1
            CSE2,_                         # (radians) course of object-2
            SPD2,_                         # (knots  ) speed  of object-2
            RNG,_                         # Initial range between objects
            BRG,_                          #(radians) init. brg from OBJ1 to 2
            RTIM )              # Returned: (min.) -elapsed time
 
 ##############################################################################
 # RCPA is a floating-point version of
 # CPA, a stand-alone subroutine to compute CPA distance and elapsed time,
 # given present range, bearing and course vectors.  If the range begween
 # the units isn't decreasing, -7.0 is returned as RTIM (means CPA was at least
 # as close as present range).  If no CPA will occur within 12 hours, -12.0 is
 # returned as RTIM.  Otherwise, 2 positive reals (RDIST, nautical miles;
 # and RTIM, elapsed minutes before CPA) are returned.
 #
 # Called By:   PL_CPA (in wslocal.rat)
 #
 # Invokes:     SIN()        COS()
 #
 # Date:        July l984
 #
 # Author:      Joe Bryant
 # Author-Mafia Note:  If I'm available and you messa this teeny bitsa
 #              code without talka me, I breaka you contac' lens!
 #                              Sincerely,        Joe
 ##########################################################
 implicit none
 real*4 RX1, RNG, BRG, RX2, RV1, RV2
 real*4 SPD2, CSE2, SPD1, CSE1
 real*4 XDOTV, RTIM, RA, RB, BABS
 real*4 RABS, FCPA, RDIST
 
# if(RNG <= RDIST)                        # If range already within RDIST,
#   { RTIM = 0                             #  Set elapsed time to 0
#     return                               #  Return control to calling prog.
#   }
 
 RX1 = RNG * COS(BRG)                     # Compute distance components,
 RX2 = RNG * SIN(BRG)                     #   For XDOTV computation
 
 RV1 = SPD2 *COS(CSE2) -SPD1 * COS(CSE1)   # Compute the speed components,
 RV2 = SPD2 *SIN(CSE2) -SPD1 * SIN(CSE1)   #   For XDOTV computation
 
 XDOTV = RX1 *RV1 + RX2 *RV2               # Compute XDOTV for vector solution
 
# TYPE 111, RV1
# TYPE 111, RV2
# TYPE 111, RX1
# TYPE 111, RX2
# TYPE 111, XDOTV
 
 if(XDOTV >= 0)                            #Dot-product indicates no closure
    {RTIM = -7.0                            # Return negative value as flag
     return
    }
 
 #     Commence generalized quadratic solution:
 
 RA = RV1 * RV1 + RV2 * RV2                # Compute the traditional A,
 
 RB = 2 * XDOTV                            #  B ,
 
 BABS = ABS(RB)
 RABS = ABS(RA)
 if (RABS < 0.0001 | BABS > 24.*RABS )
  {
   RTIM = -12.0   # Flag CPA more than 12 hrs hence (-12 vice 0 6/14/89)
   RETURN
  }
##########################################################################
#RC = RNG * RNG - RDIST * RDIST          #      C ,  and
#RDISC = RB * RB - 4.0 * RA * RC           #    Discriminant
#if(RDISC < 0)                             # No solution if discriminant < 0
#   { RTIM = -1                            # Return negative value as flag
#    return                                # Control back to calling program
#   }
## ----------------------------------------------------------------------
##              Derivation of solution for square of FCPA:
##  RDISC = 0 = RB*RB - (4.0 * RA) * RC
##              RB*RB / (4.0 * RA) = RC = RNG*RNG - FCPA*FCPA
##              FCPA*FCPA = RNG*RNG - (RB*RB/4.0 * RA)
##########################################################################
 FCPA = RNG*RNG - (RB*RB / (4.0 * RA) )  # (Solved for float of RDIST)
 if (FCPA <= 0) FCPA = 0             # jb Flag coincidence?    6/14/89
 ELSE           FCPA = SQRT (FCPA)
 
 RDIST = FCPA
 
#RTIM = 60.0 * (-RB -SQRT(RDISC)) /(2.0 * RA) + 0.5  # (if RDISC not 0)
 RTIM = (60.0 *(-RB /(2.0 * RA)) ) + 0.5  # ( with RDISC set to zero )
 
# 111 FORMAT('0',T15,F12.3)
 
 return                                    # Control back to calling program.
 end            # End of Subroutine RCPA
####

###########################################################################
##   -- This a "REAL" version of "integer" subroutine MIN_TO_TARGET ----
 # RMIN_TO_TARGET is a stand-alone subroutine to compute elapsed time for an
 # intercepting unit to reach a designated range from a target, given the
 # interceptor's range and BEARING FROM THE TARGET; the interceptor's
 # speed, and the target's course and speed.  If the designated range is 0,
 # the elapsed time is the time needed to reach the target itself.  For
 # future reference, note that an interceptor with a long-range weapon may
 # well be able to reach weapon-range EVEN IF UNABLE TO GET ON TOP OF THE
 # TARGET.
# Programmer note:
# If the initial range isn't greater than the input RADIUS, -3.0 is return-
# ed.  If there's no practical solution, -1.0 is returned.  If elapsed time
# would be greater than 12 hours, -7.0 is returned.  Otherwise, a positive
# integer (elapsed minutes) is returned.
 
 include "bbctl.inc"
 define (BBImplicit, implicit none)
 
Subroutine RMIN_TO_TARGET(_
            RADIUS,             # Desig. intercept distance ( often, 0.0 )
            CSET,               # (radians) course of TARGET        real
            SPDT,               # (knots)   speed  of TARGET        real
            SPDIx,              # (knots)   speed  of INTERCEPTOR   real
            RNGI,               # (n.mi.) Initial rng between units real
            BRG,                # (radians) init. brg FROM tgt TO INTERCEPTOR
            RTIM )    # RETURNED value (min.) elapsed time to reach RADIUS
 
 ###########################################################################
 #$%
 #$% Purpose:   RMIN_TO_TARGET computes elapsed time for an interceptor
 #$%            to reach a designated range from a target.
 #$%
 #$% Called By  ?VECTOR  OMASW  SHOOTAA  GUIMAN  INTCPT  CHECK_HIT
 #$%             (opord)(opmasw) (eng)    (mot)   (mot)    (torp)
 #$% Invokes:   COS()   ABS()   SQRT()  MAX()
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      May 1992
 #$%
 #$% Author:    Joe Bryant
 #$%
 #$% Modified:  Jim Allen 12/02 (E2317)
 #$%            Rewrite routine and handle case where speeds are the same
 #$%            Uses law of cosines and quadratic equation to solve for time
 ##########################################################
 
real*4  CSET, RNGI, RADIUS, RTIM
real*4  BRG, SPDT
real*4  SPDI
 
real*4 angleC, a, b, c, discriminator
 
if (rngi <= radius )            # Already within radius
{
    rtim = -3
    return
}
 
angleC = abs(cseT - brg)            # Compute angle between target course
$angpi(angleC)                      #  and bearing to intercept
 
spdI = spdIx
if (spdT == spdI) spdI = spdI + 0.01 # Bump intercept speed to avoid special case
 
a = (spdI * spdI) - (spdT * spdT)    # Calculate quadratic equation coefficients
 
b = 2.0 * spdT * rngI * cos(angleC)
 
c = -(rngI * rngI)
 
discriminator = (b*b) - (4.0 * a * c)
 
if (discriminator < 0.0)            # No intercept solution
{
    rtim = -1.0
    return
}
 
rtim = (-b + sqrt(discriminator)) / (2.0 * a) * $Minutes$Per$Hour
 
if (rtim < 0.0)
{
    rtim = -1.0
    return
}
 
rtim = rtim - (radius / max(spdI, 0.01) * $Minutes$Per$Hour)  # reduce by time to travel radius
 
if (rtim > 12.0 * $Minutes$Per$Hour) rtim = -7.0     # Flag for over 12  hours
 
RETURN
end
############ End of Subroutine RMIN_TO_TARGET
 

 Subroutine RPRJCT2 (_  # (All arguments are REAL*4)
    DIST,_                        # Designated distance (naut. miles)
    CSE1,_                         # (radians):course of object-1
    SPD1,_                         # (knots  ):speed  of object-1
    CSE2,_                         # (radians) course of object-2
    SPD2,_                         # (knots  ) speed  of object-2
    RNG,_                         # Initial range between objects
    BRG,_                         #(radians) init. brg from OBJ1 to 2
    TIM1,  # Elapsed min. to the earlier of 2 possible solutions
    TIM2 ) # Elapsed min. to the later of the  2 possible solutions  10/24/00
     # TIM2 includes the minutes elapsed in TIM1, and will be the greater
     #  except in the case of a coincidental equality (at CPA).
 ##########################################################
 #$% Note: Another version (PRJCT, in ANSUB.rat) computes only the earliest
 #$% of the two possible solutions, and defines the DIST input and its
 #$% single elapsed-minutes output as integers.  Here, they're real*4's..
 #$%
 #$% Purpose: Considering two units (or a unit and a stationary point)
 ### RPRJCT2 attempts to compute 2 elapsed times (quadratic solutions)
 #$% at which they will be separated by the input distance (DIST), as-
 #$% suming current courses and speeds continue.  TIM1 is the earlier
 #$% elapsed time, while TIM2 is the later.  Meaning of returned values:
 #$%     0.0 for TIM1: initial separation is within DIST.
 #$%    -1.0 fpr TIM1: No solution(s) at all available. CANNOT SOLVE!
 #$%    -7.0 for TIM!: Range is not presently decreasing, BUT logic may
 #$%         still be able to comput TIM2, if geometry/vectors permit.
 #$%   -60.0 for TIM1:  (see below for TIM2 set to 60.0)
 #$%
 #$%   -60.0 for TIM2: Precludes consideration of this unit as a target.
 #$%      Initial separation exceeds DIST; AND, TIM1 has just been flagged
 #$%      to indicate no arrival in the next hour.
 #$%      SOLUTION NOT ATTEMPTED because of this arbitrary limit, which
 #$%      is now aimed at airborne (faster) units.  When/if we use this
 #$%      also for ships, we can increase the limit--but some limit is
 #$%      needed,to avoid possibility of overflow during division.
 #$%  -120.0 for TIM2: Does NOT preclude consideration of this target.  TIM1
 #$%      has NOT been flagged for no arrival in the next hour, BUT Elapsed-
 #$%      time for target to complete its transit thru the action-area exceeds
 #$%      2 hours.  Implication:  the speed of this potential target is either:
 #$%         zero; or, at least, slow in comparison to the extent of its
 #$%         transit thru the action area.
 #$%      (Remark above concerning arbitrary limits applies here also.)
 #$%
 #$% Called By: RDDET
 #$%
 #$% Calls:     SIN        COS
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      10/26/00  (Derived from PRJCT, in ANSUB.rat)
 #$%
 #$% Author:    Joe Bryant
 #$%
 ##########################################################
IMPLICIT NONE                                   # jb  6/23/98
 
REAL*4  DIST,CSE1,SPD1,CSE2,SPD2,RNG,BRG,       # jb  6/23/98
        TIM1, TIM2,     # 2 possible solutions    jb 10/24/00
        RX1,RX2,RV1,RV2,XDOTV,RA,RB,RC,RDISC,   # jb  6/23/98
        ROOT                                    # jb 11/13/00
 
 TIM1 = 999.9 # jb Initialize to value differing from 0.0   10/25/00
 
 if(RNG <= DIST)         # If range already within DIST,
    { TIM1 = 0.0         #  Set elapsed time1 to 0.0   jb 10/24/00
##      RETURN    #  (But, Keep going for new TIM2)    jb 11/13/00
    }
 
 
 RX1 = RNG * COS(BRG)                     # Compute distance components,
 RX2 = RNG * SIN(BRG)                     #   For XDOTV computation
 
 RV1 = SPD2 *COS(CSE2) -SPD1 * COS(CSE1)   # Compute the speed components,
 RV2 = SPD2 *SIN(CSE2) -SPD1 * SIN(CSE1)   #   For XDOTV computation
 
 XDOTV = RX1 *RV1 + RX2 *RV2               # Compute XDOTV for vector solution
 
 
## TYPE 111,RV1; TYPE 111,RV2; TYPE 111,RX1; TYPE 111,RX2; TYPE 111,XDOTV
 
if(XDOTV >= 0.0)    #Dot-product indicates no closure..BUT, msy be
   # at or past CPA, or at speed 0.0.  KEEP GOING for TIM2 jb 11/13/00
    { If (TIM1 != 0.0)  TIM1 = -7.0  # Preserve if 0.0 !!  jb 11/13/00
##      RETURN     #  (No - Keep going for new TIM2)       jb 11/13/00
    }
 
 #     Commence generalized quadratic solution:
 
 RA = RV1 * RV1 + RV2 * RV2                # Compute the traditional A,
 
 RB = 2 * XDOTV                            #  B ,
 
 RC = RNG * RNG - DIST * DIST          #      C ,  and
 
 RDISC = RB * RB - 4.0 * RA * RC           #    Discriminant
 
 if(RDISC < 0.0)                             # NO SOLUTION if discriminant < 0
    { TIM1 = -1.0      # Return negative value as flag   jb 10/24/00
     RETURN                                # Control back to calling program
    }
 
 ROOT = SQRT(RDISC) # jb Avoid taking SQRT repeatedly, below    11/13/00
 
 If (TIM1 != 0.0)     # jb If Initial range exceeds DIST        11/13/00
    {
    If(abs(-RB - ROOT) > 2*abs(RA)) # if elapsed time exceeds 1 hour
        {
        TIM1 = -60.0  # -60.0: too-long-to-go-flag for TIM1
        TIM2 = -60.0  # jb -> ..and, return without trying TIM2
        RETURN  # jb (Also, avoids possible divide-overflow)     11/13/00
        }
    Else    # Compute The earlier of the 2 possible solutions:
        TIM1 = 60.0 * (-RB - ROOT) /(2.0 * RA)  #Elapsed minutes
    }
 
   # The later of the 2 possible solutions:
 
    #$%  jb ( Little or no interest if 'departure' is more than 2 hours off...
 if(abs(-RB + ROOT) > 4*abs(RA)) # if elapsed time exceeds 2 hours
    {
     TIM2 = -120.0   # Return -120.0
     RETURN  # jb (... and, Avoid possible divide-overflow   11/13/00
    }
 Else
    {
    TIM2 = 60.0 * (-RB + ROOT) /(2.0 * RA)     #Solution exists.
    }
# 111 FORMAT('0',T15,F12.3)
 
 RETURN
 end    # End of subroutine RPRJCT2

###############################################################
 Function NLTEST(_                    #Normal TEST
                 FMEAN,               #mean (input)
                 STDDEV,              #standard deviation (input)
                 X)                   #value to be tested (input)
 
 #####################################################
 #$%
 #$% Purpose:   NLTEST Determines success or failure of
 #$%            an event by matching the position of
 #$%            the input number X in a normal dis-
 #$%            tribution, defined by FMEAN and
 #$%            STDDEV, against a random number
 #$%            selected from a uniform distribution.
 #$%
 #$% Called By: ESMDET     ESMSAT     FRQDET
 #$%            PASDET     RADDET     RADSAT
 #$%
 #$% Invokes:   ABS        INT        RANDOM
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 
USE IFPORT
implicit none
 
 integer I, NLTEST
 real*4  Z, X, FMEAN, PROB, STDDEV
 
 NL$common                            #table of normal probabilities
 external NLDATA
 
 Z = (X - FMEAN) / STDDEV             #convert to standard normal
 
 NLTEST = $NO                         #initialize
 
 if (Z >= 3.0)
    {
     NLTEST = $YES                    #truncate at 3*sigma
    }
 else if (Z > -3.0)                   #if between -3 and 3
    {
     I = INT(10.0 * ABS(Z) + .5)      #compute closest index into table
 
     PROB = STDNL[I]                  #get tabulated probability
 
     if (Z < 0.0)                     #if Z negative
        {
         PROB = 1.0 - PROB            #compute complementary probability
        }
     if (PROB >= RAND(0))           #compare with uniform (0,1) deviate
        {
         NLTEST = $YES                #     to get outcome of test
        }
    }                                 #endelse
 
 return
 end
 

 Function NLTEST2(_                    #Normal TEST
                  FMEAN,               #mean (input)
                  STDDEV,              #standard deviation (input)
                  X,                   #value to be tested (input)
                  X2,                  #second value to be tested (input)
                  NLTESTx,             #result of second test (output)
                  Degradation,         # 0.0-1.0 (in)
                  NLTesty,             # result of third test (out)
                  PROB1,               # out, probability of success, test 1
                  PROB2)               # out, probability of success, test 2
 
 #####################################################
 #$%
 #$% Purpose:   NLTEST Determines success or failure of
 #$%            an event by matching the position of
 #$%            the input number X in a normal dis-
 #$%            tribution, defined by FMEAN and
 #$%            STDDEV, against a random number
 #$%            selected from a uniform distribution.
 #$%
 #$% Called By: ESMDET     ESMSAT     FRQDET
 #$%            PASDET     RADDET     RADSAT
 #$%
 #$% Invokes:   ABS        INT        RANDOM
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 
USE IFPORT
implicit none
 
Real*4      Degradation
Integer*4   NLTesty
Real*4      PROB1
Real*4      PROB2
real*4      PROB, Z, X, FMEAN, STDDEV, ZX, X2
real*4      A_RANDOM
integer     I, NLTEST2, NLTESTX
 
NL$common                           #table of normal probabilities
external NLDATA
 
NLTEST2 = $NO                        #initialize
NLTESTx = $NO                        #initialize
NLTESTy = $NO                        #initialize
 
PROB = 1.0                           # 8/90, reh
 
Z  = (X  - FMEAN) / STDDEV           #convert to standard normal
Zx = (X2 - FMEAN) / STDDEV           #convert to standard normal
 
A_random = RAND(0)                 # always draw a random number
 
if (Z >= 3.0)
    {
    NLTEST2 = $YES                   #truncate at 3*sigma
    }
else if (Z > -3.0)                   #if between -3 and 3
    {
    I = INT(10.0 * ABS(Z) + .5)      #compute closest index into table
 
    PROB = STDNL[I]                  #get tabulated probability
 
    if (Z < 0.0)                     #if Z negative
        {
        PROB = 1.0 - PROB            #compute complementary probability
        }
 
    if (PROB >= A_random )           #compare with uniform (0,1) deviate
        {
        NLTEST2 = $YES                #     to get outcome of test
        }
    }                                 #endelse
else # else no probabliity of success reh 9/90
    {
    PROB = 0.0
    }
 
PROB1 = PROB                          # probability of success
 
#------------------------------------------------------------
# now test the other value with the same random number
 
PROB = 1.0                            # reset for second test
 
if (Zx >= 3.0)
    {
    NLTESTx = $YES                   #truncate at 3*sigma
    }
 else if (Zx > -3.0)                  #if between -3 and 3
    {
    I = INT(10.0 * ABS(Zx) + .5)     #compute closest index into table
 
    PROB = STDNL[I]                  #get tabulated probability
 
    if (Zx < 0.0)                    #if Zx negative
        {
        PROB = 1.0 - PROB            #compute complementary probability
        }
 
    if (PROB >= A_random )           #compare with uniform (0,1) deviate
        {
        NLTESTx = $YES               #     to get outcome of test
        }
    }                                 #endelse
else # else no probabliity of success reh 9/90
    {
    PROB = 0.0
    }
 
PROB2 = PROB                          # second probability of success
 
#$% if any chance of success (worst/second case)
if ( Zx > -3.0 )
    {
    #$% adjust probability of success, 8/27 reh
    if ( PROB * (1.0 - Degradation) >= A_Random)
        {
        NLTESTy = $yes
        }
    }
 return
 end
 

 
 
real*4 Function RANDN(_                 #RANDom Normal number generator
                FMEAN,                #mean (input)
                STDDEV)               #standard deviation (input)
 
 
#####################################################
 #$%
 #$% Purpose:   RANDN randomly selects a number from
 #$%            a normal distribution determined by
 #$%            FMEAN and STDDEV.
 #$%            This routine is for use by the WARGAM process ONLY,
 #$%            to insure repeatability of any given run.
 #$%
 #$% Called By: DPVDSR     DRNAV      ELLOFF
 #$%            FLMANT     HFBGUP     NAVERR
 #$%            SONDET     SOSELL
 #$%
 #$% Invokes:   ISTRIP     RANDOM
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 
 USE IFPORT
 
 implicit none
 real*4  U, Z, V, FRACT
 real*4  FMEAN, STDDEV
 integer I, IU, IBELOW, IABOVE
 
NL$common                           #table of normal probabilities
 external NLDATA
 
 equivalence (IU,U)                   #used to strip out exponent bits
 
 logical NEGFLG                       #flag to indicate negative direction
 
 
 repeat                               #keep on
 
    {
     U = RAND(0)                    #draw a uniform (0,1) deviate
 
     if (U < STDNL[0])                #if less than .5
 
        {
         V = 1.0 - U                  #compute complementary probability
 
         NEGFLG = .TRUE.              #set flag
        }                             #endif
 
      else                            #otherwise
 
        {
         V = U                        #switch roles
 
         U = 1.0 - U                  #    of U and V
 
         NEGFLG = .FALSE.             #don't set flag
        }                             #endelse
 
    }                                 #endrepeat
 
 until (V <= STDNL[$EndSTDNL])               #until within table range
 
 
 I = 6                                #    for table search
 
 IBELOW = 0                           #initialization
 
 IABOVE = $EndSTDNL                          #    for table search
 
 repeat                               #keep on
 
    {
     if (V < STDNL[I])                #if less than tabulated value
 
        {
         IABOVE = I                   #adjust ceiling
 
         I = I - 1                    #prepare to test against lower value
        }                             #endif
 
     else if (V > STDNL[I])           #if greater than tabulated value
 
        {
         IBELOW = I                   #adjust floor
 
         I = I + 1                    #prepare to test against higher value
        }                             #endif
 
     else                             #if equal to tabulated value
 
        {
         IBELOW = I                   #floor equals I
 
         IABOVE = I                   #ceiling equals I
        }                             #endelse
 
    }                                 #endrepeat
 
 until (IABOVE <= IBELOW + 1)         #until value has been pinched
 
 if (IBELOW == IABOVE)                #if matches entry in table
 
     FRACT = 0                        #     nothing to add
 
 else                                 #otherwise
 
     FRACT = (V - STDNL[IBELOW]) / _     #compute amount to be added in
        (STDNL[IABOVE] - STDNL[IBELOW])  #    order to interpolate
 
 Z = 0.1 * (IBELOW + FRACT)           #gives corresponding
 
 if (NEGFLG)  Z = -Z                  #    random standard normal deviate
 
 RANDN = FMEAN + STDDEV * Z           #transform to desired mean & std dev
 
 return
 end
 

 
 
 Function RANDN2(_                    #RANDom Normal number generator
                FMEAN,                #mean (input)
                STDDEV)               #standard deviation (input)
 
 
#####################################################
 #$%
 #$% Purpose:   RANDN randomly selects a number from
 #$%            a normal distribution determined by
 #$%            FMEAN and STDDEV.
 #$%            This routine is for use by non-WARGAM processes.
 #$%            If called from within WARGAME, repeatability of any given
 #$%            run may be lost.
 #$%
 #$% Called By: DPVDSR     DRNAV      ELLOFF
 #$%            FLMANT     HFBGUP     NAVERR
 #$%            SONDET     SOSELL
 #$%
 #$% Invokes:   ISTRIP     RANDOM
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  U, RANDOM2, V, Z, FRACT
 real*4  RANDN2, FMEAN, STDDEV
 integer I, IU, IBELOW, IABOVE
 
 NL$common                           #table of normal probabilities
 external NLDATA
 
 equivalence (IU,U)                   #used to strip out exponent bits
 
 logical NEGFLG                       #flag to indicate negative direction
 
 
 repeat                               #keep on
 
    {
     U = RANDOM2(1)                   #draw a uniform (0,1) deviate
 
     if (U < STDNL[0])                #if less than .5
 
        {
         V = 1.0 - U                  #compute complementary probability
 
         NEGFLG = .TRUE.              #set flag
        }                             #endif
 
      else                            #otherwise
 
        {
         V = U                        #switch roles
 
         U = 1.0 - U                  #    of U and V
 
         NEGFLG = .FALSE.             #don't set flag
        }                             #endelse
 
    }                                 #endrepeat
 
 until (V <= STDNL[$EndSTDNL])               #until within table range
 
 I = ISTRIP(_                         #strip out exponent field
            IU,                       #word to be stripped
            7,                        #least significant bit      #@
            M8BITS)                   #mask
 
 I = 4 * (128 - I)                    #gives a close starting point
 
 if (I > 6)  I = 6                    #    for table search
 
 IBELOW = 0                           #initialization
 
 IABOVE = $EndSTDNL                          #    for table search
 
 repeat                               #keep on
 
    {
     if (V < STDNL[I])                #if less than tabulated value
 
        {
         IABOVE = I                   #adjust ceiling
 
         I = I - 1                    #prepare to test against lower value
        }                             #endif
 
     else if (V > STDNL[I])           #if greater than tabulated value
 
        {
         IBELOW = I                   #adjust floor
 
         I = I + 1                    #prepare to test against higher value
        }                             #endif
 
     else                             #if equal to tabulated value
 
        {
         IBELOW = I                   #floor equals I
 
         IABOVE = I                   #ceiling equals I
        }                             #endelse
 
    }                                 #endrepeat
 
 until (IABOVE <= IBELOW + 1)         #until value has been pinched
 
 if (IBELOW == IABOVE)                #if matches entry in table
 
     FRACT = 0                        #     nothing to add
 
 else                                 #otherwise
 
     FRACT = (V - STDNL[IBELOW]) / _     #compute amount to be added in
        (STDNL[IABOVE] - STDNL[IBELOW])  #    order to interpolate
 
 Z = 0.1 * (IBELOW + FRACT)           #gives corresponding
 
 if (NEGFLG)  Z = -Z                  #    random standard normal deviate
 
 RANDN2 = FMEAN + STDDEV * Z           #transform to desired mean & std dev
 
 return
 end

#wraprand should only be used by random, so that the portability module can
#be used to identify the correct rand().  Declaring "use ifport" in random()
#conflicts with an Intel Fortran portability function random() that has a
#different signature than RESA's random().  Other direct calls to rand() are
#fine because they use ifport and have no such conflicts.
#Invoking rand() without "use ifport" results in random() simply returning
#the argument that it is passed, usually 0.0 or 1.0, thereby essentially breaking
#the stochastic features of RESA.
real*4 function wraprand(i)
use ifport
integer*4 i
wraprand=rand(i)
return
end
Real*4 Function random(x)
real x
random = wraprand(int(x))			# rand is fortran intrinsic function
return
end
 

define ($Max_Random2_Seeds,20)
define (Random2$Common,
    integer*4   r2_seeds [ $Max_Random2_Seeds ]
    common /random2_common / r2_seeds
    )
 
Real*4 Function RANDOM2 (IX)          # uniform (0,1) RANDOM number generator
 
#####################################################
#$%
#$% Purpose:   RANDOM2 (IX) randomly selects a number in
#$%            the range 0 to 1 from a uniform distribution.
#$%            The argument IX is an index into the array of possible
#$%            random number seeds.  The routine SET_RANDOM2 can assign
#$%            initial seed values to in the seed array.
#$%
#$%            This routine is for use by non-WARGAM processes.
#$%            If called from within WARGAME, repeatability of any given
#$%            run may be lost.
#$%
#$% Invokes:   RAND
#$%
#$% Tables:    None
#$%
#$% Date:      NOV 90
#$%
#$% Author:    Dane Wills
#$%
#####################################################
 
USE IFPORT
 
implicit none
 
Integer*4   IX                      # Seed index to use... (TBD)
Integer*4   I_Use
Real*4      SET_RANDOM2
random2$common
data r2_seeds / $Max_Random2_Seeds * 3 /
 
if (IX != 0)
{
	I_Use = min ($Max_Random2_Seeds , max ( 1, IX ))            # E2143 dew 10/99
	call srand(r2_seeds[I_Use])
}
 
RANDOM2 = RAND(0)
 
return
end
#----------------------------------------
real*4 function set_random2 ( IX, new_seed )                          # E2143 dew 10/99
 
implicit none
 
Integer*4   IX                      # Seed index to use... (TBD)
integer*4   New_Seed
Integer*4   I_Use
random2$common
 
I_Use = min ($Max_Random2_Seeds , max ( 1, IX ))
 
r2_Seeds [ I_Use ] = New_Seed
 
return (new_seed)
end
 

 
 Subroutine RLL2RB( _                #Rhumb line Lat/Lon to Range/Bearing
                   FLAT1,            #latitude of 1st pt (input)
                   FLON1,            #longitude of 1st pt (input)
                   CSLAT1,           #cos of lat of 1st pt (input)
                   FLAT2,            #latitude of 2nd pt (input
                   FLON2,            #longitude of 2nd pt (input)
                   CSLAT2,           #cos of lat of 2nd pt (input)
                   RANGE,            #range (output)
                   BRNG)             #bearing (output)
 
#####################################################
 #$%
 #$% Purpose:   RLL2RB computes the rhumb line range
 #$%            and bearing of one point from another
 #$%            point when given the latitude and
 #$%            longitudes of both points.
 #$%
 #$% Called By: GETRB      GNDTRK     GPLOTC
 #$%            HFDFP1     INTCPT     MANUVR
 #$%            OBARR2     ORBTO      VECTOR
 #$%
 #$% Invokes:   ANGPI      ATAN2     SQRT
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  Y, FLAT2, FLAT1, DELLON, FLON2, FLON1
 real*4  X, CSLAT1, CSLAT2, BRNG, RANGE
 
 Y = FLAT2 - FLAT1                      #compute latitude difference
 
 DELLON = FLON2 - FLON1                 #compute longitude difference
 
 $angPI(DELLON)                         #insure short way around earth
 
 X = DELLON * .5* (CSLAT1 + CSLAT2)     #scale horizontal distance
 
 if (x==0.0 & y==0.0)
    {
    BRNG = 0.0
    RANGE = 0.0
    }
 else
    {
    RANGE = SQRT(X*X + Y*Y) _              #approximate rhumbline distance
                * (180.*60./$PI)            #    in nautical miles
    BRNG = atan2(x,y)
 
    if (BRNG < 0.0) BRNG = BRNG + $twoPI
    }
 
 return
 end
 

 Subroutine RRB2LL( _            #Rhumb line Range/Bearing to Lat/Lon
                   FLAT,         #latitude (input & output)
                   FLON,         #longitude (input & output)
                   RANGE,        #range (input)
                   RELBRG,       #relative bearing (input)
                   HEADNG,       #course (input) WARN: MAY BE a CONSTANT!
                   COSLAT)       #cosine of latitude (input & output)
 
#####################################################
 #$%
 #$% Purpose:   RRB2LL computes rhumb line of range
 #$%            and bearing to latitude and longitude.
 #$%
 #$% Called By: ESMBRG     GUIMAN     MOTION
 #$%            OPROCE     VECTOR     WGLSHP
 #$%
 #$% Calls:    ANG2PI
 #$%
 #$% Invokes:  $ANGPI      SIN    COS
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  BRG, RELBRG, HEADNG, COSBRG, SINBRG
 real*4  R, RANGE, FLAT, C, FLON, COSLAT
 
 BRG = RELBRG + HEADNG                   #compute bearing
 call ang2pi(BRG)                                #              8/21/85
 
 cosbrg= cos(brg)                        #compute cos of bearing
 sinbrg= sin(brg)                        #compute sin of bearing
 
 R = RANGE * ($PI/(180.*60.))            #convert range to radians
 
 FLAT = FLAT + R * COSBRG                #compute new latitude
 C = COS(FLAT)                           #compute cosine of new latitude
 
 FLON = FLON + R * SINBRG * _            #compute new longitude
                 2./(COSLAT+C)
 $angPI(FLON)                        #adjust for intl date line crossing
 
 COSLAT = C                              #store cosine of new lat for output
 
 return
 end
 

 Subroutine APPLL( _                 #APParent Latitude & Longitude
                  FLAT1,             #assumed lat of detector (input)
                  FLON1,             #assumed lon of detector (input)
                  RANGE,             #range to target (input)
                  BRG,               #apparent rhumb bearing to target (input)
                  FLAT2,             #apparent lat of target (output)
                  FLON2)             #apparent lon of target
 
#####################################################
 #$%
 #$% Purpose:   APPLL computes the apparent latitude
 #$%            and longitude of a second point when
 #$%            given the latitude and longitude of
 #$%            the first point, and the range and
 #$%            bearing from the first point to the
 #$%            second point.
 #$%
 #$% Called By: REPASD     REPRAD     VISMOD
 #$%
 #$% Invokes:   ANGPI      QKTRIG      COS
 #$%
 #$% Tables:    None
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #####################################################
 implicit none
 real*4  R, RANGE, COSBRG, BRG, SINBRG
 real*4  FLAT2, FLAT1, FMIDCS, FLON2, FLON1
 
 R = RANGE * ($PI/(180.*60.))        #convert range to radians
 
 cosbrg= cos(brg)                     #compute cos of bearing
 sinbrg= sin(brg)                     #compute sin of bearing
 
 FLAT2 = FLAT1 + R * COSBRG          #compute target latitude
 
 FMIDCS = .5 * (COS(FLAT1) + COS(FLAT2)) #get approx horiz scale factor
 
 FLON2 = FLON1 + R * SINBRG / FMIDCS #compute target longitude
 
 $angPI(FLON2)
 
 return
 end
 

 
include "bblcl.inc"
include "bbunt.inc"
 
Subroutine GETRB(UNT$POINTER,                        #receive posit of orgin
                 UNT2$POINTER,                       #receive posit of dest
                 RANGE,                              #return range
                 BRG)                                #retrun bearing
 
 #######################################################
 #$%
 #$% Purpose:   GETRB computes range and bearing to
 #$%            the target from the present aircraft
 #$%            position.
 #$%
 #$% Called By: AIRTOR     ATOAIR     ATOSUR    AIRASM
 #$%            AIRBOMB    BLDCM      SURTOR    Find_Match
 #$%            NWFUEL     REFUEL     OFTOR1    Get_Skunks
 #$%                                  BINGO
 #$% Calls:     RLL2RB
 #$%
 #$% Tables:    UNT
 #$%
 #$% Date:      OCT 80
 #$%
 #$% Author:    Ron Williams
 #$%
 #######################################################
 
 BBcommon
 BBDeclare(UNT$TrueLatitude$F, UNT$Pointer, UNT$TrueLongitude$F,
  	   UNT$CosTrueLat$F, UNT2$TrueLatitude$F, UNT2$Pointer,
	   UNT2$TrueLongitude$F, UNT2$CosTrueLat$F)
 real*4  RANGE, BRG
 
UNT$TRUELATITUDE$F   = xUNT$TRUELATITUDE$F              ## tpa 8/23/83
UNT$TRUELONGITUDE$F  = xUNT$TRUELONGITUDE$F
UNT$COSTRUELAT$F     = xUNT$COSTRUELAT$F
UNT2$TRUELATITUDE$F  = xUNT2$TRUELATITUDE$F
UNT2$TRUELONGITUDE$F = xUNT2$TRUELONGITUDE$F
UNT2$COSTRUELAT$F    = xUNT2$COSTRUELAT$F
 
 
call RLL2RB(UNT$TRUELATITUDE$F,   #get range to target
            UNT$TRUELONGITUDE$F,  #UNT$TRUELATITUDE$F   = UNIT latitude (In)
            UNT$COSTRUELAT$F,     #UNT$TRUELONGITUDE$F  = UNIT longitude (In)
            UNT2$TRUELATITUDE$F,  #UNT$COSTRUELAT$F     = cos of latitude (In)
            UNT2$TRUELONGITUDE$F, #UNT2$TRUELATITUDE$F  = target lat (In)
            UNT2$COSTRUELAT$F,    #UNT2$TRUELONGITUDE$F = target long (In)
            RANGE,                #UNT2$COSTRUELAT$F    = cos of latitude (In)
            BRG)                  #RANGE                = target range (Out)
                                  #BRG                  = target bearing (Out)
 
 return
 end
 
 
Subroutine GETRB_LCL (UNT$POINTER,              #receive posit of orgin
                      LCL$POINTER,              #receive posit of dest
                      RANGE,                    #return range
                      BRG)                      #retrun bearing
 
 #######################################################
 #$%
 #$% Purpose:   GETRB_LCL computes range and bearing to
 #$%            the target from the present aircraft
 #$%            position.
 #$%
 #$% Called By: AIRTOR  SURTOR
 #$%
 #$% Calls:     RLL2RB
 #$%
 #$% Tables:    UNT     LCL     RMT
 #$%
 #$% Date:      AUG 83
 #$%
 #$% Author:    Tim Adamos
 #$%
 #######################################################
 
 BBcommon
 
real*4  latitude, longitude, range, brg
BBDeclare(LCL$Pointer, UNT$TrueLatitude$F, UNT$Pointer,
	  UNT$TrueLongitude$F, UNT$CosTrueLat$F)
real*4  FCOSL
 
if (xLCL$TMAFlag$I == YES)
    {
    Latitude  = xLCL$TMALat$F
    Longitude = xLCL$TMALon$F
    }
else
    {
    Latitude  = xLCL$ApparentLat$F
    Longitude = xLCL$ApparentLon$F
    }
 
fCOSl= COS(Latitude)
 
UNT$TRUELATITUDE$F   = xUNT$TRUELATITUDE$F              ## tpa 8/23/83
UNT$TRUELONGITUDE$F  = xUNT$TRUELONGITUDE$F
UNT$COSTRUELAT$F     = xUNT$COSTRUELAT$F
 
call RLL2RB(UNT$TRUELATITUDE$F,   #get range to target
            UNT$TRUELONGITUDE$F,  #UNIT latitude (In)
            UNT$COSTRUELAT$F,     #UNIT longitude (In)
            Latitude,             #target latitude (In)
            Longitude,            #target longitude (In)
            FCOSl,                #target cos of lat(In)
            RANGE,                #cos of latitude (In)
            BRG)                  #target range (Out)
                                  #target bearing (Out)
 
 return
 end

Subroutine GETRB_sl(UNT$POINTER,                        #receive posit of orgin
                    UNT2$POINTER,                       #receive posit of dest
                    RANGE,                              #return range
                    BEAR)                               #return bearing
 
#######################################################
#$%
#$% Purpose:   GETRB_sl computes slant range and bearing to
#$%            the target from the present aircraft
#$%            position.
#$%
#$% Called By:
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      APR 84
#$%
#$% Author:    D. Wills
#$%
########################################################
 
bbcommon
 
integer         last_pos
data            last_pos/0/
 
real            rd, range, bear
data            rd /1024.0/
BBDeclare(UNT$Pointer, UNT2$Pointer)
real*4          HRANGE
 
if (UNT$pointer != last_pos)
    {
    rd = 512
    call pslant (xUNT$truelatitude$f,
                 xUNT$truelongitude$f,
                 xUNT$truealtdepth$i,
                 xUNT$costruelat$f,
                 rd)
 
    last_pos = UNT$pointer
    }
 
call slrang (XUNT2$truelatitude$f,    #find detector-target range
             XUNT2$truelongitude$f,
             XUNT2$truealtdepth$i,
             XUNT2$costruelat$f,
             hrange,
             range,
             bear)
 
return
end
 

#$% determine value at which a given probability lies on a normalization curve
real *4 Function normalization_value(_
                        FMEAN,                    # mean (input)
                        Standard_Deviation,       # standard deviation (input)
                        Probability)              # probability(input)
 
#####################################################
#$%
#$% Purpose:   Normalization_Value determines the
#$%            value along the normalization curve defined
#$%            by a standard normalization curve (modified
#$%            by function parameters). A linear interpolation
#$%            algorithm is used to determine values.
#$%
#$% Invokes:
#$%
#$% Tables:    None
#$%
#$% Date:      12/90
#$%
#$% Author:    R. Hundt
#$%
#$% Note:      If the STDNL array size is changed from
#$%             a length of 31 this function must change
#$%             accordingly.
#####################################################
implicit none
real*4      FMEAN
real*4      Standard_Deviation
real*4      Probability
 
integer*4   I
 
NL$common                           #table of normal probabilities
external NLDATA
 
real*4      factor
integer*4   Index_Save
real*4      Interpolated_Index
real*4      ref_probability
real*4      Prob
real*4      value
real*4      value_save
 
#$% verify probability in range
Prob = MAX(0.0,MIN(1.0,Probability))
 
if ( prob == 1.0 )
    {
    #$% get minimum value which satisfies
    normalization_value = FMEAN + (3.0 * Standard_Deviation)
    }
else if ( probability == 0.0 )
    {
    normalization_value = FMEAN - (3.0 * Standard_Deviation)
    }
else # else if probability lies on normalization curve
    {
    #$% initialize to normalized value (middle of curve)
    value_save = STDNL [ 0 ]
    index_save = 0
 
    #$% for all normalization values ( half curve )
    FOR ( I = 0; I <= $EndSTDNL ; I = I + 1)
        {
        value = STDNL[ I ]
        if ( Prob >= 0.5 )
            {
            #$% if index into normalization curve ~ probabliity
            if ( STDNL[I] >= Prob )
                {
                factor = 1.0
                ref_probability = prob
                BREAK                   # corresponding value "found"
                }
            }
        else # else probability is complement of the array
            {
            #$% if index into normalization curve ~ probabliity
            if ( 1.0 - STDNL[I] <= Prob )
                {
                factor = -1.0
                ref_probability = 1.0 - prob
                BREAK                   # corresponding value "found"
                }
            }
 
        value_save = STDNL[ I ]                # use later for interpolation
        index_save = I                         # use later for interpolation
 
        } # end for all normalization values
 
    if ( value - value_save == 0.0 )
        {
        #$% interpolate into curve
        Interpolated_Index = index_save
        }
    else
        {
        #$% interpolate into curve
        Interpolated_Index = index_save +
            ( (ref_probability - value_save)/(value - value_save))
        }
 
    #$% get minimum value which satisfy input conditions
    normalization_value = FMEAN + factor *
        (3.0 * (Interpolated_Index / $EndSTDNL) * Standard_Deviation)
 
    }# end else if probability lies on normalization curve
 
return
end
 

 
Integer function NInInterval(_             # Convert rate/min to N/interval
                       TimeLastUsed,       # Time Last Used: real: in/out: min
                       irate,              # Rate: integer: in: n/min
                       iremaining)         # Total remaining: integer: in
BBcommon
 
real    TimeLastUsed,
        interval,                          #  1/rate is interval in minutes
        t
integer irate
integer iremaining
 
interval = 1./float(irate)              # Minutes between events
 
t = TimeLastUsed - .0001                # Fudge factor for rounding error
# If no event since last time model set last event to start of model interval
if (t < (game$time - (interval+model$interval)))
{
    NInInterval = min(int(model$interval * irate), iremaining)
    TimeLastUsed = game$time
    if (NInInterval == 0)               # At least one
    {
        NInInterval = 1
        TimeLastUsed = game$time - model$interval
    }
}
else
{
    NInInterval = min(int((game$time - t) * irate), iremaining)
    TimeLastUsed = t + NInInterval * interval
}
 
return
end
 

 
real function mth$alog2(x)
real x
real base10to2
data base10to2/0.0/
 
#Calculate ratio to convert base 10 exponent to base 2 exponent
if (bsse10to2 == 0.0)  base10to2 = log10(2.0)
 
mth$alog2 = log10(x) / base10to2
 
return
end
