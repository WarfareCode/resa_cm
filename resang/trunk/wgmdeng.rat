                        # WGMDENG.RAT file

#$%     Look in DOC.WHO for Flowchart and Subroutine Lists.


include "ascii.inc"         
include "macros.inc"         
include "bbctl.inc"         
include "bbcode.inc"         
include "bbacc.inc"         
include "bbagd.inc"         
include "bbbml.inc"                 # jb                            4/26/89
include "bbaml.inc"         
include "bbunt.inc"         
include "bbcmc.inc"         
include "bbdeq.inc"                  # jb (replaced DYN with DEQ table)   3/89
include "bbshc.inc"         
include "bbrad.inc"         
include "bblcl.inc"         
include "bbmc.inc"         
include "bbtat.inc"         
include "bbirc.inc"            # av 8/93 - adcru and ballistic missiles
include "bbwet.inc"            # av 8/93 - adcru and ballistic missiles
include "bbtor.inc"         
include "bbbom.inc"         
include "bbeph.inc"         
include "bbnuc.inc"         
include "bbrmt.inc"         
include "bbvue.inc"         
include "bbord.inc"                 # jb                                7/5/89
include "orders.inc"                # jb                               7/20/89
include "bbjew.inc"               # JFR for jecewsi - 8/31/94
include "bbbtt.inc"               # clk 6/95 (E1419)
include "bbtrp.inc"               # SMM 2/96 (E1419)
include "bbctm.inc"               # SMM 2/96 (E1419)
include "bbpem.inc"               # clk 1/97 (E1731)
include "cenglog.inc"             # 7/12/85 COMMON BLOCK FOR ENGAGE LOG DATA
                                  # GATHERING CODE.  called "ENcommon".
include "hseng.inc"         
include "wgmdeng.inc"               # reh, 5/14/90

define (BBimplicit, IMPLICIT NONE)  # jb E2145  6/26/00
#define ($DEBUG,$$Debug$Control)

define ($spj, 1)         # Jecewsi id - JFR 8/17/94
define ($launchFac, 2)   # Jecewsi id - JFR 8/17/94

define(trace$engage$exe, istrip(trace$engage,0,M1bits)) # trace general exec
define(trace$engage$roe, istrip(trace$engage,1,M1bits)) # trace ckroe select
define(trace$engage$tgt, istrip(trace$engage,2,M2bits)) # trace assgnt select
define(trace$engage$tgx, istrip(trace$engage,3,M1bits)) # trace assgnt all
define(trace$engage$gun, istrip(trace$engage,4,M1bits)) # trace gun engagements

# moved up from bottom SMM 4/99 (E1969)
include "wgmdeng_guns.rin"             # jb  Gun Model        7/6/89
    # Consists of subroutines ARTILL,   GUNENG,     GET_SKUNKS,
    #                         Gun_Fire, Gun_Sights, Gun_Targets;
    #                          and literal Function Target_Name


#______________________________________________________________________

Subroutine engage

########################################################
#$%
#$% Purpose:   ENGAGE provides executive control for
#$%            the engagement module.  Each active
#$%            shorebase, ship, aircraft, and cruise
#$%            missile is checked for possible target
#$%            contact, and processed if an engagement 
#$%            should occur.  Torpedo impact is also 
#$%            processed.
#$%
#$% Called By: WARCYC
#$%
#$% Calls:     EINIT      ASSGNT_ALL     TORAT
#$%            CMEPRO     EPROSS   Proc_SAM_attack
#$%
#$% Tables:    UNT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 1/97 (E1731)
#$%            Added call to process persistent effect
#$%            munitions.
#$%
#$%            James Allen - 2/98 (E1864)
#$%            Removed the else if case for adcru cruise
#$%            missiles - they no longer exist.
#$%
########################################################
BBcommon
Eng$ProbHits    # moved these defines into 'WGMDENG.INC'  SMM 2/94

Integer  CMC$Pointer,CMC$Cat$I,         # jb E2145  6/27/00
    UNT$Pointer,UNT$Status$I,           # jb E2145  6/27/00
    UNT$Type$I,UNT$Assignedtarget$I     # jb E2145  6/27/00
logical has_guns

if (eph_loaded == NO)
    {
    call load_eph

    eph_loaded = YES
    }

call Persistent_Munition_Eng   # clk 1/97 (E1731)

call einit                                      #initialize status fields

call assgnt_all                                 #assign targets

call torat                                      #check weapon at target

#$% for each pointer entry
for(unt$pointer$first;still_ok(UNT);unt$pointer$next) # 9/26/88
   {
    #$% get unit status
    unt$Status$i = Xunt$Status$i

    #$% if status is being deleted, awaiting launch or refuel,
    #$% get next entry
    if(unt$Status$i == $BeingDeleted$code    |
       unt$Status$i == $ACAwaitingLaunch$code|
       unt$Status$i == $ACRefuel$code        |
       xUNT$GhostedUnit$I == $YES            |  # don't process ghosts
       xUNT$NeverEngages$i ==$YES)    # jb vice FALSEcontact   2/19/91
             NEXT

    #$% get unit type
    unt$Type$i = Xunt$Type$i

    #$% get assigned target
    unt$AssignedTarget$i = Xunt$AssignedTarget$i

    #$% if unit is a cruise missile
    if (unt$Type$i == $CruiseMissile$code)
       {
        cmc$pointer = Xunt$CMCpntr$i
        cmc$cat$i = Xcmc$cat$i

        if (cmc$cat$i == $cruz$code)
        #$% process cruise missile engagment
          call cmepro (unt$pointer)

        else if (cmc$cat$i == $ball$code)
        #$% process ballistic missile engagement
          call bmepro (unt$pointer)   
       }
     
    # if unit is an advanced SAM  and    # SMM 1/94
    # it doesn't have an assigned target or
    # it does have an assigned target and it is right on top of it
    else if ((UNT$Type$I == $SAMissile$Code) &
             ((xUNT$AssignedTarget$I != 0) & (xUNT$Status$I == $OnGuide$Code)))
        {
         call Proc_SAM_attack(UNT$Pointer)
        }
    #$% else if unit is an aircraft
    else if (unt$Type$i == $Air$code)
       {
        #$% if assigned a target
        if(unt$AssignedTarget$i != $no | has_guns(unt$Pointer))
           {
            #$% call engagement processor
            call epross (unt$pointer,unt$assignedtarget$i)
           }
       }
    #$% if this unit is a smart torpedo   5/2/90
    else if (xUNT$SuperType$i == $Torpedo$SuperCode )
        {
        call torp_engage ( UNT$Pointer )
        }
    #$% if this unit is a countermeasure 5/15/90
    else if (xUNT$SuperType$i == $CtrMeasure$SuperCode )
        {
        call countermeasure ( UNT$Pointer )         # chk for life
        }

    else if (unt$Type$i == $Surface$code       |               #17NOV1983
#            unt$Type$i == $SurfaceWithAc$Code |               #
             unt$Type$i == $Sub$Code           |               #
             unt$Type$i == $Shorebase$Code     )               #          
       {
        #$% call engagement processor
        call epross (unt$pointer,unt$assignedtarget$i)
       }

    PUTunt$UnderAttack$i ($NO)                  #clear under attack flag
   }
return
end


Subroutine Send_Deton   

########################################################
#$%
#$% Purpose:   Sends nucdetonation data to DETONATION subroutine 
#$%
#$% Called By: CMHIT  SAMENG  ATOAIR    AIRASM  TORAT   AIRBOMB
#$%
#$% Calls:     DETONATE 
#$%
#$% Tables:
#$%
#$% Date:      APRIL 85
#$%
#$% Author:    O. J. Bryant
#$%
########################################################
bbcommon
NUcommon        # Source of arguments for call of DETONATE..

if (NucDet$Count >= 10) RETURN          ## precaution no more than 10
                                        ## explosions per cycle tpa 5/7/85

call Nuc_Blast                          ## tpa 5/7/85

NucDet$Count = NucDet$Count +1  # Increment count of detonations

call DETONATE(_
                kside,          # 1 ->Blue;  2 -> Orng;   0 -> "neutral'
                iBURST,         # 1 ->Air;   2 ->SubSurf; 3 -> Surface
                iYIELD,         # 
                iDEPTH,         # IF SUBsurface; 1 -> shallow; 2 -> deep
                Intcptflag,     # $YES -> Flat/Flon is intcpt point
                INDXtgt,        # Tgt indx, 1 thru 400 (if NOT an INTERCEPT)
                nPH,            # Prob. Hit * 100 (if NOT an INTERCEPT)
                Flat,           # Position of intercept;
                Flon    )       #       or, of target, if not an intercept
                
return
end             # End subr. Send_Deton


Subroutine load_eph             # initialize Prob Hit table

########################################################
#$%
#$% Purpose:   LOAD_EPH    Initializes Prob Hit (eph) Matrix
#$%
#$% Called By: ENGAGE
#$%
#$% Calls:     None
#$%
#$% Tables:    EPH      CMC     MC      BOM
#$%
#$% Date:      DEC 83
#$%
#$% Author:    Dane Wills
#$%
#$% Modified:  Carol L. Kropp    3/92 air-to-air upgrade
#$%            Modified the way the matrix defaults for
#$%            surface-to-air weapons ($SAM$Code and
#$%            $CIWS$Code).
#$%
########################################################
BBcommon
Eng$ProbHits
Eng$ProbIndx

REAL        PH                 # jb E2145  6/27/00
Integer  N,IPH,                # jb E2145  6/27/00
    MC$Pointer, MC$Type$I,     # jb E2145  6/27/00
    CMC$Pointer,BOM$Pointer,   # jb E2145  6/27/00
    UNT$Pointer,SHC$Pointer,   # jb E2145  6/27/00
    EPH$Pointer                # jb E2145  6/27/00
integer         bom_indx[bom$slots], nbombs

#
#       The EPH Matrix is dimensioned N-Targets by M-Weapons.  The default
#       values are taken as the PH values for the various weapon types.
#       If any values are specified in EPH, they overide the default PH.
#
#       3/92:  No longer using the MC$ProbHit$F as a default for the ph
#              for surface-to-air engagements (SAM and CIWS).  If no
#              weapon/target ph was specified in the FORCE process,
#              then the weapon ph for the target altitude is used
#              (MC$BND$ProbKill$I), as specified in Enhanced Aircraft
#              Engagements (March 1992).  The altitude band ph defaults
#              to the MC$ProbHit$F if nothing was entered.



#______________________________________________________________________
# Initialize PH values in accordance with the characteristic PH's for
#  Weapons (CMC, MC & BOM):

for (cmc$pointer$first; still_ok(cmc); cmc$pointer$next) # 9/26/88
    {
    W_Indx = Xcmc$WeaponIndex$i

    ph = Xcmc$ProbHit$f
    iph = ph * 100 + 0.5                # +0.5          8/27/85

    for (T_indx=1; T_indx <= Target$slots; T_indx = T_indx + 1)
        {
        eph[T_indx,W_indx] = iph
        }
    }

for (mc$pointer$first; still_ok(mc); mc$pointer$next) # 9/26/88
   {
    MC$Type$I = xMC$Type$I
    W_Indx = Xmc$WeaponIndex$i

    if (MC$Type$I == $SAM$Code | MC$Type$I == $CIWS$Code)       # clk 3/92
      iph = -1       # weapon is a SAM or a CIWS
    else
      {
       ph = Xmc$ProbHit$f
       iph = ph * 100 + 0.5                # +0.5          8/27/85
      }

    for (T_indx=1; T_indx <= Target$slots; T_indx = T_indx + 1)
      {
       eph[T_indx,W_indx] = iph
      }
   }

nbombs = 0

for (bom$pointer$first; still_ok(bom); bom$pointer$next) # 9/26/88
    {
    W_Indx = Xbom$WeaponIndex$i

    nbombs = nbombs+1
    bom_indx[nbombs] = W_indx

    ph = Xbom$ProbHit$f
    iph = ph * 100 + 0.5                # +0.5          8/27/85

    for (T_indx=1; T_indx <= Target$slots; T_indx = T_indx + 1)
        {
        eph[T_indx,W_indx] = iph
        }
    }

#______________________________________________________________________
# For BOMs, revise the above characteristic Ph values in accordance with
#  the general rule that a BOM dropped against a shorebase always hits
#  somewhere on the base..

for (unt$pointer$first; still_ok(UNT); unt$pointer$next) # 9/26/88
    {
    if (Xunt$Type$i != $Shorebase$Code ) next
    shc$pointer = xUNT$shcPntr$i        # get ship pointer 
    T_Indx = Xshc$TargetIndex$i         # eph Target Index

    for (n = 1; n <= nbombs; n=n+1)
        {
        W_indx = bom_indx[n] 
        eph[T_indx,W_indx] = 100
        }
    }

#______________________________________________________________________
# Now revise the above PH values in accordance with the specific
#  Target/Weapon pairings from the BBEPH table.  In effect, these rep-
#  resent exceptions to the PH values already set from the (1) the
#  weapons' characteristics and (2) the general rule that bombs dropped
#  on shorebases always strike somewhere on the base.  This recognizes
#  such a circumstance as that of the 'deadly' mach-2 air-to-air missile
#  that may be quite useless against a specific mach-6 target; or a base
#  that's small compared to the CEP of a BOM delivery system. 

for (eph$pointer$first; still_ok(eph); eph$pointer$next) # 9/26/88
    {
    W_Indx = Xeph$WeaponIndex$i
    T_Indx = Xeph$TargetIndex$i
    iph    = Xeph$Ph$I + 0.5            # +0.5          8/27/85

    eph[T_indx,W_indx] = iph
    }


eph_loaded = YES

return
end    # End Load_eph 


Subroutine einit                                # Engagement initialization

########################################################
#$%
#$% Purpose:   EINIT initializes engagement procedures.
#$%
#$% Called By: ENGAGE
#$%
#$% Calls:     None
#$%
#$% Tables:    LCL        UNT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol L. Kropp - Sept. 1993
#$%            Added a/c attacking position with ASMs & BOMBs
#$%
#$%            Susan Miller - 7/97 (E1385)
#$%            UNT$TestIntercept$I is set to $no when
#$%            the assigned target is being deleted.
#$%
#$%            James Allen - 2/98 (E1864)
#$%            Expanded assigned target check for positions.
#$%
########################################################
BBcommon

Integer  UNT2$Pointer,                  # jb E2145  6/27/00
    LCL$Pointer, LCL$Mytargetflag$I,    # jb E2145  6/27/00
    UNT$Pointer,UNT$Assignedtarget$I    # jb E2145  6/27/00

#$% for each LCL entry
for (lcl$pointer$first; still_valid(lcl); lcl$pointer$next) # 9/26/88
   {
    #$% if slot not in use, get next entry
    if (Xlcl$InUse$i == $no) next

    #$% set my target flag to NO and save
    lcl$MyTargetFlag$i = $no
    PUTlcl$MyTargetFlag$i
   }

for(UNT$POINTER$FIRST;still_ok(UNT);UNT$POINTER$NEXT) # 9/26/88
    {
    if(Xunt$Status$i == $BeingDeleted$code |
       xUNT$GhostedUnit$I == $YES |     # skip ghosted units SMM 5/18/92
       xUNT$NeverEngages$i == $YES) # jb vice FalseContact  2/19/91
            NEXT

    if(xunt$engagestatus$i == $engaging$code)
        PUTunt$engagestatus$i ($engagementover$code)

    unt$AssignedTarget$i = Xunt$AssignedTarget$i        # get assigned target

    if (xUNT$Type$I == $Air$Code &            # if an a/c attacking posit
        UNT$AssignedTarget$I == UNT$Engaging$Position)        # clk 9/93
      {
       next
      }

    if (unt$AssignedTarget$i != 0 &
        unt$AssignedTarget$i != UNT$Engaging$Position)     # is there a target 
       {
        unt2$pointer$to unt$AssignedTarget$i

        if (Xunt2$status$i == $BeingDeleted$code)       # if old target is gone
           {
            if (unt$AssignedTarget$i == Xunt$AttackIndx$i)
                PUTunt$AttackIndx$i ($NO)

            PUTunt$AssignedTarget$i (0)
            putUNT$TestIntercept$I ($NO)       # SMM - 7/97 (E1385)

            if(Xunt$RulesOfEngage$i == $SPECTARGET$CODE)   #if assigned tgt
                PUTunt$RulesOfEngage$i ($IFATTACKED$CODE)  #set ROE to tight

            putUNT$ReactFlag$I ($no)   # makes sure that the reaction flag is
                                       # clear for future engagements   clk 4/92
           }
       }
   }

return
end


subroutine assgnt_all                   # assign targets to all 

########################################################
#$%
#$% Purpose:   ASSGNT_ALL assigns targets for non-cruise-msl units.
#$%
#$% Called By: ENGAGE
#$%
#$% Calls:     ASSGNT
#$%
#$% Tables:    UNT        LCL
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

Integer UNT$Pointer,UNT$Type$I      # jb E2145  6/27/00

#$% for any unit entry
for(unt$pointer$first;still_ok(UNT);unt$pointer$next) # 9/26/88
   {
    #$% if being deleted, get next entry
    if (Xunt$Status$i == $BeingDeleted$code |
        xUNT$GhostedUnit$I == $YES |  # if ghosted unit, skip it SMM 5/18/92
        xUNT$NeverEngages$i ==$YES) # jb vice FalseContact 2/19/91
            NEXT

    unt$Type$i      = Xunt$Type$i       #used in 2 places below 7/27/83

    #$% if cruise missile or an advanced SAM, get next entry
    if ((unt$Type$i == $CruiseMIssile$code) |
        (UNT$Type$I == $SAMissile$Code))  next

    call assgnt (unt$pointer,unt$type$i)
    }

return
end


subroutine assgnt (unt$pointer,unt$type$i)      # assign target to one unit

########################################################
#$%
#$% Purpose:   ASSGNT assigns targets to NON-cruisemissile units.
#$%                 (i.e., unt$type$i is NOT $CruiseMissile$Code)
#$% Called By: ENGAGE
#$%
#$% Calls:     WHOATK   CKROE   PROC_CAP   Find_Active_RMT
#$%
#$% Tables:    UNT   LCL   RMT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol L. Kropp    3/92
#$%            Added call to proc_cap and the related
#$%            if statements.
#$%            Susan Miller      5/93
#$%            Added trace$engage$exe lines 
#$%
#$%            Susan Miller 4/99 (E1969)
#$%            Added resetting of new flag, UNT$TakeUsingSAM$I
########################################################
BBcommon

LITERAL    UNT2$Name$C, CSTRIP8                # jb E2145  6/27/00
REAL    X,RANDOM,RANGE,FCNT, LCL$Range$F       # jb E2145  6/27/00
integer i_bestTMA # For lcl$Pointer for the best-quality TMA so- 4/8/86
integer i_bestQUAL      # For best TMA QUALity so far..          4/9/86
integer engage_air
Integer INEAR,ISTAT,IWHO,                      # jb E2145  1/8/01
    UNT$Pointer,UNT$Type$I,UNT$Assignedcap$I,  # jb E2145  6/27/00
    UNT$Rulesofengage$I,UNT$Assignedtarget$I,  # jb E2145  6/27/00
    LCL$Pointer,LCL$Nextindx$I,LCL$Detectee$I, # jb E2145  6/27/00
    LCL$Detectiontype$I,LCL$Remaining$I,       # jb E2145  6/27/00
    LCL$Tmaquality$I,LCL$Mytargetflag$I,       # jb E2145  6/27/00
    UNT2$Pointer,UNT2$Type$I,cmc$pointer,the_elevation
data x/0.0/		# Get next random number in sequence

i_bestTMA  = 0  # In case of no acceptable active track  4/8/86
i_bestQUAL = 0          # 0 for POOR; 1 for FAIR; 2 for GOOD     4/9/86

UNT$RulesOfEngage$I = xUNT$RulesOfEngage$I
UNT$AssignedCap$I = xUNT$AssignedCap$I

engage_air = $no    # initialize
# can UNT attack an air target?
if (UNT$RulesOfEngage$I == $AirEnemy$Code |
    UNT$RulesOfEngage$I == $AirNonFriendly$Code)
    engage_air = $yes

#$% get assigned target
unt$AssignedTarget$i = Xunt$AssignedTarget$i

# Reset flag if there is no assigned target SMM 4/99 (E1969)
if (UNT$AssignedTarget$I == $No &
    xUNT$TakeUsingSam$I == $Yes) putUNT$TakeUsingSam$I ($No)

#$% if not assigned target and under attack # jb Applies to CAPstation a/c
if (unt$AssignedTarget$i == $no &           #       as of 5/17/01
    Xunt$UnderAttack$i   == $yes )
    {
    #$% find attacker
    call whoatk (unt$pointer,iwho)

    #$% set assigned target to WHO and save
    unt$AssignedTarget$i = iwho
    PUTunt$AssignedTarget$i
    if (trace$engage$exe != $no)
       {
        call echov ("In ASSGNT assigning an attacking track (UNT # ")
        call echoi (iwho)
        call echov (" ) as target for ")        
        call echohn (Xunt$name$c,$$MaxLit)
        call echov (".")
       }
    }      

##=============================================================
#$%  jb This IF replaces all other CAPstation logic in ASSGNT  1/17/01
if (UNT$AssignedCap$I == $yes)  # jb If CAPstation interceptor  1/8/01
    {
    if(engage_air == $yes & UNT$AssignedTarget$I == 0) # jb Needs a target?
        {
         call Get_CAP_target(UNT$Pointer)   # send CAP UNT pointer
        }
    RETURN 
    }
##=========================================================

#$% if trace display requested by user (usually for debug)
if (trace$engage$tgx != $no)
    {
    #$% display message
    call echor
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" Checking: ")
    }

#$% initialize flags
inear  = 0
range = 9999999.9

#$% for each entry
for (lcl$NextIndx$i = Xunt$FirstLCLIndx$i; lcl$NextIndx$i != 0; )
    {
    #$% set LCL pointer and get next index
    lcl$pointer$to lcl$NextIndx$i
    lcl$NextIndx$i = Xlcl$NextIndx$i

    if( lcl$NextIndx$i == 0 ) # No active track was selected,    4/8/86
     {                          # but a TMA solution may have    4/8/86
      if(i_bestTMA != 0)        #  been saved while in this loop 4/8/86
       {
        inear = i_bestTMA       #  value of lcl$pointer          4/8/86
        BREAK                   #                                4/8/86
       }
     }

    #$% if last detection time is less than game minute, get next
    if (xlcl$LastDetTime$f < game$time) next
    
    #$% get detection type
    lcl$DetectionType$i = Xlcl$DetectionType$i

    #$% if not right sort of detection, get next entry

    unt2$Pointer$TO  Xlcl$detectee$i                    #       7/27/83
    unt2$Type$i      = Xunt2$Type$i                     #       7/27/83

    if (Xunt2$Status$i == $BeingDeleted$code) next

    # Check for restriction if ballistic missile   joa 6/02
    if (unt2$Type$i == $CruiseMissile$Code)
        {
        cmc$pointer = Xunt2$CMCpntr$i
        if (Xcmc$Cat$i == $Ball$Code) 
            {
            if (AutoEngageTBM$Flag == $OFF) next
            }
        }

    #$% get range
    lcl$Range$F = Xlcl$Range$F

    # Check for restriction of aircraft over land and outside auto engage rng joa 6/02
    if (Xunt2$Type$i == $Air$code)
        {
        if (lcl$Range$f > AutoEngageAircraft$Rng)
            {
            if(the_elevation(Xunt2$TrueLatitude$f*$rad2deg,Xunt2$TrueLongitude$f*$rad2deg) > 0) 
                next
            }
        }

    if((unt2$Type$i==$Air$Code | unt2$Type$i==$CruiseMissile$Code) & 
        UNT$Type$i == $Air$Code )               # Air-to-Air?   7/27/83
        {
        if(lcl$DetectionType$i != $ActiveNonVisual$code &
           lcl$DetectionType$i != $ActiveVisual$code) # 7/27/83
                                                NEXT    #       7/27/83
        LCL$Remaining$I = xLCL$Remaining$I

        if (xLCL$TallyHo$I   != 0 & 
            LCL$Remaining$I == 0 ) next         # grand slam flagged
        }

    else if( lcl$DetectionType$i == $PassiveSonar$code & #8     7/27/83
            Xlcl$TMAflag$i != $YES )            NEXT #  7/27/83
    else if (lcl$DetectionType$i != $ActiveNonVisual$code &
           lcl$DetectionType$i != $ActiveVisual$code) # jb        12/26/89
                                                NEXT

    lcl$Detectee$i = Xlcl$Detectee$i

    if (unt$AssignedTarget$i != $no          &
        unt$AssignedTarget$i == lcl$Detectee$i)
        {
##--------------------------------------------------------------------
## Priorities: non-TMA; TMAquality$i =$TMA$GOOD/FAIR/POOR$Code  4/8/86
         if( lcl$DetectionType$i == $PassiveSonar$code )
          {
           lcl$TMAquality$i = Xlcl$TMAquality$i         #       4/8/86
           if(lcl$TMAquality$i > i_bestQUAL)            #       4/8/86
            {                        # Save the lcl pointer for 
             i_bestTMA =  lcl$Pointer # the best-quality TMA,
             i_bestQUAL = lcl$TMAquality$i      #               4/9/86
             NEXT               # --but keep looking for an 
            }                   #    acceptable active track    4/8/86
          }
##--------------------------------------------------------------------
        inear = lcl$pointer
        break
        }

    #$% if trace display requested by user & there is no assigned tgt
    if (trace$engage$tgx != $no & unt$AssignedTarget$i == $no)
        {
        #$% get and display detectee
        unt2$pointer$to lcl$Detectee$i
        unt2$name$c = xunt2$name$c
        if (unt2$name$c != 0) call echohn (unt2$name$c,$$MaxLit)
        else                  call echoi (lcl$Detectee$i)
        call echo ($space)
        }

    call ckroe (unt$pointer,                # check DET model ROE select
                lcl$pointer,
                istat)

    if (istat != $YES) next     # jb != $YES, vice == $NO       3/17/87


    if (UNT$Type$i  == $Air$Code &              # lump all (non-air)
        unt2$Type$i != $Air$Code &              # tgts within 10 nmi
        unt2$Type$i != $CruiseMissile$Code)     # into "same range"
        {                                       # so all flights won't
        lcl$range$f = int(lcl$range$f/10+.5)*10 # attack same target.
        }

    #$% if range exceeded, get next
    if (lcl$Range$F > range) next


    #$% if range is same
    if (lcl$Range$F == range)
        {
        fcnt = fcnt + 1.0

        if (random(x) > 1.0/fcnt) next
        }
    else
        {
        fcnt = 1.0
        }

    #$% save range, and lcl pointer
    range = lcl$Range$F 
    inear = lcl$pointer
    } # end of loop through LCL chain for UNT

#$% if near is valid
if (inear != 0)
    {
    #$% set pointer
    lcl$pointer = inear

     #$% set my target flag to YES and store
    lcl$MyTargetFlag$i = $yes
    PUTlcl$MyTargetFlag$i

    #$% if assigned target is zero, set assigned target to detectee
    if (unt$AssignedTarget$i == 0) unt$AssignedTarget$i = Xlcl$Detectee$i
    PUTunt$AssignedTarget$i
    if (trace$engage$exe != $no)
       {
        call echor
        call echov ("In ASSGNT assigning a LCL track (UNT # ")
        call echoi (unt$AssignedTarget$i)
        call echov (" ) as target for ")        
        call echohn (Xunt$name$c,$$MaxLit)
        call echov (".")
       }
    } # end if inear !=0; holds a valid lcl$pointer

#$% if trace display requested by user & tgt assigned
if (xUNT$AssignedTarget$i != $no & trace$engage$tgt != $no)
    {
    #$% display message 
    call echov (" [")
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" targeting ")
    unt2$pointer$to unt$AssignedTarget$i
    unt2$name$c = xunt2$name$c
    if (unt2$name$c != 0) call echohn (unt2$name$c,$$MaxLit)
    else                  call echoi  (unt$AssignedTarget$i)
    call echov ("] ")
    }

if ((trace$engage$exe != $no) & (UNT$AssignedCap$I == $yes))
    {
     call echor
     call echohn (Xunt$name$c,$$MaxLit)
     call echov (" has been assigned ")
     if (xunt$AssignedTarget$i == $no) call echov ("no target in ASSGNT.  ")
     else 
        {
         call echov ("the following target in ASSGNT:  ")
         unt2$pointer$to xunt$AssignedTarget$i
         unt2$name$c = xunt2$name$c
         if (unt2$name$c != 0) call echohn (unt2$name$c,$$MaxLit)
         else                  call echoi  (xunt$AssignedTarget$i)
         call echov (".")
        }
     call echor
    }

return
end


define ($$$Enemy,1)
define ($$$Unknown,2)
define ($$$Air,1)
define ($$$Sub,2)
define ($$$Surf,3)
define ($$$AllEnemy,1)
define ($$$AirEnemy,2)
define ($$$SurfaceEnemy,3)
define ($$$SubEnemy,4)
define ($$$AllNonFriendly,5)
define ($$$AirNonFriendly,6)
define ($$$SurfaceNonFriendly,7)
define ($$$SubNonFriendly,8)



subroutine ckroe (unt$pointer,                  #check for target satisfying
                  lcl$pointer,                  #the rules of engagement
                  itake)

########################################################
#$%
#$% Purpose:   CKROE checks to see if the target
#$%            satisfies the rules of engagement.
#$%
#$% Called By: ASSGNT   Get_SKUNKS      Get_RAD
#$%            Get_CAP_target calls CKROE_RMT
#$%
#$% Calls:     None
#$%
#$% Tables:    LCL  RMT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Susan Miller 6/17/92 added entry point
#$%            to check ROE for RMT tracks
#$%
#$%            Alex Vagus 7/94 (E1258)
#$%            Added check to see if unit has guns
#$%            in addition to the has SAMs check.
#$%
########################################################
BBcommon                                        #utilize blackboard

LITERAL  UNT2$Name$C, CSTRIP8              # hb E2145  6/27/00
integer test [8,3,2]
integer entry_point_called,     
        track_class, target_id,
        detectee
Integer ID,ICLASS,ITAKE,IROE,KROE,         # hb E2145  6/27/00
    UNT$Pointer, UNT$Type$I,               # hb E2145  6/27/00
    LCL$Pointer,RMT$Pointer,UNT2$Pointer   # hb E2145  6/27/00
logical has_guns           # av 7/94 (E1258) - logical function

entry_point_called = $no

repeat                                                  # E2143 dew 10/99
    {    
     break                                              # E2143 dew 10/99
     entry CKROE_RMT(UNT$Pointer,RMT$Pointer,Itake) # added 6/17/92 SMM
     entry_point_called = $yes
    }

data test/ 48 * 0 /
test[$$$AirEnemy,           $$$Air , $$$Enemy  ] = $yes
test[$$$AirNonFriendly,     $$$Air , $$$Enemy  ] = $yes
test[$$$AirNonFriendly,     $$$Air , $$$Unknown] = $yes
test[$$$AllEnemy,           $$$Air , $$$Enemy  ] = $yes
test[$$$AllEnemy,           $$$Sub , $$$Enemy  ] = $yes
test[$$$AllEnemy,           $$$Surf, $$$Enemy  ] = $yes
test[$$$AllNonFriendly,     $$$Air , $$$Enemy  ] = $yes
test[$$$AllNonFriendly,     $$$Air , $$$Unknown] = $yes
test[$$$AllNonFriendly,     $$$Sub , $$$Enemy  ] = $yes
test[$$$AllNonFriendly,     $$$Sub , $$$Unknown] = $yes
test[$$$AllNonFriendly,     $$$Surf, $$$Enemy  ] = $yes
test[$$$AllNonFriendly,     $$$Surf, $$$Unknown] = $yes
test[$$$SubEnemy,           $$$Sub , $$$Enemy  ] = $yes
test[$$$SubNonFriendly,     $$$Sub , $$$Enemy  ] = $yes
test[$$$SubNonFriendly,     $$$Sub , $$$Unknown] = $yes
test[$$$SurfaceEnemy,       $$$Surf, $$$Enemy  ] = $yes
test[$$$SurfaceNonFriendly, $$$Surf, $$$Enemy  ] = $yes
test[$$$SurfaceNonFriendly, $$$Surf, $$$Unknown] = $yes

kroe = Xunt$RulesOfEngage$i
if (entry_point_called == $no)  
    { 
     track_class = Xlcl$Class$i
     target_id = Xlcl$targetid$i
    }
else
    {
     track_class = XRMT$Class$I
     target_id = XRMT$TargetID$I
    }

itake = $NO     # jb  (moved up: init'lz returned flag) 3/17/87

#$% determine class of target:
iclass = $NO    # jb  (moved up/made initialization)    3/17/87

if      (track_class == $Surface$code)  iclass = $$$Surf
else if (track_class == $Sub$code    )  iclass = $$$Sub
else if (track_class == $Air$code    )          # jb    3/17/87
 {
  unt$Type$i = Xunt$Type$i                      # jb    3/17/87
  IF(unt$Type$i ==$CruiseMissile$Code | unt$Type$i ==$Air$Code |
        Xunt$SamCapable$i != $NO | has_guns(unt$pointer) )  # av 7/94(E1258)
                                { iclass = $$$Air } # jb 3/17/87
  ELSE  # else if non-air unit has NO SAM's, set flag NO-CAN-DO 
                                { itake  = -1     } # jb 3/17/87
 }

#$% determine target ID
if      (target_id == $Enemy$code  ) id = $$$Enemy
else if (target_id == $Unknown$code) id = $$$Unknown
else                                      id = 0

#$% determine ROE targets
if      (kroe == $AirEnemy$Code          ) iroe = $$$AirEnemy
else if (kroe == $AirNonFriendly$Code    ) iroe = $$$AirNonFriendly
else if (kroe == $AllEnemy$Code          ) iroe = $$$AllEnemy
else if (kroe == $AllNonFriendly$Code    ) iroe = $$$AllNonFriendly
else if (kroe == $SubEnemy$Code          ) iroe = $$$SubEnemy
else if (kroe == $SubNonFriendly$Code    ) iroe = $$$SubNonFriendly
else if (kroe == $SurfaceEnemy$Code      ) iroe = $$$SurfaceEnemy
else if (kroe == $SurfaceNonFriendly$Code) iroe = $$$SurfaceNonFriendly
else                                       iroe = 0

#$% if class, ID, ROE are valid, set test
if (iclass != 0  &  id != 0  &  iroe != 0) itake = test[iroe,iclass,id]

if (entry_point_called == $no) Detectee = Xlcl$Detectee$i # jb moved up,
else                           Detectee = xRMT$Detectee$i #   for next IF, on
unt2$pointer$to Detectee                                  #    4/26/01

if (itake != $yes & itake != -1)  # jb Need to  tgt a perhaps-'friendly' crsmsl that has targeted me?
   {                              #    (unless no weapon available)   # jb  UFL99 (#6)    4/26/01
    if (Xunt2$Type$I == $Cruisemissile$Code & Xunt2$AssignedTarget$i == unt$Pointer$index)
        itake = $YES  # jb UFL99 (#6): Allow unit to fire at its attacker (a CRSMSL)     4/26/01
   } 

if (itake == $yes)
   {
    #$% if trace display requested by user (usually for debug)
    if (trace$engage$roe != $no)
       {
        #$% display message
        call echov (" [")
        call echohn (Xunt$name$c,$$MaxLit)
        call echov (" ROE select ")
        unt2$name$c = xunt2$name$c
        if (unt2$name$c != 0) call echohn (unt2$name$c,$$MaxLit)
        else                  call echoi  (Detectee)
        call echov ("] ")
       }
   }

return
end


subroutine epross (unt$pointer, 
                   unt$assignedtarget$i)

########################################################
#$%
#$% Purpose:   EPROSS determines if target is aircraft, platform
#$%            or shorebase and calls the appropriate engagement
#$%            processor.
#$%
#$% Called By: ENGAGE
#$%
#$% Calls:     GETLCL     ATOAIR     AIRTOR     ARTILL
#$%            ATOSUR     SURTOR     AIRRAD     GETRB_M
#$%
#$% Tables:    UNT        LCL                                   7/28/83
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol L. Kropp - Sept. 1993
#$%            Added a/c attacking position with ASMs & BOMBs
#$%
#$%            Carol Kropp - 2/97 (E1731)
#$%            Added for dropping mines on positions/targets.  If a 
#$%            unit has been given a DROP MINE command, this is the
#$%            engagement it is curently handling, so that the 
#$%            attacker will not us other types of weapons against the
#$%            target.
#$%
#$%            Susan Miller - 7/97 (E1385)
#$%            UNT$TestIntercept$I is set to $no when
#$%            the assigned target is being deleted.
#$%
########################################################

bbcommon
ENcommon

LITERAL    CSTRIP8                                  # jb E2145  6/27/00
REAL    RANGE, BRG                                  # jb E2145  6/27/00
Integer ICALLSUR,ISTMA,KPH,                         # jb E2145  6/27/00
    UNT$Pointer,UNT$Assignedtarget$I,               # jb E2145  6/27/00
    UNT$Attackindx$I,UNT$Type$I,                    # jb E2145  6/27/00
    UNT2$Pointer,UNT2$Type$I,UNT2$Truealtdepth$I,   # jb E2145  6/27/00
    SHC2$Pointer,SHC2$Scopedepth$I,SHC2$Keeldepth$I, # jb E2145  6/27/00
    LCL$Pointer, ORD$Pointer, UNT3$Pointer           # jb E2145  6/27/00
LOGICAL has_guns        #jb  UNT has guns? 7/3/89
logical sub_surfaced

kph = 1                 # initlz  prob-hit flag to NOT RESTRICTED

if (xUNT$DroppingMineFlag$I == $yes)    # clk 2/97 (E1731)
  {
   call Process_Mine_Weapons (UNT$Pointer)
   return
  }   # end of if processing a DROP MINE command
else if (xUNT$Type$I == $Air$Code &            # if an a/c atacking posit
         UNT$AssignedTarget$I == UNT$Engaging$Position)        # clk 9/93
  {
   call Air_Engage_Posit (UNT$Pointer)
   return
  }

#$% if assigned target
if (unt$AssignedTarget$i != $no)
    {
    unt2$pointer$to unt$AssignedTarget$i        #get target pointer
    unt2$Type$i = Xunt2$Type$i                  #get target type
    }
else
    {
    #$% set target pointer and type to null
    unt2$pointer = $null$code
    unt2$type$i  = $null$code
    }

if (unt2$Type$i == $Sub$code)   #if TARGET is SUB,      1/20/87
    {  # get info for use below....
    shc2$Pointer      = xUNT2$SHCpntr$i    # get ship char pointer 
    shc2$SCOPEdepth$i = Xshc2$SCOPEdepth$i        #2      7/3/89
    shc2$KEELdepth$i   = Xshc2$KEELdepth$i        #2      7/3/89
    unt2$truealtdepth$i = Xunt2$truealtdepth$i    #       1/20/87
    }

unt$Type$i = Xunt$Type$i

call getlcl_Act (unt$pointer, unt$AssignedTarget$i, lcl$pointer)

if (unt$Type$i == $Air$code & unt2$type$i != $NULL$code)  # if unit is a/c
    {                                                     # and has target
    if(unt2$type$i == $sub$code)                # if target is submarine
       {
        if (lcl$pointer == 0)                   # if NO LCL pointer, check TMA
            {
            call getlcl_TMA (unt$pointer,
                             unt$AssignedTarget$i,
                             lcl$pointer)

            if (lcl$pointer == 0) return        # if NO LCL pointer, return

            isTMA = lcl$pointer
            }
        else 
            {
            isTMA = NO
            }

        call atosub (unt$pointer,               #  call air-to-sub engage
                     unt2$pointer,              #  pass target pointer
                     isTMA)
       }
    else if(unt2$Type$i == $Air$code         |       #if target is a/c
            unt2$Type$i == $CruiseMissile$code)      #or cruise missile
       {
        if ((lcl$pointer == 0) &                # if LCL pointer zero and 
            (xUNT$AssignedCap$I == $no)) return # not a CAP a/c, return

        if(Xunt$UseGuns$i == $NO)               # jb                8/10/89
            call atoair (unt$pointer,           #  call air-to-air engage
                         unt2$pointer)          #  pass target pointer
       }

    else if(unt$type$i == $air$code & Xunt$UseGuns$i == $YES &   # jb 7/19/89
            unt2$type$i != $air$code & unt2$type$i != $NULL$code &
            unt2$type$i != $CruiseMissile$code)
       {
        call getrb_M (unt$Pointer,unt2$Pointer,RANGE,Brg)     # jb 7/25/89 \/
        if(RANGE <=0.1 +Xunt$AttackRange$F | Xunt$status$i ==$ONGUIDE$CODE)
           {
            for(ord$pointer$first; ord$pointer$ok; ord$pointer$next) # 7/20/89
              {
               if(Xord$W01$C ==$Lex$TAKE$ & Xord$ADDindx$i ==unt$Pointer$index)
                   {
                    if (trace$engage$gun != $no)            # DEW 1/11/90
                        {
                        call echov (" Delete ORD (take w/gun)...")
                        }
                    PUTord$Status$i ($BeingDeleted$Code)
                    BREAK
                   }
              }
            unt$AttackIndx$i = Xunt$AttackIndx$i    # jb    7/25/89
            if(unt$AttackIndx$i != 0)               # jb    7/25/89
               {
                unt3$pointer$TO (unt$AttackIndx$i)  # jb    7/25/89
                PUTunt3$UnderAttack$i ($NO)         # jb    7/25/89
               }           
            putunt$status$i ($proceeding$code)
            putunt$underattack$i ($NO)
            putunt$orderedspeed$f (222.2)
            putUNT$AttackIndx$i (0)
            putUNT$AssignedTarget$i (0)
            putUNT$TestIntercept$I ($NO)       # SMM 7/97 (E1385)
            putUNT$EngageStatus$i ($NOEngagements$Code)
            call deassign_guns(unt$pointer,0,$take$guncode,$fired$guncode)#7/89
            call deassign_guns(unt$pointer,unt$AttackIndx$i,
                               $take$guncode,$take$guncode)      # DEW 1/11/90
            PUTunt$RulesOfEngage$i  ($IfAttacked$code)      # jb        7/18/89
################################################
            PUTunt$coverflag$i  (0) # clear cover flag
################################################
           }    # End if on top of target
       }    # End if USING GUNS...

    else
       {
        if (unt2$Type$i != $ShoreBase$code &    # if target ship, and....
            lcl$pointer == 0) return            # if LCL pointer zero, return

        call atosur (unt$pointer,               #  call air-to-surface engage
                     unt2$pointer)              #  pass target pointer
       }
   }  # End if unt$Type$i == $Air$code

else if(unt$Type$i == $Surface$code       |     # if unit is ship
        unt$Type$i == $Sub$code            )    # or sub
   {
    if (unt2$Type$i == $Air$code |              #if target is a/c
        unt2$Type$i == $CruiseMissile$code)     #or cruise missile
       {
        continue
       }
    else if (unt2$Type$i == $Surface$code       |       #if target surface
             unt2$Type$i == $Sub$code           )       # or submarine
       {
        call getlcl_act (unt$pointer,                   #7/28/83
                         unt$AssignedTarget$i,
                         lcl$pointer)

        if (lcl$pointer == 0)                   # if NO LCL pointer, check TMA
            {
            call getlcl_TMA (unt$pointer,
                             unt$AssignedTarget$i,
                             lcl$pointer)

            if (lcl$pointer == 0) return        # if NO LCL pointer, return

            isTMA = lcl$pointer
            }
        else 
            {
            isTMA = NO
            }

        iCALLsur = $YES         # SOW item 4.1 j4:              1/15/87
        if (unt2$Type$i == $Sub$code)   #if target is SUB,      1/15/87
         {                      # mustn't be below SCOPE depth  1/15/87
          if (unt2$truealtdepth$i > shc2$SCOPEdepth$i) # jb unt2 3/27/89
                iCALLsur = $NO                          #       1/15/87
         }

        If (iCALLsur != $NO)                            #       1/15/87
         {
          call surtor (unt$pointer,       # call surface torpedo engage
                     unt2$pointer,      #pass target pointer
                     isTMA)
         }
       }

    call airrad (unt$pointer)                   #call (ship) air defense

   }    # end if ship/sub

else # if unit is SHOREBASE
   {
    if (unt2$Type$i == $Air$code|               #if target is a/c
        unt2$Type$i == $CruiseMissile$code)     #or cruise missile
       {
        continue
       }

    call airrad (unt$pointer)                   #call shore air defense
   } # end if shorebase


#$% Check all UNT types for call to ARTILL:

if ( has_guns(unt$pointer) )
    {                                # No ARTILL call if unt has NO GUNS..
    if (unt$type$i == $sub$code)
        {
        if ( sub_surfaced(unt$pointer) )
            {
            call artill (unt$pointer)       #call Gun Offense
            }
        }
    else
        {
        call artill (unt$pointer)           #call Gun Offense
        }
    }    # End    if UNT has gun(s)..

### <<RG>>
### THIS NEXT BLOCK OF CODE IS USED TO GATHER DATA FOR THE 
### ENGAGEMENT LOG.  THE BLOCK WILL BE WRITTEN EACH TIME THRU THIS 
### PROCEDURE, THEN THE BLOCK WILL BE ZEROED OUT.  THE BLOCK AND
### EQUIVALENCE STATEMENT OVERLAYS ARE DEFINED IN MACRO 'ENcommon',
### WHICH USES FILE 'hseng.inc'.  THE FILE IS DEFINED AND OPENED
### IN 'WGMDREC.RAT' WITH THE OTHER HISTORY FILES.  (JULY 1985)

if (log$engage != $no)               # IF ENGAGEMENT LOG IS DESIRED
   {
    if (Xeng$platform$c != $BLANKLIT)               # IF SOME DATA WAS COLLECTED
    {
       PUTeng$Time$f( game$time )
       call write_eng_rec
    }
   }
## END (log$engage != $no)

return
end    # End EPROSS


subroutine whoatk (unt$pointer,iwho)

########################################################
#$%
#$% Purpose:   WHOATK determines which unit
#$%            is attacking a platform, and
#$%            assigns the attacker to be
#$%            the assigned target for the
#$%            platform.
#$%
#$% Called By: ASSGNT
#$%
#$% Calls:     None
#$%
#$% Tables:    UNT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
bbcommon

Integer INDX,IWHO,             # jb  E1245 6/27/00
    UNT$Pointer, UNT$Type$I,   # jb  E1245 6/27/00
    UNT2$Pointer,UNT2$Type$I   # jb  E1245 6/27/00

iwho = $no
indx = unt$pointer$index

#$% for each unit
for(unt2$pointer$first;still_ok(unt2);unt2$pointer$next)  # 9/26/88
   {
    if (Xunt2$AssignedTarget$i != indx |        # This is NOT the attacker..
         unt2$pointer == unt$pointer)   NEXT    #$%  Unit can't attack itself!..

    unt$Type$i = Xunt$Type$i
    unt2$Type$i = Xunt2$Type$i                  # jb               1/27/87
    if  (unt2$Type$i == $ShoreBase$code & #xX if attacker shorebase 1/27/87 
        (unt$Type$i == $Sub$code   |            # and (target is sub or
         unt$Type$i == $Surface$code)   )       # surface ship)
       {
        BREAK           # Break, not Next, since attacker was found..
       }                #  but attackee not eligible to respond..

    else if( (unt2$Type$i == $AIR$code |        #if attacker is air- 1/27/87
        unt2$Type$i ==$CruiseMissile$code)  &   # borne and unit un- 1/27/87
        ( unt$type$I != $AIR$code &             # der attack needs   1/27/87
          Xunt$SAMcapable$i == $NO )    )   # but lacks SAM Launcher 1/27/87
       {  # n.b.: WHOATK called by ASSGNT, where UNT$type$i NOT CruzMissl..
        BREAK   # jb Break, not Next, since attacker was found..     1/27/87
       }                #  but attackee not eligible to respond..    1/27/87

    else
       {
        #$% save attacker (to be made the attackee's assigned target)
        iwho = unt2$pointer$index
       }

    BREAK
   }

return
end


define (CAPCommon,
    integer UNT$CAPRange$I, UNT$CAPAltitude$I
    real    UNT$CAPLatitude$F, UNT$CAPLongitude$F, COS_CAP_Lat
    common  /CAP_com/ UNT$CAPRange$I,UNT$CAPAltitude$I,UNT$CAPLatitude$F,
                      UNT$CAPLongitude$F,COS_CAP_Lat
    )

include "wgmdeng_air.rin"               # includes the subroutines:
                                        # Proc_CAP, Proc_React, Air_React
                                        # None_Found, All_Gone, Disengage_Air
                                        # Avg_CAP, Intercept, 
                                        # Launch_and_Kill, In_Firing_Range
                                        # Who_to_kill

subroutine atoair (unt$pointer,         # receive a/c unit pointer
                   unt2$pointer)        # receive target unit pointer

########################################################
#$%
#$% Purpose:   ATOAIR processes air-to-air engage-
#$%            ments, determines current game
#$%            minute, and computes damage effects.
#$%
#$% Called By: EPROSS
#$%
#$% Calls:     GETBOG     DEQGET     SEND
#$%            BINGO      GETRB_M    None_found
#$%            Proc_CAP   Test_for_intercept
#$%            Proc_react Launch_and_Kill 
#$%            Engdata    MBURange   
#$%            Write_eng_rec         Update_Destroyed_Aircraft
#$%            Generate_eng_rec      Send_Deton
#$%            All_gone   Assgnt     Disengage_air
#$%            Avg_CAP    In_Firing_Range   
#$%            Who_To_Kill
#$%
#$% Tables:    UNT        DEQ
#$%            MC         AML
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Susan Miller - March 1992
#$%            Included air-to-air enhancements.
#$%            
#$%            Jonathan Richardson - 9/93 (E1104)
#$%            Added new BDA variable, Added parameter (BDA_Nbr_fired)
#$%            to Process_AAM_Hit and Process_AAM_Grand_Slam.
#$%
#$%            Carol Kropp - 11/96 (E1695)
#$%            Added provision for engaging CEC track
#$%            if the unit has no LCL detection of target.
#$%
#$%            Susan Miller - 7/97 (E1410)
#$%            Added setting and use of variable unsuccessful
#$%            and initialization of nhit to $no, to account
#$%            for the times when the a/c does not engage
#$%            (level engagement air >= 1).  Subroutine
#$%            launch_and_kill determines if the a/c will
#$%            engage at levels >= 1.
#$%
#$%            Susan Miller - 12/97 (E1914)
#$%            Fixed call to Test_for_intercept which was
#$%            using ACC$Pointer of target rather than
#$%            of attacker.
#$% 
########################################################
bbcommon
NUcommon                                        #       5/8/85
ENcommon
Eng$ProbHits
Eng$ProbIndx
CAPCommon


LITERAL UNT$Name$C,UNT2$Name$C,CSTRIP8       # jb E2145  6/28/00

Real*4  mc$probkill$f,  # missile kill probability
        rannum,      # random number 
        mburange,
        spj_factor   # Jecewsi self protective jamming factor - JFR 8/17/94
integer idummy       # dummy variable, data not currently used
REAL    X, RANDOM, DEQ$Timelastused$F        # jb E2145  6/28/00
Real*4  missile_pk   # temporary storage for missile kill probability - JFR 2/20/94
integer altdiff,     # alt diff btwn a/c and target
        absalt,      # absolute value of alt diff
        eqlist[5,30],# equipment list
        ac_tgt,      # set to yes if target is air$code, no, cruise missile
        cont_intercept, # flag for successful intercept
        tgt_reacted, # flag for target flight reaction to attack
        irng,        # integer range
        jj,          # message length
        i, n,        # loop counter
        max_missile_range,
        nfound,      # number of weapon items found in DEQGET
        naam,        # set to $no if no missile in range, or missile index
        ntarg,       # number in target group
        ntargt,      # number in target group, set to 1 if cruise missile
        past_cap,    # flag if the attacking a/c is past it's cap range
        target_maxalt, # max alt of target
        NInInterval, # Function converting rate/min to rate/interval
        maxfire,     # Missiles to be fired constrained by inventory/targets
        npm,         # Missile fire rate per minute
        totals[2]    # totals[1] hits per game cycle, 
                     # totals[2] missiles fired per game cycle
integer BDA_Nbr_Fired #nbr of aam's fired during engagement -- JFR  (E1104)
Integer IDISENGAGE,LEADER_INDEX,NKILL,NRATE,      # jb E2145  6/28/00
    UNT$Pointer,UNT2$Hits$I,UNT$View$I,           # jb E2145  6/28/00
    UNT$Mission$I, UNT$Testintercept$I,           # jb E2145  6/28/00
    LCL$Pointer,LCL$Tallyho$I,LCL$Remaining$I,    # jb E2145  6/28/00
    AML2$Pointer, AML2$Nextindx$I,                # jb E2145  6/28/00
    CMC$Pointer,DEQ$Pointer,MC$Pointer,           # jb E2145  6/28/00
    AML$Pointer, UNT2$Pointer                     # jb E2145  6/28/00
integer ACC$Pointer, ACC2$Pointer  # smm 12/97 (E1914)
integer unsuccessful # $yes if aam launch did not occur - smm 7/97 (E1410)
integer nhit         # $yes/$no flag for if a hit did occur - smm 7/97 (E1410)
BBDeclare (unt3$pointer)
real    standoff_range, range, bearing
integer max_range, shortest_range

character   msg[ARB]
data x/0.0/		# Get next random number in sequence


###unt2/deq2/AML2 refer to target; UNT and DEQ refer to attacking a/c..

unsuccessful = $no
nhit = $no

# Check for restriction if ballistic missile   joa 6/02
if (Xunt2$Type$i == $CruiseMissile$Code)
    {
    cmc$pointer = Xunt2$CMCpntr$i
    if (Xcmc$Cat$i == $Ball$Code) 
        {
        if (AutoEngageTBM$Flag == $OFF) return
        }
    }

unt$Name$c = xunt$Name$c    # attacker name
unt$View$i = xunt$View$i    # attacker view

# extract the values and put in common variables
UNT$CapLatitude$f  = xUNT$CapLatitude$f
UNT$CapLongitude$f = xUNT$CapLongitude$f
COS_CAP_Lat= COS(UNT$CAPLatitude$f)
UNT$CAPRange$I = xUNT$CAPRange$I
UNT$CAPAltitude$I = xUNT$CAPAltitude$I

unt2$name$c = Xunt2$name$c  # target name
#$% if trace display requested by user (usually for debug)
if (trace$engage$exe != $no)
   {
    call echor
    call echoV  ('!')                       # jb E2144  (echoV) 8/2/00
    call echov (" Air to Air.....")
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" Attacking ")
    call echohn (unt2$name$c,$$MaxLit)                         #       9/19/85
   }

if (xUNT2$Status$I == $BeingDeleted$Code)   # if the target is dead - forget it,
  {                                         # don't waste bullets!!!     # 11/17/92
   if (trace$engage$exe != $no)
     {
      call echov  (" -- The targets status =  ")
      call echov  ("$BeingDeleted$Code -- returning out!!!")
      call echor
     }
   return
  }

call GETBOG(_                                   #get detection pairing
            unt$pointer,                        #pass detector
            unt2$pointer,                       #pass detectee
            LCL$POINTER)                        #receive detection pntr

# A/C has to have an assigned target to get to this routine and
# if it's a CAP a/c, it may have a RMT detection as an assigned 
# target (as set in Get_CAP_target)  SMM 6/92
if ((lcl$pointer == 0) &                # no LCL detections and
    (xUNT$AssignedCap$I == $no))        # not a CAP a/c, return  SMM 6/92
  {
   if (xUNT$CECTrackAssigned$I == $no)  # the target could be a CEC track
     return                             # from the CEC Model - clk 11/96 (E1695)
  }   # end of if there is no LCL detection

if(XUNT2$TYPE$I == $AIR$CODE)                   #if target is A/C flight
   {
    NTARGT = Xunt2$NbrAc$i      # get nmbr in tgt flight (jb unt2 3/28/89
    ac_tgt = $yes

    AML2$NextIndx$i = xUNT2$AmlIndx$i           # jb unt2        3/28/89

    # changed ACC$pointer to ACC2$pointer to distinguish attacker (ACC$Pointer)
    # from target (ACC2$Pointer)             # smm 12/97 (E1914)
    ACC2$Pointer = xUNT2$ACCPntr$I               # jb unt2        3/28/89 
    target_maxalt = xACC2$MaxAlt$I               # SMM 3/27/92  
    T_indx = xACC2$TargetIndex$I
   }                                            #end if tgt is A/C flt
else
   {
    NTARGT = 1                                  #otherwise, one missile
    ac_tgt = $no                                #cruise missile target

    CMC$pointer = Xunt2$CmcPntr$i               # CMC POINTER
    T_indx = Xcmc$TargetIndex$i
   }

ntarg = NTARGT

# Since the attacking a/c may not have a LCL pointer (may be a
# RMT pointer), check for a valid LCL before putting info
if (lcl$pointer > 0)
    {
     PUTlcl$Remaining$i (ntarg)
     lcl$TallyHo$i = Xlcl$TallyHo$i
     if (lcl$TallyHo$i == 0) putlcl$TallyHo$i (Ntarg)
    }

nfound = 0                          # init item count
call DEQGET(unt$pointer,                # jb receive UNT pointer    3/22/88
            $AAM$CODE,                  # receive equipment ident code
            nfound,                     # receive/return nbr items fnd
            eqlist)                     # receive/return list of EQ

if(nfound == 0)                     # if no AAM'S found
   {
    call none_found(UNT$Pointer,    # send attacker's UNT pointer
                    LCL$Pointer,    # send attacker's LCL pointer
                    ntargt)         # send number in target flight
    return
   }


# See if the target is within firing range.
irng = 0
call In_Firing_Range (unt$pointer,     # send attacker UNT pointer
                      unt2$pointer,    # send target UNT pointer
                      nFound,          # send number of AAMs
                      naam,            # receive index of AAM
                      EqList,          # send/receive equipment list
                      irng,            # send integer range of AAM
                      altdiff,         # receive altitude differential
                      absalt,          # receive absolute value of altitude
                      ac_tgt)          # send flag, yes for a/c, 
                                       # no for cruise missile

if(NAAM == $NO)                        # if no missile in range
   {
    if (trace$engage$exe != $no)
       {
        call echov (" ..not in range @")
        call echoi  (iRng)
        # Adding the altitude differential.
        if (level$air$engagement == 1)  # cruise missile or a/c as target
            {
             call echov (" (&")
             if (altdiff < 0) call echov ("-")  # target below
             else             call echov (" ")  # target equal or above
             call echoi  (absalt)
             call echov  (") ")
            }
       } # end if trace engagement on

    # If standoff range not already set, 
    #   set in priority order of characteristics and shortest loaded weapon
    # joa 2/05 per_sor
    if (Xunt$AttackRange$f == 0.0)
    {
        acc$pointer = Xunt$ACCPntr$i
        standoff_range = Xacc$StandoffRange$f

        max_range = 0
        for (i=1; i <= nfound; i = i + 1)
        {
            if (eqList[4,i] > max_range) max_range = eqList[4,i]
        }

        shortest_range = 1024
        for (i=1; i <= nfound; i = i + 1)
        {
            if (eqList[4,i] < shortest_range) shortest_range = eqList[4,i]
        }

        if (standoff_range == 0.0)
        {
            standoff_range = shortest_range
        }

        # Send warning message if standoff_range greater than max range weapon
        if (standoff_range > max_range)     # joa 2/04 per_sor
        {
            jj = 0
            call smovv ("WARNING: ",msg,jj)
            call smovh (UNT$Name$c,$$MaxLit,msg,jj)
            call smovv (" standoff range of ",msg,jj)
            call smovf (standoff_range, 501, msg, jj)
            call smovv (" nmi exceeds max weapon range of ",msg,jj)
            call smovi (max_range, msg, jj)
            call smovv (" nmi.",msg, jj)
            call send_(UNT$View$i,0,jj,msg)
        }

        standoff_range = standoff_range  - 0.01     # Handle imprecision
        putunt$ATTACKRANGE$F (standoff_range)       # joa 2/05 per_sor

        call rll2rb(xunt$truelatitude$f,xunt$truelongitude$f,
                       xunt$costruelat$f,
                       xunt2$truelatitude$f,xunt2$truelongitude$f,
                       xunt2$costruelat$f,
                       range,bearing)
        bearing = bearing + $PI
        $ang2pi(bearing)
        putunt$attackbearing$F (bearing)

        # Assign return base as guide, and calculate range and bearing
        #   to return to current position
        if (Xunt$GuideIndx$i == 0)
        {
            if (Xunt$LaunchIndx$i != 0)
            {
                unt3$pointer$to Xunt$LaunchIndx$i
                call GETRB_M (UNT3$Pointer, UNT$Pointer,
                                 range, bearing)
                PUTunt$GuideIndx$i (unt3$pointer$index)
                PUTunt$GuideRange$f (range)
                PUTunt$GuideBearing$f (bearing)
                PUTunt$GuideTrue$i ($YES)                            
            }
        }
    }

    if(Level$Air$Engagement == 1) 
        {
         # If the flight is on a defensive mission, test for intercept.
         unt$Mission$i = xunt$Mission$i
         if (unt$Mission$i == $Sweep$code       | 
             unt$mission$i == $strikecap$code   |
             unt$Mission$i == $CAP$code         | 
             unt$Mission$i == $AirDefense$code  | 
             unt$Mission$i == $Escort$code)
            {
             ACC$Pointer = xUNT$AccPntr$I          # get attackers ACC$Pointer (E1384)
             call Test_for_Intercept(UNT$pointer,  # send attacker's UNT pointer
                                     UNT2$pointer, # send target's UNt pointer
                                     ACC$pointer,  # send attacker's ACC pointer
                                     LCL$pointer,  # send attacker's LCL pointer
                                     EqList,       # send attacker's equipment list
                                     nFound,       # send number of equip. items
                                     iRng,         # send range to target
                                     ntargt,       # send # in target flight
                                     cont_intercept,# receive intercept flag
                                     max_missile_range) # receive 
            }                                   
         else  cont_intercept = $yes

         # If cont_intercept equals yes, the intercept will take place.
         if (cont_intercept == $yes)
            {
             putunt$Status$i        ($Proceeding$code) # set status to proceed
             putunt$AttackIndx$i    (unt2$pointer$index) # set tgt attack guide
            }

         return
        } # end if level$air$engagement = 1

    if (Level$Air$Engagement != 1)
        {
         PUTunt$status$i        ($Proceeding$code)
         PUTunt$attackindx$i    (unt2$pointer$index) #make target attack guide
        }
    return  # out of program, no missiles in range for this engagement
   } # end if no missile in range

# Air-to-air enhancements 3/25/92 SMM
# if level of air engagement set to 1 and target is an aircraft and 
# not a cruise missile, process reaction to attack
if ((Level$Air$Engagement == 1) & (ac_tgt != $no) & # a/c as target
    (xUNT2$GhostedUnit$I != $YES))   # don't process ghost target's reaction
    {
     # Set TestIntercept flag back to zero if set otherwise.
     if (xunt$TestIntercept$i != $no)
        {
         unt$TestIntercept$i = $no
         putunt$TestIntercept$i
        }

     call PROC_REACT(UNT$Pointer,       # send attacker's UNT pointer
                     UNT2$Pointer,      # send target's UNT pointer
                     LCL$Pointer,       # send LCL pointer to target
                     tgt_reacted)       # receive reacted flag, yes or no

     # if the target reacted to attack by splitting, there are more
     # targets to process so return and process engagement next game cycle
     if (tgt_reacted == $yes) return          # 3/25/92 SMM
    }

PUTunt$engagestatus$i ($engaging$code)
PUTunt2$underattack$i ($yes)

DEQ$Pointer$To  (eqlist [1, NAAM])
mc$pointer = eqlist[2,NAAM]                     #get proper missile pointer
nkill = 0                                       #number killed to zero
maxfire = min(ntargt, eqlist[3,NAAM])

deq$TimeLastUsed$f = Xdeq$TimeLastUsed$f
npm = XMC$FIRERATE$i   # can fire this many (jb unt 3/28/89)
nrate = NInInterval(_                   # Convert rate/min to rate/interval
                       deq$TimeLastUsed$f, # in/out
                       npm,
                       maxfire)
nrate = nrate * Xunt$NBRAC$I # got fire rate for VTS for each a/c so mult 
                             # by nbr in collective flight - JFR 4/18/94
nrate = min0(nrate,ntargt) # only fire as many as there are targets - JFR 4/18/94

if (nrate == 0)                             # Can't fire in this interval
    return        
PUTdeq$TimeLastUsed$f

#$% clk 2/17/93 - New ALSP Air-to-Air ICD
#$% When attacking a ghosted flight, the owning actor of that flight
#$% determines the number of hits and kills.
If ((ALSP$Active == $YES) & (xUNT2$GhostedUnit$I == $YES))
    {
     DEQ$Pointer$To  (eqlist [1, NAAM])
     call ALSP_Send_AAM_Engage (UNT$Pointer,       # send attacker UNT pointer
                                DEQ$Pointer,       # send the attackers equipment pointer
                                eqlist [3, NAAM],  # send the number of AAMs available
                                MC$Pointer,        # send AAM characteristic pointer
                                UNT2$Pointer,      # send target UNT pointer
                                nrate,             # send the number of AAMs to be fired
                                ntargt,            # send the number of a/c being targeted
                                irng)              # send the range for engagement log
    }
else    # target is not a ghosted unit, so process interaction
    {
     call Get_AAM_Probability_of_Kill (UNT$Pointer, MC$Pointer,
                                       altdiff, irng, t_indx, MC$ProbKill$F)

     if (jecewsi$game != $no)  # if JECEWSI is participating, adjust the PK 
        {                      # for self protect jamming - jfr 8/17/94
         # now get the self protective jamming prob of hit factor
         call get_jecewsi_factor (UNT$Pointer, UNT2$Pointer, $spj, spj_factor)
         MC$ProbKill$F = MC$ProbKill$F * spj_factor # degrade prob of kill due to spj - JFR 8/17/94
        }

     missile_pk = MC$ProbKill$F # to set up initial PK for firing loop - JFR 2/20/94

     unt2$hits$i = Xunt2$hits$i

     if (Level$Air$Engagement == 1)
        {
         if (ac_tgt != $no)     # if not a cruise missile
            {
             AML$pointer$to xUNT$AMLIndx$i       # Set attacker's and
             AML2$NextIndx$i = xUNT2$AMLIndx$i   # target's AML pointers

             leader_index = AML2$NextIndx$i      # Retain leader callsign after attrition
             NHIT = 0
            }
        } 

     for (i = 1; i <= 2; i = i + 1)
         totals[i] = 0

     BDA_Nbr_Fired = 0 # JFR 9/24/93 # init the number fired (E1104)

     for (n = 1; n <= Nrate; n = n + 1)      # for the firing rate
       {
        if (eqlist[3,NAAM] <= 0)    # if no weapons left, break
          break      

        if(NTARGT == 0)             # if all targets killed, break
           break       

        if (trace$engage$exe != $no)
           call echoi (n)

        # if target not a cruise missile or
        # enhanced air-to-air and not a cruise missile and hit made or first time through
        if ((ac_tgt != $no) |   
            (level$air$engagement == 1 & ac_tgt != $no & (NHIT ==1 | N == 1)))
            {
             AML2$pointer$to AML2$NextIndx$i
             AML2$NextIndx$i = xAML2$NextIndx$i
            }

        rannum = random(x)  # get random number 

        BDA_Nbr_Fired = BDA_Nbr_Fired + 1 # JFR 9/24/93 bump up nbr fired

        if (level$air$engagement < 1)
          {
           eqlist[3,NAAM] = eqlist[3,NAAM] - 1  # decrement missile count
           nhit = $yes                          # SMM 7/97 (E1410)
          }                                     # (rather than using an old value)
        else # (Level$Air$Engagement >= 1)
          { #using difficulty multipliers - JFR 2/20/94
           mc$probkill$f = missile_pk # restore starting PK value - JFR 2/20/94
           call launch_and_kill(UNT$Pointer, UNT2$Pointer,
                                MC$Pointer,  eqlist, 
                                naam,             # send attacker weapon index
                                rannum,           # send random number
                                mc$probkill$f,    # send/receive missile prob. hit
                                nhit,             # receive yes/no hit
                                totals,           # receive array of totals
                                unsuccessful)     # $yes/$no flag - SMM 7/97 (E1410)
           }
        if (unsuccessful == $yes)   # if the a/c did not successfully deploy AAMs,
           next                     # then there is nothing more to do - SMM 7/97 (E1410)

        if (log$engage != $no)                # if engagement log is desired
            {
             call engdata(UNT$Pointer, UNT2$Pointer) 
             PUTeng$Weapon$c( Xmc$name$c )     # get weapon type
             PUTeng$Range$f( float(irng) )     # range to target
             PUTeng$MBURange$f( MBURange(UNT2$Pointer) )       # range to MBU
            }
 
        if (MC$PROBKILL$F < rannum)
           {         
            if (log$engage != $no)              # if engagement log is desired
               {
                call engdata(UNT$Pointer, UNT2$Pointer) # jhm 12/01 (E2247)
                PUTeng$Result$i( eng$Miss$code ) 
                PUTeng$ResultPh$f( MC$ProbKill$f * 100. )   # move prob. of hit
                call write_eng_rec
               }
            next                                # step to next iteration
           }  

        #$% At this point MC$ProbKill$F >= rannum

        if (nhit != $no)   # nhit = $yes for level < 1 and is determined
          {                # for levels >= 1 (no launch is possible) - SMM 7/97 (E1410)
           call Process_AAM_Hit (UNT$Pointer,     UNT2$Pointer,    ac_tgt,
                                 AML2$Pointer,    leader_index,    CMC$Pointer,
                                 MC$Pointer,      ntargt,          nkill,
                                 BDA_Nbr_Fired) # JFR 4/5/94 for BDA
          }   # end of if a hit occured
       } # end of for loop through nrate

     #----------------------------------------------------
     #            Note:  3 lines from DEQGET..
     #    eqlist[1,nfound] = DEQ$Pointer$index       # save index of equipment
     #    eqlist[2,nfound] = Xdeq$pntr$i             #   equipment pointer
     #    eqlist[3,nfound] = deq$remaining$i         #   equipment count
     #----------------------------------------------------

     Deq$Pointer$TO eqlist[1,NAAM]                 # jb 3/28/89    5/18/89

     if(eqlist[3,NAAM] <= 0)                         # if no missiles remaining
        PUTdeq$REMAINING$I (0) 
     else
        PUTdeq$REMAINING$I (eqlist[3,NAAM])      

     if (NKILL != 0)  # got a kill
       {
        # Track could be a RMT track and LCL would not be set
        # so check now before putting values
        if (LCL$Pointer != 0)
            {
             if (Level$Air$Engagement == 1)  # target is a/c or cruise missile
                lcl$Remaining$I = max0(ntarg - nkill,0)
             else    # not enhanced model
                { # enter number remaining
                 lcl$Remaining$i = max0(ntarg - unt2$hits$i,0) 
                }
             PUTlcl$Remaining$i 
            }
        PUTunt$status$i      ($Proceeding$code)
        PUTunt$attackindx$i  (unt2$pointer$index)     #target as attack guide
       } # if nkill != 0

     if (NTARGT <= 0)            # if all killed
        call Process_AAM_Grand_Slam (UNT$Pointer,  UNT2$Pointer,
                                     LCL$Pointer,  ac_tgt, MC$Pointer,
                                     BDA_Nbr_Fired) # JFR 4/3/94 for BDA
     else   # ntargt > 0
        {
         if ((Level$Air$Engagement == 1 & ac_tgt != $no))
            {
             # adding probability of continuing the engagement
             call Disengage_air (unt$pointer, unt2$pointer, idisengage)
    
             if (iDisengage == $no)
                {
                 putunt$Status$i      ($Proceeding$code)
                 putunt$AttackIndx$i  (unt2$pointer$index)
                }
            }
        }   # end of ntargt > 0 - targets remaining
    }    # end of non-ghosted target


if (Level$Air$Engagement == 1)
     # if there are less than 2 missiles per a/c bingo
     call Avg_Cap(unt$pointer,  # flights unt pointer
                  nfound,       # number of AAMs found in DEQGET
                  eqlist)       # list of equipment found in DEQGET
                  
else # level$air$engagement != 1
    {
     nfound = 0                                      # init item count

     call DEQGET(unt$pointer,        # jb receive UNT pointer    3/22/88
                 $AAM$CODE,                    # receive equipment ident code
                 nfound,                       # receive/return nbr items fnd
                 eqlist)                       # receive/return list of EQ

     unt$mission$i = Xunt$mission$i          # jb up frm nxt 2 lines 4/16/87

     if ((nfound == 0) & (unt$mission$i == $cap$code      |
                          unt$mission$i == $strikecap$code|
                          unt$Mission$i == $Sweep$code    |
                          unt$mission$i == $AirDefense$code))
        {
         call bingo (UNT$Pointer)                    #return CAP to base
         jj = 0
         call smovv (" From: ", msg, jj)
         call smovhn (xunt$name$c, $$MaxLit, msg, jj)
         call smovv (", all AAMs expended, returning to base. ", msg, jj)
         call send_  (xunt$view$i, 0, jj, msg) # jb    7/11/89
       }
    } # end else level$air$engagement != 1

# If enhanced air to air model and 
# if the A/C is on CAP, check how far the A/C is from his CAP position.  
# If greater than specified range, break off engagement and CAP.
if ((Level$Air$engagement == 1) & (xunt$AssignedCap$i != $no) &
    (xUNT$RulesOfEngage$I != $IfAttacked$Code))
    {
     past_cap = $yes
     call PROC_CAP (unt$pointer, past_cap, idummy)    
    }   # end of if (unt$AssignedCap$i == $yes)

return
end     # end of ATOAIR
                                  

subroutine Get_AAM_Probability_of_Kill (_
                UNT$Pointer,            # attacker's unit pointer
                MC$Pointer,             # AAM characteristic pointer
                altitude_difference,    # the altitude between attacker and target
                range,                  # range from attacker to target
                target_index,           # the target probability of hit matrix index
                probability_of_kill)    # return the probability of kill
########################################################
#$%
#$% Purpose:   Get_AAM_Probability_of_Kill calculates the
#$%            probability of hit/kill for an air-to-air
#$%            engagement.  For level of air engagment 1,
#$%            altitude differential and air effectiveness
#$%            multiplier are factored in.
#$%
#$% Called by: AtoAir
#$%
#$% Calls:     Echo..
#$%
#$% Tables:    UNT        ACC       MC
#$%
#$% Date:      February 1993
#$%
#$% Author:    Code moved from atoair.
#$%
########################################################
BBCommon
Eng$ProbHits

LITERAL    CSTRIP8                # jb  E2145 6/28/00
REAL     ACC$Aireffectmult$F      # jb  E2145 6/28/00
real     probability_of_kill
integer  UNT$Pointer, MC$Pointer
integer  altitude_difference, range
integer  target_index
integer  ACC$Pointer
integer  attacker_maxalt
integer  probability_of_hit
integer  weapon_index
Integer UNT2$Pointer              # jb  E2145 6/28/00
    
    # get the target
    UNT2$Pointer$To xUNT$AssignedTarget$I

    if (Level$Air$Engagement < 1)
      {
         weapon_index = xMC$WeaponIndex$I
         probability_of_hit = eph [target_index, weapon_index]
         probability_of_kill = probability_of_hit * 0.01
        }
    else    # Air-to-air enhancements 3/25/92 SMM
        {
         Acc$Pointer = xUNT$AccPntr$I        # get the attacker's acc pointer
         attacker_maxalt = xACC$MaxAlt$I     # and the attacker's max altitude
    
         if (altitude_difference < 0)                       # if target is below,
             probability_of_hit = xMC$AltitudeBelowPK$I     # get PK for targets below the attacker.
         else if (xunt2$TrueAltDepth$i > attacker_maxalt)   # if target is above attacker's maximum altitude,
            probability_of_hit = xMC$AboveMaxPK$I           # get the PK for targets above maximum altitude
         else                                         
            probability_of_hit = xMC$AltitudeAbovePK$I      # get the PK for targets above the attacker

         probability_of_kill = probability_of_hit * 0.01

         # Aircraft Effectiveness Multipliers.  Get the AEM for the attacker and
         # adjust  probability of kill.  If the ACC$AirEffectMult$F == 0, use 1.0. 
         ACC$AirEffectMult$F = xACC$AirEffectMult$F
         If (ACC$AirEffectMult$F <= 0.0)
             ACC$AirEffectMult$F = 1.0

         probability_of_kill = probability_of_kill * ACC$AirEffectMult$F

         # If result is greater than 1.0 (100%), limit value to 1.0. 
         if (probability_of_kill > 1.0)
             probability_of_kill = 1.0
        }

    
    if (trace$engage$exe != $no)
       {
        call echov  (" w/")
        call echohn (xMC$Name$C, $$MaxLit)
        call echov  (" (PH/PK=")
        call echoi  (probability_of_hit)
        call echov  ("%) ")
        call echov  (" @")
        call echoi  (range)

        if (Level$Air$Engagement >= 1)
            {
             call echov  (" - ")
             call echohn (xACC$Type$C, $$MaxLit)
             call echov  (" class has an AEM = ")
             call echof  (ACC$AirEffectMult$F, 3)
             call echov  (", adjusted PH/PK = ")
             call echoi  (int(probability_of_kill * 100), 3)
             call echov  ("%.")
            }

         call echor
       } # end trace
    
return
end     # end of Get_AAM_Probability_of_Kill
                                  

subroutine Process_AAM_Hit (_
                UNT$Pointer,       # input - attacker
                UNT2$Pointer,      # input - target
                ac_target_flag,    # input - $yes if an a/c, $no if a cm
                AML2$Pointer,      # input - target's AML entry if an a/c
                leader_index,      # input - flight leaders AML is an a/c
                CMC$Pointer,       # input - targets CMC entry is a cruise missile
                MC$Pointer,        # input - attacking AAM characteristic pointer
                num_targets,       # in/out - decremented
                num_kills,         # in/out - incremented
                BDA_Nbr_Fired)     # in/out - JFR 4/5/94 for BDA
#############################################################
#$%
#$% Purpose:   Process_AAM_Hit processes an AAM hit against
#$%            an aircraft and updates the engagement data.
#$%            For a cruise missile, a test for intercept is
#$%            computed if it is nuclear and if successful
#$%            SEND_DETON is called to detonate it.
#$%
#$% Called by: AtoAir
#$%            ALSP_Receive_AAM_Engage
#$%
#$% Calls:     Who_To_Kill                  <wgmdeng_air.rin>
#$%            Update_Destroyed_Aircraft    <lbcommn.rat>
#$%            Generate_eng_rec             <wgmdrec.rat>
#$%            RANDOM                       <lbmath.rat>
#$%            SEND_DETON
#$%            Echo...                      <lbecho.rat>
#$%            Update_DAC_CM_BDA            <lbcommn.rat>
#$%
#$% Tables:    UNT        LCL       MC
#$%
#$% Date:      February 1993
#$%
#$% Author:    Code moved from atoair.
#$%
#$% Modified:  Jonathan Richardson - 4/94 (E1104)
#$%            Added parameter BDA_Nbr_Fired for use in BDA.
#$%            Added BDA_Nbr_Fired to parameter list of Who_to_Kill.
#$%
#$%            Susan Miller - 2/96 (E1104)
#$%            Added call to Update_DAC_CM_BDA
#$%            to handle a cruise missile target.
#$%
########################################################
BBcommon
encommon

LITERAL  UNT2$Name$C, CSTRIP8          # jb E2145  6/28/00
REAL    X, RANDOM, FLAT,FLON, TEST     # jb E2145  6/28/00
integer   UNT$Pointer,     UNT2$Pointer
integer   ac_target_flag
integer   AML2$Pointer,    leader_index,   CMC$Pointer
integer   MC$Pointer,      num_targets,    num_kills
integer   BDA_Nbr_Fired  # JFR (E1104) for BDA
Integer  NPH,IBURST,IDEPTH,INDXTGT,KSIDE,     # jb E2145  6/28/00
    INTCPTFLAG, IYIELD,                       # jb E2145  6/28/00
    UNT2$Hits$I,UNT2$Misshits$I,UNT2$View$I   # jb E2145  6/28/00
data x/0.0/		# Get next random number in sequence

  if (log$engage != $no) # if engagement log is desired
     {                   # setup a hit entry
      call engdata (unt$pointer, unt2$pointer) # jhm 12/01 (E2247)
      PUTeng$Result$i( eng$Hit$code )
      PUTeng$Time$f( game$time )
      call write_eng_rec
     }

  num_targets = num_targets - 1
  num_kills = num_kills + 1

  # if enhanced air-to-air & target is an aircraft
  if ((Level$Air$Engagement == 1) & (ac_target_flag == $yes))
    {
    call who_to_kill (UNT$Pointer, UNT2$Pointer,
                      MC$Pointer,  leader_index, BDA_Nbr_Fired)
    BDA_Nbr_Fired = 0 # JFR 9/27/93 -- adjust num between each kill
    }

  # else if target is a cruise missile and not hit or
  # target is an a/c and it's not destroyed
  else if ((ac_target_flag == $no  & xUNT2$Hits$I   == 0)             |
           (ac_target_flag == $yes & xAML2$Status$I != $Destroyed$Code))
    {
     UNT2$Hits$I = xUNT2$Hits$I + 1          # add hit to target - updating
     putUNT2$Hits$I                          # these fields causes the damage
     UNT2$MissHits$I = xUNT2$MissHits$I + 1  # routine to be executed in wgmddam.rat
     putUNT2$MissHits$I

     if (ac_target_flag != $no)      # Target is NOT a Cruise-Missile
       {
        putAML2$Status$I  ($Destroyed$Code)

        #$% Enter data into the DAC table.       clk 3/92
        call Update_Destroyed_Aircraft (UNT2$Pointer, UNT$Pointer,
                                        $AirToAirMissile$Code,
                                        xMC$Name$C, AML2$Pointer, BDA_Nbr_Fired)
        BDA_Nbr_Fired = 0 # JFR 9/24/93 - reset since want nbr fired for each kill


        if (log$engage != $no)              # if engagement log desired
         {
          call engdata (UNT$Pointer, UNT2$Pointer)    #jhm 12/01  Want Lat/Long for splash (E2247)
          call Generate_eng_rec ("SPLASH  ", "ENGAGE  ", xAML2$SideNumber$C)
         }
       }  # end of if target is not a cruise missile
     else     # Target is a Cruise-Missile
       {
        ###############################################
        #<<<>>> Added 4/4/85 for intercept of nuclear crsmsl..
        #Set up vrbls in NUcommon for call to SEND_DETON subroutine:

        if (xCMC$FlightAlt$I > 50000)     #       5/21/85
          test = 0.45
        else
          test = 0.05
        
        iYIELD = Xcmc$Yield$i                 # CRSmsl tgt    4/4/85
        IF (iYIELD >0 & Nuclear$Capable !=$NO &
            xUNT2$Nuclear$I !=$NO & RANDOM(x) < test)  #       5/21/85
          {
           IntcptFlag = 1                # INTERCEPT case..
           INDXtgt = unt2$Pointer$index  # (irrevelant for intcpt case)
           FLAT = Xunt2$TrueLatitude$F   # position of   # unt2  3/28/89
           FLON = Xunt2$TrueLongitude$F  # the intercept # unt2  3/28/89
           nPH  = 100                    # (No miss for INTERCEPT)

           unt2$VIEW$I = Xunt2$VIEW$I # CrsMsl belongs to TGT's view!
           if    (unt2$VIEW$I > $LastBlue$View) kside = 2
           else if(unt2$VIEW$I > $Neutral$View) kside = 1
           else                                 kside = 0

           iBURST  = $AIR$Code # (Intercepts generally in air..but..)
           if (test < 0.3) iBURST = $Surface$Code # not always! 5/21/85

           iDEPTH = 1  # irrelevant:  NOT subsurface..

           call SEND_DETON
          }            # End if crsmsl is nuclear      4/4/85
        else # not nuclear
          call Update_DAC_CM_BDA(UNT$Pointer, UNT2$Pointer, $AirToAirMissile$Code,
                                 xMC$Name$C, BDA_Nbr_Fired)
       }      # End if intercept of crsmsl            4/4/85


     #$% if trace display requested by user (usually for debug)
     if (trace$engage$exe != $no)
       {
        call echo ($aster)
        call echov ("  [")
        if (ac_target_flag != $no)  call echohn (xAML2$SideNumber$c, $$MaxLit)
        else                        call echohn (unt2$Name$C, $$MaxLit) # 10/10/85
        call echov (" down]")
       }
    } # end if cruise missile with no hits, or a/c that's not destroyed


return
end     # end of Process_AAM_Hit
                                  

subroutine Process_AAM_Grand_Slam (_
                UNT$Pointer,        # input - the attacker
                UNT2$Pointer,       # input - the target
                LCL$Pointer,        # input - attacker's local detection of target
                air_target_flag,    # input - $yes if target is an a/c,
                                    #         $no if a cruise missile
                MC$Pointer,         # input - missile pointer
                BDA_Nbr_Fired)      # input - nbr AAM fired for BDA - JFR 4/3/94
########################################################
#$%
#$% Purpose:   Process_AAM_Grand_Slam updates the status
#$%            of the a/c in flight destroyed by AAMs.
#$%            The information regarding the status of
#$%            engagement is also updated for the attacker.
#$%
#$% Called by: AtoAir
#$%
#$% Calls:     Echo..                       <lbecho.rat>
#$%            All_Gone
#$%            Update_Destroyed_Aircraft    <lbcommn.rat>
#$%
#$% Tables:    UNT        LCL       MC
#$%
#$% Date:      February 1993
#$%
#$% Author:    Code moved from atoair.
#$%
#$% Modified:  Jonathan Richardson - 4/94 (E1104)
#$%            Added parameter BDA_Nbr_Fired for use in BDA.
#$%
#$%            Susan Miller - 7/97 (E1385)
#$%            UNT$TestIntercept$I is set to $no when
#$%            the assigned target is being deleted.
#$%
#$%            Susan Miller - 7/97 (E1410)
#$%            When checking to make sure the target
#$%            suffered as many hits are there are a/c
#$%            in the flight, the nbr of a/c in the
#$%            attacking mission was used - changed the
#$%            if statement and associated assignment.
#$%
########################################################
BBcommon

LITERAL  CSTRIP8                        # jb E2145  6/28/00
integer  UNT$Pointer, UNT2$Pointer, LCL$Pointer, UNT3$pointer
integer  air_target_flag, MC$Pointer
integer  BDA_Nbr_Fired  # JFR (E1104)
integer  AML2$Pointer,AML2$Nextindx$I,  # jb E2145  6/28/00
    UNT2$Nbrac$I,UNT2$Hits$I,           # jb E2145  6/28/00
    LCL$Remaining$I, UNT$Type$I         # jb E2145  6/28/00

    if (trace$engage$exe != $no)    # Send message to trace file.
       {
        call echo  ($space)
        call echov (" Grand Slam")
       }

    if (level$air$engagement >= 1)
       {
        putunt$TailChaseOverride$i ($No)

        if (air_target_flag != $no)
           call all_gone(unt$pointer, unt2$pointer)
       } # end if level$air$engagement = 1
    else  # not enhanced air-to-air
       {
        if (air_target_flag != $no)  # Target is NOT a Cruise-Missile #      9/19/85
           {
            AML2$NextIndx$i = Xunt2$AmlIndx$i 

            while (AML2$NextIndx$i != 0)                      #       9/19/85
               {                                                #       9/19/85
                AML2$pointer$to AML2$NextIndx$i                 #       9/19/85

                if (xAML2$status$i != $destroyed$code )            
                   #$% Enter data into the DAC table.       clk 3/92
                   call Update_Destroyed_Aircraft (UNT2$Pointer, UNT$Pointer,
                                                   $AirToAirMissile$Code,
                                                   xMC$Name$C, AML2$Pointer, BDA_Nbr_Fired)

                if (log$engage != $no)              # if engagement log desired
                   {
                    if (xAML2$status$i != $destroyed$code )
                     {
                       call engdata (UNT$Pointer, UNT2$Pointer)    #jhm 12/01  Want Lat/Long for splash (E2247)            
                       call Generate_eng_rec ("SPLASH  ","ENGAGE  ", xaml2$SideNumber$c)
                     }
                   }                                             
        
                putAML2$status$i ( $destroyed$code )            #       9/19/85
                AML2$NextIndx$i = XAML2$NextIndx$i              #       9/19/85
               }    # end of while loop through flight chain    #       9/19/85
           } # end if target not a cruise-missile

        UNT2$NbrAc$I = xUNT2$NbrAc$I                # hit'em all, so make sure
        UNT2$Hits$I = xUNT2$Hits$I                  # the are as many hits as a/c
#        UNT$NbrAc$I = xUNT$NbrAc$I          # check changed from comparing
        if (UNT2$Hits$I < UNT2$NbrAc$I)      # UNT2 hits against nbr of a/c in
          putUNT2$Hits$i (UNT2$NbrAc$I)      # UNT to nbr of a/c in UNT2 - SMM 7/97 (E1410)

        LCL$Remaining$I = 0                         #flag grand slam
        putLCL$Remaining$I 

        if (Xunt$RulesOfEngage$i == $SPECTARGET$CODE)#if assigned targt
             putunt$RulesOfEngage$i ($IFATTACKED$CODE)       #set ROE to if attak

        unt$type$i = Xunt$type$i
    
        call assgnt (unt$pointer,unt$type$i)        # assign a new target
       } # end if not enhanced air model and a/c target

    putunt$EngageStatus$i ($EngagementOver$code)
    putUNT$STATUS$I ($Proceeding$code)
    UNT3$Pointer$To XUNT$AttackIndx$I # jb (no X)    1/3/00 
    if (unt3$pointer$ok)
        putUNT3$UnderAttack$i ($NO)  # send the target on his way
    putUNT$ATTACKINDX$I ($NO)           # delete attack guide
    putUNT$ASSIGNEDTARGET$I ($NO)       # delete target
    putUNT$ReactFlag$I ($no)            # reset the react flag 
    putUNT$TestIntercept$I ($NO)        # SMM 7/97 (E1385)

return
end     # end of Process_AAM_Grand_Slam
                                  

subroutine airtor (unt$pointer,         #pass a/c unit pointer
                   unt2$pointer,                #pass target unit pointer
                   iover,
                   isTMA)

########################################################
#$%
#$% Purpose:   AIRTOR processes aircraft-submarine
#$%            engagements, maneuvering the air-
#$%            craft and launching torpedo
#$%
#$% Called by: ATOSUB
#$%
#$% Calls:     GETTOR     GETRB_M
#$%            ECHOH      ECHOR
#$%            UPDATE_NAVAL_UNIT_BDA_DEFERRED       GET_DSS_DATA
#$%
#$% Tables:    UNT        
#$%            TOR        TAT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Jonathan Richardson - 4/94 (E1104)
#$%            Added code to handle BDA data.
#$%
#$%            Susan Miller 12/97 (E1697)
#$%            Changed call update_naval_unit_bda_deferred to 
#$%            update_naval_unit_bda - entry point removed
#$%            Added 2 update_naval_unit_bda parameters to 
#$%            indicate whether damage is deferred. 
########################################################
BBcommon
Encommon

Literal   BDA_Class,    CSTRIP8              # jb E2145  6/28/00

Real*4    Rand_Num,PH_a
real      Ntime
real      mburange
REAL    X, RANDOM, BDA_DAM,BRG_ACT,BRG_TMA,         # jb E2145  6/28/00
        DEQ$Timelastused$F,RANGE_ACT,RANGE_TMA,     # jb E2145  6/28/00
        TOR$Maxprobhit$F, PH_T, PMIN, BD            # jb E2145  6/28/00
integer   NinInterval
Integer*4 BDA_tracknumber, BDA_Result_code, BDA_nbr_fired # JFR 6/18/93
Integer I,IPH,BDA_TORHITS,ISTMA,IOVER,IBEST,        # jb E2145  6/28/00
    IRNG_A,IRNGY_A,IRNG_T,IRNGY_T,NHITS,            # jb E2145  6/28/00
    ITORP_WEIGHT,BDA_CLASSID,NFIRE,                 # jb E2145  6/28/00
    UNT$Pointer,UNT$Engagestatus$I,UNT$Orderedaltdepth$I, # jb E2145 6/28/00
    UNT2$Pointer,UNT2$Underattack$I,                # jb E2145  6/28/00
    DEQ$Pointer,DEQ$Remaining$I,                    # jb E2145  6/28/00
    TOR$Pointer,TOR$Maxrange$I,TOR$Yield$I,         # jb E2145  6/28/00
    LCL$Pointer, TAT$Pointer                        # jb E2145  6/28/00
BBDeclare (unt3$pointer)
real      range, bearing
data x/0.0/		# Get next random number in sequence

call GETRB_M(_                                    #get range and bearing
           UNT$pointer,                         #pass A/C pointer 3/28/89
           UNT2$POINTER,                        #pass target pointer
           RANGE_act,                           #receive range
           BRG_act)                             #receive bearing

if (isTma != NO)
    {                                           # process TMA Target
    lcl$pointer = isTMA
    call GETRB_lcl(_                            #get range and bearing
                   UNT$pointer,                 #pass A/C pointer
                   lcl$pointer,                 #pass target pointer
                   RANGE_tma,                   #receive range
                   BRG_tma)                     #receive bearing
    }
else
    {                                           # Active Track
    range_tma = RANGE_act
    brg_tma   = BRG_act
    }

irng_a   = range_act +0.5                               #       5/7/86
irngy_a  = range_act * $Yds$Per$Mile                    #       5/7/86

irng_t   = range_tma +0.5                               #       5/7/86
irngy_t  = range_tma * $Yds$Per$Mile                    #       5/7/86

call gettor (unt$pointer,                        # 10/10/90 hdf
             unt2$pointer,                       # 7/89 (fix UNT2)
             range_act,                         # for range x   5/7/86
             iBEST,             # receive DEQ index, or ZERO    3/29/89
             ph_a,                              # and    Prob Hit
             ph_t)

if (iBEST == $no)                    # if no torpedos found ( jb 3/28/89)
    {
    iover = YES
    return
    }

iover = NO

if (isTma == NO)
    {                                           # Active Track
    ph_t = ph_a
    }

if (trace$engage$exe != $no)
   {
    call echor
    call echoV  ('!')                       # jb E2144  (echoV) 8/2/00
    call echov (" Air to Sub (Torp).....")
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" Attacking ")
    call echohn (xunt2$name$c,$$MaxLit)
    if (isTMA != NO) call echov (" (w/TMA)")
   }

PUTunt$status$i      ($proceeding$code)
PUTunt$attackindx$i  (unt2$pointer$index)       #target as attack guide
PUTUNT$attackrange$f (0.0)                      #attack range to zero

# Assign return base as guide, and calculate range and bearing
#   to return to current position
if (Xunt$GuideIndx$i == 0)
{
    if (Xunt$LaunchIndx$i != 0)
    {
        unt3$pointer$to Xunt$LaunchIndx$i
        call GETRB_M (UNT3$Pointer, UNT$Pointer,
                        range, bearing)
        PUTunt$GuideIndx$i (unt3$pointer$index)
        PUTunt$GuideRange$f (range)
        PUTunt$GuideBearing$f (bearing)
        PUTunt$GuideTrue$i ($YES)                            
    }
}

DEQ$Pointer$TO (iBEST)    # jb (but..may be out of torpedo range) 3/29/89
tor$pointer = Xdeq$Pntr$i            #  get torpedo pointer # jb  3/28/89

if (abs(brg_act - brg_tma) > 15) ph_t = 0.0     #               5/7/86

if (trace$engage$exe != $no)
    {
    call echov (" w/")
    call echohn (Xtor$type$c,$$MaxLit)

    if (isTMA != NO) 
        {
        call echov (" TmaRng(Y)=")
        call echoi (irngy_t)
        }

    call echov (" rng(Y)=")
    call echoi (irngy_a)

    call echov (" Ph=")
    iph = ph_t * 100 + .5
    call echoi (iph)
    call echov ("%")

    if (isTMA != NO) 
        {
        call echov (" (")

        iph = ph_a * 100.0 + .5
        call echoi (iph)
        call echov ("% true) ")
        }
    }

tor$MaxRange$i = Xtor$MaxRange$i                # get maximum range

if ( irng_a <= tor$MaxRange$i & (game$time - Xdeq$TimeLastUsed$f) >= 4) #      11/3/86
    # range within max range 5/8/86; plus fire only @ 4 minutes..   
   {
    PUTunt$engagestatus$i ($engaging$code)      # set engage status

    PUTunt2$underattack$i ($yes)                # set under attack flag to YES

    if (xUNT$TrueAltDepth$i <= Xtor$MaxAlt$i)
       {
        TOR$MaxProbHit$F = xTOR$MaxProbHit$F    #                       1/19/84
        Pmin = MIN( 0.5, TOR$MaxProbHit$F )     # set MIN. probability  1/19/84
        if (PH_a < Pmin ) return   # don't shoot w/less than minimum Ph 5/27/86

        NHITS = 0
        deq$Remaining$i = Xdeq$Remaining$i    

        # Get number fired in model interval
        deq$TimeLastUsed$f = Xdeq$TimeLastUsed$f
        nfire = NinInterval(deq$TimeLastUsed$f, Xtor$FireRate$i,
                            deq$Remaining$i)
        PUTdeq$TimeLastUsed$f

        for(i=1; i <= nfire; i=i+1)   #do until firing rate met
           {
            if (deq$Remaining$i == 0) break  #if torpedos expended 

            deq$Remaining$i = deq$Remaining$i -1 
            PUTdeq$Remaining$i                   

            if (trace$engage$exe != $no) call echoi (i)

######## Write a engagement record for each torpedo fired #################
#################### Dec. 23, 1985  <SCC>  ################################
            if (log$engage != $no)                # if engagement log is desired
              {
               call engdata(UNT$Pointer, UNT2$Pointer)
               PUTeng$Weapon$c( Xtor$type$c )            # weapon name 
               PUTeng$Range$f( float(irng_a) )          # range_act +0.5 to target      8/14/85
               PUTeng$MBUrange$f( MBURange(UNT2$Pointer) )       # range to MBU
              }  

            Rand_Num = Random(X)
            if (PH_a >= Rand_Num)       #  if hit
              { 
                IF  (( EMI$IntraPlatform != $no ) & (EMI$Analysis != $NO))
                    {
                     }
              }
            if (PH_a < Rand_Num)       #  if not hit
                {
                if (log$engage != $no)       # if engagement log is desired
                  {
                   PUTeng$Time$f( game$time )
                   PUTeng$Result$i( eng$Miss$code )
                   PUTeng$Resultph$f( ph_a * 100. )
                   call write_eng_rec
                  }
                next
              }
            if (log$engage != $no)       # if engagement log is desired
              {
               PUTeng$Time$f( game$time )
               PUTeng$Result$i( eng$Hit$code )
               call write_eng_rec
              }
                      
            #$% increment number of hits
            NHITS = NHITS + 1

            if (trace$engage$exe != $no) call echov ("Hit ")

           }

        if (NHITS != 0)                          #if hit
          { 
           # (E1104)
           # Process BDA here since the TAT table does not have provision for
           # number fired. NOTE: time may be after current game minute so
           #                     the status board may have to check it
           # Since the time is deferred, need to call the entry point routine
    
           # Get the values for input to update routine - JFR 6/22/93
           BDA_Nbr_Fired = xtor$FireRate$i # get nbr of bombs fired - JFR 6/22/93

           # get Torpedo warhead wgt for BDA - JFR 6/22/93
           BDA_TORHits =  Xtor$Weight$i * nhits 
           BDA_Result_code = $NavalTorpedo$Code

           for(TAT$POINTER$FIRST;still_valid(TAT);TAT$POINTER$NEXT) # 9/26/88
             {
              # find empty Time-at-Target slot
              if(XTAT$TARGETINDX$I != 0)  next

              NTIME = ((range_act)/Xtor$Speed$I) * $Minutes$Per$Hour +
                        GAME$TIME + 1.0 # T.A.T.
                        # Adding 1 to force at least one minute of delay

              iTorp_Weight = xTOR$Weight$I * nHits

              tor$Yield$i = xtor$Yield$i

              putTAT$TargetIndx$I (UNT2$POINTER$INDEX)  # save target pointer
              putTAT$SourceIndx$I (UNT$POINTER$INDEX)   # save aircraft pointer
              puttat$Time$f       (NTIME)               # save time to target
              putTAT$Weight$I     (iTorp_Weight)        # Lbs TNT of the torp
              putTAT$Hits$I       (NHITS)               # save number of hits
              putTAT$Ident$I      ($Torpedo$code)       # this is a torpedo
              putTAT$YIELD$I      (tor$Yield$i) # nuclear yield? 5/17/85

              nhits = 0                                 # zero number of hits

              #$% get DSS specific data - JFR 6/22/93 
              call Get_DSS_Data(UNT2$Pointer, UNT$Pointer, BDA_TORHits,
                                BDA_Result_code, BD, BDA_TrackNumber,
                                BDA_Class, BDA_ClassID)

              #$% data into the DSS table.   --- JFR 6/16/93
              call Update_Naval_unit_BDA(_
                        UNT2$Pointer,       # in -
                        UNT$Pointer,        # in - 
                        $NavalTorpedo$Code, # in -
                        BDA_Result_code,    # in -
                        BDA_Dam,            # in -
                        BDA_TrackNumber,    # in -
                        BDA_Class,          # in -
                        BDA_ClassID,        # in -
                        BDA_Nbr_Fired,      # in -
                        xTOR$Type$C,        # in -
                        $yes,               # in # SMM 12/97 (E1697) deferred
                        ntime)              # in # SMM 12/97 (E1697)

              break
             }

           #$% if number of hits
           if (nhits != 0)
             {
              call echor
              call echov ("TAT Table overflow for Air engagement")
             }
          
          }                                         #end if A/C at max range
       }
    else
       {
        #$% set engage status
        unt$engagestatus$i=$engaging$code
        PUTunt$engagestatus$i

        #$% set under attack to YES
        unt2$underattack$i = $yes
        PUTunt2$underattack$i

        UNT$ORDEREDALTDEPTH$I = max(Xtor$MaxAlt$i-10,1) #launch alt to max
        PUTUNT$ORDEREDALTDEPTH$I
       }
   }
#$% else if target range within double maximum range
else if ( irng_a <= 2 * tor$MaxRange$i)                 #       5/8/86
   {
    #$% set engage status
    unt$engagestatus$i=$engaging$code
    PUTunt$engagestatus$i

    #$% set target under attack to YES
    unt2$underattack$i = $yes
    PUTunt2$underattack$i

    UNT$ORDEREDALTDEPTH$I = max(Xtor$MaxAlt$i-10,1) #~max launch alt 1/9/83
    PUTUNT$ORDEREDALTDEPTH$I
   }
#$% else if target range within ten times maximum range
else if ( irng_a <= 10 * tor$MaxRange$i)                #       5/8/86
   {
    UNT$ORDEREDALTDEPTH$I = min(xUNT$ORDEREDALTDEPTH$I,500) # jb 7/9/90
    PUTUNT$ORDEREDALTDEPTH$I
   }


## <<RG>>   (JULY 1985)
## THIS CODE IS USED FOR ENGAGEMENT LOG DATA COLLECTION
if (log$engage != $no)       # if engagement log is desired
    {
    if (Xeng$Result$i == eng$Null$code)       # if data not already collected
        {
        if (nhits > 0)                     # if he is hit
            {
            PUTeng$Result$i( eng$Hit$code )
            }
        else                                              
            {
            PUTeng$Result$i( eng$Miss$code )
            PUTeng$Resultph$f( ph_a * 100. )
            }
        }
    }
## END (log$engage != $no



return
end             # end of AIRTOR

subroutine atosub (unt$pointer,                #get a/c unit pointer
                   unt2$pointer,                #get target unit pointer
                   isTMA)

########################################################
#$% 
#$% Purpose:   ATOSUB processes air-to-submarine
#$%            engagements using torpedoes ASMs and bombs.
#$%
#$% Called By: EPROSS
#$%
#$% Calls:     AIRTOR   AIRASM  AIRBOMB AIROVER
#$%
#$% Tables:    UNT              SHC
#$%
#$% Date:      FEB 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
bbcommon

integer dummy
Integer IOVER, ISTMA,                      # jb E2145  6/28/00 
    SHC$Pointer,UNT2$Pointer,UNT$Pointer   # jb E2145  6/28/00
logical isurf                   # jb                            7/3/89

dummy = $NO
iover = $NO                     # Initlz. for airtor?/AIRASM/   12/17/85c

SHC$Pointer = xUNT2$SHCpntr$i           #  DetectEE             3/28/89
isurf = (Xunt2$truealtdepth$i <= Xshc$KEELdepth$I) # SURFACED ? 7/3/89

if (isurf & isTMA == $NO)              # jb                    7/3/89
    {
    call airasm (unt$pointer,                   # call (airborne) ASM
                 unt2$pointer,                  #  pass target pointer
                 iover,                         # returns Yes when over
                 dummy)     # dummy return value used in atosur 3/93 SMM
    }
else
    {
    iover = YES
    }

if (iover == YES)
    {
    call airtor (unt$pointer,                   # call airborne torpedo
                 unt2$pointer,                  #  pass target pointer
                 iover,                         # returns Yes when over
                 isTMA)
    }

if (iover == YES & isurf)                       # jb            7/3/89
    {
    call airbomb(unt$pointer,                   # call bombing subroutine
                 unt2$pointer,                  #  pass target pointer
                 iover,                         # returns Yes when over
                 dummy)     # dummy return value used in atosur 3/93 SMM
    }

if (iover == YES)
    {
    call airover(unt$pointer,                   # 
                 unt2$pointer)                  #  pass target pointer
    }

return
end        # end of ATOSUB

subroutine atosur (unt$pointer,                 #get a/c unit pointer
                   unt2$pointer)                #get target unit pointer

########################################################
#$%
#$% Purpose:   ATOSUR processes air-to-surface engagements
#$%            using ASM or bombs.  Bombs always 'hit'--
#$%            BUT, the EFFECTS of hits DEPEND ON PROB.HIT--
#$%            while missile hits are stochastic.
#$%
#$% Called By: EPROSS
#$%
#$% Calls:     AIRASM AIRBOMB AIROVER (but not AIRTOR)
#$%
#$% Tables:    
#$%
#$% Date:      FEB 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
bbcommon

Integer MOVER, IOVER,           # jb E2145  6/28/00
    UNT$Pointer,UNT2$Pointer   # jb E2145  6/28/00
integer ASM_fired, UNT$MultipleTarget$I, Bomb_dropped   # smm 3/93 (E1103)

mOVER = $NO             # Intlz. for airtor?/AIRASM/    12/18/85c
iover = $NO             # Intlz. for airtor?/AIRASM/    12/17/85c

UNT$MultipleTarget$I = xUNT$MultipleTarget$I        # smm 3/93
ASM_fired = $no
Bomb_dropped = $no


# if this is an attack command being processed and the unit has
# attacked it's target this cycle, return now and wait for the order
# to be processed again before dropping any more weapons...SMM 6/6/94
if ((UNT$MultipleTarget$I == $yes) &
    (xUNT$AttackedTarget$I == $yes)) return

call airasm (unt$pointer,                       # call ASM subroutine
             unt2$pointer,                      #  pass target pointer
             mOVER,             # returns Yes if ASM eng. over  12/18/85c
             ASM_fired)         # returns yes if one weapon was fired
                                # used for ATTACK command  SMM 3/93

if (UNT$MultipleTarget$I == $yes)       # SMM 3/93
    {
     # if a missile was not fired, drop a bomb
     if (ASM_fired == $no) 
        {
         if (mOVER == $yes)
             call airbomb(unt$pointer,     # call bombing subroutine
                          unt2$pointer,    # pass target pointer
                          iover,           # returns Yes when over
                          bomb_dropped)    # returns yes if bomb dropped
        }   
     # if either engagement 
     if ((ASM_fired == $yes) | (bomb_dropped == $yes))
         call airover(unt$pointer,
                      unt2$pointer)
     return         
    }

if ((mOVER == YES | Xunt$mission$i == $Strike$Code) &   ## <RG> 9/25/85 to allow
    (UNT$MultipleTarget$I != $yes))
    {         ## ---------------------------------  strike aircraft to bomb.
    call airbomb(unt$pointer,                   # call bombing subroutine
                 unt2$pointer,                  #  pass target pointer
                 iover,                         # returns Yes when over
                 bomb_dropped)                  # returns yes if bomb dropped
    }

if (iover == YES & mOVER == $YES)               #               12/18/85c
    {
    call airover(unt$pointer,
                 unt2$pointer)
    }

return
end            # end of ATOSUR

subroutine airbomb(unt$pointer,                #get a/c unit pointer
                   unt2$pointer,                #get target unit pointer
                   iover,                       # engagement over ? (yes/no)
                   bomb_dropped)               #return 1 if bomb dropped

##################################################################
#$%
#$% Purpose:   AIRBOMB processes air-to-surface engagements us-
#$%        ing bombs.  All bombs dropped are treated as "hits"--
#$%        but the WEIGHT OF EXPLOSIVE DELIVERED IS REDUCED BY
#$%        MULTIPLYING THE TOTAL PAYLOAD WEIGHT BY THE AVERAGE
#$%        PROBABILITY OF HIT.  Against ships, nuclear warheads
#$%        are treated as usual, but shorebase targets are instead
#$%        subjected to an arbitrarily large conventional payload.
#$%
#$% Called By: ATOSUR   ATOSUB
#$%
#$% Calls:    SmBsunk   GETRB_M
#$%           UPDATE_NAVAL_UNIT_BDA       GET_DSS_DATA
#$%
#$% Tables:    UNT        DEQ
#$%            BOM        MC
#$%
#$% Date:      MAY 83
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - Sept. 1993
#$%            Added variable number_bombs_to_drop for
#$%            use when attacking a ghosted unit, since
#$%            hit/damage is determined by the owning actor.
#$%
#$%            Carol Kropp - 10/94
#$%            Added call to Record_C2_Air_Ground_Eng
#$%            and Record_C2_Flight_EQ_Expended - WPC C2
#$%
#$%            Carol Kropp - 7/95 (E1419)
#$%            Replace 10/94 calls with call to
#$%            Record_Ground_Unit_Attack, which handles C2 and TMS.
#$%
#$%            Carol Kropp - 10/95 (E1455)
#$%            When the target is a "shared" base, an ALSP
#$%            interaction message needs to be sent as well
#$%            as damage assessment to the RESA version of
#$%            the base.
#$%
#$%            JFR (E1104) Added code to handle new BDA information.
#$%
#$%            Jonathan Richardson - 6/96 (E1084)
#$%            Defined msg & msg_len to send a message to
#$%            the player view when a unit is hit by a bomb.
#$%
#$%            Susan Miller 5/98 (E1988)
#$%            If the target is a surface or sub, use speed
#$%            in calculating the ph. 
#$%
#$%            Susan Miller 12/97 (E1697)
#$%            Increased size of BDA_List array to hold target
#$%            UNT2$Pointer and DEQ$Pointer$Index.
#$%            Added 2 update_naval_unit_bda parameters to 
#$%            indicate whether damage is deferred. 
#$%            Send miss message and add pounds for bomb hit message.
########################################################
bbcommon
NUcommon                                        #       5/8/85
ENcommon
Eng$ProbHits
Eng$ProbIndx

Literal     BDA_Class
LITERAL    CSTRIP8                              # jb E2145  6/28/00
REAL X, RANDOM, RANGE, BRG,                     # jb E2145  6/29/00
    UNT2$Truelatitude$F,UNT2$Truelongitude$F    # jb E2145  6/28/00
Real*4      BDA_Dam
Real*4      Rannum,Ph
real        random_num                              # clk 11/93
real        mburange
real        reduction_factor,target_speed  # SMM 5/98 (E1988)
Integer I,N,NP,IDROP,IOVER,                     # jb E2145  6/28/00
    IEPUS,ITNT,ITNT_SUM,NTNT,                   # jb E2145  6/28/00
    NFOUND,BDA_CLASSID,                         # jb E2145  6/28/00
    UNT$Pointer,UNT$View$I,                     # jb E2145  6/28/00
    UNT$Nuctake$I,UNT$Nucfree$I,                # jb E2145  6/28/00
    BOM$Pointer,BOM$Droprange$I,                # jb E2145  6/28/00
    BOM$Weight$I,                               # jb E2145  6/28/00
    UNT2$Pointer,UNT2$Hits$I,                   # jb E2145  6/28/00
    UNT2$Bombhits$I,DEQ$Remaining$I             # jb E2145  6/28/00
integer     eqlist[5,30], DEQ$Pointer
integer     bomb_dropped, UNT$MultipleTarget$I      # SMM 3/93
integer     number_bombs_to_drop                    # clk 9/93
integer     number_bomb_hits                        # clk 11/93
integer     SHC$Pointer
integer     msg_len
integer*4   bda_list[30,5] , bda_weaps, bda_found, bda_bombhits # JFR 6/22/93
Integer*4   BDA_tracknumber, BDA_Result_code, BDA_nbr_fired # JFR 6/22/93
integer     UNT2$Type$I                    # SMM 5/98 (E1988)
integer     max_range, shortest_range, jj
BBDeclare   (unt3$pointer, acc$pointer, unt$name$c)
real        standoff_range, bearing
     
character   msg[ARB]
data x/0.0/		# Get next random number in sequence

number_bomb_hits = 0

UNT$MultipleTarget$I = xUNT$MultipleTarget$I

nfound = 0                                      # init item count
call DEQGET(unt$pointer,                        # jb             3/22/88
                  $BOMB$CODE,                   # receive equipment ident code
                  nfound,                       # receive/return nbr items fnd
                  eqlist)                       # receive/return list of EQ

IF  (nfound == $NO)                              #if NO bombs found
    {
    iover = yes
    return
    }

# Get max range of loaded bombs
max_range = 0
for (i=1; i <= nfound; i = i + 1)
{
    if (eqList[4,i] > max_range) max_range = eqList[4,i]
}

call getrb_M(_                                    #get range to target
     UNT$pointer,                               #pass A/C pointer
     unt2$pointer,                  #pass target pointer (jb unt2)    3/28/89
     range,                                     #receive range
     brg)                                       #receive bearing

if (min(Xunt$AttackRange$f,range) > max_range)
{
    iover = yes
    msg_len = 0
    call smovhn (xUNT$Name$C, $$MaxLit, msg, msg_len)
    call smovv  (" breaking engagement with weapons inside standoff range.", msg, msg_len)
    call send_   (xUNT$View$I, 0, msg_len, msg)
    return
}

IF (trace$engage$exe != $no)
   {
   call echor
   call echoV  ('!')                        # jb E2144  (echoV) 8/2/00
   call echov (" Air to Surf (Bomb)....")
   call echohn (Xunt$name$c,$$MaxLit)
   call echov (" Attacking ")
   call echohn (xunt2$name$c,$$MaxLit)
   }

for (i = 1 ; i <= 30 ; i = i + 1)
    { # init the BDA arrays --- JFR 9/21/93
     bda_list[i,1] = 0
     bda_list[i,2] = 0
     bda_list[i,3] = 0
     bda_list[i,4] = 0  # target pointer SMM 12/97 (E1697) 
     bda_list[i,5] = 0  # DEQ$Pointer$index    SMM 12/97 (E1697)
    }

#______________________________________________________________________
shc$pointer = Xunt2$ShcPntr$I                   
T_Indx = Xshc$TargetIndex$i

##-----------------------------------------------------------------
#       Added 5/29/85 to find smallest drop-range and avg. PHit:
PH = 0.0
nP = 0
Ntnt = 0        # Initlz. potentional conventional tnt          12/17/85c

# if the attacker has multiple targets, only drop one bomb 3/93 SMM (E1103)
if (UNT$MultipleTarget$I == 1)
    nfound = 1

for (N = 1; N <= nfound; N = N+1)       #do for all bombs
    {
    IF  (eqlist[3,n] == 0) next            #     out of stock !
    bom$pointer = eqlist[2,n]

    Ntnt = Ntnt + Xbom$Weight$i   # Accum. conventional lbs TNT   12/17/85c

    W_Indx = Xbom$WeaponIndex$i
    PH = PH + eph[T_indx,W_indx] / 100.0  # Prepare to
    nP = nP +1                            #  compute average PH, below
   
    BOM$DropRange$I = xBOM$DropRange$I                    ## tpa 5/23/85
    IF  (nP < 2) 
        Idrop =  BOM$DropRange$I
    ELSE 
        Idrop = min(Idrop, Bom$DropRange$I) # select MINIMUM drop-range
    }

UNT$NucTake$I = xUNT$NucTake$I                  #               12/17/85c
UNT$NucFree$I = xUNT$NucFree$I                  #               12/17/85c
iF  (Ntnt <= 0 & UNT$NucFree$I != $YES & UNT$NucTake$I != $YES) #12/17/85c
    {           # Bombs strictly nuclear but attack is conventional...
    iover = yes                                 #               12/17/85c
    return                                      #               12/17/85c
    }

PH = PH / nP                            # compute average PH
UNT2$Type$I = xUNT2$Type$I              # SMM 5/98 (E1988)
if ((UNT2$Type$I == $Surface$Code) | (UNT2$Type$I == $Sub$Code))
   {
    target_speed = xUNT2$TrueSpeed$F
    reduction_factor = 1.0 - (target_speed/100.0)
    reduction_factor = AMAX1 (0.01, reduction_factor)  # SMM 5/98 (E1988)
    ph = ph * reduction_factor                         # SMM 5/98 (E1988)
   }

#______________________________________________________________________
IF  (RANGE <= IDrop +3)                   ## tpa 5/23/85
    {
    putUNT2$UnderAttack$I ($YES)     #flag unit under attack
    }
 
bda_weaps = 0 # JFR 6/22/93

IF  (INT(RANGE) <= BOM$DropRange$I)            #if within one mile 5/23/85
    {
    PUTunt$EngageStatus$i ($engaging$code)

    itnt_sum = 0
    iYIELD   = 0        # initialize YIELD      5/8/85
    for (N = 1; N <= nfound; N = N+1)   #do for all bombs
        {
        IF  (eqlist[3,n] == 0) next      #     out of stock !

        bom$pointer = eqlist[2,n]
        IF  (iYIELD < 1)         # Find the FIRST        5/20/85
            {                     #   nuclear yield..     5/8/85
            iYIELD = Xbom$YIELD$i
            iBurst = Xbom$BurstType$I
            iDepth = Xbom$BurstDepth$I +1 #              5/8/85
            }
        IF  (iYIELD < 1)         # Still conventional?.. 6/24/85
            {
## intra emi :
            IF  (( EMI$IntraPlatform != $no ) & (EMI$Analysis != $NO))
                {
                Rannum = 1.0     # random number is not drawn
                DEQ$Pointer$To Eqlist[1,n]
                 }

            # if the attacker has multiple targets, only drop one bomb 3/93 SMM (E1103)
            # clk 11/93 - per Dan Bacon, drop one salvo, not one bomb
            if (UNT$MultipleTarget$I == 1)
              {
                number_bombs_to_drop = xBOM$RoundsPerSalvo$I   # clk 9/93
                if (number_bombs_to_drop > eqlist[3,N])
                   number_bombs_to_drop = eqlist[3,N]
              }
            else 
                number_bombs_to_drop = eqlist[3,n]     # clk 9/93

            if (xUNT2$Type$I == $Shorebase$Code)
              {
               itnt = INT (Xbom$Weight$i * number_bombs_to_drop * ph + 0.5)
               # since all bombs are hits for shore bases
               number_bomb_hits = number_bombs_to_drop
              }
            else
              {
               number_bomb_hits = 0
               for (i = 1; i <= number_bombs_to_drop; i = i + 1)
                 {
                  random_num = Random(x)
                  if (random_num <= ph)
                    number_bomb_hits = number_bomb_hits + 1
                 }
               itnt = Xbom$Weight$i * number_bomb_hits
              }

            itnt_sum = itnt_sum + itnt
            }

        Deq$Pointer$TO (eqlist[1,N])    # point to bombs # jb 3/28/89
        DEQ$Remaining$i = eqlist[3,N] - number_bombs_to_drop
        putDEQ$Remaining$i
        if (UNT$MultipleTarget$I == 1)
            {
             bomb_dropped = $yes
             putUNT$AttackedTarget$I ($yes)
            }

        if (xUNT2$GhostedUnit$I == $yes &      # if an ALSP ghost - clk 9/93
            ALSP$Active == $yes)
          {
           call ALSP_Send_ASM_or_Bomb_Engage (UNT$Pointer, $Bomb$Code,
                                              BOM$Pointer, UNT2$Pointer,
                                              number_bombs_to_drop,
                                              xUNT$TargetType$I)

           call Log_ALSP_Engagement_engdata (UNT$Pointer, UNT2$Pointer, xBOM$Name$C,
                                             INT(range),number_bombs_to_drop)

           itnt_sum = number_bombs_to_drop * xBOM$Weight$I
          }
        else       # not an ALSP ghost...
          {
           if (xUNT2$Type$I == $ShoreBase$Code)    # clk 10/95 (E1455)
             {
              SHC$Pointer = xUNT2$SHCpntr$I
              if (xSHC$ALSPSharedBase$I == $yes & ALSP$Active == $yes)
                {
                 call ALSP_Send_ASM_or_Bomb_Engage (UNT$Pointer, $Bomb$Code,
                                                    BOM$Pointer, UNT2$Pointer,
                                                    number_bombs_to_drop,
                                                    xUNT$TargetType$I)

                 call Log_ALSP_Engagement_engdata (UNT$Pointer, UNT2$Pointer, xBOM$Name$C,
                                            INT(range),number_bombs_to_drop)         # JHM 7/17/02
                }
             }

           # Now find out if this is a similar bomb (remember it is a hit) - JFR 6/22/93
           bda_found = $no  # JFR 6/22/93
           for (i = 1 ; i <= bda_weaps ; i = i + 1)
             {# find bomb pointer match and 
              # deq pointer index match  SMM 12/97 (E1697)
              if ((bom$pointer == bda_list[i,1]) &
                  (DEQ$Pointer$Index == bda_list[i,5]))  # SMM 12/97 (E1697)
                {
                 bda_found = $yes  # JFR 6/22/93
                 #incr nbr of hits 
                 bda_list[i,2] = bda_list[i,2] + number_bomb_hits 
                 # incr warhead weight for this type of bomb
                 bda_list[i,3] = bda_list[i,3] + itnt_sum 
                 # save target pointer  SMM 12/97 (E1697)
                 bda_list[i,4] = UNT2$Pointer 
                }                          
             }

           if (bda_found == $no)
            { # new type of bomb for BDA - JFR 6/22/93
             bda_weaps = bda_weaps + 1 # JFR 6/22/93
             bda_list[i,1] = bom$pointer    # JFR 6/22/93
             bda_list[i,2] = bda_list[i,2] + number_bomb_hits # incr nbr of hits 
             # increment warhead weight for this type of bomb
             bda_list[i,3] = bda_list[i,3] + itnt_sum  

             # save target pointer  SMM 12/97 (E1697)
             bda_list[i,4] = UNT2$Pointer 

             # save DEQ$Pointer$Index in case there are more than one of 
             # this type of bomb on unit.    SMM 12/97 (E1697)
             bda_list[i,5] = DEQ$Pointer$Index 
            }                  

           #################### Dec. 23, 1985  <SCC>  #############################
           IF  (log$engage != $no)                # if engagement log is desired
              {
               call engdata(UNT$Pointer,UNT2$Pointer)
               PUTeng$Time$f( game$time )
               PUTeng$Range$f( range )               # get the target range
               PUTeng$Weapon$c( xBOM$Name$c )        # weapon type
               PUTeng$MBURange$f( MBURange(UNT2$Pointer) )       # range to MBU
               if (itnt_sum > 0) # was actually a hit SMM 1/9/96
                  putENG$Result$I   (ENG$Hit$Code)
               else
                 {
                  putENG$Result$I   (ENG$Miss$Code)
                  putENG$ResultPh$F (ph*100.0)
                 }
               call write_eng_rec
              } 
           ######################## End of change <SCC> ###########################

           # amount of tnt hit could have been reduced to 0 by 
           # prob. hit calculations - SMM 12/97 (E1697)
           if (itnt_sum > 0)
             {
              msg_len = 0        # jfr - (E1084)
              call smovhn (xUNT2$Name$C, $$MaxLit, msg, msg_len)
              call smovv  (" DAMAGED BY BOMB HIT", msg, msg_len)
              call send_   (xUNT2$View$I, 0, msg_len, msg)
             }
           else # send miss message SMM 12/97 (E1697)
             {  
              msg_len = 0
              call smovhn (xUNT$Name$C, $$MaxLit, msg, msg_len)
              call smovv  (" MISSED BOMB TARGET.  ", msg, msg_len)
              call send_   (xUNT$View$I, 0, msg_len, msg)
             } 

           IF  (trace$engage$exe != $no)
              {
               call echo ($space)
               call echohn (Xbom$name$c,$$MaxLit)
               call echov (" EPU=")
               call echoi (itnt/100)
              }
          }      # end of if not a ghosted unit being attacked
        }                                       #end do for all bombs

#=======================================================================
# If a nuclear bomb was included in the attack:         #       5/8/85

    IF  (Nuclear$Capable != $NO & iyield  >  0 &         #       12/13/85
        (xUNT$NucFree$I == $YES | xUNT$NucTake$I == $YES)) #    12/13/85
        {
        unt$View$i = Xunt$View$i                        #       5/8/85
        call whside (UNT$View$i,kside)                  #       5/8/85
        indxTgt    = UNT2$Pointer$Index
        IntcptFlag = $NO
        nPH        = 100                                #<<<>>> 5/21/85
        Flat       = Xunt2$TrueLatitude$F          # jb unt2    3/28/89
        Flon       = Xunt2$TrueLongitude$F         # jb unt2    3/28/89
        call Send_Deton
        IF  (Xunt2$type$i == $Shorebase$Code) # jb No nuclear dam- 10/21/86
            {              # age to shorebase (by bombs or otherwise) - so, 
            itnt_sum = max(itnt_sum,7700) # assure some conventional.. 10/21/86
            }
        msg_len = 0        # jfr - (E1084)
        call smovhn (xUNT2$Name$C, $$MaxLit, msg, msg_len)
        call smovv  (" DAMAGED BY NUCLEAR BOMB HIT", msg, msg_len)
        call send_   (xUNT2$View$I, 0, msg_len, msg)
        }

    if ((xUNT2$GhostedUnit$I != $yes) &     # if not a ghost - clk 9/93
        (itnt_sum > 0)) # was actually a hit SMM 1/9/96
      {                                  # setup hits for damage assessment
       unt2$Hits$i =    Xunt2$Hits$i     + itnt_sum        # jb    10/21/86
       unt2$Hits$i =    min(unt2$Hits$i,$Hi_UNT$Hits$I)  # jb - Prevent o'flo  10/21/86
       PUTunt2$Hits$i                                      # jb    10/21/86
    
       unt2$BombHits$I  = Xunt2$BombHITS$I + itnt_sum      # jb    10/21/86
       unt2$BombHits$I  = min(unt2$BombHITS$I,$Hi_UNT$BombHits$I) # jb -vs. o'flo 10/21/86
       PUTunt2$BombHits$I                                  # jb    10/21/86

       # now cycle through the weapons list to generate DSS entry for
       # each type of bomb
       for (i = 1 ; i <= bda_weaps ; i = i + 1)
         {
          bda_bombhits = bda_list[i,3]    # JFR 6/22/93
          bom$pointer = bda_list[i,1]     # JFR 6/22/93
          UNT2$Pointer = bda_list[i,4]    # SMM 12/97 (E1697)
          # now get the values for input to update routine - JFR 6/22/93
          BDA_Nbr_Fired = bda_list[i,2] # get nbr of bombs fired
          BDA_Result_code = $Airbomb$Code

          call GET_DSS_DATA (UNT2$POINTER, UNT$POINTER, Bda_BombHits,
                             BDA_Result_code, BDA_Dam, BDA_TRACKNUMBER,
                             BDA_CLASS, BDA_CLASSID)

          #$% Enter data into the DSS table.   --- JFR 6/16/93
          call Update_Naval_unit_BDA(UNT2$Pointer,          # JFR 6/16/93
                                     UNT$Pointer,           # JFR 6/16/93
                                     $AirBomb$Code,         # JFR 6/16/93
                                     BDA_Result_code,       # JFR 6/16/93
                                     BDA_Dam,               # JFR 7/30/93
                                     BDA_TRACKNUMBER,       # JFR 6/16/93
                                     BDA_CLASS,             # JFR 6/18/93
                                     BDA_CLASSID,            # JFR 9/13/93
                                     BDA_Nbr_Fired,         # JFR 6/16/93
                                     xBOM$Name$C,           # JFR 6/16/93
                                     $no,          # not deferred SMM 12/97 
                                     0.0)          # no deferred time
                            # jb E2208  0.0 vice $NO)   9/27/00
         } # end of for loop through weapons list
      } # end if not a ghosted unit
    if (xUNT2$Type$I == $Shorebase$Code)     # clk - 10/94
      {                                      # WPC C2
       UNT2$TrueLatitude$F = xUNT2$TrueLatitude$F
       UNT2$TrueLongitude$F = xUNT2$TrueLongitude$F
       BOM$Weight$I = xBOM$Weight$I
       iepus = BOM$Weight$I * number_bombs_to_drop / 100

       call Record_Ground_Unit_Attack (UNT$Pointer, UNT2$Pointer,
                                       UNT2$TrueLatitude$F, UNT2$TrueLongitude$F,
                                       BOM$Pointer, number_bombs_to_drop, iepus)
      }

    iover = YES
    }                                           #end if within range
ELSE
    {
    PUTunt$status$i      ($proceeding$code)
    PUTunt$attackindx$i  (UNT2$POINTER$INDEX)   #base as attack guide

    # If standoff range not already set, 
    #   set in priority order of characteristics and shortest loaded weapon
    # joa 2/05 per_sor
    if (Xunt$AttackRange$f == 0.0)
    {
        acc$pointer = Xunt$ACCPntr$i
        standoff_range = Xacc$StandoffRange$f

        max_range = 0
        for (i=1; i <= nfound; i = i + 1)
        {
            if (eqList[4,i] > max_range) max_range = eqList[4,i]
        }

        shortest_range = 1024
        for (i=1; i <= nfound; i = i + 1)
        {
            if (eqList[4,i] < shortest_range) shortest_range = eqList[4,i]
        }

        if (standoff_range == 0.0)
        {
            standoff_range = shortest_range
        }

        # Send warning message if standoff_range greater than max range weapon
        if (standoff_range > max_range)     # joa 2/04 per_sor
        {
            jj = 0
            call smovv ("WARNING: ",msg,jj)
            call smovh (UNT$Name$c,$$MaxLit,msg,jj)
            call smovv (" standoff range of ",msg,jj)
            call smovf (standoff_range, 501, msg, jj)
            call smovv (" nmi exceeds max weapon range of ",msg,jj)
            call smovi (max_range, msg, jj)
            call smovv (" nmi.",msg, jj)
            call send_(UNT$View$i,0,jj,msg)
        }

        standoff_range = standoff_range  - 0.01     # Handle imprecision
        putunt$ATTACKRANGE$F (standoff_range)       # joa 2/05 per_sor

        call rll2rb(xunt$truelatitude$f,xunt$truelongitude$f,
                       xunt$costruelat$f,
                       xunt2$truelatitude$f,xunt2$truelongitude$f,
                       xunt2$costruelat$f,
                       range,bearing)
        bearing = bearing + $PI
        $ang2pi(bearing)
        putunt$attackbearing$F (bearing)

        # Assign return base as guide, and calculate range and bearing
        #   to return to current position
        if (Xunt$GuideIndx$i == 0)
        {
            if (Xunt$LaunchIndx$i != 0)
            {
                unt3$pointer$to Xunt$LaunchIndx$i
                call GETRB_M (UNT3$Pointer, UNT$Pointer,
                                 range, bearing)
                PUTunt$GuideIndx$i (unt3$pointer$index)
                PUTunt$GuideRange$f (range)
                PUTunt$GuideBearing$f (bearing)
                PUTunt$GuideTrue$i ($YES)                            
            }
        }
    }

    iover = NO
    }

return
end        # end of AirBomb

subroutine airAsm (unt$pointer,         # get a/c unit pointer
                   unt2$pointer,        # get target unit pointer
                   mOVER,               # eng. over ? (yes/no)
                   asm_fired)           # return $yes if a weapon was fired
########################################################
#$%
#$% Purpose:   AIRASM processes air-to-surface
#$%            engagements using ASM.
#$%
#$% Called By: 
#$%
#$% Calls:     SmBsunk    GETRB_M
#$%            Get_ASM_or_Bomb_PH
#$%            UPDATE_NAVAL_UNIT_BDA       GET_DSS_DATA
#$%
#$% Tables:    UNT        DEQ
#$%            BOM        MC
#$%
#$% Date:      MAY 83
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 10/94
#$%            Added call to Record_C2_Air_Ground_Eng
#$%            and Record_C2_Flight_EQ_Expended - WPC C2
#$%
#$%            Carol Kropp - 7/95 (E1419)
#$%            Replace 10/94 calls with call to
#$%            Record_Ground_Unit_Attack, which handles C2 and TMS.
#$%
#$%            Carol Kropp - 10/95 (E1455)
#$%            When the target is a "shared" base, an ALSP
#$%            interaction message needs to be sent as well
#$%            as damage assessment to the RESA version of
#$%            the base.
#$%
#$%            JFR (E1104) Added code to handle BDA information
#$%
#$%            Jonathan Richardson - 6/96 (E1084)
#$%            Defined msg & msg_len to send a message to
#$%            the player view when a unit is hit by an ASM.
#$%
#$%             Susan Miller 5/98 (E1988) 
#$%             Added weapon type to get_asm_or_bomb_ph call.
#$%
#$%            Susan Miller 12/97 (E1697)
#$%            Added 2 update_naval_unit_bda parameters to 
#$%            indicate whether damage is deferred. 
#$%            Added miss message. 
########################################################
bbcommon
ENcommon
Eng$ProbHits
Eng$ProbIndx
NUcommon                                        # Nuclear data 5/2/85---clf

LITERAL    CSTRIP8                              # jb E2145  6/28/00
real       mburange
real*4     BDA_Dam # JFR (E1104)
Real*4     mc$probhit$f,rannum
REAL  RANGE, BRG, X, RANDOM,                    # jb E2145  6/28/00
    UNT2$Truelatitude$F,UNT2$Truelongitude$F    # jb E2145  6/28/00

integer    eqlist[5,30], nfound
integer    asm_fired, UNT$MultipleTarget$I      # smm 3/93 (E1103)
integer*4  BDA_ASMHits  # JFR 6/22/93 (E1104)
Integer*4  BDA_tracknumber, BDA_Result_code, BDA_nbr_fired # JFR 6/18/93 (E1104)
Literal    BDA_Class
integer    iepus             # clk 10/94
integer    SHC$Pointer
integer    msg_len
Integer N,IRNG,IPH,IFIRED,I_HITS,I_TNTS,        # jb E2145  6/28/00
    K_ARMHITS,BDA_CLASSID,MOVER,                # jb E2145  6/28/00
    NASM, MRANGE, NRATE                         # jb E2145  6/28/00
Integer UNT$Pointer,UNT$View$I,                 # jb E2145  6/28/00
    MC$Pointer,MC$Maxrange$I,MC$Weight$I,       # jb E2145  6/28/00
    DEQ$Pointer, DEQ$Remaining$I,               # jb E2145  6/28/00
    UNT2$Pointer,UNT2$Hits$I,UNT2$Misshits$I    # jb E2145  6/28/00
BBdeclare (unt3$pointer, acc$pointer, unt$name$c)
real      standoff_range, bearing
integer   max_range, shortest_range, i, jj
character  msg[ARB]
data x/0.0/		# Get next random number in sequence

nfound = 0                                      # init item count
call DEQGET(unt$pointer,        # jb receive UNT pointer    3/22/88
                  $ASM$CODE,                    # receive equipment ident code
                  nfound,                       # receive/return nbr items fnd
                  eqlist)                       # receive/return list of EQ
             
if (nfound == 0)                                # if no ASM's found
    {
    mOVER = YES                                 #  vice iOVER   12/18/85c
    return
    }

if (trace$engage$exe != $no)
   {
    call echor
    call echoV  ('!')                       # jb E2144  (echoV) 8/2/00
    call echov (" Air to Surf (ASM)....")
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" Attacking ")
    call echohn (xunt2$name$c,$$MaxLit)
   }

call getrb_M(_                                    #get range to target
     UNT$pointer,                               #pass A/C pointer
     Unt2$pointer,                              #pass target pointer 3/29/89
     range,                                     #receive range
     brg)                                       #receive bearing

nasm   = $NO                                    #flag no missiles in range
mrange = 1000                                   #start at max missile range
irng   = int(range)                             #get integer range

if (trace$engage$exe != $no)
    {
    call echov (" Rng=")
    call echoi (irng)
    }

for(N = 1; N <= nfound; N = N+1)                #do for all missiles found
    {
    if (eqlist[3,N] == 0) next                  # out-of-stock

    mc$pointer    = eqlist[2,N]                 #get missile pointer
    mc$maxrange$i = Xmc$maxrange$i              #get missile max range
    mc$maxrange$i = MAX(1,mc$maxrange$i)        #               8/7/85

    if(irng <= mc$maxrange$i)                   #if target within range
        {
        if(mc$maxrange$i < mrange)              #if a closer range missile
            {
            mrange = mc$maxrange$i              #save new missile range
            nasm   = n                          #save missile index
            }                                   #end if a closer missile
        }                                       #end if target within range
    }                                           #end do for all missiles found

if (nasm == $NO)                                #if no missiles in range
    {
    PUTunt$status$i ($proceeding$code)
    PUTunt$attackindx$i (unt2$pointer$index)    #target as attack guide

    # If standoff range not already set, 
    #   set in priority order of characteristics and shortest loaded weapon
    # joa 2/05 per_sor
    if (Xunt$AttackRange$f == 0.0)
    {
        acc$pointer = Xunt$ACCPntr$i
        standoff_range = Xacc$StandoffRange$f

        max_range = 0
        for (i=1; i <= nfound; i = i + 1)
        {
            if (eqList[4,i] > max_range) max_range = eqList[4,i]
        }

        shortest_range = 1024
        for (i=1; i <= nfound; i = i + 1)
        {
            if (eqList[4,i] < shortest_range) shortest_range = eqList[4,i]
        }

        if (standoff_range == 0.0)
        {
            standoff_range = shortest_range
        }

        # Send warning message if standoff_range greater than max range weapon
        if (standoff_range > max_range)     # joa 2/04 per_sor
        {
            jj = 0
            call smovv ("WARNING: ",msg,jj)
            call smovh (UNT$Name$c,$$MaxLit,msg,jj)
            call smovv (" standoff range of ",msg,jj)
            call smovf (standoff_range, 501, msg, jj)
            call smovv (" nmi exceeds max weapon range of ",msg,jj)
            call smovi (max_range, msg, jj)
            call smovv (" nmi.",msg, jj)
            call send_(UNT$View$i,0,jj,msg)
        }

        standoff_range = standoff_range  - 0.01     # Handle imprecision
        putunt$ATTACKRANGE$F (standoff_range)       # joa 2/05 per_sor

        call rll2rb(xunt$truelatitude$f,xunt$truelongitude$f,
                       xunt$costruelat$f,
                       xunt2$truelatitude$f,xunt2$truelongitude$f,
                       xunt2$costruelat$f,
                       range,bearing)
        bearing = bearing + $PI
        $ang2pi(bearing)
        putunt$attackbearing$F (bearing)

        # Assign return base as guide, and calculate range and bearing
        #   to return to current position
        if (Xunt$GuideIndx$i == 0)
        {
            if (Xunt$LaunchIndx$i != 0)
            {
                unt3$pointer$to Xunt$LaunchIndx$i
                call GETRB_M (UNT3$Pointer, UNT$Pointer,
                                 range, bearing)
                PUTunt$GuideIndx$i (unt3$pointer$index)
                PUTunt$GuideRange$f (range)
                PUTunt$GuideBearing$f (bearing)
                PUTunt$GuideTrue$i ($YES)                            
            }
        }
    }

    mOVER = NO                                  #  vice iOVER   12/18/85c
    }                                           #end if no missiles in range
else
    {
    mOVER = NO                                  #  vice iOVER   12/18/85c

    PUTunt$engagestatus$i ($engaging$code)
    PUTunt2$UnderAttack$i ($yes)

    mc$pointer = eqlist[2,NASM]                 #get missile pointer

    mc$weight$i = xmc$weight$i                  #get missile warhead weight

    #______________________________________________________________________
    # Get Prob-Hit
    W_Indx = Xmc$WeaponIndex$i
    call Get_ASM_or_Bomb_PH (UNT2$Pointer, w_indx, 
                             mc$probhit$f, $ASM$Code)

    deq$Pointer$TO (eqlist[1,NASM])  

    # if the attacker has multiple targets, only fire one ASM 3/93 SMM
    # clk 11/93 - per Dan Bacon, shoot one salvo, not one asm
    UNT$MultipleTarget$I = xUNT$MultipleTarget$I
    if (UNT$MultipleTarget$I == $yes)
       nrate = xMC$RoundsPerSalvo$I
    else 
       nrate = XUNT$nbrac$i * Xmc$roundspersalvo$i 


    if (xUNT2$GhostedUnit$I == $yes &       # if a ghosted unit with a non-zero
        xUNT2$ALSPid$I != 0)                # ALSP id, then it is an ALSP ghost
      {
        if (nrate > eqlist [3, nasm])    # make sure that no excess ASMs are fired
          nrate = eqlist [3,nasm]

        call ALSP_Send_ASM_or_Bomb_Engage (UNT$Pointer, $ASM$Code,
                                           MC$Pointer,  UNT2$Pointer,
                                           nrate, xUNT$TargetType$I)
        call Log_ALSP_Engagement_engdata (UNT$Pointer,UNT2$Pointer, xMC$Name$C,
                                          INT(range), nrate)          # JHM 7/17/02

        DEQ$Remaining$I = xDEQ$Remaining$I - nrate    # decrement the number of ASMs
        putDEQ$Remaining$I                            # left after engagement

        iepus = nrate
      }
    else                                 # not an ALSP ghost
      {                                  # process the ph and delivered epus
       if (xUNT2$Type$I == $ShoreBase$Code)    # clk 10/95 (E1455)
         {
          SHC$Pointer = xUNT2$SHCpntr$I
          if (xSHC$ALSPSharedBase$I == $yes & ALSP$Active == $yes)
            {
             call ALSP_Send_ASM_or_Bomb_Engage (UNT$Pointer, $ASM$Code,
                                                MC$Pointer,  UNT2$Pointer,
                                                nrate, xUNT$TargetType$I)
             call Log_ALSP_Engagement_engdata (UNT$Pointer, UNT2$Pointer, xMC$Name$C, 
                                       INT(range), nrate)         # JHM 7/17/02
            }
         }

           # this block is for nuclear attacks                     5/2/85---clf
           iyield = xMC$Yield$I
           if (Nuclear$Capable == $YES & iyield > 0 &
              (xUNT$NucFree$I == $YES | xUNT$NucTake$I == $YES))
             {
               unt$View$i = Xunt$View$i                        #       5/8/85
               call whside (UNT$View$i,kside)                  #       5/8/85
               iBurst     = xMC$BurstType$I
               indxTgt    = UNT2$Pointer$Index
               iDepth     = xMC$BurstDepth$I +1        # +1    5/8/85
               IntcptFlag = $NO
               nPH        = mc$probhit$f        # jb adjusted if SmallBoat 4/26/89
               Flat       = xUNT2$TrueLatitude$F
               Flon       = xUNT2$TrueLongitude$F     

               msg_len = 0        # jfr - (E1084)
               call smovhn (xUNT2$Name$C, $$MaxLit, msg, msg_len)
               call smovv  (" DAMAGED BY NUCLEAR ASM", msg, msg_len)
               call send_   (xUNT2$View$I, 0, msg_len, msg)

               call Send_Deton

               eqlist[3,NASM] = eqlist[3,NASM] - 1
               if (eqlist[3,NASM] < 0)  eqlist[3,NASM] = 0 # jb    5/18/89
               PUTDeq$Remaining$i (EQLIST[3,nasm])

               putUNT$NucTake$I      ($NO)

               if(xUNT2$TYPE$I == $ShoreBase$Code)     # jb Since NUCDAM gives 10/21/86
                {                              # no damage VS shorebases, this 10/21/86
                 UNT2$HITS$I = XUNT2$HITS$I            # insertion is made to  10/21/86
                 UNT2$HITS$I = max(UNT2$HITS$I,77)     # cause some to occur   10/21/86
                 putUNT2$HITS$I                        #  by bringing the      10/21/86
                 UNT2$MissHITS$I = XUNT2$MissHITS$I    #  conventional damage  10/21/86
                 UNT2$MissHITS$I = max(UNT2$MissHITS$I,77) # model
                 putUNT2$MissHITS$I                    #  into play...         10/21/86
                }
             }       #       end of nuclear code
           ELSE 
             {
               if (trace$engage$exe != $no)
                 {
                   call echov (" w/")
                   call echohn (Xmc$name$c,$$MaxLit)
                   call echov (" Ph=")
                   iph=mc$probhit$f*100
                   call echoi (iph)
                   call echo ($percent)
                   call echo ($space)
                 }

               i_hits = 0
               for(N = 1; N <= NRATE; N = N+1)         #do for max that can be fired
                 {
                   eqlist[3,NASM] = eqlist[3,NASM] - 1 #decrement missile count
                   if (eqlist[3,NASM] < 0)  eqlist[3,NASM] = 0 # jb    5/18/89

                  if (trace$engage$exe != $no)
                    call echoi (n)

                  Rannum = Random(X)

                  IF  (mc$probhit$f >= rannum)      # if hit
                    {
### intra emi                                   airasm 10/90 hdf
                      IF  (( EMI$IntraPlatform != $no ) & (EMI$Analysis != $NO))
                        {
                          DEQ$Pointer$To Eqlist[1,NASM]
                        }

                      if (trace$engage$exe != $no)
                        call echov (" Hit ")

                      i_hits = i_hits + 1

######### write a record for each weapon fired. Dec. 16, 1985 <SCC> #########
                      if (log$engage != $no)       # if engagement log is desired
                        {
                         call engdata(UNT$Pointer,UNT2$Pointer)
                         PUTeng$Time$f( game$time )
                         PUTeng$MBURange$f( MBURange(UNT2$Pointer) )      # range to MBU
                         PUTeng$Range$f( float(irng) )                    # range to target
                         PUTeng$Weapon$c( Xmc$name$c )                    # get weapon name
                         PUTeng$Result$i( eng$Hit$code )
                         call write_eng_rec
                        }
                    }                               #end if hit
                  else        # a miss
                    {
                      if (log$engage != $no)       # if engagement log is desired
                        {
                         call engdata(UNT$Pointer,UNT2$Pointer)
                         PUTeng$Time$f( game$time )
                         PUTeng$MBURange$f( MBURange(UNT2$Pointer) )      # range to MBU
                         PUTeng$Range$f( float(irng) )                    # range to target
                         PUTeng$Weapon$c( Xmc$name$c )                    # get weapon name
                         PUTeng$Result$i( eng$Miss$code )
                         PUTeng$Resultph$f( mc$probhit$f * 100. )
                         call write_eng_rec
                        }

                    }         # end of a miss
############################ end of change <SCC> ###############################

                  if(eqlist[3,NASM] <= 0)             #if all missiles fired
                    {
                      eqlist[3,NASM] = 0
                      PUTdeq$remaining$i (0) # delete msl 

                      break                          #exit loop for salvo
                    }                                #end if all missiles fired
                 }                                   #end do for max that can fire

               # E2287 JOA UFL02 - Move hit miss message out of rate loop
               if (i_hits == 0)                      # all missiles missed
                 {
                     # send a miss message to the firing unit SMM 12/97 (E1697)
                     msg_len = 0
                     call smovhn (xUNT$Name$C, $$MaxLit, msg, msg_len)
                     call smovv  (" ASM MISSED TARGET.  ", msg, msg_len)
                     call send_   (xUNT$View$I, 0, msg_len, msg)
                 }
               else                                  # Some missiles hit
                 {
                      msg_len = 0        # jfr - (E1084)
                      call smovhn (xUNT2$Name$C, $$MaxLit, msg, msg_len)
                      call smovv  (" DAMAGED BY ASM", msg, msg_len)
                      call send_   (xUNT2$View$I, 0, msg_len, msg)
                 }

               i_tnts = i_hits * mc$weight$i           #compute lbs TNT

               PUTunt2$hits$i     (Xunt2$hits$i     + i_tnts)  # record tnt's
               PUTunt2$MissHits$I (Xunt2$MissHits$I + i_tnts)

               if (Xmc$ARMflag$i != $NO)               # this is an ARM..      3/6/85
                 {
                  k_ARMhits = i_hits * mc$weight$i    # additional ARM lbs TNT 3/6/85
                  PUTunt2$ARMhits$I (Xunt2$ARMhits$I + k_ARMhits)     #       3/6/85
                 }

               # damage incurred    # and not an ARM
               if (i_hits > 0)      # & Xmc$ARMflag$i == $NO) 
                                    # don't know why this was here SMM 1/16/96
                                    # ARM missiles were not being recorded
                 {# perform battle damage assessment - JFR 6/22/93 (E1104)
                  # now get the values for input to update routine 
                  BDA_Nbr_Fired = i_hits      # get nbr of ASM's fired 
                  BDA_ASMHits = i_tnts        # get ASM warhead weight for BDA 
                  BDA_Result_code = $AirToSurfMissile$Code

                  call GET_DSS_DATA (UNT2$POINTER, UNT$POINTER, BDA_ASMHits,
                                     BDA_Result_code, BDA_Dam, BDA_TRACKNUMBER,
                                     BDA_CLASS, BDA_CLASSID)

                  #$% Enter data into the DSS table.   --- JFR 6/16/93
                  call Update_Naval_unit_BDA(UNT2$Pointer,     # JFR 6/16/93
                                       UNT$Pointer,            # JFR 6/16/93
                                       $AirtoSurfMissile$Code, # JFR 6/16/93
                                       BDA_Result_code,        # JFR 6/16/93
                                       BDA_Dam,                # JFR 7/30/93
                                       BDA_TRACKNUMBER,        # JFR 6/16/93
                                       BDA_CLASS,              # JFR 6/18/93
                                       BDA_CLASSID,            # JFR 9/13/93
                                       BDA_Nbr_Fired,          # JFR 6/16/93
                                       xMC$Name$C,             # JFR 6/16/93
                                       $no, 0.0)               # no deferred time
                                    # jb E2208 0.0 vice $NO)   9/27/00
                 }
               PUTdeq$remaining$i (eqlist[3,NASM]) # restore msls 
             }  #    End of else NOT nuclear..                  
           iepus = i_hits
      }         #    end of target is not a ghosted unit

    if (xUNT2$Type$I == $Shorebase$Code)     # clk - 10/94
      {                                      # WPC c2
       UNT2$TrueLatitude$F = xUNT2$TrueLatitude$F
       UNT2$TrueLongitude$F = xUNT2$TrueLongitude$F
       ifired = iepus                        # iepus was the # fired
       iepus = xMC$Weight$I * ifired / 100

       call Record_Ground_Unit_Attack (UNT$Pointer, UNT2$Pointer,
                                       UNT2$TrueLatitude$F, UNT2$TrueLongitude$F,
                                       MC$Pointer, ifired, iepus)
      }

    if (UNT$MultipleTarget$I == $yes)   # SMM 3/93 (E1103)
      {
       if (xUNT$EngageStatus$I == $Engaging$Code)
          putUNT$EngageStatus$I ($EngagementOver$Code)
       putUNT$Status$I ($Proceeding$Code)
       putUNT$AttackIndx$I ($no)
       putUNT$AssignedTarget$I ($no)
       putUNT$AttackedTarget$I ($yes)
       asm_fired = $yes  
      }
    }           #    end of ASM within range

nfound = 0                                      # init item count
call DEQGET(unt$pointer,        # jb send UNT pointer    3/22/88
                  $ASM$CODE,                    # send equipment ident code
                  nfound,                       # receive nbr items fnd
                  eqlist)                       # receive list of EQ
             
if (nfound == 0)                                # if no ASM's found
    mOVER = YES                                 #  vice iOVER   12/18/85c

return
end             # end of AirASM


subroutine airOver(unt$pointer,                #get a/c unit pointer
                   unt2$pointer)               #get target unit pointer

########################################################
#$%
#$% Purpose:   AIROVER processes completion of air-to-surface
#$%            engagements.
#$%
#$% Called By: ATOSUR   ATOSUB
#$%
#$% Calls:     BINGO
#$%
#$% Tables:    
#$%
#$% Date:      MAY 83
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Susan Miller 3/25/95  removed ASM_fired, Bomb_dropped
#$%            because they are not used.
#$%
#$%            Carol Kropp - 7/95 (E1419)
#$%            Added missions AI, BAI and CAS to the auto
#$%            bingo list when engagement is complete.  Also
#$%            added message to let play know.
#$%
########################################################
bbcommon

LITERAL    CSTRIP8                              # jb E2145  6/28/00
integer     eqlist[5,ARB], nfound, kfound, ASM_found, Bomb_found
integer     UNT$MultipleTarget$I
integer     msg_len
Integer  UNT2$Pointer, UNT3$Pointer,
    UNT$Pointer,UNT$Mission$I                   # jb E2145  6/28/00

character   msg[ARB]

UNT$MultipleTarget$I = xUNT$MultipleTarget$I

if (trace$engage$exe != $no)
   {
    call echor
    call echov  ('!')
    call echov (" Air to Surf (ASM)....")
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" Attacking ")
    call echohn (xunt2$name$c,$$MaxLit)
   }

if(xunt$engagestatus$i==$engaging$code)
    {
    PUTunt$engagestatus$i ($engagementover$code)
    }

call Clear_BTT_Info (UNT$Pointer)   # clk 7/95 (E1419)

#---------- Moved up fm below IF; removed ELSE.. jb     4/3/87
if (UNT$MultipleTarget$I != $yes) 
    {
    UNT3$Pointer$To XUNT$AttackIndx$I # jb (no X)    1/3/00 
    if (unt3$pointer$ok)
        putUNT3$UnderAttack$i ($NO)  # send the target on his way
     PUTunt$RulesOfEngage$i ($IfAttacked$code)
     PUTunt$status$i ($proceeding$code)
     PUTunt$AssignedTarget$i ($NO)
     PUTunt$attackindx$i ($NO)
    }
#-------------------------------------------------

UNT$Mission$I = xUNT$Mission$I
if (UNT$Mission$I == $Strike$Code                    |
    UNT$Mission$I == $AirInteraction$Code            |
    UNT$Mission$I == $BattleFieldAirInteraction$Code |
    UNT$Mission$I == $CloseAirSupport$Code           )  
    {                                   
    ASM_found = 0
    Bomb_found = 0

    # if multiple target set to yes, then we only dropped 1 ASM or bomb salvo
    # and there may be some left        SMM 3/93
    if (UNT$MultipleTarget$I == $yes) 
        {
         call DEQGET(unt$pointer,    # send UNT pointer
                     $ASM$Code,      # send equipment ident code
                     ASM_found,      # receive nbr items found
                     eqlist)         # receive list of EQ

         if (ASM_found == 0)
            {
             call DEQGET(unt$pointer,    # send UNT pointer
                         $Bomb$Code,     # send equipment ident code
                         Bomb_found,     # receive nbr items found
                         eqlist)         # receive list of EQ
            }
        }

    nfound = 0    # jb    Set 0 for non-iterative call        7/25/89
    call DEQGET(unt$pointer,                  # jb send UNT pointer 3/22/88
                $CruiseMissile$Code,          # send equipment ident code
                nfound,                       # receive nbr items fnd
                eqlist)                       # receive list of EQ

    kfound = 0    # jb    Set 0 for non-iterative call        8/29/89
    call DEQGET(unt$pointer,                  # jb send UNT pointer
                $GUN$Code,          # send equipment ident code 8/29/89
                kfound,                       # receive nbr fnd 8/29/89
                eqlist)                       # receive list of EQ

    # if no CruiseMissiles, Guns, ASMs or bombs 3/93 SMM
    if (nfound + kfound + ASM_found + Bomb_found < 1)  
      {
        call bingo(unt$pointer)                  #recall the flight

        msg_len = 0
        call smovv  (" From: ", msg, msg_len)
        call smovhn (xUNT$Name$C, $$MaxLit, msg, msg_len)
        call smovv  (", all surface weapons expended, returning to base. ",
                                                              msg, msg_len)
        call send_   (xUNT$View$I, 0, msg_len, msg)
      }
    else if ( nfound == 0 )                   # jb             10/17/89 
        if (UNT$MultipleTarget$I != $yes) 
            PUTunt$OrderedSpeed$F (222.3)         # jb             9/5/89 
    }    # End if STRIKE mission

return
end     # end of AirOver

subroutine airrad (unt$pointer)                #engage enemy/nonfriendly air

########################################################
#$%
#$% Purpose:   AIRRAD initializes surface-to-air
#$%            engagements using SAM and CIWS as
#$%            applicable.
#$%
#$% Called By: EPROSS
#$%
#$% Calls:     SAMENG   deqget  getrad  sort_eqlist
#$%            Adv_SAM_engage   target_name(WGMDENG_GUNS.RIN)
#$%                             
#$% Tables:    UNT        MC
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Susan Miller 7/1/94 PER #E1308 to allow a SAM
#$%            the chance to be fired even if the firing unit 
#$%            has been targeted.
#$% 
#$%            JFR 7/18/94 PER E1252 Modify SAM engagements so
#$%            a SAM will shoot as soon as the target is detected,
#$%            in range, and satisfies ROE.  Then revert to 
#$%            SHOOT-LOOK-SHOOT or SHOOT-LOOK-LOOK-SHOOT.
#$%
#$%            Susan Miller 4/99 (E1969)
#$%            Added call to Take_Using_SAM so if the assigned target
#$%            is from a TAKE (using) SAM command, it will be
#$%            processed as such rather than an ROE assigned target.
#$%
########################################################
bbcommon

LITERAL    CSTRIP8                  # jb E2145  6/28/00
literal target_name  # function to get rmt track number SMM 4/99 (E1969)
literal ILEX[20]     # SMM 4/99 (E1969)
integer         eqlist[5,30], nfound
integer         nraid[31], ranges[31], mxxx
integer         UNT$AssignedTarget$I 

# added array to hold local track pointers used to test flag value
integer         nlocal[31]  # JFR 7/18/94 PER E1252
integer ORD$Pointer  # SMM 4/99 (E1969)
Integer N,IWORD,MRANGE,MLIMIT,   # jb E2145  6/28/00
    UNT2$Pointer,UNT2$Type$I,    # jb E2145  6/28/00
    UNT$Pointer, MC$Pointer, UNT3$Pointer

nfound = 0                                      # init item count

# if this is a TAKE using SAM order and their is an assigned target,
# call appropriate routine SMM 4/99 (E1969)
UNT$AssignedTarget$I = xUNT$AssignedTarget$I
if ((xUNT$TakeUsingSAM$I == $YES) & (UNT$AssignedTarget$I != 0))
    {
     iword = 3
     ilex[1] = $lex$TAKE$
     ilex[2] = target_name(UNT$Pointer, UNT$AssignedTarget$I)
     ilex[3] = $lex$SAM$ 
     ORD$Pointer = 0
     call Take_using_SAM (UNT$Pointer, iword, ILEX, ORD$Pointer)
    }
# process advanced SAM engagements first as long as this isn't a previous take SMM 4/99 (E1969)
else if ((xUNT$FirstAEGIndex$I != 0) &
         (xUNT$SamCapable$I != 0)) call Adv_SAM_engage(UNT$Pointer)

if (Xunt$UnderAttack$i == $YES)                 #if this is defensive action
     call DEQGET(unt$pointer,   # jb UNT pointer    3/22/88
                  $CIWS$Code,           # equipment ident code
                  nfound,                       # <- nbr items fnd ->
                  eqlist)                       # <- list of EQ ->

#ELSE 
# removed the else so that a SAM would be allowed the chance to shoot
# whether the firing unit was under attack or not.  SMM 7/1/94 PER # E1308
call DEQGET(unt$pointer,        # jb UNT pointer ELSE  5/18/89
                  $SAM$Code,            # equipment ident code
                  nfound,                       # <- nbr items fnd ->
                  eqlist)                       # <- list of EQ ->


#______________________________________________________________________
# extract Max-Range & Engagement limits for all weapons 

mrange = 0
mlimit = 0

for (n=1; n <= nfound; n=n+1)
    {
    mc$pointer    = eqlist[2,n]                 # get MC pointer
    mxxx          = Xmc$maxRange$i              # get max range 8/7/85
    eqlist[4,n]   = MAX(1,mxxx)                 #               8/7/85
    eqlist[5,n]   = Xmc$NbrSimEngages$i         # Simult-Engmt limit

    mlimit = mlimit + eqlist[5,n]               # summ limits

    mrange = max(mrange,eqlist[4,n])    # save maximum MISSILE range
    if( Level$AA > 0 ) mrange = 1.5 * mrange  #<<<>>>or FIRING range
    }                                                   # 1/14/87

if (mlimit > 30) mlimit = 30

#______________________________________________________________________
# sort weapons by increasing range

call sort_eqlist (eqlist,nfound,4)              # sort equip list by range

if (mlimit == 0) return

#______________________________________________________________________
# get the targets

call getrad (unt$pointer,               # get MLIMIT targets within MRANGE
             mrange,                    # Pass Max Range
             mlimit,                    # pass engagement limit
             Nraid,                     # return target pointers
             nlocal,                    # return local track pointers JFR 7/18/93
             ranges)                    # return target ranges

if (Nraid[1] == 0)                         ## 10/10/85 <RG>  If no air targets
  {                                        ## and his assigned target
   UNT$AssignedTarget$I = xUNT$AssignedTarget$I
   if (UNT$AssignedTarget$I != 0)   # check for valid target  SMM 4/99 (E1969)
     {
      unt2$pointer$to  unt$AssignedTarget$i  ## is aircraft or CM, set his 
      unt2$type$i = Xunt2$type$i              ## indexes back to zero so he can
      if (unt2$type$i == $Air$code |          ## be reassigned a new target.
          unt2$type$i == $CruiseMissile$code)
        {
         UNT3$Pointer$To XUNT$AttackIndx$I # jb (no X)    1/3/00 
         if (unt3$pointer$ok)
            putUNT3$UnderAttack$i ($NO)  # send the target on his way
         PUTunt$AssignedTarget$i  ($No)
         PUTunt$AttackIndx$i      ($No)
        }
     } # end assigned target SMM 4/99 (E1969)
   return
  }

if (trace$engage$exe != $no & Xunt$UnderAttack$i == $YES)
    {
    call echor
    call echoV  ('!')                   # jb E2144  (echoV) 8/2/00
    call echov ("Air Raid....")
    call echohn (xunt$name$c,$$MaxLit)
    call echov (" MRng=")
    call echoi (mrange)
    call echov (" ELim=")
    call echoi (mlimit)
    call echov (" SAMtypes=")                        ##      2/8/84
    call echoi (Nfound)
    }

#______________________________________________________________________
# process engagement
call sameng(_                                   # call SAM engagement
            unt$pointer,                        # pass unit pointer
            eqlist,                             # pass sam&ciws data 
            nfound,                             # pass nbr of EQs
            mrange,                             # pass MAX range
            mlimit,                             # pass engagement limits
            Nraid,                              # pass target pointers
            nlocal,                             # pass local track pointers JFR 7/18/94
            ranges)                             # pass target ranges

return
end                     # end of airrad

subroutine sameng(_                             #process surf->air engagements
                  unt$pointer,                  # receive unit pointer
                  eqlist,                       # receive sam&ciws data 
                  nfound,                       # receive nbr of EQs
                  mrange,                       # receive MAX range
                  mlimit,                       # receive engagement limits
                  Nraid,                        # receive target pointers
                  nlocal,                       # receive lcl track pntrs JFR 7/18/94
                  ranges)                       # receive target ranges

########################################################
#$%
#$% Purpose:   SAMENG processes surface-to-air
#$%            engagements, computes number of
#$%            hits, damage level, and weapon
#$%            assets remaining.  Multiple en-
#$%            gagements are also processed.
#$%
#$% Called By: AIRRAD
#$%
#$% Calls:     GETBOG   MBURange    ENGDATA     SEND_DETON
#$%            Get_SAM_Probability_of_Hit
#$%            Process_SAM_Hit
#$%
#$% Tables:    UNT        MC
#$%            LCL        AML        
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - March, Sept. 1993
#$%            Moved code to compute PK and process a
#$%            hit to separate subroutines, for modularity
#$%            and reuseability.  Also added for shooting
#$%            SAMs at ghosted units.
#$%
#$%            Susan Miller 6/30/94  changed the variable tstrng
#$%            to an integer and added 0.5 to its calculation so
#$%            that if the attacking unit has a speed of 0 (meaning
#$%            it is probably right on top of it's target), tstrng
#$%            will be at least one.  This will then preclude $CIWS
#$%            weapons from being subjected to the every other minute
#$%            or every third game cycle selection process.
#$%
#$%            JFR 7/18/94 PER E1252 Modify SAM engagements so
#$%            a SAM will shoot as soon as the target is detected,
#$%            in range, and satisfies ROE.  Then revert to 
#$%            SHOOT-LOOK-SHOOT or SHOOT-LOOK-LOOK-SHOOT.
#$%
#$%            JFR (E1104) Add code to handle BDA.
#$%
#$%            Carol Kropp - 11/96 (E1695)
#$%            Added checks to ensure that the local table
#$%            pointer is good before modifying table data,
#$%            the target may not be directly detected by the
#$%            attacker.
#$%
#$%            Susan Miller - 7/97 (E1430)
#$%            Send a message when all SAMs are expended.
#$%
########################################################
BBcommon
ENcommon
Eng$ProbHits
Eng$ProbIndx
NUcommon        # holds variables needed by SEND_DETON  4/4/85

literal         ixname
LITERAL     UNT2$Name$C, CSTRIP8                  # jb E2145  6/28/00
REAL        X, RANDOM, UNT2$Truespeed$F           # jb E2145  6/28/00
Real*4          Rannum,mc$probkill$f
real*4          spj_factor  # jecewsi - JFR 9/28/94
real            mburange
real*4          TimeSinceFire
integer         eqlist[5,ARB], nfound
integer         nraid[ARB], ranges[ARB],t,m,DEQ$Pointer
integer         tstrng 
integer         nlocal[ARB] # JFR 7/18/94 PER E1252
integer         BDA_Nbr_Fired    # JFR 9/24/93 (E1104)
integer         MC$Pointer, msglen   # SMM 7/97 (E1430)
Integer N,NL,NX,NFIRE,NHIT,NKILL,NTARG,ICAN,      # jb E2145  6/28/00
    NTARGT,IAIRTG,IPH,IPH_RANGE,ISPDMI,           # jb E2145  6/28/00
    UNT2$Pointer,UNT2$Type$I,                     # jb E2145  6/28/00
    LCL$Pointer,LCL$Tallyho$I,                    # jb E2145  6/28/00
    LCL$Remaining$I,LCL$Detectee$I,               # jb E2145  6/28/00
    AML$Pointer,AML$Nextindx$I,                   # jb E2145  6/28/00
    UNT$Pointer,UNT$Assignedtarget$I,             # jb E2145  6/28/00
    ACC$Pointer, CMC$Pointer, UNT3$Pointer,
    MC$Maxrange$I,                                # jb E2145  6/28/00
    mrange,mlimit   # arguments no longer used

character       msg[ARB]
logical*1       UAV_too_high
data x/0.0/		# Get next random number in sequence

IF  (trace$engage$exe != $no & nraid[1] != 0)
    {
    call echor
    call echoV  ('!')                   # jb E2144  (echoV) 8/2/00
    call echohn(Xunt$name$c,$$MaxLit)
    call echov ("-Raid:")
    for (nx=1; nx<=21; nx=nx+1)
        {
        IF  (nraid[nx]==0) 
            break
        call echo  ($space)
        unt2$pointer = nraid[nx]
        unt2$name$c = xunt2$name$c
        IF  (unt2$name$c != 0)  
            call echohn (unt2$name$c,$$MaxLit)
        ELSE                   
            call echoi (unt2$pointer$index)
        call echov ("@")
        call echoi (ranges[nx])
        }
    }

t      = 0                                      # zero target pointer
ntarg  = 0
ntargt = 0

IF  (nfound < 1)                            ## 10/10/85 <RG>  If no SAM's
    {                                        ## to fire and his assigned target
    unt2$pointer$to  Xunt$AssignedTarget$i  ## is aircraft or CM, set his 
    unt2$type$i = Xunt2$type$i              ## indexes back to zero so he can
    IF  (unt2$type$i == $Air$code |          ## be reassigned a new target.
         unt2$type$i == $CruiseMissile$code)
        {
        UNT3$Pointer$To XUNT$AttackIndx$I # jb (no X)    1/3/00 
        if (unt3$pointer$ok)
            putUNT3$UnderAttack$i ($NO)  # send the target on his way
        PUTunt$AssignedTarget$i  ($No)
        PUTunt$AttackIndx$i      ($No)
        }
    }

m = 1                                   # point to first missile
repeat                  # Thru targets within weapons (CIWS/SAMs)
        
    {
    BDA_Nbr_Fired = 0   # JFR 9/24/93 (E1104)

    IF  (m > nfound ) break              # if out of SAM's/CIWS

    IF  (ntargt <= 0)                    # if out of targets within unit
        {
        t = t + 1                       # get data for next target
        unt2$pointer = nraid[t]
        lcl$pointer = nlocal[t]         # get data for shooters local tracks - JFR 7/18/94
        IF  (! unt2$pointer$ok) BREAK            # if out of units

        IF  (Xunt2$type$i == $air$code)          # if target is aircraft Vs CM
            {
            iairtg = $yes                       # set air target to YES

            aml$NextIndx$i = xUNT2$AmlIndx$i   

            ntarg = Xunt2$NbrAc$i               

            ACC$pointer = Xunt2$AccPntr$i       
            T_indx = Xacc$TargetIndex$i         # Tgt index in EPH table

            UAV_too_high = xACC$UAVflag$i == $YES & _            # dew 3/20/90
                           Xunt2$TrueAltDepth$i > UAV$Engagement$Ceiling
            }
        ELSE
            {
            iairtg = $no                # set air target to NO
            ntarg = 1                   # set target counter to one

            CMC$pointer = Xunt2$CmcPntr$i
            T_indx = Xcmc$TargetIndex$i         # Tgt index in EPH table
            UAV_too_high = .false.                              # dew 3/20/90
            }

        ntargt = ntarg                  # set targets remaining
        nkill = 0                       # zero number of kills

        next
        }     # end if out of targets within unit

    
    IF  ( eqlist[3,m] <= 0 |             # if out of this type missile or...
          eqlist[5,m] <= 0 )             # engagement limit met or....
        {
        m = m+1                           #    get next missile type
        next
        }
    
    unt2$TrueSpeed$F = Xunt2$TrueSpeed$F    
    #~Threat trvl in 1 min 3/29/89             # changed tstrng to an integer
    tstrng = INT(((unt2$TrueSpeed$F+30.) * $Hours$per$Minute)+0.5)      # SMM 6/30/94

        ##-- Pulled up here from below to avoid unnecessary processing  1/28/87
    mc$Pointer = eqlist(2,m)                    # jb    2/9/87
    DEQ$Pointer$To Eqlist[1,m]
    TimeSinceFire = game$time - Xdeq$TimeLastUsed$f
    IF  (Xmc$Type$I == $CIWS$Code &             # jb    3/25/86
        Xunt2$AttackIndx$i ==UNT$pointer$INDEX & # DEFENSE!!2/6/87
        tstrng >= ranges[t]) #  Bypass S-L-S if Threat is         3/25/86
        {                    #  within ~ a minute of arrival..
            # INCOMPLETE: indicates tentative point-of-contact with CIWS,
            # but doesn't yet provide for passing of CIWS arrays..etc.
            # ???Need to add arrays/spawn vice call?/arrange for entry of
            # results and/or intra-minute update of arrays/???/reset of
            # CIWS$BUSY....
        If ( 1 >2 & CIWS$Busy == $NO)            # jb           7/22/91
            {
            CIWS$Busy = $YES
##            Call CIWS(UNT2$Pointer,        # Airborne Target
##                      UNT$Pointer)         # CIWS' platform
##            RETURN
            }

        }                      
    ELSE IF ((ranges[t] > 40 &      # Only ev. 3 minutes if 3/15/84
              TimeSinceFire < 3.) | # 3     range > 40.     2/10/84
             (ranges[t] <= 40 &     # Every 2 minutes if    3/15/84
              TimeSinceFire < 2.) ) # 2     range <= 40.    3/15/84
        {
        m = m+1                          #                       2/10/84
        NEXT                             #                       2/20/84
        }
        ##-- End of section pulled up here from just before CALL GETBOG 1/28/87

#####-----------  Range-Rate Option     1/13/87  ---------------------------

    IspdMI       = Xmc$AVspeed$i        # Msl Average Speed     1/13/87

    IF  ( LEVEL$AA < 1 | IspdMI < 100 )  # Range-rate not to be computed 1/13/87
        {
        IF  ( eqlist[4,m] < ranges[t] &    #  If not in range &
            tstrng      < ranges[t]  )   #  threat >1 min. away  3/17/86
            {
            m = m+1                         #    get next missile type
            next
            }
        }
    ELSE                                # Consider Range-Rate   1/13/87
        {
        mc$MaxRange$i = Xmc$MaxRange$i            # jb    moved up 4/9/87
        IF  (ranges[t] > 1.5 * mc$MaxRange$i)       # jb            4/9/87
            {
            m = m+1                         #    skip this missile  4/9/87
            next                                    # jb            4/9/87
            }
       call SHOOTAA(unt$pointer,  # (IN) Shooting Unit           1/13/87
                    unt2$pointer, # (IN) Target
                    ican,   # (OUT) Flag - whether might intercept 
                    IspdMI) # Msl AvgSpeed IN;  Miles To Go, OUT
 
       IF  ( (ican < 0) | (IspdMI > mc$MaxRange$i) ) # Too far, or Msl too slow 
           {
           m = m+1                         #    get next missile type
           next
           }          
        }  # End of ELSE consider range rate...
#####-----      End of Range-Rate experiment 1/13/87    ---------------------
    
    call getbog (_                      #get detection pairing
                 unt$pointer,           #pass detector
                 unt2$pointer,          #pass detectee
                 LCL$POINTER)           #receive detection pointer

    mc$pointer = eqlist[2,m]            # set MC pointer for SAM or CIWS
    call Get_SAM_Probability_of_Hit (UNT2$Pointer, MC$Pointer,
                                     t_indx, MC$ProbKill$F, iph_range)

    if (JECEWSI$Game != $no)   # if JECEWSI is participating, factor in
       {                       # self protect jamming effects - jfr 8/17/94
        call get_jecewsi_factor (UNT$Pointer, UNT2$Pointer, $spj, spj_factor)
        MC$ProbKill$F = MC$ProbKill$F * spj_factor
       }

    if (iph_range < ranges [t])         # if the target is out of range
      {
       m = m + 1      # increment missile counter
       next           # proceed to the next iteration of the repeat
      }

    #------ Inserted for UAV's too high for SAMs                3/20/90
    IF  (UAV_too_high) 
        mc$probkill$f = 0.0

    IF  (trace$engage$exe != $no)
        {
        call echor
        call echov  ("! Sam Fire.... w/")
        call echohn (Xmc$name$c,$$MaxLit)

        call echov (" Pk=")
        iph=mc$probkill$f*100
        call echoi (iph)
        call echov ("%   ")

        unt2$pointer = nraid[t]
        ixname = xunt2$name$c
        IF  (ixname != 0) 
            call echohn (ixname,$$MaxLit)
        ELSE             
            call echoi(unt2$pointer$index)
        call echo ($LBrack)
        call echoi (ntargt)
        call echov ("] @ ")
        call echoi (ranges[t])
        call echo  ($space)
        }

    PUTunt$engagestatus$i ($engaging$code)      # set engage status

    PUTunt2$UnderAttack$i ($YES)                # set under attack to YES

    if (LCL$Pointer$Valid)     # clk 11/96 (E1695)
      {                        # could be shooting at someting not detected
       lcl$TallyHo$i = Xlcl$TallyHo$i              # get tally ho

       # if tally ho is zero, update DB w/number of targets
       IF  (lcl$TallyHo$i == 0) 
           PUTlcl$TallyHo$i (Ntarg)
      }

    nL = nL +1                                  # Count of launches 2/8/84
    nfire = 1                                   # weapon fire to one

    rannum = random(x)                          # generate random number

##intra emi :

    IF  (mc$probkill$f >= rannum) 
        {
        IF  (( EMI$IntraPlatform != $no ) & (EMI$Analysis != $NO))
            {
            DEQ$Pointer$To Eqlist[1,m]
             }
         }

    if (xUNT2$GhostedUnit$I == $yes &     # clk 9/93 - if the target is a ghost
        xUNT2$ALSPid$I != 0)              # send a message and record the firing
      {
       call ALSP_Send_SAM_Engage (UNT$Pointer, MC$Pointer,
                                  UNT2$Pointer, nfire, nfire)
       call Log_ALSP_Engagement_engdata (UNT$Pointer,UNT2$Pointer, xMC$Name$C,
                                         ranges[t], nfire)                      # JHM 7/16/02
      }
    else       # target is not ghosted via ALSP
      {
       IF  (mc$probkill$f >= rannum) 
           nhit = 1       # HIT ?
       ELSE                         
           nhit = 0       # Miss ?

       ## <<RG>>   (JULY 1985)
       ## THIS CODE IS USED FOR ENGAGEMENT LOG DATA COLLECTION
       IF  (log$engage != $no)              # if engagement log is desired
           {
            call engdata (UNT$Pointer, UNT2$Pointer)
            PUTeng$Time$f( game$time )
            PUTeng$Weapon$c( Xmc$name$c )         # weapon name
            PUTeng$MBURange$f( MBURange(UNT2$Pointer) )     # range to MBU
            PUTeng$Range$f( ranges[t] )           # range to target
            IF  (nhit > 0)                  # if one was hit
               PUTeng$Result$i( eng$Hit$code )
            ELSE
              {
               PUTeng$Result$i( eng$Miss$code )
               PUTeng$Resultph$f( mc$probkill$f * 100.)
              } 
            call write_eng_rec
           } ## END (log$engage != $no)

       IF  (trace$engage$exe != $no)
           {
           IF  (nhit == 1) 
               call echov (" Hit")
           ELSE           
               call echov (" Miss")
           }

       BDA_Nbr_Fired = BDA_Nbr_Fired + 1           # JFR 9/24/93 (E1104)
       nkill = nkill + nhit                        # compute number killed

       IF  (iairtg != $no)                          # if Aircraft target hit
           {
           aml$pointer$to aml$NextIndx$i           # get AML next index
           aml$NextIndx$i = xaml$NextIndx$i
           }

       IF  (nhit > 0)                               #if any hits
           {
             call Process_SAM_Hit (UNT$Pointer,   UNT2$Pointer,   iairtg,
                                   AML$Pointer,   CMC$Pointer,    MC$Pointer,
                                   BDA_Nbr_Fired) # JFR for BDA (E1104)
           }  # end if any hits

       if (LCL$Pointer$Valid)     # clk 11/96 (E1695)
         {                        # could be shooting at someting not detected
          LCL$Remaining$i = max0(ntarg - xunt2$hits$i,0)       # update number left
          PUTLCL$Remaining$I
          IF  (lcl$remaining$i == 0)                    ## 10/10/85 <RG>  If no planes
            {                                           ## left, and his assigned targt
             unt$AssignedTarget$i=Xunt$AssignedTarget$i ## this aircraft or CM,set his
             lcl$detectee$i = Xlcl$detectee$i           ## indexes back to zero so he can
                                                        ## be reassigned a new target.
             IF (unt$AssignedTarget$i == lcl$detectee$i)
               {
                PUTunt$AssignedTarget$i  ($No)
                PUTunt$AttackIndx$i      ($No)
               }   # end of if the attacker was assigned this track
            }   # end of if the target is destroyed
         }   # end of if the target is in the attacker LCL table
      }            # end of target is a RESA controlled unit, vice a ghost

    eqlist[5,m] = eqlist[5,m] - 1               # end of one engagement
    eqlist[3,m] = eqlist[3,m] - nfire           # decrement AAM's

    IF  (eqlist[3,m] < 0) 
        eqlist[3,m] = 0        # jb            5/18/89    
    ntargt = ntargt - 1
    }                    # end of REPEAT thru targets within weapons
    
for (n=1; n<= nfound; n=n+1)                    # update equipment remaining
    {
    DEQ$Pointer$TO (eqlist[1,n])        
    if (Xdeq$remaining$i != eqlist[3,n])		# Something fired
       PUTdeq$TimeLastUsed$f (game$time)       # Time when sam last fired
    PUTdeq$remaining$i (eqlist[3,n])    

    if (eqlist[3,n] == 0)   # notify unit if it has
        {                   # no more SAMs - SMM 7/97 (E1430)
         # get weapon pointer
         MC$Pointer = xDEQ$Pntr$I

         msglen = 0
         call smovhn (xUNT$Name$C, $$MaxLit, msg, msglen)
         call smovv  (" has expended all " ,msg, msglen)
         call smovhn (xMC$Name$C, $$MaxLit, msg, msglen)
         call smovv  (" SAMs.  " ,msg, msglen)
         call smov   ($bell, msg, msglen)
         call smov   ($bell, msg, msglen)
         call send_   (xUNT$View$I,0,msglen,msg)
        }
    }

return
end             # end of SAMENG


subroutine Get_SAM_Probability_of_Hit (_
                UNT2$Pointer,           # targets's unit pointer
                MC$Pointer,             # AAM characteristic pointer
                target_index,           # the target probability of hit matrix index
                probability_of_hit,     # return the probability of hit
                missile_max_range)      # return the max range at the target alt.
########################################################
#$%
#$% Purpose:   Get_SAM_Probability_of_Hit calculates the
#$%            probability of hit for a surfact-to-air
#$%            engagement.
#$%
#$% Called by: SamEng
#$%            ALSP_Receive_SAM_Engage <alsp_receive_interact.rat>
#$%
#$% Calls:     Echo..
#$%
#$% Tables:    UNT       MC
#$%
#$% Date:      March 1993
#$%
#$% Author:    Code reused from SamEng.
#$%
########################################################
BBCommon
Eng$ProbHits

real     probability_of_hit
integer  UNT2$Pointer, MC$Pointer
integer  target_index, missile_max_range
integer  weapon_index
Integer UNT2$Truealtdepth$I, MC$BND$Index   # jb E2145  6/28/00

    weapon_index = xMC$WeaponIndex$I
    probability_of_hit = eph[target_index, weapon_index] * 0.01
    missile_max_range = xMC$MaxRange$I

    if (probability_of_hit < 0.0)          # clk 3/92
      {#$% Get the probability from the weapon characteristics.
       #$% Added altitude bands with PK values for each band.
       #$% Targets above the last altitude get a PK of 0.

       UNT2$TrueAltDepth$I = xUNT2$TrueAltDepth$I
       for (MC$BND$Index = 1;  MC$BND$Index <= MC$BND$Slots;      # loop through
                               MC$BND$Index = MC$BND$Index + 1)   # alt. bands
         {
          if (UNT2$TrueAltDepth$I < xMC$BND$Altitude$I)
            {
             probability_of_hit = xMC$BND$ProbKill$I * 0.01   # get the prob
             missile_max_range = xMC$BND$MaxRange$I           # get the max range
             break
            }
         }       # end of loop through altitude bands

       if (MC$BND$Index > MC$BND$Slots) # the target altitude is above the last altitude band
         {
          probability_of_hit = 0.0
          missile_max_range = 0
         }
      }         # end of get probability from the weapon characteristics

return
end

subroutine Process_SAM_Hit (_
                UNT$Pointer,       # input - attacker
                UNT2$Pointer,      # input - target
                iairtg,            # input - $yes if an a/c, $no if a cm
                AML$Pointer,       # input - target's AML entry if an a/c
                CMC$Pointer,       # input - targets CMC entry is a cruise missile
                MC$Pointer,        # input - attacking SAM characteristic pointer
                BDA_Nbr_Fired)     # input - number fired for BDA - JFR 4/3/94
#############################################################
#$%
#$% Purpose:   Process_SAM_Hit processes an SAM hit against
#$%            an aircraft flight or cruise missile and updates
#$%            the engagement data.  For a nuclear cruise missile
#$%            SEND_DETON is called to detonate it.
#$%
#$% Called by: SamEng
#$%            ALSP_Receive_SAM_Engage      <alsp_receive_interact>
#$%
#$% Calls:     Update_Destroyed_Aircraft    <lbcommn.rat>
#$%            Generate_eng_rec             <wgmdrec.rat>
#$%            SEND_DETON
#$%            Echo...                      <lbecho.rat>
#$%            Update_DAC_BDA_CM            <lbcommn.rat>
#$%
#$% Tables:    UNT      AML     CMC     MC
#$%
#$% Date:      March 1993
#$%
#$% Author:    Code moved from SamEng.
#$%
#$% Modified:  JFR (E1104) Added a parameter to support BDA.
#$%            Added BDA_Nbr_Fired to Update_Destroyed_Aircraft
#$%            parameter list.
#$%
#$%            SMM (E1104) 2/96  Added call to routine 
#$%            Update_DAC_CM_BDA to handle cruisemissile targets.
#$%
########################################################
BBcommon

LITERAL    CSTRIP8                  # jb E2145  6/28/00
REAL  TEST, X, RANDOM         # jb  E2145 6/28/00
integer   UNT$Pointer,     UNT2$Pointer
integer   iairtg
integer   AML$Pointer,    CMC$Pointer,     MC$Pointer
integer   BDA_Nbr_Fired    # JFR 9/24/93 (E1104)
REAL    FLAT,FLON                      # jb E2145  6/28/00
Integer INEW,IBURST,IDEPTH,IYIELD,NPH, # jb E2145  6/28/00
    IUSENUC,INTCPTFLAG,KSIDE,               # jb E2145  6/28/00
    UNT2$View$I,UNT2$Hits$I,UNT2$Misshits$I # jb E2145  6/28/00
data x/0.0/		# Get next random number in sequence

    unt2$Hits$I     = Xunt2$hits$i              # get target hits
    unt2$Misshits$i = Xunt2$MissHits$i

    IF  (iairtg == $no)                      # if not Aircraft 
      {                                      # (i.e. Cruz Miss)
       IF  (unt2$hits$i == 0) 
        {
         inew = $yes   # New Hit ?
         if (xMC$Type$I == $CIWS$Code)
             call Update_DAC_CM_BDA (UNT$Pointer, UNT2$Pointer,
                                     $CloseInWeaponSystem$Code,
                                     xMC$Name$C, BDA_Nbr_Fired)
         else 
             call Update_DAC_CM_BDA (UNT$Pointer, UNT2$Pointer,
                                     $SurftoAirMissile$Code,
                                     xMC$Name$C, BDA_Nbr_Fired)
        }
       ELSE        
         inew = $no      # ... NO
      }
    ELSE IF (xaml$status$i != $destroyed$code)
      {
       #$% Enter data into the DAC table.       clk 3/92
       if (xMC$Type$I == $CIWS$Code)
         call Update_Destroyed_Aircraft (UNT2$Pointer, UNT$Pointer,
                                         $CloseInWeaponSystem$Code,
                                         xMC$Name$C, AML$Pointer,
                                         BDA_Nbr_Fired) # JFR 9/24/93 (E1104)
       else
         call Update_Destroyed_Aircraft (UNT2$Pointer, UNT$Pointer,
                                         $SurfToAirMissile$Code,
                                         xMC$Name$C, AML$Pointer,
                                         BDA_Nbr_Fired) # JFR 9/24/93 (E1104)

       IF  (log$engage != $no)              # if engagement log desired
         {
          call engdata (UNT$Pointer, UNT2$Pointer)    #jhm 7/02  Want Lat/Long for splash (E2247)
          call Generate_eng_rec ("SPLASH  ","ENGAGE  ",xaml$SideNumber$c)
         }
       PUTaml$status$i ($destroyed$code)   # set destroyed status
       inew = $yes                         # new hit
      }
    ELSE  
      inew = $no                        # NOT new hit

    IF  (inew == $yes)                       # if new kill
      {
       unt2$hits$i = unt2$hits$i + 1 # add new kill to previous
       PUTunt2$hits$i

       ###############################################
       ##    <<<>>> Added 4/4/85 for nuclear intercept....
             
       iYIELD = Xmc$YIELD$i  # is SAM possibly nuclear?      5/9/85
       IF  ( iairtg == $no & iYIELD == 0 ) # if NOT, is TGT   5/9/85
         {                                # a nuclear crsmsl? 5/9/85
#####       iYIELD = Xcmc$Yield$i               # removed       12/13/85c
            IF  (Xcmc$FlightAlt$i > 50000) 
                test = 0.45   #       5/21/85
            ELSE                          
                test = 0.05   #       5/21/85
            IF  ( RANDOM(x) < test) 
                iYIELD = Xcmc$Yield$i #      12/13/85c
         }
            
       iusenuc = Xunt2$nuclear$i                     #       5/21/85
            
       IF  (xunt$NucTAKE$i != $NO |                   #    8/1/90 hdf
            xUNT$NucFree$i == YES) 
         iusenuc = $YES     #       6/6/85

       IF  (iYIELD >0 & Nuclear$Capable !=$NO &
            iusenuc !=$NO )                            #       12/13/85c
    #       iusenuc !=$NO & RANDOM(x) < test)          #       5/21/85
         {
          # Set up vrbls in NUcommon for call to SEND_DETON subroutine:
          IntcptFlag = 1                # INTERCEPT case..

          FLAT = Xunt2$TrueLatitude$F   # position of   
          FLON = Xunt2$TrueLongitude$F  # the intercept 
          nPH  = 100                    # (No miss for INTERCEPT)

          unt2$VIEW$I = Xunt2$VIEW$I    # TGT's view
          IF  (unt2$VIEW$I > $LastBlue$View) 
             kside = 2
          ELSE IF (unt2$VIEW$I > $Neutral$View) 
             kside = 1
          ELSE                                 
             kside = 0

          iBURST  = $AIR$Code # (Intercepts generally in air..but..)
          IF  (test < 0.3) 
             iBURST = $Surface$Code # not always! 5/21/85

          iDEPTH = 1                  # ..irrelevant: NOT subsurface..

          call SEND_DETON
        }    # End if nuclear intercept of nuclear crsmsl    12/13/85c
      #######################################################

       unt2$MissHits$i = unt2$MissHits$i + 1  
       PUTunt2$MissHits$i

       IF  (trace$engage$exe != $no)
          {
           call echov ("  [")
           IF  (iairtg == $yes) 
              call echohn (xaml$SideNumber$c,5)
           ELSE                
              call echohn (xunt2$name$c, $$maxlit)
           call echov (" down]")
          }
      }  # end if new kill

return
end


subroutine getrad (unt$pointer,         #get MLIMIT targets within MRANGE
                   mrange,              # get max range
                   mlimit,              # get engagement limit
                   Nraid,               # return target pointers
                   nlocal,              # return local track for shooter JFR 7/18/94
                   ranges)              # return target ranges

########################################################
#$%
#$% Purpose:   GETRAD generates a list of acceptable
#$%            targets and ranges as a function of
#$%            available SAM weapons (Range/Limit).
#$%
#$% Called By: AIRRAD
#$%
#$% Calls:     GETLCL_ACT            CKROE
#$%
#$% Tables:    UNT        LCL
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  Carol Kropp - 4/94 (E1258)
#$%            The missile range (mrange) was compared to
#$%            the detected range + .5, which caused the
#$%            check to fail at very close ranges.
#$%            Converted the missile range to a floating
#$%            point value and removed the .5 in the "if"
#$%            statement.
#$%
#$%            JFR 7/18/94 PER E1252 Modify SAM engagements so
#$%            a SAM will shoot as soon as the target is detected,
#$%            in range, and satisfies ROE.  Then revert to 
#$%            SHOOT-LOOK-SHOOT or SHOOT-LOOK-LOOK-SHOOT.
#$%
########################################################
bbcommon

real    max_sam_range      # clk 4/94 (E1258)
REAL    X, RANDOM, LCL$Range$F                   # jb E2145 6/29/00
Integer MRANGE,MLIMIT,NCOUNT,ILOSE,IHOLD,        # jb E2145 6/29/00
    N,II,IEQ,INDX,IPNT,ISTAT,JSTAT,              # jb E2145 6/29/00
    LARGST,MULT,NEQTOT,                          # jb E2145 6/29/00
    UNT$Pointer,UNT$View$I,UNT2$Assignedtarget$I, # jb E2145 6/29/00
    UNT2$Pointer,UNT2$Type$I,                    # jb E2145 6/29/00
    LCL$Pointer,LCL$Nextindx$I,LCL$Detectee$I    # jb E2145 6/29/00
integer NRAID[21],RANGES[21]
# added array to hold local track pointers used to test flag value
integer         nlocal[31]  # JFR 7/18/94 PER E1252
integer  the_elevation, cmc$pointer
data x/0.0/		# Get next random number in sequence

max_sam_range = FLOAT (mrange)   

ieq = mlimit + 1
ncount = 0
#$% for each target entry
for (n=1; n<= 21; n=n+1) nraid[n] = 0

ihold = Xunt$AssignedTarget$i           # temp save of assigned target
indx  = unt$pointer$index

if (ihold != 0)                         # if given assigned target....
   {
    #$% set target UNT pointer
    unt2$pointer$to ihold

    #$% get target type
    unt2$type$i = Xunt2$type$i

    call getlcl_act (unt$pointer,
                     ihold,
                     lcl$pointer)

    #$% if LCL pointer is zero or last detection time not exceeded
##    if (lcl$pointer         == 0                  |  # jb (see below) 4/26/01 
    if (!lcl$pointer$valid)  # jb separate this IF from the next (ELSE IF, now)
         CONTINUE                           # jb 4/26/01
    else if (Xlcl$LastDetTime$f   <  Game$time      |
             Xlcl$DetectionType$i != $ActiveNonVisual$code)
         CONTINUE

    #$% else if aircraft or cruise missile
    else if (unt2$type$i == $air$code |                 # if airborne....
             unt2$type$i == $CruiseMissile$code)
       {
        #$% get range
        lcl$Range$F = xlcl$Range$F

        #$% if within range
        if (lcl$Range$F <= max_sam_range)
           {
            #$% set target and range
            unt2$pointer$to ihold
            nraid[1] = unt2$pointer
            ranges[1] = INT (lcl$Range$F + 0.5)
            nlocal[1] = lcl$pointer # set local track of assigned target JFR 7/18/94
            ncount = 1
           }
       }
   }

#$% get view
unt$view$i = Xunt$view$i

#$% if view is Neutral, return
if (unt$view$i == $Neutral$view) return

#$% for each entry
for (lcl$NextIndx$i = Xunt$FirstLCLIndx$i; lcl$NextIndx$i != 0; )
   {
    #$% set LCL pointer and get next index
    lcl$pointer$to lcl$NextIndx$i
    lcl$NextIndx$i = Xlcl$NextIndx$i

    if (xlcl$inuse$i == 0) next                 # if slot not in use......

    if (xlcl$detectionType$i != $ActiveNonVisual$code) next   # not active....

    if (xlcl$LastDetTime$f < game$time) next          # not current....

    if (Xlcl$Class$i != $air$code) next         # if not airborne....

    #$% get detectee
    lcl$detectee$i = Xlcl$detectee$i
    unt2$pointer$to lcl$detectee$i

    # Check for restriction if ballistic missile   joa 6/02
    if (Xunt2$Type$i == $CruiseMissile$Code)
        {
        cmc$pointer = Xunt2$CMCpntr$i
        if (Xcmc$Cat$i == $Ball$Code) 
            {
            if (AutoEngageTBM$Flag == $OFF) next
            }
        }
    #$% get range
    lcl$Range$F = xlcl$Range$F

    # Check for restriction of aircraft over land and outside auto engage rng joa 6/02
    if (Xunt2$Type$i == $Air$code)
        {
        if (lcl$Range$f > AutoEngageAircraft$Rng)
            {
            if(the_elevation(Xunt2$TrueLatitude$f*$rad2deg,Xunt2$TrueLongitude$f*$rad2deg) > 0) 
                next
            }
        }
    jstat = $no                                 # check for already on list
    #$% for each entry
    for (n=1; n<=ncount; n=n+1)
       {
        #$% if not same target
        if (nraid[n] != unt2$pointer) next
        jstat = $yes
        break
       }
    if (jstat == $yes) next                     # on list.... skip it

    #$% if greater than missile range, get next
    if (lcl$Range$F > max_sam_range) next

    call ckroe (unt$pointer,                    # check DET model ROE select
                lcl$pointer,
                istat)

    #$% get assigned target
    unt2$assignedTarget$i = Xunt2$assignedTarget$i

    if (istat >= $yes)                          # if within ROE
        {
        continue                                # Open Fire
        }
    else if (istat == -1)                       # No can shoot (no weapons)
        {
        next                                    # next LCL in chain
        }
    else if (unt2$assignedTarget$i == indx )    # if object firing at us...
        {                       
        continue                                # ...  return fire..
        }
    else                                        # Don't Shoot
        {
        next                                    # next LCL in chain
        }

    ipnt = ncount + 1
    for (n=1; n <= ncount; n=n+1)               # find correct slot
       {
        if (ranges[n] <= int(lcl$Range$F +0.5)) next
        ipnt = n
        break
       }

    #$% increment counter
    ncount = ncount + 1
    for (n = ncount; n>ipnt; n=n-1)             # shift targets right
       {
        nraid[n] = nraid[n-1]
        ranges[n] = ranges[n-1]
       }

    nraid[ipnt] = unt2$pointer                  # insert new entry
    ranges[ipnt] = INT (lcl$Range$F + 0.5)
    nlocal[ipnt] = lcl$pointer # insert local track JFR 7/18/94

 #### The following scheme gives uniform probability of selection
 #### whenever there is no clear-cut choice because of a tie.

    if (ncount > mlimit)                        # if one has to be discarded
       {
        if (ipnt < ieq)  ieq = ieq + 1

        if (ranges[ncount] == ranges[mlimit])   # if bumped value is in tie
           {
            if (ieq > mlimit)                   # if string of largest needs
               {                                #          to be identified
                ieq = mlimit
                largst = ranges[mlimit]
                neqtot = 2

                for (ii=mlimit-1;ii>=1;ii=ii-1)     # work backwards
                   {
                    if (ranges[ii] < largst) break  # until range is smaller
                    ieq = ii                        # pointer to first of tied
                    neqtot = neqtot + 1             # number tied for largest
                   }
               }
            else if (ranges[ipnt] == ranges[ieq]) # else if new one in tie
                neqtot = neqtot + 1             # add one to total with value

            if (ipnt != ncount)                 # if new entry not tied for
                mult = mlimit - ipnt + 2        #                    largest
            else
                mult = neqtot

            ilose = ieq + int(mult*random(x))   # randomly selected loser

            if (ilose <= mlimit)                # if bumped value is not loser
               {
                nraid[ilose] = nraid[ncount]    # overwrite loser with
                ranges[ilose] = ranges[ncount]  #            bumped data
                nlocal[ilose] = nlocal[ncount] # choose best local track JFR 7/18/94
               }
           }

        ncount = mlimit                         # number of good entries
       }
   }

nraid[ncount+1] = 0                             # clear extra name

return
end             # end of getrad



subroutine gettor (unt$pointer,                  # 10/10/90 hdf
                   unt2$pointer,                # 9/19/85 <SCC>\
                   range_act,                   # for range x
                   iBEST,        # jb deq$pointer$index, or ZERO  3/28/89
                   ph_a,                        # and    Prob Hit
                   ph_t)                        # and    Prob Hit (TMA)

########################################################
#$%
#$% Purpose:   GETTOR
#$%
#$%
#$% Called By: AIRTOR     SURTOR
#$%
#$% Calls:     None
#$%
#$% Tables:    DEQ        TOR
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

REAL P,PB,PH_A,PH_T,RANGE_ACT,TOR$Maxprobhit$F  # jb E2145  6/29/00
Integer IBEST,IHAVE,IUPI,                       # jb E2145  6/29/00
    UNT$Pointer,UNT$Type$I,                     # jb E2145  6/29/00
    TOR$Pointer,TOR$Maxalt$I,                   # jb E2145  6/29/00
    TOR$Maxrange$I,TOR$PH$Index,                # jb E2145  6/29/00
    UNT2$Pointer,SHC$Pointer,DEQ$Pointer        # jb E2145  6/29/00
integer RangeY

#RangeY = range_tma * $Yds$Per$Mile     # range in yards          5/7/86
RangeY = range_act * $Yds$Per$Mile +0.5 # range, yards 5/7/86 +.5 6/29/00 

unt$type$i = Xunt$type$i                   

ihave = $no
ibest = 0
pb = 0.0

#$% for each entry
iUPI = UNT$Pointer$index                           
for_DEQ_CHAIN (iUPI)                                
   {
    #$% if not torpedo, get next entry
    if (Xdeq$ident$i != $Torpedo$code) next        

    #$% if equipment remaining is zero, get next
    if (Xdeq$Remaining$i == 0) next                

    #$% set TOR pointer
    tor$pointer = Xdeq$Pntr$i                   

    if (xTOR$AutoLaunch$i == $no) next # available for ROE engagement   DEW 1/90

        #$% Inhibit expending submerged-targets-only torpedoes:
    if (xTOR$subs$i == $yes)    # Submerged-tgt-only torpedo   1/23/86
     {
      if (Xunt2$type$i ^= $sub$code)  # Ineligible surface ship
            NEXT                     # jb    Re-set as before    2/19/91
      else      # This IS a SUB; but skip it if on the surface: 
       {        
        SHC$Pointer = xUNT2$SHCpntr$i    
        if (Xunt2$truealtdepth$i <= Xshc$KEELdepth$i) NEXT #    3/28/89
       }
     }
                # end of Inhibit code       9/18/85

    #$% Prevent non-air units from automatic launch of airlaunch-capable
    #   torpedoes (this requires that tor$MaxAlt$i be ZERO for OTHERs):

    TOR$MaxProbHit$F = xTOR$MaxProbHit$F        ## get max prob hit tpa 7/27/83

    tor$MaxAlt$i = Xtor$MaxAlt$i
    if (unt$type$i == $air$code)                  
        {
        if (tor$MaxAlt$i == 0) next
        }
    else 
        {
        if (tor$MaxAlt$i != 0) next
        }

    ihave = deq$Pointer$index                
    #$% get maximum torpedo
    tor$MaxRange$i = Xtor$MaxRange$i

    #$% if maximum range
#    if (tor$MaxRange$i < range_tma)  next              #       5/7/86
    if (tor$MaxRange$i < range_act)  next               #       5/7/86

    p = 1.0
    #$% for each probable hit entry
    for (tor$ph$index = 1; tor$ph$index$ok; tor$ph$index = tor$ph$index + 1)
       {
        if (RangeY <= Xtor$ph$Range$i) break
        p = p - 0.1
       }

    if (p > pb)
       {
        pb = p
        iBEST = deq$Pointer$index            
       }
   }

#$% if best
if (ibest != 0)
   {
    #$% set probability of hit
#    ph_t = pb                                          #       5/7/86
#    ph_t = MIN(ph_t,TOR$MaxProbHit$F)                  #       5/7/86
    ph_a = MIN(pb,TOR$MaxProbHit$F)                     #       5/7/86

    ph_t = ph_a                 ##  AS OF 5/7/86, this Ph applies for both:

############  DISABLED 5/7/86 - always use actual range to compute Ph...!!
#    if (range_act != range_tma)
#        {
#        RangeY = range_act * $Yds$Per$Mile             # range in yards
#
#        tor$pointer = Xdyn$eq$Pntr$i           #$% set TOR pointer
#
#        TOR$MaxProbHit$F = xTOR$MaxProbHit$F   ## get max prob hit tpa 7/27/83
#
#        tor$MaxRange$i = Xtor$MaxRange$i
#
#        p = 1.0
#        #$% for each probable hit entry
#        for (tor$ph$index=1; tor$ph$index$ok; tor$ph$index=tor$ph$index + 1)
#           {
#          if (RangeY <= Xtor$ph$Range$i) break
#          p = p - 0.1
#           }
#
#       ph_a = p
#       }
######################  End of DISABLE on 5/7/86  ##########################

   }    # END of  if (iBEST != 0 )

#$% else if have
else if (ihave != $no)
   {
    iBEST = ihave                    # jb return iBEST            3/29/89
    ph_T = 0.0
    ph_a = 0.0
   }
else
   {
    iBEST = 0                        # jb return iBEST            3/29/89
    ph_t = 0.0
    ph_a = 0.0
   }

return
end        # End   GETTOR



subroutine surtor(_                     #
           unt$pointer,                 #receive attackers unit pntr
           unt2$pointer,                #receive target unit pointer
           isTMA)

########################################################
#$%
#$% Purpose:   SURTOR processes surface torpedo
#$%            engagements, determining torpedo
#$%            availability, number of hits,
#$%            and damage level.
#$%
#$% Called By: EPROSS
#$%
#$% Calls:     GETRB_M    GETTOR  engdata  MBURange
#$%            UPDATE_NAVAL_UNIT_BDA      GET_DSS_DATA
#$%
#$% Tables:    UNT      TOR
#$%            TAT      DEQ
#$%
#$% Date:      AUG 85
#$%
#$% Author:    Dana Wills
#$%
#$% Modified:  JFR (E1104) Added code to handle BDA.
#$%
#$%            Susan Miller 5/98 (E1989)
#$%            Removed small boat prob hit degradation.
#$%
#$%            Susan Miller 12/97 (E1697)
#$%            Changed call update_naval_unit_bda_deferred to 
#$%            update_naval_unit_bda - entry point removed
#$%            Added 2 update_naval_unit_bda parameters to 
#$%            indicate whether damage is deferred. 
########################################################
BBcommon
ENcommon

Literal   BDA_Class         
LITERAL     CSTRIP8                         # jb E2145  6/29/00
REAL      X, RANDOM, PH_T, PMIN,            # jb E2145  6/29/00
    BRG_ACT,RANGE_ACT,BRG_TMA,RANGE_TMA,    # jb E2145  6/29/00
    DEQ$Timelastused$F                      # jb E2145  6/29/00
Real*4    Rand_Num, PH_a, BDA_Dam
real      Ntime
real      mburange

integer*4 BDA_TORHits
Integer*4 BDA_tracknumber, BDA_Result_code, BDA_nbr_fired # JFR 6/18/93
integer   NinInterval
Integer  N,NFIRE,NHITS,IPH,IBEST,IRNG_A,    # jb E2145  6/29/00
         IRNGY_A,IRNG_T,IRNGY_T,ISTMA,      # jb E2145  6/29/00
         IWAIT,BDA_CLASSID,                 # jb E2145  6/29/00
    UNT$Pointer,UNT$Status$I,               # jb E2145  6/29/00
    TOR$Pointer,TOR$Firerate$I,             # jb E2145  6/29/00
    DEQ$Pointer,DEQ$Remaining$I,            # jb E2145  6/29/00
    LCL$Pointer,UNT2$Pointer,TAT$Pointer    # jb E2145  6/29/00
data x/0.0/		# Get next random number in sequence

call GETRB_M(_                                    #get range and bearing
           UNT$pointer,                         #pass A/C posit pointer
           unt2$POINTER,          #pass target pointer (jb unt2) 3/29/89
           RANGE_act,                           #receive range
           BRG_act)                             #receive bearing

if (isTma != NO)
    {
    lcl$pointer = isTMA
    call GETRB_lcl(_                            #get range and bearing
                   UNT$pointer,                 #pass A/C pointer
                   lcl$pointer,                 #pass target pointer
                   RANGE_tma,                   #receive range
                   BRG_tma)                     #receive bearing
    }
else            # This makes range_tma the applicable range, no matter
    {           # whether ISTMA is true or false....??
    range_tma = range_act
    brg_tma   = brg_act
    }

irng_a   = range_act +0.5                               #       5/7/86
irngy_a  = range_act * $Yds$Per$Mile                    #       5/7/86

irng_t   = range_tma +0.5                               #       5/7/86
irngy_t  = range_tma * $Yds$Per$Mile                    #       5/7/86

call gettor (unt$pointer,                         # 10/10/90 hdf
             unt2$pointer,                       # (fix UNT2) 7/89
             range_act,                         # for range x   5/7/86
             iBEST,                         # deq index, or ZERO 3/29/89
             ph_a,                              # and    Prob Hit
             ph_t)

unt$status$i = Xunt$status$i                         # jb    8/18/89
if (iBEST == 0)                         #if no torpedos found    3/29/89
    {
     putunt$OutOfTor$i ($yes)                   # out of torpedo  <SCC> 
     return
    }

deq$Pointer$TO (iBEST)                          # jb              3/29/89
iwait = Xdeq$TimeWhenUse$f > game$time        

if (trace$engage$exe != $no)
   {
    call echor
    call echoV  ('!')                   # jb E2144  (echoV) 8/2/00
    call echov ("Surf Torpedo.....")
    call echohn (Xunt$name$c,$$MaxLit)
    call echov (" Attacking ")
    call echohn (xunt2$name$c,$$MaxLit)
    if (isTMA != NO) call echov (" (w/TMA)")
   }

if(unt$status$i != $Sinking$Code & unt$status$i != $UnderTow$Code &
                 unt$status$i != $DeadInWater$Code ) # jb    8/18/89
    PUTunt$status$i ($PROCEEDING$CODE)       

PUTunt$attackindx$i  (unt2$pointer$index)       #target as attack guide
PUTUNT$attackrange$f (0.0)                      #attack range to zero

tor$pointer = Xdeq$Pntr$i                 

#if (abs(brg_act - brg_tma) > 15) ph_a = 0.0    #               5/7/86
if (isTMA != $NO)                               #               5/8/86
    if (abs(brg_act - brg_tma) > 15) ph_t = 0.0 #               5/7/86

if (trace$engage$exe != $no)
    {
    call echov (" w/")
    call echohn (Xtor$type$c,$$MaxLit)

    if (isTMA != NO) 
        {
        call echov (" TmaRng(Y)=")
        call echoi (irngy_t)
        }

    call echov (" rng(Y)=")
    call echoi (irngy_a)

    call echov (" Ph=")
    iph = ph_t * 100 + .5
    call echoi (iph)
    call echov ("%")

    if (isTMA != NO) 
        {
        call echov (" (")
        iph = ph_a * 100 + .5
        call echoi (iph)
        call echov ("% true) ")
        }

    if (iwait == YES) call echov (" (look'n see)")
    }

Pmin = min( 0.5, xTOR$MaxProbHit$F )    # set MIN. probability  7/27/83
if (Ph_t < Pmin )       # don't shoot w/less than minimum Ph    7/27/83
   {
    if (trace$engage$exe != $no)
        call echov (" Ph Too Low")

    if(unt$status$i != $Sinking$Code & unt$status$i != $UnderTow$Code &
                 unt$status$i != $DeadInWater$Code ) # jb    8/18/89
        PUTunt$status$i ($PROCEEDING$CODE)       

    PUTunt$attackindx$i (unt2$pointer$index)    # assign as attack guide
    PUTUNT$attackrange$f (0.0)                  # attack range.. on top of

    return
   }

if (iwait == YES) return                               # damaged/disabled

tor$FireRate$i = Xtor$FireRate$i                # get fire rate
deq$Remaining$i = Xdeq$Remaining$i              

# Number of torpedoes fired in model interval
deq$TimeLastUsed$f = Xdeq$TimeLastUsed$f
nfire = NinInterval(deq$TimeLastUsed$f, tor$FireRate$i, deq$Remaining$i)
if (nfire == 0) return

PUTdeq$TimeLastUsed$f

if (deq$Remaining$i < nfire)   # update torp. invntry DEQ 3/29/89
   {
    nfire = deq$Remaining$i    
    deq$Remaining$i = 0                 
   }
else
   {
    deq$Remaining$i = deq$Remaining$i - nfire    # jb DEQ 3/29/89
   }

PUTdeq$Remaining$i              # save torpedo count (jb DEQ )  3/29/89
PUTunt$engagestatus$i ($engaging$code)          # set engagement status

NTIME = (range_act/Xtor$Speed$I)*$Minutes$per$Hour + GAME$TIME  # calc time at target

PUTdeq$TimeWhenUse$f (game$time+2.)  # earliest fire-again time  (jb DEQ 3/29/89)

NHITS = 0                                       #zero sum of hits
for (N=1; N <= nfire; N=N+1)          #do for number to fire
   {

    if (trace$engage$exe != $no) 
        call echoi (n)

#### A collection of <<RG>>' code to write a record for each firing ######
###################### Dec. 19, 1985  by  <SCC>  #########################

    if (log$engage != $no)                # if engagement log is desired
      {
       call engdata(UNT$Pointer, UNT2$Pointer)
       PUTeng$Weapon$c( Xtor$type$c )               # get weapon type
       PUTeng$Range$f( float(irng_a) )              #= range_act +0.5 to target     8/14/85
       PUTeng$MBURange$f( MBURange(UNT2$Pointer) )  # range to MBU
      } 

## intra emi:

    Rand_Num = Random(X)
    if (PH_a >= Rand_Num)       #  if hit
       { 
       IF  (( EMI$IntraPlatform != $no ) & (EMI$Analysis != $NO))
           {
            }
       }
    if (PH_a < Rand_Num)       #  if not hit
      {
       if (log$engage != $no)               # if engagement log is desired
         {
          PUTeng$Time$f( game$time )
          PUTeng$Result$i( eng$Miss$code )
          PUTeng$Resultph$f( ph_a * 100. )
          call write_eng_rec
         }
       next                                # next iteration
      }  ## END  (log$engage != $no)

    if (log$engage != $no)                 # if engagement log is desired
      {
       PUTeng$Time$f( game$time )
       PUTeng$Result$i( eng$Hit$code )
       call write_eng_rec
      }
############################### End of change. Dec. 19, 1985 <SCC> #######

    if (trace$engage$exe != $no) 
        call echov (" Hit ")

    NHITS = NHITS + 1                           #total hits
   }

if (NHITS != 0)                                 #if any hits
   {
    # (E1104)
    # Process BDA here since the TAT table does not have provision for
    # number fired. NOTE: time may be after current game minute so
    #                     the status board may have to check it
    # Also, since the time is deferred we have to call the entry point routine
    
    # now get the values for input to update routine - JFR 6/22/93
    BDA_Nbr_Fired = tor$FireRate$i # get nbr of bombs fired - JFR 6/22/93
    BDA_TORHits =  Xtor$Weight$i * nhits # get Torpedo warhead weight for BDA - JFR 6/22/93
    BDA_Result_code = $NavalTorpedo$Code

    call GET_DSS_DATA (UNT2$POINTER, UNT$POINTER, BDA_TORHits,
                       BDA_Result_code, BDA_Dam, BDA_TRACKNUMBER, 
                       BDA_CLASS, BDA_CLASSID)

    #$% data into the DSS table.   --- JFR 6/16/93
    call Update_Naval_unit_BDA(UNT2$Pointer,           # JFR 6/16/93
                               UNT$Pointer,            # JFR 6/16/93
                               $NavalTorpedo$Code,      # JFR 6/16/93
                               BDA_Result_code,        # JFR 6/16/93
                               BDA_Dam,                # JFR 7/30/93
                               BDA_TRACKNUMBER,        # JFR 6/16/93
                               BDA_CLASS,              # JFR 6/18/93
                               BDA_CLASSID,            # JFR 9/13/93
                               BDA_Nbr_Fired,          # JFR 6/16/93
                               xTOR$TYPE$C,            # JFR 6/16/93
                               $yes,     # this is deferred damage SMM 12/97
                               ntime)    # deferred time           (E1697)

    if (trace$engage$exe != $no)
       {
        call echov (" EPUs=")
        call echoi (XTOR$WEIGHT$I * NHITS / 100)
       }

    for(TAT$POINTER$FIRST;still_valid(TAT);TAT$POINTER$NEXT)  # 9/26/88
       {
        if (XTAT$TARGETINDX$I != 0)  next

        PUTtat$TargetIndx$I (unt2$pointer$index)        # set target pointer
        PUTtat$SourceIndx$I (unt$pointer$index)         # set source pointer
        PUTtat$Time$f       (ntime)                     # set time to target
        PUTtat$Weight$I     (Xtor$Weight$i * nhits)     # lbs of TNT in the torp
        PUTtat$Hits$I       (nhits)
        PUTtat$Ident$I      ($Torpedo$Code)
        putTAT$YIELD$I      (Xtor$Yield$i) # possible nuclear yield? 5/20/85

        nhits = 0                                       # zero sum-of-hits
        break
       }

    if (nhits != 0)
       {
        call echor
        call echov ("TAT Table overflow for Surface Engagement")
       }
   }

return
end     # end of SURTOR

Subroutine TORAT    #

########################################################
#$%                                            
#$% Purpose:   TORAT processes Torpedoes/Mines that
#$%            have reached the target.  If the target
#$%            is still active, damage level is in-
#$%            cremented.
#$%
#$% Called By: ENGAGE
#$%
#$% Calls:      SEND    SEND_DETON   ROE_Check  
#$%             SmBsunk (smovh..)    whside
#$%
#$% Tables:    TAT        UNT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
# NOTE:  UNT is hunter;  UNT2 is target;  UNT3 for DETON's/Notifies..

BBcommon
NUcommon                                                #       5/8/85

LITERAL   UNT2$Name$C, CSTRIP8                  # jb E2145  6/29/00
Integer JJ,ILEN,IUSENUC,                        # jb E2145  6/29/00
    UNT$Pointer,UNT$View$I,UNT$Nuctake$I,       # jb E2145  6/29/00
    TAT$Pointer,TAT$Targetindx$I,               # jb E2145  6/29/00
    TOR$Pointer,
    TAT$Sourceindx$I,TAT$Weight$I,TAT$Ident$I,  # jb E2145  6/29/00
    UNT3$Pointer,UNT3$Truealtdepth$I,           # jb E2145  6/29/00
    UNT2$Pointer,UNT2$Supertype$I,UNT2$Speed$I  # jb E2145  6/29/00
character msg[ARB]
   
unt$view$i = $Neutral$View              # jb default init'lz    8/21/87
unt$nuctake$i = $NO             # initialize test-flag          5/21/85
#$% for each TAT entry
for(tat$pointer$first;still_valid(tat);tat$pointer$next) # 9/26/88
   {
    tat$TargetIndx$i = Xtat$TargetIndx$i                # get target index
    if (tat$TargetIndx$i == 0)  next                    # index is zero?

    unt2$pointer$to tat$TargetIndx$i

    if (Xunt2$Status$i == $BeingDeleted$code)
       {
        tat$zero
        next
       }

    tat$SourceIndx$i = Xtat$SourceIndx$i

    if (tat$SourceIndx$i != 0)
       {
        unt$pointer$to tat$SourceIndx$i
        unt$NucTAKE$i = Xunt$NucTAKE$i                  #       5/21/85

        if(Xunt$Status$i == $BeingDeleted$code)
           {
            PUTtat$SourceIndx$i (0)             # zero source index
           }
       }
     else
       {
        kside = 2                     # Default Orange??      5/20/85
        unt$pointer = 0
       }

    if (Xtat$Time$f > game$time) next         # has Time-At-Target arrived ?

    tat$Ident$i = Xtat$Ident$i                  # moved up here 5/20/85

    # Torpedo is engaging ghosted unit
    if (xUNT2$GhostedUnit$I == $yes & 
        ALSP$Active == $yes)
    {
        call ALSP_Send_Dumb_Torpedo_Engage (UNT$Pointer,
                                            UNT2$Pointer,
                                            TAT$Pointer)

        tor$pointer$to Xtat$TORIndx$i
        call Log_ALSP_Engagement_Engdata (UNT$Pointer,UNT2$Pointer,
                                          xTOR$Type$C, 0, 1)
    
        tat$zero                                    # zero TAT entry
        next
    }
    
    if (XTAT$Hits$i == 0)
    {
        tat$zero                                    # zero TAT entry
        next
    }

#=======================================================================
# this block is for NUCLEAR TORPEDO attacks                     5/8/85

    iusenuc = Xtat$NucFlag$i
    if (unt$NucTAKE$i != $NO) iusenuc = $YES            #       5/21/85

    iyield = xTAT$Yield$I                               #       5/8/85
    if (Nuclear$Capable == $YES       &                 #       5/8/85
        iusenuc         != $NO        &                 #       5/20/85
        iyield           > 0    )
##      tat$ident$i == $torpedo$code  &                 # 13?   5/20/85
      {
        if(unt$Pointer$VALID)                           # jb    8/21/87
           unt$VIEW$i = Xunt$VIEW$i                     #       5/8/85
        if (KSIDE != 2)                                 #       5/20/85
          call whside (UNT$View$i,KSIDE)                #       5/8/85

        iBURST     = 2    # $Burst$SURFACE                      5/8/85
        iDEPTH     = 1    # $Depth$400 (irrelevant for SURFACE) 5/8/85
        unt3$Pointer$TO TAT$TargetIndx$i     
        unt3$TrueAltDepth$i =Xunt3$TrueAltDepth$i 
        if (unt3$TrueAltDepth$i > 0)         
         {
          iBURST = 3                            #$Burst$Subsurf 5/8/85
          if(unt3$TrueAltDepth$i >500) IDEPTH =2 #$Depth$600;UNT3 3/23/89
         }

        IntcptFlag = $NO        # (torpedo reaches target)
        ##unt3$pointer$to tat$TargetIndx$i   # done above (vice POS2)  3/23/89
        Flat       = xunt3$TrueLatitude$F  
        Flon       = xunt3$TrueLongitude$F 
        call Send_Deton 

        call ROE_Check (iyield, UNT$Pointer)            ## tpa 6/14/85

     }    # End of IF nuclear..

    ELSE    #unt unt2
     {    # NOT nuclear..:

    #______________________________________________________________________

      tat$Weight$i = Xtat$Weight$i              # get lbs TNT
##    tat$Ident$i = Xtat$Ident$i                #  moved up..   5/20/85

      if (tat$Weight$i != 0)                            # if Weight non zero
       {
        PUTunt2$Hits$i     (Xunt2$Hits$i + tat$Weight$i)# compute New hits 

        if (tat$Ident$i == $Torpedo$code |
            tat$Ident$i == $Mine$code     )
           {
           PUTunt2$TorpHits$i (Xunt2$TorpHits$i + tat$Weight$i)
           }

        PUTunt2$UnderAttack$i ($yes)    # set target-under-attack YES
       }

      if(tat$SourceIndx$i != 0)         # if originator still around
       {
        unt$pointer$to tat$SourceIndx$i         # jb (added)    4/21/87
        ilen = 0
        call smovhn(Xunt$Name$c,$$MaxLit,msg,ilen)
        call smovv(": ",msg,ilen)
       }
      else
       {
        unt$view$i = $Neutral$View  # jb notify CONTROL, anyway 4/21/87
        ilen = 8        # jb (start info at same column)        3/17/87
       }

      UNT2$SuperType$i = xUNT2$SuperType$i        # jb          3/5/91
      If (tat$Ident$i == $Torpedo$code)
       {
        call smovi(Xtat$Hits$i,msg,ilen)
        call smovv(" torpedoes exploded.",msg,ilen) # msg1 chg to msg 2/4/91 hdf
        call send_(unt$View$i,0,ilen,msg)                 # jb    8/21/87

        if (UNT2$SuperType$i == $FalseContact$SuperCode) # jb    3/5/91
           {
            UNT2$Speed$I = 0.4 + xUNT2$Speed$I/2
            putUNT2$Speed$I
            putUNT2$OrderedAltDepth$I (xUNT2$OrderedAltDepth$I + 333)
           }
       }
      Else if (tat$Ident$i == $Mine$code & # jb Tell Player that 7/6/89 
               UNT2$SuperType$i != $SmallBoat$SuperCode)   # DEW 5/1/90
       {
        unt2$name$c = xunt2$name$c
        jj = 0
        call smovhn (unt2$name$c, $$MaxLit, msg, jj)
        Call SMOVV(" struck mine at ",msg,jj)

        call smovll(xUNT2$assumedLATITUDE$f,"NS",msg,jj)
        call smovV(" ",msg,jj)
        call smovll(xUNT2$assumedLONGITUDE$f,"EW",msg,jj)

        call send_  (xunt2$view$i, 0, jj, msg) # jb    7/11/89
       }

     }    # End of else NOT nuclear..:                  #       5/8/85

    tat$zero                                    # zero TAT entry
    }   # End of FOR tat..

return 
end    # End TORAT 


subroutine getlcl_act (                     
                unt$pointer,            #receive detector pointer
                idetee,                 #receive detectee index
                lcl$pointer)            #return detection pointer or 0

########################################################
#$%
#$% Purpose:   GETLCL_ACT searches for the local table
#$%            entry for an active detection of the given unit.
#$%
#$% Called By: EPROSS   GETRAD  GETBOG  GET_SKUNKS
#$%
#$% Calls:     None
#$%
#$% Tables:    LCL        UNT
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

Integer  IDETEE,  UNT$Pointer,                      # jb E2145  6/29/00
    LCL$Pointer,LCL$Nextindx$I,LCL$Detectiontype$I  # jb E2145  6/29/00

#$% for each LCL entry
for(lcl$NextIndx$i = Xunt$FirstLCLIndx$i; lcl$NextIndx$i != 0; )
   {
    #$% get LCL next index
    lcl$pointer$to lcl$NextIndx$i
    lcl$NextIndx$i = Xlcl$NextIndx$i

    #$% if not detectee, get next entry
    if (Xlcl$Detectee$i != idetee) next

    #$% get detection type
    lcl$DetectionType$i = Xlcl$DetectionType$i

    #$% if detection type is not active visual or non visual, get next
    if (lcl$DetectionType$i != $ActiveVisual$code  &
        lcl$DetectionType$i != $ActiveNonVisual$code) next

    return
   }

#$% zero LCL pointer
lcl$pointer = 0

return
end    # End getlcl_act


subroutine getlcl_tma (
                      unt$pointer,              #receive detector pointer
                      idetee,                   #receive detectee index
                      lcl$pointer)              #return detection pointer or 0

########################################################
#$%
#$% Purpose:  GETLCL_TMA searches the LCL table for TMA detections
#$%           of IDETEE.  Returns the pointer for the first GOOD-
#$%           quality track, if any.  During search, saves the first
#$%           FAIR quality pointer, if any; else the first POOR-
#$%           quality pointer, if any.  If none at all, returns a
#$%           value of 0 in lcl$pointer         jb      4/9/86
#$%             
#$%
#$% Called By: EPROSS     GETRAD
#$%
#$% Calls:     None
#$%
#$% Tables:    LCL        UNT
#$%
#$% Date:      AUG 83
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

Integer  IDETEE, UNT$Pointer,                   # jb E2145  6/29/00
    LCL$Pointer,LCL$Nextindx$I,LCL$Tmaquality$I # jb E2145  6/29/00

integer i_bestQUAL      # For best TMA QUALity so far..          4/9/86
integer i_bestTMA # For lcl$Pointer for the best-quality TMA so- 4/9/86
i_bestTMA = 0   # lution, in case of no acceptable active track  4/9/86
i_bestQUAL = 0          # 0 for POOR; 1 for FAIR; 2 for GOOD     4/9/86

#$% for each LCL entry
for(lcl$NextIndx$i = Xunt$FirstLCLIndx$i; lcl$NextIndx$i != 0; )
   {
    lcl$pointer$TO lcl$NextIndx$i               # set up for next LCL index
    lcl$NextIndx$i = Xlcl$NextIndx$i

    if( lcl$NextIndx$i == 0 ) # No GOOD quality track was found, 4/9/86
     {                          # but a FAIR or POOR may have    4/9/86
      if(i_bestTMA != 0)        #  been saved while in this loop 4/9/86
       {
        lcl$Pointer = i_bestTMA # FAIR or POOR quality found     4/9/86
       }
      else lcl$Pointer = 0      # Nothing at all was found  @@    4/9/86

      RETURN            # return after complete lcl search %%     4/9/86
     }

    if (Xlcl$Detectee$i != idetee) next         # if not target, get next entry

    if (Xlcl$DetectionType$i != $PassiveSonar$code) next        # not P. Sonar

    if (Xlcl$TmaFlag$i != YES) next             # Not TMA'd

    ## Priorities: TMAquality$i =$TMA$GOOD/FAIR/POOR$Code       4/9/86
    lcl$TMAquality$i = Xlcl$TMAquality$i                #       4/9/86

    if(lcl$TMAquality$i == $TMA$Good$Code) RETURN       # %%    4/9/86
    else if(lcl$TMAquality$i > i_bestQUAL)              #       4/9/86
     {                          # Save the lcl pointer for
      i_bestTMA =  lcl$Pointer # the best-quality so far--      4/9/86
      i_bestQUAL = lcl$TMAquality$i             #               4/9/86
      NEXT                      # --but keep looking for a      4/9/86
     }                          #    GOOD-quality track         4/9/86

#   return      # 2 RETURNs now above - look for %%             4/9/86

   }    #       End FOR lcl$NextIndex....

#lcl$pointer = 0  # not found (zero LCL pointer) see @@ above   4/9/86 

return            # No longer expect to execute this RETURN 4/9/86
end    # End getlcl_tma


subroutine getbog (unt$pointer,                                       #smn002
                   unt2$pointer,
                   LCL$POINTER)

########################################################
#$%
#$% Purpose:   GETBOG determines if selected tar-
#$%            get is on current detection list.
#$%
#$% Called By: ATOAIR     SAMENG
#$%
#$% Calls:     getlcl_act
#$%
#$% Tables:    UNT        LCL
#$%
#$% Date:      JAN 81
#$%
#$% Author:
#$%
#$% Modified:  Carol Kropp - 3/30/94
#$%            An unknown track was designated enemy since
#$%            the attacking unit had weapons free.  The
#$%            target was friendly and when IFF was activated
#$%            the detection changed to friendly, but the
#$%            unit continued to engage since it was assigned.
#$%            Added a check to see if the LCL detection is
#$%            designated friendly and if so, the LCL$Pointer
#$%            will be returned as 0--  jb UFL99 (#6) PROVIDED 
#$%            THIS unit NOT ATTACKING ME!  4/26/01
#$%
#$%            Susan Miller - 7/97 (E1385)
#$%            UNT$TestIntercept$I is set to $no when
#$%            the assigned target is being deleted.
#$%
########################################################
BBcommon

Integer IDETEE, UNT2$Pointer,           # jb E2145  6/29/00
    UNT$Pointer,UNT$Assignedtarget$I,   # jb E2145  6/29/00
    LCL$Pointer,LCL$Detectiontype$I,    # jb E2145  6/29/00
    LCL$Targetid$I, LCL$Detectee$I      # jb E2145  6/29/00

idetee = unt2$pointer$index

call getlcl_act (unt$pointer,idetee,lcl$pointer)

if (lcl$pointer == 0) return            # if LCL pointer is zero, skip

lcl$DetectionType$i = Xlcl$DetectionType$i              #       7/27/83
if (lcl$DetectionType$i == $ActiveNonVisual$code |
    lcl$DetectionType$i == $ActiveVisual$Code )         #       7/27/83
   {
    LCL$TargetID$I = xLCL$TargetID$I                # \/ clk 3/94
    if (LCL$TargetID$I == $Friendly$Code &   # if the target is identified friendly
        xUNT2$AssignedTarget$i != UNT$Pointer$Index) # jb UFL99 (#6) AND IS 
      {                                              #  NOT ATTACKING ME! 4/26/01
       LCL$Detectee$I = xLCL$Detectee$I               # need to check to see if the
       UNT$AssignedTarget$I = xUNT$AssignedTarget$I   # designated friendly unit was
       if (LCL$Detectee$I == UNT$AssignedTarget$I)    # previously assigned as the target
         {
          putUNT$AssignedTarget$I ($no)
          putUNT$TestIntercept$I ($NO)       # SMM 7/97 (E1385)
         }

       LCL$Pointer = 0
      }
    else
      {
       if (lcl$targetId$i == $unknown$code)       # if target ID unknown
          PUTlcl$targetId$i ($enemy$code)         # flag target as enemy

       PUTunt$ReportNewAir$i ($yes)        #set report-new-aircraft to YES
       PUTlcl$ReportStatus$i ($NeedsReport$code)   # set report status
       PUTlcl$MyTargetFlag$i ($yes)        # set my target flag to YES
      }
   }
else
   {
    lcl$pointer = 0                     # return zero LCL pointer
   }

return
end    # End GETBOG


Subroutine NUC_BLAST            # graphics data for NUCLEAR blast

########################################################
#$%
#$% Purpose:   NUC_BLAST BUILDS DATA FOR GRAPHIC EFFECTS
#$%
#$% Called By: SEND_DETON
#$%
#$% Calls:      (echo..)     
#$%
#$% Tables:    NUC
#$%
#$% Date:      MAY 85
#$%
#$% Author:    T P ADAMOS
#$%
########################################################
BBcommon
NUcommon

real*4  r_radius
Integer JEXPLOSION,             # jb E2145  6/29/00
    NUC$Pointer, NUC$Radius$I   # jb E2145  6/29/00

jExplosion = 0

for (NUC$Pointer$First; still_valid(NUC); NUC$Pointer$Next) # 9/26/88
    {
    if (xNUC$Radius$I != 0) next                ## find empty slot
    
    if (trace$engage$exe != $no & jExplosion == 0)
        {
        call echor
        call echov  ('!')
        call echov("*** NUCLEAR EXPLOSION ***")
        }

    if (jExplosion == 0)
        {
        NUC$Radius$I = 25

        jExplosion   = 1
        }
    else                                ## calculate 1.5 PSI damage range
        {
        r_radius = iYIELD * 1000.
        r_radius = SQRT(r_radius)       # note:  STET!..SQRT on BOTH
        NUC$Radius$I = 0.5 + SQRT(r_radius) / 7. # these lines...5/16/85

        jExplosion   = 2
        }

    
    putNUC$Reference$I (0)              # clear DON'T-SEND flag 5/16/85
    putNUC$Radius$I
    putNUC$LATITUDE$F (flat)
    putNUC$LONGITUDE$F(flon)
    if (!nuc$POINTER$OK)                #if beyond prev "last"  5/15/85
        NUC$LAST$TO NUC$POINTER + NUC$ENTRY - 1  # new "last"   5/15/85


    if (jExplosion == 2)    BREAK               ## exit if blast is complete
    }

RETURN
END


Subroutine ROE_Check (i_Yield, UNT$Pointer)
BBcommon

LITERAL     CSTRIP8                         # jb E2145  6/29/00
Integer I_YIELD, UNT$Pointer                # jb E2145  6/29/00

if (i_Yield > 0)        ## if nuclear weapon explode change ROE
    {
    putUNT$RulesOfEngage$I ($IfAttacked$Code)   ## tpa 6/14/85
    putUNT$NucFree$I       (NO)
    }

if (trace$engage$exe != $no)
   {
    #$% display message
    call echor
    call echov  ('!')
    call echohn (xUNT$Name$C,$$MaxLit)
    call echov (" WEAPONs TIGHT..")
   }

return
end    # End NUC_BLAST



subroutine engdata(unt$pointer,      # receive attacker UNT pointer
                   unt2$pointer)     # receive target UNT pointer   

#####################################################################
#$%
#$%  PURPOSE :       ENGDATA is a data collection routine which
#$%                  collects pertinent data for the engagement
#$%                  log.  It is called by the engagement routines
#$%                  only when the variable 'log$engage' is set to
#$%                  non-zero.
#$%
#$%  CALLED BY :     Any routine which processes engagements.
#$%
#$%  CALLS :         TRKNUM
#$%  
#$%  TABLES :        VUE   RMT   UNT
#$%
#$%  DATE :          JULY  1985
#$%
#$%  AUTHOR :        RUSS GOLISH
#$%
#$%  Modified:       Carol Kropp - 7/95 (E1419)
#$%                  Added additional information to the
#$%                  engagement log (BE, TIN, and attacker
#$%                  and target types).
#$%
#$%                  Susan Miller - 3/97 (E1798)
#$%                  Before extracting name and platform type
#$%                  data ensure that the unit table pointer
#$%                  values are good.
#$%
#####################################################################
BBcommon
ENcommon

## USED FOR COLLECTION OF ENGAGEMENT LOG DATA WHICH WILL BE WRITTEN TO
## DISK IN SUBROUTINE 'EPROSS' IF ENGAGEMENT LOG IS DESIRED. 

literal  track
LITERAL     CSTRIP, CSTRIP8, VUE$Trackcode$C  # jb E2145  6/29/00
integer  UNT$Pointer, UNT2$Pointer
integer  UNT$Type$I, UNT$SubType$I, UNT2$Type$I, UNT2$SubType$I
integer  UNT$SuperType$I, unt2$SuperType$I
integer  TBL$Pointer
integer  UNT$BTTIndx$I, BTT$Pointer
Integer  LASTRMT, I_CODE,                     # jb E2145  6/29/00
    I_CODE_ACTIVE, I_CODE_PASSIVE,            # jb E2145  6/29/00
    VUE$Pointer,VUE$Firstrmtindx$I,VUE$Lastrmtindx$I, # jb E2145  6/29/00
    RMT$Pointer,RMT$Class$I,RMT$Tracknumber$I,   # jb E2145  6/29/00
    RMT$Detectiontype$I                      # jb E2145  6/29/00

   putENG$Time$F (Game$Time)

   if (UNT$Pointer$Valid)   # check for valid pointer - smm 3/97 (E1798)
     {
      UNT$Type$I = xUNT$Type$I           # obtain and store
      UNT$SuperType$i = xUNT$SuperType$i 
      if (UNT$SuperType$i == $SmallBoat$SuperCode)
          putENG$Platform$C (xUNT$Event$C)    # attacker name boat serial 
      else
          putENG$Platform$C (xUNT$Name$C)    # attacker name
      putENG$ShoLat$F (xUNT$TrueLatitude$F)  # jhm E2247 12/01 attacker lat
      putENG$ShoLong$F (xUNT$TrueLongitude$F) # jhm E2247 12/01 attacker lon
      putENG$SalspID$I (xUNT$AlspId$I)       # jhm E2247 12/01 shooter alspid 
      if (UNT$Type$I == $Air$Code)       # attacker type
         TBL$Pointer = xUNT$AccPntr$I
      else if (UNT$Type$I == $CruiseMissile$Code)
         TBL$Pointer = xUNT$CmcPntr$I
      else if (UNT$Type$I == $Sub$Code)
        {
         UNT$SubType$I = xUNT$SubType$I
         if (UNT$SubType$I == $Torpedo$SubCode)
           TBL$Pointer = xUNT$TrpPntr$I
         else   # a marker or regular sub
           TBL$Pointer = xUNT$ShcPntr$I
        }
      else   # ship or boat
         TBL$Pointer = xUNT$ShcPntr$I
      putENG$PlatformType$C (xTBL$Name$C)

      UNT$BTTIndx$I = xUNT$BTTIndx$I
     }
   else
     {
      putENG$Platform$C     ("UNK     ")    #JHM CT02 E2257 1/02 to 8 char
      putENG$PlatformType$C ("UNK     ")
      UNT$BTTIndx$I = 0
     }

   if (UNT2$Pointer$Valid)   # check for valid pointer - smm 3/97 (E1798)
     {
      UNT2$SuperType$i = xUNT2$SuperType$i 
      if (UNT2$SuperType$i == $SmallBoat$SuperCode)
          putENG$Target$C (xUNT2$Event$C)    # attacker name boat serial 
      else
          putENG$Target$C (xUNT2$Name$C)    # attacker name
      putENG$RecLat$f (xUNT2$TrueLatitude$f) 
      putENG$RecLon$f (xUNT2$TrueLongitude$f)
      putENG$HierarchyId$I (xUNT2$HierarchyId$I) # jhm 12/01 E2257 target taskid
      putENG$TalspID$I (xUNT2$AlspId$i)  # jhm 12/01 E2247  target alspid
      UNT2$Type$I = xUNT2$Type$I         # obtain and store
      if (UNT2$Type$I == $Air$Code)      # target type
         TBL$Pointer = xUNT2$AccPntr$I
      else if (UNT2$Type$I == $CruiseMissile$Code)
         TBL$Pointer = xUNT2$CmcPntr$I
      else if (UNT2$Type$I == $Sub$Code)
        {
         UNT2$SubType$I = xUNT2$SubType$I
         if (UNT2$SubType$I == $Torpedo$SubCode)
           TBL$Pointer = xUNT2$TrpPntr$I
         else if (UNT2$SubType$I == $CtrMeasure$SubCode)
           TBL$Pointer = xUNT2$CtmPntr$I
         else   # a marker or regular sub
           TBL$Pointer = xUNT2$ShcPntr$I
        }
      else   # ship or boat
         TBL$Pointer = xUNT2$ShcPntr$I
      putENG$TargetType$C (xTBL$Name$C)
     }
   else
     {
      putENG$Target$C     ("UNK     ")  #JHM CT02 E2257 1/02  TO 8 CHAR
      putENG$TargetType$C ("UNK     ")
     }

   UNT$BTTIndx$I = xUNT$BTTIndx$I
   if (UNT$BTTIndx$I != 0)
     {
      BTT$Pointer$To   (UNT$BTTIndx$I)
      putENG$BEPart1$C (xBTT$BEnumber1$C)
      putENG$BEPart2$C (xBTT$BEnumber2$C)
      putENG$TIN$C     (xBTT$TINnumber$C)
     }
   else
     {
      putENG$BEPart1$C ("        ")
      putENG$BEPart2$C ("        ")
      putENG$TIN$C     ("        ")
     }

   VUE$Pointer$To  xUNT$View$I              # set viewpntr to pointer found 
                                            # for this platform in UNT tabl

   VUE$FirstRmtIndx$I = xVUE$FirstRmtIndx$I #  1st and last indexes into
   VUE$LastRmtIndx$I  = xVue$LastRmtIndx$I  #  RMT table for his view.
   
   RMT$Pointer$To  xVUE$LastRmtIndx$I       #  last RMT pointer position
   lastrmt = RMT$Pointer                    #  and save it in here for loop

   VUE$TrackCode$C    = xVUE$TrackCode$C    #  extract the Track Code

   i_code_active = 99                       #  Initialization <SCC>
   i_code_passive = 99                      #  Dec. 18, 85    <SCC>
  
for (RMT$Pointer$TO VUE$FirstRmtIndx$I;RMT$Pointer <= lastrmt;RMT$Pointer$Next)
     {
      if (UNT2$Pointer$Index == xRMT$Detectee$I)  # we found our guy
        {
         RMT$Class$I       = xRMT$Class$I         # extract his Class
         RMT$TrackNumber$I = xRMT$TrackNumber$I   # extract his track no.

         RMT$DetectionType$I = xRMT$DetectionType$I  #possibly save an extract

############# searching for active detection. Dec. 18, 85 <SCC> #############

         if (RMT$DetectionType$I == $ActiveVisual$Code |
             RMT$DetectionType$I == $ActiveNonVisual$Code)
           {i_code_active = RMT$DetectionType$I
            break
           }

########### saving the first passive detection. Dec. 18, 85 <SCC> ##########
## retaining the original logic, in case failing of finding an active one ##

         if (RMT$DetectionType$I == $PassiveSonar$Code |
             RMT$DetectionType$I == $Esm$Code)
           {if (i_code_passive == 99)
              {i_code_passive = RMT$DetectionType$I
              }
           }
        }                                     
      }  

   if (i_code_active != 99) {i_code = i_code_active}   # set up i_code
   else                     {i_code = i_code_passive}  # for call TRKNUM
################## end of change ############   Dec. 18, 85 <SCC> #########

if (i_code_active != 99 | i_code_passive != 99)# Track on target found
   {
   call TRKNUM(VUE$TrackCode$C,                # get the complete track
               i_code,                         # no. back as a literal 
               RMT$Class$I,
               RMT$TrackNumber$I,
               track)                          # track no. will go in here
   
   PUTeng$Track$c( track )
   }
else
    {
    PUTeng$Track$c( "NOTRACK " )
    }

RETURN
END    # End ENGDATA


real function MBURange(UNT2$Pointer)    #

#####################################################################
#$%
#$%  PURPOSE :       MBURange computes the Range from the current
#$%                  engagement's target to the MBU (Main Battle Unit).
#$%                  
#$%  CALLED BY :     Any routine which processes engagements.
#$%
#$%  CALLS :         RLL2RB
#$%  
#$%  TABLES :        UNT
#$%
#$%  DATE :          August 1985
#$%
#$%  AUTHOR :        RUSS GOLISH
#$%
#####################################################################
# NOTE:  UNT is for MBU;  UNT2  for target

BBcommon

REAL FLAT1, FLON1, BCLAT1,      # jb E2145  6/29/00
     FLAT2, FLON2, BCLAT2,      # jb E2145  6/29/00
     RRANGE, BRNG               # jb E2145  6/29/00
Integer MBUNIT,                 # jb E2145  6/29/00
    UNT$Pointer, UNT2$Pointer   # jb E2145  6/29/00

MBUNIT = max(1,Main$BattleUnit)
UNT$Pointer$To  (MBUNIT)              # Set UNT Pointer to MBU
if (xUNT$InUse$I != $NO)              #    if MBU.....
  {                                   # There is a MBU, must compute the  
   FLAT1 = XUNT$TrueLatitude$F        # Range of target from MBU.
   FLON1 = XUNT$TrueLongitude$F
   BCLAT1 =cos(FLAT1)

   FLAT2 = Xunt2$TrueLatitude$F
   FLON2 = Xunt2$TrueLongitude$F
   BCLAT2 =cos(FLAT2)

   call RLL2RB( _                #Rhumb line Lat/Lon to Range/Bearing
                   FLAT1,            #latitude of 1st pt (input)
                   FLON1,            #longitude of 1st pt (input)
                   BCLAT1,           #cos of lat of 1st pt (input)
                   FLAT2,            #latitude of 2nd pt (input
                   FLON2,            #longitude of 2nd pt (input)
                   BCLAT2,           #cos of lat of 2nd pt (input)
                   RRANGE,           #range (output)
                   BRNG)             #bearing (output)

   mburange = RRANGE                 # Range to Main Battle Unit (MBU)
  }
else
    mburange = -1.0

RETURN
END    # End MBUrange




subroutine torget (unt2$pointer,                # 9/19/85 <SCC>\
                   range_act,                   # for range x
                   range_tma,                   # for range x
                   iBEST,       # jb  DEQ$Pointer$index, or ZERO   3/29/89
                   ph_a,                        # and    Prob Hit
                   ph_t,                        # and    Prob Hit (TMA)
                   ISTMA )                      #               5/5/86
########################################################
#$%
#$% Purpose:   Possible replacement for GETTOR
#$%
#$%
#$% Called By: AIRTOR     SURTOR
#$%
#$% Calls:     None
#$%
#$% Tables:    DEQ        TOR
#$%
#$% Date:      JAN 81
#$%
#$% Author:    Dana Wills
#$%
########################################################
BBcommon

REAL P,PB,PH_T,PH_A,RANGE_ACT,RANGE_TMA,    # jb E2145  6/29/00
    TOR$Maxprobhit$F                        # jb E2145  6/29/00

Integer IHAVE,IBEST,IUPI,ISTMA,             # jb E2145  6/29/00
    UNT2$Pointer,UNT2$Type$I,               # jb E2145  6/29/00
    TOR$Pointer,TOR$Maxalt$I,               # jb E2145  6/29/00
    TOR$Maxrange$I,TOR$PH$Index,            # jb E2145  6/29/00
    DEQ$Pointer                             # jb E2145  6/29/00
Integer Rangex          # jb E2145 (conform to Rangey)  6/29/00
integer RangeY
integer SHC$Pointer
 

RangeX = 0.5 + range_act * $Yds$Per$Mile      # range in yards        5/5/86
RangeY = 0.5 + range_tma * $Yds$Per$Mile              # range in yards
unt2$type$i = Xunt2$type$i                

ihave = $no
ibest = 0
pb = 0.0

#$% for each entry
iUPI = UNT2$Pointer$index                            
for_DEQ_CHAIN (iUPI)                                 
   {            #       Find the BEST applicable torpedo
    #$% if not torpedo, get next entry
    if (Xdeq$ident$i != $Torpedo$code) next  

    #$% if equipment remaining is zero, get next
    if (Xdeq$Remaining$i == 0) next           

    tor$pointer = Xdeq$Pntr$i  #$% TOR pointer

    if (xTOR$AutoLaunch$i == $no) next # available for ROE engagement   DEW 1/90

        #$% Inhibit expending submerged-targets-only torpedoes:
    if (xTOR$subs$i == $yes)    # Submerged-tgt-only torpedo   1/23/86
     {
      if (Xunt2$type$i ^= $sub$code ) # Ineligible surface ship
            NEXT
      else      # This IS a SUB; but skip it if on the surface: 
       {        
        shc$pointer = xUNT2$shcPntr$i        # get ship pointer 
        if (Xunt2$truealtdepth$i <= Xshc$KEELdepth$i) NEXT #   3/23/89
       }
     }
                # end of Inhibit code       9/18/85

    #$% Prevent non-air units from automatic launch of airlaunch-capable
    #   torpedoes (this requires that tor$MaxAlt$i be ZERO for OTHERs):

    TOR$MaxProbHit$F = xTOR$MaxProbHit$F        ## max prob hit tpa 7/27/83

    tor$MaxAlt$i = Xtor$MaxAlt$i
    if (unt2$type$i == $air$code)                
        {
        if (tor$MaxAlt$i == 0) next
        }
    else 
        {
        if (tor$MaxAlt$i != 0) next
        }

    ihave = deq$Pointer$Index
    #$% get maximum torpedo
    tor$MaxRange$i = Xtor$MaxRange$i

    #$% if maximum range
#    if (tor$MaxRange$i < range_tma)  next              #       5/5/86
    if(tor$MaxRange$i  < range_act & ISTMA != $YES |    #       5/5/86
       (tor$MaxRange$i < range_tma & ISTMA != $NO)  )   #       5/5/86
                NEXT                                    #       5/5/86


    ## Find the best torpedo for     
    p = 1.0
        #$% for each probable hit entry
    for (tor$ph$index = 1; tor$ph$index$ok; tor$ph$index = tor$ph$index + 1)
       {
        if (RangeY <= Xtor$ph$Range$i) break
        p = p - 0.1
       }

    if (p > pb)
       {
        pb = p
        iBEST = deq$Pointer$index        
       }
   }

#$% if best
if (ibest != 0)
   {
    #$% set pointer
    #$% set probable hit
    ph_t = pb                                           # set prob. for TMA
    ph_t = MIN(ph_t,TOR$MaxProbHit$F)                   #       tpa     7/27/83

    ph_a = ph_t
   }                                                    #               5/5/86

#   if (range_act != range_tma)
if (range_act != range_tma)
    {
        RangeY = range_act * $Yds$Per$Mile              # range in yards

        tor$pointer = Xdeq$Pntr$i    #$% set TOR pointer (jb DEQ)    3/29/89

        TOR$MaxProbHit$F = xTOR$MaxProbHit$F    ## get max prob hit tpa 7/27/83

        tor$MaxRange$i = Xtor$MaxRange$i

        p = 1.0
        #$% for each probable hit entry
        for (tor$ph$index=1; tor$ph$index$ok; tor$ph$index=tor$ph$index + 1)
           {
           if (RangeY <= Xtor$ph$Range$i) break
           p = p - 0.1
           }

        ph_a = p
       }
    
#$% else if have
else if (ihave != $no)
   {
    iBEST = ihave                              # jb (Return iBEST..) 3/29/89
    ph_T = 0.0
    ph_a = 0.0
   }
else
   {
    iBEST = 0                                  # jb (Return iBEST..) 3/29/89
    ph_t = 0.0
    ph_a = 0.0
   }

return
end    # End TORGET


Subroutine SHOOTAA(unt$pointer,  # (in) Shooting Unit\
                   unt2$pointer, # (in) Target
                   ican,   # (OUT) Flag whether might intercept 
                   IspdMI) # Msl AvgSpeed IN;  Miles To Go, OUT

#################################################################
#$%     # (SHOOTAA derived from VECTOR, in wgopord.rat)
#$% Purpose:   SHOOTAA computes whether a SAM or AAM has sufficient
#$%     speed to make an intercept; and if so, how far it would have
#$%     would have to fly.  May not be called if LEVEL$AA is set to 0.
#$%     Returned values of ICAN:  -1  --> CANNOT INTERCEPT 
#$%                                0  --> NOW WITHIN RANGE
#$%                              > 0  --> MINUTES TO INTERCEPT
#$%
#$%     Returned value of IspdMI      --> N. Miles to Intercept
#$%
#$% Called By: SAMENG   ATOAIR
#$%
#$% Calls:     RRB2LL     RLL2RB     ANGPI
#$%            QCOS       MIN_TO_TARGET
#$%
#$% Tables:    UNT        
#$%            ACD        ACC        
#$%
#$% Author:   Joe Bryant  1/87
#$%
#$% Modified:  Jonathan Richarson - 11/94
#$%            If JECEWSI is participating, factor in
#$%            self protect and comms jamming.
#$%
########################################################
BBcommon

LITERAL     CSTRIP8                        # jb E2145  6/29/00
real*4 launch_factor  # SMM 7/96 (E1631) 
REAL  X,RANDOM,PROB_LAUNCH,RANLAUNCH,      # jb E2145  6/29/00
    XLAT,XLON,XCOS,FLAT,FLON,FCOS,         # jb E2145  6/29/00
    TLAT,TLON,TCOS,TCRS,TSPD,              # jb E2145  6/29/00
    RANGE,BRNG,RADIUS,PRNG,                # jb E2145  6/29/00
    SPDMAX,TOGO,HDNG,                      # jb E2145  6/29/00
    JEW$C3factor$F                         # jb E2145  6/29/00
real RTIM
Integer INRNG,KQ,IQ2,IQ3,ICAN,             # jb E2145  6/29/00
    JTIM,ISPDMI,                          # jb E2145  6/29/00
    UNT$Pointer,JEW$Pointer,UNT2$Pointer   # jb E2145  6/29/00

character NMSG1[ARB]
data x/0.0/		# Get next random number in sequence

# UNT refers to SHOOTING unit.

flat = Xunt$TrueLatitude$f
flon = Xunt$TrueLongitude$f
fcos = Xunt$CosTrueLat$f

tlat = Xunt2$TrueLatitude$f             # Target Position
tlon = Xunt2$TrueLongitude$f
tcos = COS(tlat)

tcrs   = Xunt2$TrueCourse$F             # Target course         1/14/86
call ang2PI(tcrs)
tspd   = Xunt2$TrueSpeed$f              #               & speed

if (jecewsi$game != $no)           # JFR 11/27/94
   {
    call get_jecewsi_factor (UNT$Pointer, UNT2$Pointer, $LaunchFac, launch_factor)
    JEW$Pointer$To (UNT$Pointer$Index)
    JEW$C3Factor$F = xJEW$C3Factor$F
    prob_launch = launch_factor * JEW$C3Factor$F
    ranlaunch = random(x)
    if (prob_launch < ranlaunch)
      {
       ican = -1      # Flag no intercept
       return         # launch failed due to EW effects
      }
   }

call RLL2RB( _                  #Rhumb line Lat/Lon to Range/Bearing
                   tlat,        #latitude of TARGET
                   tlon,        #longitude of TARGET
                   tcos,        #cos of lat of TARGET
                   flat,        #latitude of Interceptor
                   flon,        #longitude of Interceptor
                   fcos,        #cos of lat of Interceptor
                   RANGE,       #range (output)
                   BRNG)        #bearing (output) Tgt to Interceptor

call ang2PI(BRNG)               # vice $ang2pi  8/21/85

SPDMAX = IspdMI                 # float the Avg.Speed of AA missile

RADIUS = 0.     # (0 aims at collision rather than weapons-range intercept)
call RMIN_TO_TARGET(_
            RADIUS,             # Desig. intercept distance ( often, 0.)
            TCRS,               # (radians) course of TARGET        real
            TSPD,               # (knots)   speed  of TARGET        real
            SPDMAX,             # (knots)   speed  of INTERCEPTOR   real
            RANGE,              # (n.mi.) Initial rng between units real
            BRNG,               # (radians) init. brg FROM tgt TO INTERCEPTOR
            RTIM )    # RETURNED value (min.) elapsed time to reach RADIUS


If ( RTIM == -3 ) RTIM = 0      # Flag already within range; 

if( RTIM > 60 | RTIM < 0 )      # No AA intercept for -1 or -7; and
 {                              #  SAM assumed to fly less than an hour.
  ican = -1                     # Flag no intercept
  RETURN
 }

ican = RTIM     # Minutes to Intercept (or Zero, for CLOSE!)    1/12/87

if ( RTIM > 0 ) # 1st typical case:  find Intercept Point; then Heading..
 {
  xlat = tlat                   # Target initial latitude
  xlon = tlon                   # Target initial longitude
  xcos = tcos                   # cos of tgt init. latitude
  prng = (tspd *RTIM) * $Hours$Per$Minute # Tgt travel to intercept point
  call RRB2LL( _        # Find Lat/Long of the Intercept-Point
                   xlat,        #TGT latitude -> Intercept Latitude
                   xlon,        #TGT longitude -> Intercept Long.
                   prng,        #range (input) to Intercept Point
                   0.0,         #relative bearing (input)
                   tcrs,        #TGT heading (input)
                   xcos)        #cosine of TGT latitude (old and new)

  call RLL2RB( _        #Find Interceptor Heading & Distance TOGO
                   flat,        #latitude of INTERCEPTOR
                   flon,        #longitude of INTERCEPTOR
                   fcos,        #cos of lat of INTERCEPTOR
                   xlat,        #latitude of Intercept Point
                   xlon,        #longitude of Intercept Point
                   xcos,        #cos of lat of Intercept Point
                   TOGO,        #(output) range TOGO to intercept point
                   HDNG)        #(output) HDNG of Interceptor to "  "
  #call ang2PI(HDNG)    #  HDNG not used below ... so not adjusted   1/12/87

 }      # End of 1st typical case, with RTIM > 0


else
 {  
  ican = 0              # RESET flag to indicate 0 minutes      2/24/86
  RTIM = 0
  TOGO = 0.0                                            #       1/12/86
 }

IspdMI = int(TOGO)      # Send back INT(dist. to go to intercept) 1/12/87

IF ( 1 < 2 ) RETURN             # Deactivate debugging msg.     1/28/87
##Following message tentatively inserted 3/18/83:
inRNG = RANGE
kq = 0
call smovhn (xUNT$Name$C, $$MaxLit,nmsg1,kq)
call smovv  (" AA InitRange ",nmsg1,kq)
call smovi  (  inRNG,             nmsg1,kq)

call smovv  (" SPD  ",nmsg1,kq)
iq2 = max(SPDMAX, 2.0) +0.5                             #       7/31/84
call smovi  (      iq2,     nmsg1,kq)

call smovv (" to travel ",nmsg1,kq)
iq3 = max(0, IspdMI)
call smovi  (       iq3,    nmsg1,kq)

call smovv  (" NMI in ",  nmsg1,kq)
JTIM = MAX(0.0 ,RTIM)                                      #       8/21/85
call smovi  (       JTIM,    nmsg1,kq)                  #       8/21/85
call smovv  (" min.", nmsg1,kq)

call send_ (Xunt$VIEW$i,0, kq,nmsg1)

return
end    # End  SHOOTAA


Real Function XRel_Speed(spd1,crs1,spd2,crs2)
########################################################
#$%
#$% Purpose:   XRel_Speed calculates the relative speed between 
#$%   two objects.  Course angles are in radians.
#$%
#$% Called By: IR_MOD
#$%
#$% Date:      September 1992
#$%
#$% Author:    John Strauch
#$%
########################################################
BBimplicit                          # jb E2145  6/29/00

REAL  RV1,RV2,SPD2,CRS2,SPD1,CRS1   # jb E2145  6/29/00

rv1 = spd2 * cos(crs2) - spd1 * cos(crs1)
rv2 = spd2 * sin(crs2) - spd1 * sin(crs1)
XRel_Speed = sqrt(rv1 * rv1 + rv2 * rv2)
return
end


Real Function XProbability(pixels)

########################################################
#$%
#$% Purpose:   XProbability converts number of pixels in
#$%   the IR's field of view to a probability. For detection
#$%   10% corresponds to 1 pixel, 30% to 1.5, 50% to 2,
#$%   80% to 3, 95% to 4, and 100% to 6.  For Classification
#$%   (Recognition) use pixels/4 and for Identification 
#$%   use pixels/6.4.
#$%
#$%   XProbability is allowed to be greater than one since it
#$%   may be adjusted downward later due to relative speed,
#$%   scan rate, operator ability and time of day. (2/3/93)
#$%
#$% Called By: IR_MOD
#$%
#$% Date:      November 1992
#$%
#$% Author:    John Strauch
#$%
########################################################
BBimplicit

REAL   PIXELS       # jb  E2145  6/29/00

if      (pixels <  .8) XProbability = 0
else if (pixels < 2.6) XProbability = .4 * pixels - .3
else if (pixels < 4.3) XProbability = .15 * pixels + .35
else                   XProbability = .025 * pixels + .85

return
end


subroutine bmepro (unt$pointer) 
########################################################
#$%
#$% Purpose:   BMEPRO processes ballistic missile
#$%            engagements. 
#$%                       
#$% Called By: ENGAGE
#$%
#$% Calls:     ALSP_Send_Posit_Engage  <alsp_send_interact.rat>
#$%            Log_Posit_Eng
#$%            Process_TBM_Hits
#$%
#$% Tables:    UNT
#$%
#$% Date:      JUN 93
#$%
#$% Author:    Alex Vagus
#$%
#$% Modified:  Carol Kropp - Dec. 1993
#$%            Added for sending of ALSP interactions.
#$%            Also moved search for targets to a separate
#$%            routine (for reusability).
#$%
#$%            Susan Miller - 4/98 (E1590)
#$%            Add check whether missile is at current elevation or 
#$%            above it.  If it is at current elevation, the missile 
#$%            will explode.  If it is at termination time, put it 
#$%            at current elevation.
#$%
########################################################
BBcommon
NUcommon
ENcommon

LITERAL  ENG$Weapon$C, ENG$Platform$C, CSTRIP8 # jb E2145  6/29/00
LITERAL  CMC$Type$C, UNT$Name$C, UNT2$Name$C   # JHM    10/02
Integer  UNT$AttackIndx$i, UNT$TargetType$I, UNT2$GhostedUnit$I  #JHm 10/02
Integer  UNT2$Pointer 
integer  hit_flag
real     impact_lat, impact_lon

Integer IEPUS, IDUMMY_TARGET_CODE,             # jb E2145  6/29/00
   UNT$Pointer, UNT$View$I                     # jb E2145  6/29/00
 
integer  the_elevation  # function to obtain elevation  # SMM 4/98 (E1590)
integer  UNT$TrueAltDepth$I, alt_at_point                 # SMM 4/98 (E1590)
integer  CMC$Pointer, UNT$OrderedAltDepth$I               # SMM 4/98 (E1590)

UNT$OrderedAltDepth$I = xUNT$OrderedAltDepth$I
UNT$TrueAltDepth$I = xUNT$TrueAltDepth$I
alt_at_point = the_elevation (xUNT$Truelatitude$F*$rad2deg,      # SMM 4/98 (E1590)
                              xUNT$TrueLongitude$F*$rad2deg)

if (xUNT$TimeTerm$F < Game$Time)               #if missile flight terminated
  {
   PUTunt$status$i ($beingdeleted$code)        #remove missile from system
  
   # if the missile isn't at the current elevation at detonation time, 
   # put it there.
   if (UNT$TrueAltDepth$I != alt_at_point)     # SMM 4/98 (E1590)
     {
      UNT$TrueAltDepth$I = alt_at_point
      putUNT$TrueAltDepth$I
     }

   #$% if an engagment log is being kept, log the termination
   CMC$Pointer = xUNT$CMCpntr$I            # clk 2/94 (E1124)
   if (log$engage != $no)
      call Log_Run_Time_Termination (UNT$Pointer, CMC$Pointer)

   return 
  }

if(Xunt$hits$i >= 1)         #this missile has been hit 
   return 

if (UNT$TrueAltDepth$I != UNT$OrderedAltDepth$I) # this missile still flying 
  {# but need to check to see if the missile is above the current elevation 
   # get the altitude at this point SMM 4/98 (E1590)

   if (UNT$TrueAltDepth$I < alt_at_point)
     {
      putUNT$Status$I ($BeingDeleted$Code) # remove missile from system
      if (log$engage != $no)
        {
         call engdata (unt$pointer, 0)
         CMC$Pointer = xUNT$CMCpntr$I
         putENG$TargetType$C  ("LAND")
         ENG$Weapon$C = xCMC$Type$C      # CM Type
         putENG$Weapon$C
         putENG$Result$I  (ENG$Miss$Code)
         call write_eng_rec
        }   # end of if an engagement log is desired
     } 
   return
  }

# At this point, the missile has reached the impact point

   impact_lat = Xunt$BallisticImpactLat$f
   impact_lon = Xunt$BallisticImpactLon$f   

   # if the missile isn't at the current elevation at impact time, 
   # put it there.                               SMM 4/98 (E1590)
   if (UNT$TrueAltDepth$I != alt_at_point)
      {
       UNT$TrueAltDepth$I = alt_at_point
       putUNT$TrueAltDepth$I
      }

   CMC$Pointer = xUNT$CMCPntr$I

   # This is meant to allow targeted bases for TBM shots (E2311)  JHM 10/02
   if (xUNT$AttackIndx$i != 0)  # alsp messages now conform to ALSP ICD
     {
       unt2$pointer$to xUNT$AttackIndx$i
       if (xUNT2$GhostedUnit$I == $yes &      # if an ALSP ghost
         ALSP$Active == $yes)
        {
         UNT$TargetType$I = xUNT$TargetType$I
         call ALSP_Send_CM_Engage (UNT$Pointer, UNT2$Pointer, UNT$TargetType$I)
         call Log_ALSP_Engagement_engdata (unt$pointer,
                                           unt2$pointer,
                                           xCMC$Type$C,
                                           0, 1)
         PUTunt$status$i ($beingdeleted$code)    #remove missile from system
          # since the tbm is impacting and the status is set to 
          # being deleted below, go ahead and clear the BTT info
         call Clear_BTT_Info (UNT$Pointer)
         return   #end of processing, damage assessed by alsp ghost
        }
     }  # end of attackindx not equal 0   JHM 10/02
 


   # note - this routine will only send msg if ALSP is active
   idummy_target_code = 0
   call ALSP_Send_Posit_Engage (UNT$Pointer, $CruiseMissile$Code,
                                CMC$Pointer, 1, impact_lat, impact_lon,
                                idummy_target_code)

   iepus = INT ((xCMC$Weight$I * 0.01) + 0.5)
   call Log_Posit_Eng (UNT$Pointer, CMC$Pointer, impact_lat, impact_lon,
                       0, 1, 1, iepus)     # zero range, one hit, one fired

   iYIELD = Xcmc$Yield$i
   IF  (iYIELD >0 & Nuclear$Capable !=$NO & Xunt$Nuclear$i !=$NO)
                    # attacking ballistic missile is NUCLEAR.4/25/85
    {
      IntcptFlag = 0  #   NOT intercepted..
      FLAT = Xunt$TrueLatitude$F   ##..whose position is this.. (jb 3/27/89)
      FLON = Xunt$TrueLongitude$F   
      nPH  = 100                   # always a hit
      unt$VIEW$I = Xunt$VIEW$I
      IF  (unt$VIEW$I > $LastBlue$View)  
         kside = 2
      ELSE IF (unt$VIEW$I > $Neutral$View)   
         kside = 1
      ELSE                                  
         kside = 0

      iBURST  = Xcmc$BurstType$i
      iDEPTH = 1                    # Irrelevant.. NOT subsurface..
      IF  (iBURST == $SubSurface$Code)
         iDEPTH = Xcmc$BurstDepth$I +1 # add 1 to this flag for convenience
             #of NUCDAM processing..which expects 1 or 2 vice 0 or 1
 
       call SEND_DETON
    }
         ## End of attacking ballistic nuclear..

   call Process_TBM_Hits (UNT$Pointer, CMC$Pointer,
                          impact_lat, impact_lon, hit_flag)

   PUTunt$status$i ($beingdeleted$code)        #remove missile from system
 
   # since the tbm is impacting and the status is set to 
   # being deleted below, go ahead and clear the BTT info
   call Clear_BTT_Info (UNT$Pointer)
 
return    #end BMEPRO
end


Subroutine Log_Posit_Eng (UNT$Pointer,      # in: attacking platform UNT pointer
                          TBL$Pointer,      # in: generic char pointer for weapon
                          target_lat,       # in: position latitude (radians)
                          target_long,      # in: position longitude (radians)
                          range,            # in: integer range from target
                          number_hits,      # in: number of hits
                          number_fired,     # in: number of weapon fired
                          epus_delivered)   # in: amount of epus
################################################################################
#$%
#$% Purpose:    Log_Posit_Eng will set up and write out the engagement log
#$%             record for the position engagement, if an engagement log
#$%             is desired.
#$%
#$% Called By:  ASM_at_Posit
#$%             Bomb_at_Posit
#$%             BMEPRO
#$%             CMEPRO
#$%             gun_targets
#$%
#$% Calls:      RadToDMS
#$%             Smov..
#$%             Write_Eng_Rec
#$%             Record_TMS_Ground_Attack
#$%             Record_C2_Air_Ground_Eng
#$%             Record_C2_Flight_EQ_Expended
#$%
#$% Tables:     UNT     TBL     ACC     CMC     SHC
#$%
#$% Date:       August 1993
#$%
#$% Author:     Carol L. Kropp
#$%
#$% Modified:   Carol Kropp - 6/95 (E1419)
#$%             Changed input params attacker_name to attacker's
#$%             UNT$Pointer and weapon_name to weapon's characteristics
#$%             pointer and added new param for epus to make the routine
#$%             more extendable.  With the additional info other loggin
#$%             type routine can be called, so the code is only in one
#$%             place.  Also added handling of BE and TIN information (for
#$%             the TMS interface implementation).
#$%
#$%             Carol Kropp - 12/96 (E1726)
#$%             Record_C2_Flight_EQ_Expended changed to 
#$%             Record_Flight_EQ_Expended.
#$%
#$%             Carol Kropp - 2/97 (E1731)
#$%             PEMIndx shares the space of TIN in the the ENG entry, so
#$%             make sure that the PEMIndx if set before call does not get
#$%             wiped out (events are mutually exclusive).
#$%
################################################################################
BBCommon
ENCommon

LITERAL   CSTRIP8          # jb E2145  6/29/00
literal   unit_name        # attacking platform's name
literal   weapon_name      # weapon characteristic name
literal   ENG$TargetType$C
real      target_lat, target_long
integer   UNT$Pointer, TBL$Pointer
integer   range, number_hits, number_fired
integer   epus_delivered
integer   BTT$Pointer      # pointer to BE and TIN Table entry
integer   UNT$BTTIndx$I    # BE and TIN Table Index for platform
integer   dummy            # dummy variable/parameter
integer   UNT$Type$I       # attacker's platform class
integer   UNT$LaunchIndx$I # index to platform which launched cm
integer   UNT2$Pointer     # launching platform for cruise missiles
Integer   UNT2$Type$I      # jb E2145   6/29/00
integer   temp, k
integer   PEMIndx
BBDeclare (agd$pointer)

VMSchar  Ground_size_to_char*ARB
VMSchar  sizeV*ARB
 
  if (UNT$Pointer$Valid)
    unit_name = xUNT$Name$C
  else
    unit_name = 'Unknown'

  weapon_name = xTBL$Name$C
  UNT$BTTIndx$I = xUNT$BTTIndx$I

  UNT$Type$I = xUNT$Type$I
  if (log$engage != $no)          # if engagement log is desired
    {
     call engdata (unt$pointer, 0)
     putENG$Weapon$C      (weapon_name) 
     putENG$TargetType$C  ("POSITION")
     putENG$RecLat$F      (target_lat)
     putENG$RecLon$F      (target_long)
     putENG$Range$F       (float(range))
     putENG$Result$I      (ENG$P$Code)
     putENG$NumberHit$I   (number_hits)
     putENG$NumberFired$I (number_fired)

     if (Xunt$agdIndex$i != 0)              # Targeted by alspid
     {
        agd$pointer$to Xunt$AGDIndex$i
        putENG$Target$C  (Xagd$Name$C) 
        putENG$TAlspId$i  (Xagd$ALSPID$I) 
        sizeV = Ground_size_to_Char (Xagd$ALSPSize$I)
        k = 0
        call smovhn (%%ref(sizeV), $$MaxLit, ENG$TargetType$C, k)
        PUTENG$TargetType$C
     }

     temp = TBL$Pointer
     if (UNT$Type$I == $Air$Code)
        TBL$Pointer = xUNT$AccPntr$I
     else if (UNT$Type$I == $CruiseMissile$Code)
        TBL$Pointer = xUNT$CmcPntr$I
     else   # ship or boat
        TBL$Pointer = xUNT$ShcPntr$I
     putENG$PlatformType$C (xTBL$Name$C)
     TBL$Pointer = temp

     PEMIndx = xENG$PEMIndx$I

     if (UNT$BTTIndx$I != 0)
       {
        BTT$Pointer$To   (UNT$BTTIndx$I)
        putENG$BEPart1$C (xBTT$BEnumber1$C)
        putENG$BEPart2$C (xBTT$BEnumber2$C)
        putENG$TIN$C     (xBTT$TINnumber$C)
       }
     else
       {
        putENG$BEPart1$C ("        ")
        putENG$BEPart2$C ("        ")
        putENG$TIN$C     ("        ")
       }

     if (PEMIndx != 0)
       putENG$PEMIndx$I  (PEMIndx)
     call write_eng_rec
   }               # end of if an engagement log is desired
#  if (UNT$BTTIndx$I != 0)
#    call Record_TMS_Ground_Attack (UNT$pointer, dummy, target_lat, target_long,
#                                   weapon_name, number_hits, epus_delivered)

  if (UNT$Type$I == $CruiseMissile$Code)      # only do the C2 ground eng
    {                                         # when the cruise missiles
     UNT$LaunchIndx$I = xUNT$LaunchIndx$I     # are launched from aircraft
     UNT2$Pointer$To  (UNT$LaunchIndx$I)
     UNT2$Type$I = xUNT2$Type$I
#     if (UNT2$Type$I == $Air$Code)
#       call Record_C2_Air_Ground_Eng (dummy, target_lat, target_long,
#                                      epus_delivered, UNT$Pointer)
    }
  else if (UNT$Type$I == $Air$Code) 
    {
#     call Record_C2_Air_Ground_Eng (dummy, target_lat, target_long,
#                                    epus_delivered, UNT$Pointer)
     call Record_Flight_EQ_Expended (UNT$Pointer, TBL$Pointer, number_fired)
    }



return
end


Subroutine Air_Engage_Posit (UNT$Pointer)      # in: attacking unit pointer
################################################################################
#$%
#$% Purpose:    Air_Engage_Posit processes air-to-surface engagements using
#$%             ASM and bombs against a position.
#$%
#$% Called By:  EPROSS
#$%
#$% Calls:      DEQGET     ECHO..     RLL2RB
#$%             ASM_at_Posit
#$%             BOMB_at_Posit
#$%             Bingo            <wgmdflt.rat>
#$%
#$% Tables:     UNT     ACC
#$%
#$% Date:       August 1993
#$%
#$% Author:     Carol L. Kropp
#$%
#$% Modified:   Carol Kropp - 2/97 (E1731)
#$%             Subroutine Bomb_at_Posit changed to Bomb_or_Mine_at_Posit.
#$%
################################################################################
BBCommon

LITERAL     CSTRIP8                        # jb E2145  6/29/00
real     range_to_posit, bearing_to_posit
real     attacker_lat, attacker_long, target_lat, target_long
real     fudge
BBDeclare  (UNT$Pointer, AGD$Pointer, UNT3$Pointer, UNT$Mission$I)
integer  number_eq, number_asms, number_bombs
integer  eqlist[5,30]

data fudge/0.005/

  if (trace$engage$exe != $no)
    {
     call echor
     call echov  ("! Air to Surf.....")
     call echohn (xUNT$Name$C, $$MaxLit)
     call echov  (" Attacking A Position")
    }

  number_eq = 0       # initialize to zero equipment items located
  call DEQGET (UNT$Pointer, $ASM$code, number_eq, EqList)
  number_asms = number_eq
  call DEQGET (UNT$pointer, $Bomb$code, number_eq, EqList)
  number_bombs = number_eq - number_asms

  if (number_eq <= 0)       # if no ASMs or Bombs, nothing to shoot
  {
     if (trace$engage$exe != $no)
        call echov  (", but has no ASMs or BOMBs - deassigning target.")

     # since the engagement is over  go ahead and clear the BTT info
     call Clear_BTT_Info (UNT$Pointer)   # clk 7/95 (E1419)

     putUNT$EngageStatus$I   ($EngagementOver$Code)
    UNT3$Pointer$To XUNT$AttackIndx$I # jb (no X)    1/3/00 
    if (unt3$pointer$ok)
        putUNT3$UnderAttack$i ($NO)  # send the target on his way
     putUNT$AttackIndx$I     ($no)
     putUNT$AssignedTarget$I ($no)
     putUNT$Status$I         ($Proceeding$Code)
     putUNT$ReactFlag$I      ($no)
     putUNT$AGDIndex$I       ($no)

     UNT$Mission$I = XUNT$Mission$I
     if (UNT$Mission$I == $Strike$Code                    |
         UNT$Mission$I == $AirInteraction$Code            |
         UNT$Mission$I == $BattleFieldAirInteraction$Code |
         UNT$Mission$I == $CloseAirSupport$Code           )  
        call Bingo (UNT$Pointer)
  }
  else
    {
     attacker_lat = xUNT$TrueLatitude$F
     attacker_long = xUNT$TrueLongitude$F

     if (xUNT$AGDIndex$i == 0)
     {       
         target_lat = xUNT$TargetLatitude$f
         target_long = xUNT$TargetLongitude$f
     }
     else       # Get latest position 
     {
        agd$pointer$to xUNT$AGDIndex$i
        target_lat = xAGD$TrueLatitude$f
        target_long = xAGD$TrueLongitude$f
     }

     call RLL2RB (target_lat,     target_long,     xUNT$CosTrueLat$F,
                  attacker_lat,   attacker_long,   cos(target_lat),
                  range_to_posit, bearing_to_posit)
     range_to_posit = range_to_posit - fudge
     if (trace$engage$exe != $no)
       {
        call echov (" Rng =")
        call echof (range_to_posit, 0703)
       }

     #$%  Process the ASMs against the position
     if (number_asms > 0)    # if the unit has any ASMs to go against posit
       {
        call ASM_at_Posit (UNT$Pointer, range_to_posit,
                           target_lat,  target_long,
                           number_asms, eqlist)
       }       # end of ASM processing against the position

     #$%  Process the BOMBs against the position
     if (number_bombs > 0)   # if the unit has any Bombs to go against posit
       {
        call BOMB_or_Mine_at_Posit (UNT$Pointer, range_to_posit, 
                                    target_lat, target_long,
                                    number_eq,    (number_asms + 1),  eqlist)
       }       # end of bomb processing
    }          # end of unit has weapons capable of targeting position

return
end


Subroutine ASM_at_Posit (UNT$Pointer,      # in: attacking unit pointer
                         range_to_target,  # in: nmi range to the target
                         target_lat,       # in: position latitude
                         target_long,      # in: position longitude
                         number_asms,      # in: number of asm entries in eqlist
                         eqlist)           # in/out:  equipment list
################################################################################
#$%
#$% Purpose:    ASM_at_Posit processes air-to-surface missile engagements
#$%             against a position.  Also, calls the routine to send an
#$%             ALSP interaction message and log the egagement.  Since RESA
#$%             is not processing any sort of damage regarding this interaction
#$%             allow all asms to hit.
#$%
#$% Called By:  Air_Engage_Posit
#$%
#$% Calls:      ECHO..
#$%             ALSP_Send_Posit_Engage
#$%
#$% Tables:     UNT     MC     ACC     DEQ
#$%
#$% Date:       August 1993
#$%
#$% Author:     Carol L. Kropp
#$%
#$% Modified:   Carol Kropp - 10/94
#$%             added call to Record_C2_Air_Ground_Eng
#$%             and Record_C2_Flight_EQ_Expended - WPC C2
#$%
#$%             Carol Kropp - 7/95 (E1419)
#$%             Replaced 10/94 calls with call to expanded Log_Posit_Eng.
#$%
################################################################################
BBCommon

LITERAL     CSTRIP8                 # jb E2145  6/29/00
Integer  IEPUS,UNT$Targettype$I     # jb E2145  6/29/00
integer   UNT$Pointer
real      range_to_target, target_lat, target_long
integer   number_asms, eqlist[5,30]
 
integer  asm_in_range, shortest_range, number_to_fire, ripple_flag
integer  n                   # loop control and indexing variable
integer  MC$Pointer,   MC$MaxRange$I
integer  DEQ$Pointer, DEQ$RippleQty$I

asm_in_range = $no
shortest_range = 1024
ripple_flag = $no

for (N = 1; N <= number_asms; N = N + 1)  # find shortest range asm
{
    if (EqList[3,N] > 0)
    {    
        MC$Pointer = EqList[2,N]
        MC$MaxRange$I = xMC$MaxRange$I

        if (range_to_target <= MC$MaxRange$I)  # if missile is in range
        {
            #$% If max range less than saved range, keep it and get next.
            if (MC$MaxRange$I < shortest_range)
            {
                shortest_range = MC$MaxRange$I
                asm_in_range = n
            }
        }       # end of missile within range
    }          # end of any missiles of this type left
}             # end loop through all missiles found

if (asm_in_range != $no)     # if an asm in range
{
    putUNT$EngageStatus$i ($Engaging$code)

    DEQ$Pointer$To (EqList [1, asm_in_range])  
    MC$Pointer = EqList [2, asm_in_range]

    number_to_fire = xUNT$NbrAc$I * xMC$RoundsPerSalvo$I
    if (number_to_fire > EqList [3,asm_in_range])
       number_to_fire = EqList [3,asm_in_range]

    DEQ$RippleQty$i = xDEQ$RippleQty$i
    if (DEQ$RippleQty$i != 0)
    {
        number_to_fire = min (number_to_fire, DEQ$RippleQty$i)
        ripple_flag = $yes

        if (trace$engage$exe != $no)
        {
            call echov  (" (ripple)")
        }
    }

    if (trace$engage$exe != $no)
    {
        call echor
        call echov  ("   w/ ")
        call echoi  (number_to_fire)
        call echov  (" ")
        call echohn (xMC$Name$C, $$MaxLit)
        call echo   ($space)
    }

    # note - this routine will only send ALSP msg id ALSP is active
    UNT$TargetType$I = xUNT$TargetType$I
    call ALSP_Send_Posit_Engage (UNT$Pointer,    $ASM$Code,    MC$Pointer,
                                  number_to_fire, target_lat,  target_long,
                                  UNT$TargetType$I)

    iepus = xMC$Weight$I * number_to_fire / 100
    call Log_Posit_Eng (UNT$Pointer, MC$Pointer,
                         target_lat, target_long, int(range_to_target),
                         number_to_fire, number_to_fire, iepus)

    EqList [3, asm_in_range] = EqList [3, asm_in_range] - number_to_fire
    putDEQ$Remaining$I  (EqList [3, asm_in_range])    # decrement the units asm store
}        # end of ASM processing...if any ASMs are in range

if (ripple_flag == $yes)
{
    putUNT$EngageStatus$I ($EngagementOver$Code) # Allow next STRIKE
    putUNT$AGDIndex$I (0)
}

return
end


Subroutine BOMB_or_Mine_at_Posit (_
                          UNT$Pointer,      # in: attacking unit pointer
                          range_to_target,  # in: nmi range to the target
                          target_lat,       # in: position latitude
                          target_long,      # in: position longitude
                          number_eq,        # in: number of items in eqlist
                          eq_start_index,   # in: location in eqlist where bombs start
                          eqlist)           # in/out:  equipment list
################################################################################
#$%
#$% Purpose:    Bomb_or_Mine_at_Posit processes air-to-surface engagements
#$%             against a position.  Also, calls the routine to send an
#$%             ALSP interaction message and log the egagement.  Since RESA
#$%             is not processing any sort of damage regarding this interaction
#$%             allow all bombs to hit.
#$%
#$% Called By:  Air_Engage_Posit
#$%
#$% Calls:      ECHO..
#$%             ALSP_Send_Posit_Engage
#$%             Create_Persistent_Munition   <wgmdmine.rat>
#$%
#$% Tables:     UNT     BOM     ACC     DEQ
#$%
#$% Date:       August 1993
#$%
#$% Author:     Carol L. Kropp
#$%
#$% Modified:   Carol Kropp - 10/94
#$%             added call to Record_C2_Air_Ground_Eng
#$%             and Record_C2_Flight_EQ_Expended - WPC C2
#$%
#$%             Carol Kropp - 7/95 (E1419)
#$%             Replaced 10/94 calls with call to expanded Log_Posit_Eng.
#$%
#$%             Susan Miller 3/25/95  removed the 6th parameter input, 
#$%             number_bombs, since it was not used.
#$%
#$%             Carol Kropp - 1/97 (E1731)
#$%             Expended from Bomb_at_Posit to include mines and possibility
#$%             of persistent effects after initial detonation.
#$%
#$%             Carol Kropp - 7/97 (E1858)
#$%             Moved the lines which set iepus and call Log_Posit_Eng from
#$%             right before the creation of a PEM (if necessary) to right
#$%             after so that the PEM related engagement log fiels could
#$%             be set with the the PEM$Pointer$Index info.
#$%
################################################################################
BBCommon

LITERAL     CSTRIP8                       # jb E2145  6/29/00
real      range_to_target, target_lat, target_long
integer   UNT$Pointer,UNT$Targettype$I    # jb E2145  6/29/00
integer   number_eq, eq_start_index, eqlist[5,30], shortest_range
integer  n, m, number_to_drop
integer  BOM$Pointer, DEQ$Pointer, DEQ$RippleQty$I, BOM$DropRange$i
integer  iepus
integer  platform_side, ripple_flag
integer  bomb_in_range

ripple_flag = $no
bomb_in_range = 0
shortest_range = 1024

for (n = eq_start_index; n <= number_eq; n = n + 1)
{
    if (EqList [3, n] > 0)      # if any of this type left
    {
        BOM$Pointer = EqList[2,N]
        BOM$DropRange$I = xBOM$DropRange$I

        if (range_to_target <= BOM$DropRange$I)  # if bomb is in range
        {
            #$% If max range less than saved range, keep it and get next.
            if (BOM$DropRange$I < shortest_range)
            {
                shortest_range = BOM$DropRange$I
                bomb_in_range = n
            }
        }       # end of bomb within range
    }          # end of any bombs of this type left
}             # end loop through all bombs found

if (bomb_in_range != $no)     # if an bombs in range
{
    putUNT$EngageStatus$I ($Engaging$code)

    n = bomb_in_range

    DEQ$Pointer$To  (EqList [1, n])
    BOM$Pointer    = EqList [2, n]
    number_to_drop = EqList [3, n]

    DEQ$RippleQty$i = xDEQ$RippleQty$i
    if (DEQ$RippleQty$i != 0)
    {
        number_to_drop = min (number_to_drop, DEQ$RippleQty$i)
        ripple_flag = $yes

        if (trace$engage$exe != $no)
        {
            call echov  (" (ripple)")
        }
    }

    if (trace$engage$exe != $no)
    {
        call echor
        call echov  ("    W/ ")
        call echoi  (Number_to_Drop)
        call echo   ($space)
        call echohn (xBOM$Name$C, $$MaxLit)
    }

    # note - this routine will only send ALSP msg id ALSP is active
    #        and it also does the engagement log if required
    UNT$TargetType$I = xUNT$TargetType$I
    call ALSP_Send_Posit_Engage (UNT$Pointer,    $Bomb$Code,   BOM$Pointer,
                                     Number_to_Drop, target_lat,   target_long,
                                     UNT$TargetType$I)

    if (xBOM$NbrPersistentDets$I > 0)   # clk 1/97 (E1731)
    {
        call whside (xUNT$View$I, platform_side)
        for (m = 1; m <= Number_to_drop; m = m + 1)
        {
            call Create_Persistent_Munition (UNT$Pointer, BOM$Pointer,
                                               target_lat,   target_long,
                                               $no, platform_side, 0, 0, 0)
        }   # end of loop through each of this type
    }   # end of if the weapon has persistent effects

    iepus = xBOM$Weight$I * Number_to_drop / 100
    call Log_Posit_Eng (UNT$Pointer, BOM$Pointer, target_lat, target_long,
                            0, Number_to_Drop, Number_To_Drop, iepus)

    EqList [3, n] = max(0, EqList [3, n] - number_to_drop)
    putDEQ$Remaining$I  (EqList [3, n])    # decrement the units store
}       # end of if any bombs/mines of this type left on the unit


if (ripple_flag == $yes)
{
    putUNT$EngageStatus$I ($EngagementOver$Code) # Allow next STRIKE
    putUNT$AGDIndex$I (0)
}

return
end


subroutine Get_ASM_or_Bomb_PH (_
                UNT$Pointer,           # in:  targets's unit pointer
                weapon_eph_index,      # in:  weapon index into eph
                probability_of_hit,    # out: probability of hit
                weapon_type)           # in:  $asm$code or $bomb$code
########################################################
#$%
#$% Purpose:   Get_ASM_or_Bomb_PH calculates the
#$%            probability of hit for a air-to-surface
#$%            missile or bomb.
#$%
#$% Called by: AirASM
#$%            ALSP_Receive_ASM_Engage  <alsp_receive_interact.rat>
#$%            ALSP_Receive_BOMB_Engage <alsp_receive_interact.rat>
#$%
#$% Calls:     Echo..    FLOAT    AMAX1
#$%
#$% Tables:    UNT       SHC
#$%
#$% Date:      Sept. 1993
#$%
#$% Author:    Code moved from AirASM
#$%
#$% Modified:  Susan Miller 5/98 (E1989)
#$%            Removed small boat prob hit degradation for
#$%            ASM hits.  Added parameter, weapon_type, so
#$%            that bomb ph will be calculated the same as
#$%            in routine airbomb.
#$%
########################################################
BBCommon
Eng$ProbHits

real     probability_of_hit
real     reduction_factor, target_speed
integer  UNT$Pointer, weapon_eph_index, weapon_type

integer  target_eph_index, SHC$Pointer
integer  UNT$Type$I

  SHC$Pointer = xUNT$ShcPntr$I
  target_eph_index = xSHC$TargetIndex$I

  probability_of_hit = eph [target_eph_index, weapon_eph_index] * 0.01
  if (weapon_type == $Bomb$code)
    {
     UNT$Type$I = xUNT$Type$I   # get target type
     if ((UNT$Type$I == $Surface$Code) | (UNT$Type$I == $Sub$Code))
       {
        target_speed = xUNT$TrueSpeed$F
        reduction_factor = 1.0 - (target_speed/100.0)
        reduction_factor = AMAX1(0.01,reduction_factor)  
        probability_of_hit = probability_of_hit * reduction_factor
       } # end if surface or sub
    } # end if weapon is a bomb

return
end



Subroutine Process_TBM_Hits (_
           UNT$Pointer,     # in: Attacking missile UNT pointer
           CMC$Pointer,     # in: Attacking missile characteristic pointer
           impact_lat,      # in: latitude of impact position
           impact_long,     # in: longitude of impact position
           hit_flag)        # out: 0 means no hits; 1 means one or more hits
########################################################
#$%
#$% Purpose:   Process_TBM_Hits searchs the UNT table
#$%            determining which units are within the
#$%            damage radius of the missile and assesses
#$%            damage.
#$%
#$% Called By: BMEPRO
#$%
#$% Calls:     COS
#$%            RLL2RB
#$%            INT
#$%            MBURange
#$%            Write_Eng_Rec
#$%
#$% Tables:    UNT        CMC
#$%
#$% Date:      December 1993
#$%
#$% Author:    Code moved from CMHIT (clk)
#$%
########################################################
BBcommon
ENcommon

literal  missile_name, missile_type, target_name, attacker_track
LITERAL     CSTRIP8                     # jb E2145  6/29/00
REAL        BRNG                        # jb E2145  6/29/00
real     impact_lat, impact_long
real     cos_impact_lat
real     target_lat, target_long, cos_target_lat
real     range_nmi
integer  UNT$Pointer, hit_flag
integer  range_yds
integer  delivered_epu
integer  UNT2$Pointer,UNT2$Type$I,  # jb E2145  6/29/00
    UNT2$Hits$I,UNT2$Misshits$I,    # jb E2145  6/29/00
    CMC$Pointer,CMC$Damageradi$I,   # jb E2145  6/29/00
    CMC$Weight$I                    # jb E2145  6/29/00
 
   missile_name = xUNT$Name$C
   missile_type = xCMC$Type$C

   if (xUNT$GhostedUnit$I == $yes)
     attacker_track = 'GATKR'
   else
     attacker_track = 'TBM'

   cos_impact_lat = COS (impact_lat)
   CMC$DamageRadi$I = xCMC$DamageRadi$I
   CMC$Weight$I = xCMC$Weight$I

   hit_flag = $no

   # Loop through the UNT table for targets
   for (UNT2$Pointer$First; UNT2$Pointer$Ok; UNT2$Pointer$Next) 
    {
     if (xUNT2$Status$I == $BeingDeleted$Code)
       next

     UNT2$Type$I = xUNT2$Type$I
     if ((UNT2$Type$I == $ShoreBase$Code) | (UNT2$Type$I == $Surface$Code))
       {
        target_lat = xUNT2$TrueLatitude$F
        target_long = xUNT2$TrueLongitude$F
        cos_target_lat = xUNT2$CosTrueLat$F

        if (xUNT2$GhostedUnit$I == $yes)
          next

        #$% compute distance from impact point to target       
        call RLL2RB (impact_lat, impact_long, cos_impact_lat,
                     target_lat, target_long, cos_target_lat,
                     range_nmi, brng)

        range_yds = INT (range_nmi * 2025.37)    # convert the range into yards

        if (range_yds <= CMC$DamageRadi$I)
          {
           hit_flag = $yes
           target_name = xUNT2$Name$C

           delivered_epu = INT (CMC$Weight$I * (1.0 - range_yds/float(CMC$DamageRadi$I)))
           UNT2$Hits$I = xUNT2$Hits$I + delivered_epu
           putUNT2$Hits$I 
           UNT2$MissHits$I = xUNT2$MissHits$I + delivered_epu
           putUNT2$MissHits$I

           if (log$engage != $no)
             {
              call engdata (UNT$Pointer, UNT2$Pointer)
              PUTeng$Weapon$c( missile_type )
              PUTeng$Track$c( attacker_track )
              PUTeng$Result$i( eng$Hit$code )

              call write_eng_rec
             }
          }     # end of if unit is within the Damage Radius
       }     # end of if unit is a base or surface unit
    }     # end of loop through the UNT table

   if (log$engage == $yes & hit_flag == $no)   # if log engagement is desired
     {                                         # and nothing got hit
      call engdata (UNT$Pointer, UNT2$Pointer)
      putENG$PlatformType$C (missile_type)
      PUTeng$Target$c( "NONE    " )
      PUTeng$RecLat$f( impact_lat )
      PUTeng$RecLon$f( impact_long )
      PUTeng$Weapon$c( missile_type )
      PUTeng$Track$c( attacker_track )
      PUTeng$Result$i( eng$Hit$code )

      call write_eng_rec
     }

return
end


Subroutine Log_Run_Time_Termination (UNT$Pointer,    # in:  the missile UNT pointer
                                     TBL$Pointer)    # in:  the characteristic pointer
################################################################################
#$%
#$% Purpose:    Log_Run_Time_Termination will set up and write out the
#$%             engagement log record for the termination.  (E1124)
#$%
#$% Called By:  torp_engage  <wgmdtorp.rat>
#$%             
#$%
#$% Calls:      Write_Eng_Rec
#$%
#$% Tables:     None
#$%
#$% Date:       Feb. 1994
#$%
#$% Author:     Carol L. Kropp
#$%
#$% Modified:   Carol Kropp - 7/95 (E1419)
#$%             Changed arguments to UNT$Pointer and the weapon Table pointer,
#$%             so that additional information could be provided to the
#$%             engagment log.
#$%
#$%             Susan Miller - 6/97 (E1612)
#$%             Defined variable class_name as a literal (renamed it from
#$%             TBL$Name$C since it isn't a global variable and the $ signs 
#$%             don't get translated to underscores) and changed xBTT$TIN$C 
#$%             to xBTT$TINnumber$C to match name in BTT table.
#$%
################################################################################
BBCommon
ENCommon

LITERAL   CSTRIP8           # jb E2145  6/29/00
literal   class_name
Integer   BTT$Pointer       # jb E2145  6/29/00
integer   UNT$Pointer, TBL$Pointer
integer   UNT$BTTIndx$I

  if (log$engage != $no)          # if engagement log is desired
    {
     class_name = xTBL$Name$C

     call engdata (unt$pointer, 0)
     putENG$Platform$C     ('EXPIRED ')
     putENG$PlatformType$C (class_name)
     putENG$Weapon$C       (class_name)
     putENG$Target$C       (xUNT$Name$C)
     putENG$Result$I       (ENG$Termination$Code)
    
     UNT$BTTIndx$I = xUNT$BTTIndx$I
     if (UNT$BTTIndx$I != 0)
       {
        BTT$Pointer$To   (UNT$BTTIndx$I)
        putENG$BEPart1$C (xBTT$BEnumber1$C)
        putENG$BEPart2$C (xBTT$BEnumber2$C)
        putENG$TIN$C     (xBTT$TINnumber$C)
       }

     call write_eng_rec
   }                              # end of if an engagement log is desired

return
end


subroutine get_jecewsi_factor(unt$pointer,  # attacker
                          unt2$pointer,     # self protective jammer effects of victim
                          id,               # spj factor calculation or launch factor
                          jecewsi_factor)   # SPJ or launch factorfactor 
################################################################################
#$%
#$% Purpose:    GET_JECEWSI_FACTOR determines the spj factor or launch factor
#$%             if id = $spj then it determines the degradation in ability
#$%             to successfully guide a weapon to the intended target
#$%             due to self protective jamming measures employed by
#$%             the target. The spj factor is dependent upon the geometry
#$%             of the target and shooter (8 quadrants))
#$%             if id = $launchFac then it determines the degradation in ability
#$%             to successfully launch a weapon to the intended target
#$%             due to self protective jamming measures employed by
#$%             the target. The launch factor is dependent upon the geometry
#$%             of the target and shooter (8 quadrants))
#$%
#$% Called By:  atoair
#$%             
#$%
#$% Calls:      None
#$%
#$% Tables:     None
#$%
#$% Date:       August 1994
#$%
#$% Author:     John F. Richardson
#$%
################################################################################
BBCommon
ENCommon

real*4 jecewsi_factor
REAL BRG,DIRECTION,RANGE,                   # jb E2145  6/29/00
     QUADRANT, FQUADRANT                    # jb E2145  6/29/00
Integer IQUADRANT, I_SWITCH_1,              # jb E2145  6/29/00
   UNT2$Pointer,UNT$Pointer,JEW$Pointer     # jb E2145  6/29/00
Integer id
 
# first find the bearing from the shooter to the unit employing
# self protective jamming
call RLL2RB (xUNT2$TrueLatitude$f,   
             xUNT2$TrueLongitude$f,  
             xUNT2$CosTrueLat$f,     
             xUNT$TrueLatitude$f,  
             xUNT$TrueLongitude$f, 
             xUNT$CosTrueLat$f,    
             Range,                 
             Brg)                   # receive bearing


direction = Brg * $rad2deg   # convert to a direction in degrees
quadrant = direction/45.0    # convert direction into 45 degree quadrants
iquadrant = int(quadrant)    # get integer quadrant
fquadrant = float(iquadrant)  # set integer quadrant to float

# 1-45 = quadrant 1, 46-90 = quadrant 2 , etc.
if (fquadrant < quadrant) iquadrant = iquadrant + 1 # inside next quadrant

if (direction == 0.0 |
    direction == 360.0) iquadrant = 8 # handle the odd case

JEW$POINTER$TO (UNT$POINTER$INDEX) # set JEW pointer to same slot as shooter UNT - JFR 8/17/94

if (id == $spj)
   { # want PK factor
    Switch (iquadrant)
            {
            case 1: # quadrant 1
                jecewsi_factor = xJEW$SpjFactor1$f;
            case 2: # quadrant 2
                jecewsi_factor = xJEW$SpjFactor2$f;
            case 3: # quadrant 3
                jecewsi_factor = xJEW$SpjFactor3$f;
            case 4: # quadrant 4
                jecewsi_factor = xJEW$SpjFactor4$f;
            case 5: # quadrant 5
                jecewsi_factor = xJEW$SpjFactor5$f;
            case 6: # quadrant 6
                jecewsi_factor = xJEW$SpjFactor6$f;
            case 7: # quadrant 7
                jecewsi_factor = xJEW$SpjFactor7$f;
            case 8: # quadrant 8
                jecewsi_factor = xJEW$SpjFactor8$f;
            }
   }
else
   {
    Switch (iquadrant)
            {
            case 1: # quadrant 1
                jecewsi_factor = xJEW$LaunchFactor1$f;
            case 2: # quadrant 2
                jecewsi_factor = xJEW$LaunchFactor2$f;
            case 3: # quadrant 3
                jecewsi_factor = xJEW$LaunchFactor3$f;
            case 4: # quadrant 4
                jecewsi_factor = xJEW$LaunchFactor4$f;
            case 5: # quadrant 5
                jecewsi_factor = xJEW$LaunchFactor5$f;
            case 6: # quadrant 6
                jecewsi_factor = xJEW$LaunchFactor6$f;
            case 7: # quadrant 7
                jecewsi_factor = xJEW$LaunchFactor7$f;
            case 8: # quadrant 8
                jecewsi_factor = xJEW$LaunchFactor8$f;
            }
   }

return
end


Subroutine Clear_BTT_Info (UNT$Pointer)   # in: unit for which BTT info is
                                          #     to be cleared
##########################################################################
#$%
#$% Purpose:    Clear_BTT_Info will clear the BTT entry for the specified
#$%             unit and clear the UNT$BTTIndx$I field of the unit.
#$%
#$% Called By:  
#$%             
#$% Calls:      None
#$%
#$% Tables:     UNT     BTT
#$%
#$% Date:       June 1995
#$%
#$% Author:     Carol L. Kropp
#$%
##########################################################################
BBCommon

LITERAL BTT$Benumber1$C,BTT$Benumber2$C,BTT$Tinnumber$C # jb E2145  6/29/00
integer  UNT$Pointer
integer  UNT$BTTIndx$I
integer  BTT$Pointer
integer  kk
  UNT$BTTIndx$I = xUNT$BTTIndx$I
  if (UNT$BTTIndx$I != 0)
    {
     BTT$Pointer$To  (UNT$BTTIndx$I)
     kk = 0; call smovv ("        ", BTT$BEnumber1$C, kk)
     putBTT$BEnumber1$C
     kk = 0; call smovv ("        ", BTT$BEnumber2$C, kk)
     putBTT$BEnumber2$C
     kk = 0; call smovv ("        ", BTT$TINnumber$C, kk)
     putBTT$TINnumber$C

     putUNT$BTTIndx$I (0)
    }

return
end


Subroutine Record_Ground_Unit_Attack (_
                 UNT$Pointer,     # in:  The attacker's UNT pointer
                 UNT2$Pointer,    # in:  The target's UNT pointer (or 0)
                 target_lat,      # in:  Targeted latitude (impact point)
                 target_lon,      # in:  Targeted longitude (impact point)
                 TBL$Pointer,     # in:  generic weapon characteristic Pointer
                 amount,          # in:  Amount of weapon used
                 epus_delivered)  # in:  Amount of delivered epu
##########################################################################
#$%
#$% Purpose:    Record_Ground_Unit_Attack will record the attack for
#$%             both the C2 and TMS interfaces.
#$%
#$% Called By:  
#$%             
#$% Calls:      Record_TMS_Ground_Attack     <wgtms.rat>
#$%             Record_C2_Air_Ground_Eng     <wgc2airground.rat>
#$%             Record_C2_Flight_EQ_Expended <wgairhist.rat>
#$%
#$% Tables:     UNT     TBL
#$%
#$% Date:       July 1995
#$%
#$% Author:     Carol L. Kropp
#$%
#$%            Carol Kropp - 12/96 (E1726)
#$%            Record_C2_Flight_EQ_Expended changed to 
#$%            Record_Flight_EQ_Expended.
#$%
##########################################################################
BBCommon

LITERAL     CSTRIP8                     # jb E2145  6/29/00
real     target_lat, target_lon
integer  UNT$Pointer, UNT2$Pointer
integer  TBL$Pointer, amount, epus_delivered
integer  UNT$Type$I       # attacker's platform class
integer  UNT$LaunchIndx$I # UNT index of cruise missile's launching platform
integer  UNT3$Pointer     # launching platform of a cruise missile

#  if (xUNT$BTTIndx$I != 0)
#    call Record_TMS_Ground_Attack (UNT$pointer, UNT2$Pointer,
#                                   target_lat,  target_lon,
#                                   xTBL$Name$C, amount, epus_delivered)
  UNT$Type$I = xUNT$Type$I
  if (UNT$Type$I == $CruiseMissile$Code)      # only do the C2 ground eng
    {                                         # when the cruise missiles
     UNT$LaunchIndx$I = xUNT$LaunchIndx$I     # are launched from aircraft
     UNT3$Pointer$To  (UNT$LaunchIndx$I)
#     if (xUNT3$Type$I == $Air$Code)
#       call Record_C2_Air_Ground_Eng (UNT2$Pointer, target_lat, target_lon,
#                                      epus_delivered, UNT$Pointer)
    }
  else if (UNT$Type$I == $Air$Code) 
    {
#     call Record_C2_Air_Ground_Eng (UNT2$Pointer, target_lat, target_lon,
#                                    epus_delivered, UNT$Pointer)
     call Record_Flight_EQ_Expended (UNT$Pointer, TBL$Pointer, amount)
    }

return
end     # end of Record_Ground_Unit_Attack

Subroutine Log_ALSP_Engagement_engdata (_
                     unt$pointer,      # in: unit pointer of attacker
                     unt2$pointer,     # in: unit pointer of target
                     weapon_name,      # in: literal name of weapon
                     range,            # in: integer range from target
                     number_fired)     # in: number of weapon fired
################################################################################
#$%
#$% Purpose:    Log_ALSP_Engagement_engdata will set up and write out the engagement log
#$%             record for when an RESA owned unit attacks an ALSP ghost.
#$%             Since the actor which owns the target evaluates hit/kill, a
#$%             record of the attack is made for the engagement log. Engdata used
#$%             for standardization of gathering eng log data.
#$%
#$% Called By:  AirASM
#$%             AirBomb
#$%
#$% Calls:      Write_Eng_Rec, engdata
#$%
#$% Tables:     None
#$%
#$% Date:       September 1993, July 2002
#$%
#$% Author:     Carol L. Kropp
#$%             John McCormick
#$% Modified:   general structure borrowed from log_alsp_engagement
################################################################################
BBCommon
ENCommon

literal   weapon_name
integer   range, number_fired, UNT$Pointer, UNT2$Pointer

  if (log$engage != $no)                            # if engagement log is desired
    {
       call engdata (UNT$Pointer, UNT2$Pointer)
       PUTeng$Weapon$c( weapon_name )
       PUTeng$Result$i( eng$Fired$code )
       PUTeng$NumberFired$i( number_fired )         # record the number of shots
       PUTeng$Range$f( range )                      # range to target

       call write_eng_rec
   }                                                # end of if an engagement log is desired

return
end
