include "ascii.inc"
include "bbacc.inc"
include "bbads.inc"
include "bbaeg.inc"
include "bbaml.inc"
include "bbbom.inc"             # for wgmdeng.inc
include "bbcode.inc"
include "bbcmc.inc"
include "bbctl.inc"
include "bbdeq.inc"
include "bbjew.inc"             # for jecewsi - JFR 9/20/94
include "bblcl.inc"
include "bbmc.inc"              # for wgmdeng.inc
include "bbord.inc"
include "bbrmt.inc"
include "bbrvu.inc"
include "bbshc.inc"             # for wgmdeng.inc
include "bbunt.inc"
include "bbvue.inc"
include "hseng.inc"
include "cenglog.inc"
include "wgmdeng.inc"
 
define ($spj, 1)         # Jecewsi id - JFR 9/20/94
define ($launchFac, 2)   # Jecewsi id - JFR 9/20/94
 
define (BBImplicit, Implicit None)
define(trace$engage$exe, istrip(trace$engage,0,M1bits)) # trace general exec
 
# smm 7/97 (E1587)
# Added definition of $initial, $miss, $hit, $detonation,
# $attemptedhit, changed value of $unsuccessful and $noroom.
define($initial,0)          # SMM 7/97 (E1587)
define($miss,1)             # SMM 7/97 (E1587)
define($hit,2)              # SMM 7/97 (E1587)
define($noroom,3)           # SMM #E1414 6/95
define($unsuccessful,4)     # SMM #E1414 6/95
define($detonation,5)       # DIS ghost         # SMM 3/22/95
define($attemptedhit,6)     # ALSP ghost
 

Subroutine Prep_AEG_slot (UNT$Pointer,  # receive firing UNT pointer
                          RMT$Pointer,  # receive RMT track pointer
                          limit,        # receive track limit of firing unit
                          RMT$Detectee$I)# receive detectee index
#######################################################################
#$% Purpose:   Prep_AEG_slot counts the number of AEG slots that are
#$%            filled for this unit and checks for a match for this
#$%            RMT track, and will only save this track if this ships
#$%            limit has not been exceeded and this track is unique.
#$%
#$% Called By: RMTPUT
#$%
#$% Calls:     ECHO...    Fill_AEG_slot   Complete_ADS_Data
#$%            After_hit_clear_AEG
#$%
#$% Tables:    UNT   RMT   AEG   LCL
#$%
#$% Date:      Nov 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer RMT$Pointer, UNT$Pointer, limit, RMT$Detectee$I
 
literal cstrip8, UNT2$Name$C, AEG$TargetUNTName$C
integer AEG$Pointer, LCL$Pointer, first_AEG_index, number_used, i
integer AEG$NumberInFlight$I, AEG$RMTPointerIndex$I, found_it
integer UNT2$Pointer, cleared_flag, break_after_clear, prev_aeg
integer last_in_list
Integer LCOMP           # jb AAI01/LCOMP    2/14/01
 
 found_it = 0
 number_used = 0
 cleared_flag = $no
 break_after_clear = $no
 LCL$Pointer = 0
 prev_aeg = 0
 last_in_list = 0
 
 UNT2$Pointer$To RMT$Detectee$I  # get target UNT pointer
 UNT2$Name$C = xUNT2$Name$C
 
 # first count the number of slots that are filled for this unit
 first_AEG_index = xUNT$FirstAEGIndex$I
 if (first_AEG_index != 0)
    {
     for (i = first_AEG_index; i != 0;)
        {
         # keep track of how many tracks this unit has in the AEG table
         number_used = number_used + 1
 
         # set pointer
         AEG$Pointer$To i
 
         AEG$TargetUNTName$C = xAEG$TargetUNTName$C
 
         # get the next index in the linked list
         i = xAEG$NextIndex$I
 
         # check to see whether this RMT track is already saved in
         # the AEG table and is still the same unit
         if ((xAEG$TargetUNTIndex$I == RMT$Detectee$I) &
             LCOMP(AEG$TargetUNTName$C,UNT2$Name$C)==0) #jb AAI01/LCOMP 2/14/01
            {
             if (xAEG$TargetUNTDestroyed$I != $yes)
                {
                 if (xAEG$AircraftFlag$I == $yes)
                    {
                     # update some data
                     AEG$NumberInFlight$I = xRMT$Remaining$I
                     putAEG$NumberInFlight$I
                    }
                 else putAEG$NumberInFlight$I (1)
 
                 AEG$RMTPointerIndex$I = RMT$Pointer$Index
                 putAEG$RMTPointerIndex$I
 
                 if (trace$visual != $no)
                     {
                      call echov (" Target UNT index is ")
                      call echoi (xAEG$TargetUNTIndex$I)
                      call echov (" and the RMT detectee UNT is ")
                      call echoi (xRMT$Detectee$I)
                      call echor
                     }
                }
             else # this target was destroyed, so clear out this slot
                {
                 call After_hit_clear_AEG(AEG$Pointer$Index,cleared_flag)
                 if ((cleared_flag == $yes) & (number_used != 0))
                    {
                     number_used = number_used - 1
                     cleared_flag = $no
                     if (prev_aeg == 0) break
                     else  AEG$Pointer$To prev_aeg
                    }
                }
             return # the rmt detectee has already been saved in the AEG table
            }
         # check to see whether this slot is no longer valid, and clear
         # if it is not, update the linked list and continue the search
         # thru the AEG table
         if (xAEG$TargetUNTDestroyed$I == $yes)
            {
             call After_hit_clear_AEG(AEG$Pointer$Index,cleared_flag)
             if ((cleared_flag == $yes) & (number_used != 0))
                {
                 number_used = number_used - 1
 
                 # if the next index is zero, this was the last in the list
                 if (i == 0) break
                }
            }
 
         # if we cleared out this aeg pointer index, don't change the previous
         # flag to that index, just reset the cleared_flag
         if (cleared_flag == $yes)
             cleared_flag = $no
         else
             # save this index as the previous index
             prev_aeg = AEG$Pointer$Index
        } # end of for loop through the linked list of AEG tracks
    } # end if this is not the first AEG index saved for this unit
 
 # check to see if this units limit of AEG tracks has been exceeded
 if (number_used >= limit)
    {
     # display message
     call echov (" [")      # jb E2144  5/23/00
     call echohn (xUNT$Name$C,$$MaxLit)
     call echov (" AEG>")   # jb E2144  5/23/00
     call echoi (limit)
     call echov ("]")       # jb E2144  5/23/00
     return
    }
 
 if (AEGIS$first$free == 0)              # if no free slots
   {
    call echor
    call echov ("AEG Table overflow")    # jb E2144  5/23/00
    call echor
 
    return
   }
 else
   {
    # find the LCL pointer for this RMT target
    call Find_LCL(UNT$Pointer, RMT$Pointer,    # send
                  LCL$Pointer, found_it)       # receive
 
    if (found_it != 0)
        {
         # set the AEG pointer to the last AEG entry for this unit
         if (prev_aeg != 0)
             AEG$Pointer$To prev_aeg
         else
             AEG$Pointer = 0
 
         # fill in the appropriate data
         call Fill_AEG_slot(UNT$Pointer, RMT$Pointer, LCL$Pointer,  # send
                           AEG$Pointer) # send the last AEG pointer for this
 
        }
                                        # unit
    else if (trace$visual != $no)
        {
         call echor
         call echov (" This RMT track not found in ")
         call echohn (xUNT$Name$C,$$MaxLit)
         call echov ("'s LCL list.")
         call echor
        }
   }
 
return
end # Prep_AEG_slot

 
Subroutine Fill_AEG_slot (UNT$Pointer,  # receive firing UNT pointer
                          RMT$Pointer,  # receive RMT track pointer
                          LCL$Pointer,  # receive LCL track pointer
                          AEG$Pointer)  # receive AEG pointer
#######################################################################
#$% Purpose:   Fill_AEG_slot fills in the following data:
#$%            AEG$NextIndex$I, AEG$LCLPntrIndex$I, AEG$DefendedUNTIndex$I,
#$%            AEG$FiringUNTIndex$I, AEG$TargetUNTIndex$I, AEG$AircraftFlag$I,
#$%            LCL$AssocAEGIndex$I, AEG$RMTPointerIndex$I
#$%
#$% Called By: Prep_AEG_slot
#$%
#$% Calls:     ECHO...
#$%
#$% Tables:    UNT   LCL   AEG   RMT
#$%
#$% Date:      Dec 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer UNT$Pointer, RMT$Pointer, AEG$Pointer, LCL$Pointer
 
integer UNT2$Pointer, UNT$FirstAEGIndex$I, UNT2$Type$I, LCL$Detectee$I
integer AEG$NextIndex$I, AEG$LCLPntrIndex$I, AEG$TargetUNTIndex$I
integer LCL$AssocAEGIndex$I, AEG$NumberInFlight$I, AEG$FiringUNTIndex$I
integer AEG$DefendedUNTIndex$I, index, UNT$DefendedUNTIndex$I
integer AEG$RMTPointerIndex$I, AEG$TargetUNTDestroyed$i, AEG$View$I
literal AEG$TargetUNTName$C, cstrip8, UNT2$Name$C
 
 # if this is the first AEG index?
 if (xUNT$FirstAEGIndex$I == 0)
    {
     # set first AEG index to the first free slot and store it
     UNT$FirstAEGIndex$I = AEGIS$first$free
     putUNT$FirstAEGIndex$I
    }
 else
    {
     # set next index to first free slot and store it
     AEG$NextIndex$I = AEGIS$first$free
     putAEG$NextIndex$I
    }
 
 # reset the first free with the old first free next index
 AEG$pointer$to AEGIS$first$free
 index = xAEG$nextindex$i
 AEGIS$first$free = index
 
 # set next index to zero and store it
 AEG$nextindex$i = 0
 putAEG$nextindex$i
 
 # set the associated LCL pointer
 AEG$LCLPntrIndex$I = LCL$Pointer$Index
 putAEG$LCLPntrIndex$I
 
 # set the defended unit and the firing unit,
 # defended unit may get changed later by the user
 UNT$DefendedUNTIndex$I = xUNT$DefendedUNTIndex$I
 if (UNT$DefendedUNTIndex$I == 0)
     AEG$DefendedUNTIndex$I = UNT$Pointer$Index
 else
     AEG$DefendedUNTIndex$I = UNT$DefendedUNTIndex$I
 AEG$FiringUNTIndex$I = UNT$Pointer$Index
 putAEG$DefendedUNTIndex$I
 putAEG$FiringUNTIndex$I
 
 # get the unit pointer of the target
 LCL$Detectee$I = xLCL$Detectee$I
 
 # save the target index
 AEG$TargetUNTIndex$I = LCL$Detectee$I
 putAEG$TargetUNTIndex$I
 
 # get the target type
 UNT2$Pointer$To LCL$Detectee$I
 UNT2$Type$I = xUNT2$Type$I
 UNT2$Name$C = xUNT2$Name$C
 
 AEG$TargetUNTName$C = UNT2$Name$C
 putAEG$TargetUNTName$C
 
 # set flag yes for aircraft and no for missile target
 if (UNT2$Type$I == $AIR$CODE)
    {
     putAEG$AircraftFlag$I ($YES)
     AEG$NumberInFlight$I = xLCL$Remaining$I
     putAEG$NumberInFlight$I
    }
 if (UNT2$Type$I == $CRUISEMISSILE$CODE)
    {
     putAEG$AircraftFlag$I ($no)
     putAEG$NumberInFlight$I (1)
    }
 
 # save the view of the firing unit
 AEG$View$I = xUNT$View$I
 putAEG$View$I
 
 # save the RMT pointer index
 AEG$RMTPointerIndex$I = RMT$Pointer$Index
 putAEG$RMTPointerIndex$I
 
 # make sure this target isn't destroyed before it is fired upon
 AEG$TargetUNTDestroyed$i = $No
 putAEG$TargetUNTDestroyed$i
 
 # save associated AEG index in LCL pointer slot
 LCL$AssocAEGIndex$I = AEG$Pointer$Index
 putLCL$AssocAEGIndex$I
 
 # debug messages, add trace$visual after initial testing is complete
 if (trace$visual != $no)
     {
       call echor
       call echov (" AEGIS track being saved at AEG Pointer index ")
       call echoi (AEG$Pointer$Index)
       call echor
       call echov (" AEGIS track assoc. with LCL track index ")
       call echoi (LCL$Pointer$Index)
       call echor
     }
 
return
end # Fill_AEG_slot

 
Subroutine Clear_AEG_slot (UNT$Pointer,  # receive firing UNT pointer
                           LCL$Pointer,  # receive LCL track pointer
                           RMT$Pointer)  # receive RMT track pointer
 
#######################################################################
#$% Purpose:   Clear_AEG_slot searches the units AEG linked list for a
#$%            match of the index saved for the LCL slot being deleted.
#$%
#$% Called By: LCLDEL
#$%
#$% Calls:     ECHO...
#$%
#$% Tables:    UNT   LCL   AEG
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer UNT$Pointer, LCL$Pointer, RMT$Pointer
 
integer AEG$Pointer, AEGindex, del_AEGindex, prev_AEGindex
integer UNT$FirstAEGIndex$I, FirstAEGIndex, AEG$NextIndex$I
integer AEG_to_match
 
 del_AEGindex = 0
 AEG_to_match = 0
 prev_AEGindex = 0
 
 # error somewhere, so return
 if ((LCL$Pointer == 0) & (RMT$Pointer == 0))  return
 
 # get the first AEG index for this unit and if it is zero, return
 UNT$FirstAEGIndex$I = xUNT$FirstAEGIndex$I
 if (UNT$FirstAEGIndex$I == 0) return
 
 FirstAEGIndex = UNT$FirstAEGIndex$I
 
 # loop through list until match is found
 for (AEGindex = FirstAEGIndex; AEGindex > 0;)
    {
     # set pointer
     AEG$Pointer$To AEGindex
 
     # if AEG pointer is not valid, return
     if (!AEG$Pointer$Valid) return
 
     # if this index matches the index associated with track to be deleted
     if (((LCL$Pointer != 0) & (AEG$Pointer$Index == xLCL$AssocAEGIndex$I)) |
         ((RMT$Pointer != 0) & (xAEG$RMTPointerIndex$I == RMT$Pointer$Index)))
        {
             # save the index to delete
             del_AEGindex = AEG$Pointer$Index
 
             # if this is the first AEG index for this unit
             if (AEG$Pointer$Index == UNT$FirstAEGIndex$I)
                {
                 # set units first AEG index to the next AEG index in the list
                 # even if it is zero
                 AEG$NextIndex$I = xAEG$NextIndex$I
                 UNT$FirstAEGIndex$I = AEG$NextIndex$I
                 putUNT$FirstAEGIndex$I
 
                 AEGindex = AEG$NextIndex$I
                }
             else # it must not be the first
                {
                 # get this slots next index
                 AEG$NextIndex$I = xAEG$NextIndex$I
                 AEGindex = AEG$NextIndex$I
 
                 # set the pointer to the previous index in the list
                 AEG$Pointer$To prev_AEGindex
 
                 # save the following slots next index into the prev slot
                 putAEG$NextIndex$I
                } # end not the first
 
 
         # now delete the index that was saved as a match
         AEG$Pointer$To del_AEGindex
         # if the AEG pointer is not valid, return
         if (!AEG$Pointer$Valid) return
 
         # debug messages, add trace$visual after initial testing is complete
         if (trace$visual != $no)
            {
             call echor
             call echov (" AEGIS track being removed, AEG Pointer index ")
             call echoi (AEG$Pointer$Index)
             call echor
             if (LCL$Pointer != 0)
               {
                call echov (" AEGIS track assoc. with LCL track index ")
                call echoi (LCL$Pointer$Index)
               }
             else if (RMT$Pointer != 0)
               {
                call echov (" AEGIS track assoc. with RMT track index ")
                call echoi (RMT$Pointer$Index)
               }
             call echor
            }
 
         # clear out this slot
         AEG$zero
 
         # set next index to first free slot in this recently cleared slot
         AEG$NextIndex$I = AEGIS$First$Free
         putAEG$NextIndex$I
 
         # set first free slot
         AEGIS$First$Free = AEG$Pointer$Index
        } # found the AEG slot to delete
     else # this was not the slot to delete
        {
         prev_AEGindex = AEG$Pointer$Index
         AEGindex = xAEG$NextIndex$I
        } # this was not the AEG slot to delete
    } # looping through list of AEG slots
 
return # Clear_AEG_slot
end

 
Subroutine After_hit_clear_AEG(index,  # receive AEG slot index to be cleared
                               cleared)# return flag set to $yes for cleared slot
########################################################################
#$% Purpose:   After_hit_clear_AEG looks in AEG table for the matching
#$%            slot and clears it out after resetting the linked list
#$%            info.
#$%
#$% Called By: Prep_AEG_slot
#$%
#$% Tables:    UNT   AEG
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
########################################################################
BBcommon
 
integer index, cleared
 
integer UNT2$Pointer, AEG$Pointer, UNT2$FirstAEGIndex$I, AEG$NextIndex$I
integer UNT3$Pointer, current_AEG, next_AEG, previous_AEG
Integer LCOMP           # jb AAI01/LCOMP    2/14/01
literal Cstrip8
 
 current_AEG = 0
 previous_AEG = 0
 
 # get the firing units first AEG index
 AEG$Pointer$To index
 UNT2$Pointer$To xAEG$FiringUNTIndex$I
 UNT2$FirstAEGIndex$I = xUNT2$FirstAEGIndex$I
 next_AEG = UNT2$FirstAEGIndex$I
 
 UNT3$Pointer$To xAEG$TargetUNTIndex$I
 # if the target unit name matches the unit name and it is not being
 # deleted yet, don't want to clear this slot
 if ((xUNT3$Status$I != $BeingDeleted$Code) &
     LCOMP(xUNT3$Name$C,xAEG$TargetUNTName$C)==0) RETURN #jb AAI01/LCOMP 2/14/01
 
 while ((next_AEG != 0) & (cleared != $Yes))
    {
     # save next AEG
     current_AEG = next_AEG
 
     # get the AEG pointer
     AEG$Pointer$To current_AEG
 
     # get the next AEG index
     next_AEG = xAEG$NextIndex$I
 
     # if this is not the one we want to delete, get the next one
     if (AEG$Pointer$Index != index)
        {
         # save the current AEG detection and get the next one
         previous_AEG = current_AEG
         next
        }
 
     # clear the AEG pointer
     AEG$zero
     cleared = $yes
 
     # set next index and store
     AEG$NextIndex$I = AEGIS$First$Free
     putAEG$NextIndex$I
 
     AEGIS$First$Free = current_AEG
 
     # if no previous entry
     if (previous_AEG == 0)
        {
         # set first AEG entry to next and store
         UNT2$FirstAEGIndex$I = next_AEG
         putUNT2$FirstAEGIndex$I
        }
     else
        {
         # set AEG pointer
         AEG$Pointer$To previous_AEG
 
         # set next AEG entry and store
         AEG$NextIndex$I = next_AEG
         putAEG$NextIndex$I
        }
    }
 
return
end # After_hit_clear_AEG

 
Subroutine Adv_SAM_Engage (UNT$Pointer) # receive firing UNT pointer
#######################################################################
#$% Purpose:  Adv_SAM_Engage gets the number of advanced SAMs this unit
#$%           has, the range of the SAMs and sorts the SAM list by
#$%           increasing range of SAM.  It then calls SAM_assignment to
#$%           launch and assign advanced SAMs at the targets.
#$%
#$% Called By: AIRRAD
#$%
#$% Calls:     DEQGET    sort_eqlist    SAM_assignment
#$%            Fill_CPA_info
#$%
#$% Tables:    CMC   UNT
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer  UNT$Pointer
 
integer  CMC$Pointer, CMC$SamMaxRange$I, AdvancedSAMs_found, SAM_eqlist[5,30]
integer  n
 
 AdvancedSAMs_found = 0
 
 # does this unit have any advanced SAMs?
 # SAM_eqlist[1,nfound] = DEQ$Pointer$index  # save index of equipment
 # SAM_eqlist[2,nfound] = Xdeq$pntr$i        #   equipment pointer
 # SAM_eqlist[3,nfound] = deq$remaining$i    #   equipment count
 call DEQGET(UNT$Pointer,
            $AdvancedSAM$Code,
            AdvancedSAMs_found,     # total num. of advanced SAMs on this unit
            SAM_eqlist)
 
 # if this unit has no advanced sams, return
 if (AdvancedSAMs_found == 0) return
 
 for (n=1; n <= AdvancedSAMs_found; n=n+1)
    {
     CMC$Pointer = SAM_eqlist[2,n]       # get CMC pointer
     CMC$SamMaxRange$I = xCMC$SamMaxRange$I    # get range
     SAM_eqlist[4,n] = MAX(1,CMC$SamMaxRange$I) # save the max range
     SAM_eqlist[5,n] = xCMC$SAMSimul$I   # simul. in flight and guided
    }
 
 # sort equipment list by increasing range
 call sort_eqlist(SAM_eqlist,AdvancedSAMs_found,4)
 
 # finds appropriate targets from this units AEG list and fires a
 # SAM if it is within range
 call Find_and_Fire(UNT$Pointer,SAM_eqlist,AdvancedSAMs_found)
 
return # Adv_SAM_engage
end

 
Subroutine Find_and_Fire(UNT$Pointer, # receive unit pointer
                         SAM_eqlist,  # receive list of SAMs on this unit
                         AdvancedSAMs_found) # receive number of SAMs on unit
#######################################################################
#$% Purpose:  Find_and_Fire loops through the unit's linked AEG list to
#$%           create a list of targets including their CPA range to the
#$%           defended unit (UNT2). Saves AEG$CPATime$f and AEG$CPADistance$I
#$%           UNT$Pointer is the firing platform, max_range is max range
#$%           for all SAMs on board the firing platform, num_of_tgts is
#$%           the total number of targets saved in the array tgt_list,
#$%           and new_list is a temporary array duplicate of tgt_list
#$%           used for sorting purposes.
#$%
#$% Called By: Adv_SAM_Engage
#$%
#$% Calls:     Sort_tgt_list   Ckroe   Check_the_range   SAM_assignment
#$%
#$% Tables:    UNT   LCL   AEG
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 5/95 (E1372)
#$%            Added a check so max simul is not exceeded.
#$%
#$%            Susan Miller 4/99 (E1969)
#$%            Only check the rules of engagement when this file
#$%            is not processing a Take (using) SAM order.
#$%
#######################################################################
BBcommon
 
integer UNT$Pointer, AdvancedSAMs_found, SAM_eqlist[5,30]
Integer LCOMP           # jb AAI01/LCOMP    2/14/01
integer AEG$Pointer, tgt_list(6,400), new_list(6,400), UNT$FirstAEGIndex$I
integer LCL$Pointer, total_tgts, num_of_tgts, AEG$AircraftFlag$I
integer n, m, bad_target, AEG$NumberInFlight$I, UNT3$Pointer, AEGindex
integer target_alt, AEG$MeetsROE$I, max_simul, still_viable_tgts
real    max_flight_time
literal Cstrip8
 
 total_tgts = 0
 num_of_tgts = 0
 bad_target = $no
 max_flight_time = 0.0
 still_viable_tgts = 0
 
 # for each target entry zero out the tgt_list
 for (n=1; n<= 400; n=n+1)
    for (m=1; m<= 6; m=m+1)
        {
         tgt_list[m,n] = 0
         new_list[m,n] = 0
        }
 
 UNT$FirstAEGIndex$I = xUNT$FirstAEGIndex$I
 # if the unit has a list of targets in the AEG table...
 for (AEGindex = UNT$FirstAEGIndex$I; AEGindex > 0;)
    {
     # set pointer
     AEG$Pointer$To AEGindex
     AEGindex = xAEG$NextIndex$I
 
     if (xAEG$TargetUNTDestroyed$I == $yes) next # already destroyed
     if (xAEG$SAMAssigned$I == $yes) next        # already assigned
 
     # get the corresponding LCL pointer and target unit pointer
     LCL$Pointer$To xAEG$LCLPntrIndex$I
     UNT3$Pointer$To xLCL$Detectee$I
 
     # check to see whether this target unit pointer is valid,
     # if not, check the next one
     if (!UNT3$Pointer$Valid) next
 
     # check to see whether this target has been destroyed and is still
     # the same name, or the UNT name is different from the name saved
     # in the AEG table
     if (((xUNT3$Status$I == $BeingDeleted$Code) &
          LCOMP(xUNT3$Name$C,xAEG$TargetUNTName$C)==0) |    # jb AAI01 2/14/00
          LCOMP(xUNT3$Name$C,xAEG$TargetUNTName$C)!=0) NEXT # jb AAI01 2/14/00
##     if (((xUNT3$Status$I == $BeingDeleted$Code) &
##          (xUNT3$Name$C == xAEG$TargetUNTName$C)) |
##          (xUNT3$Name$C != xAEG$TargetUNTName$C)) next
 
     # if this track has not been updated this cycle
     # skip it
     if (xlcl$LastDetTime$f < Game$Time) next
 
     # if not a missile, it must be an aircraft, so need to check the ROEs
#     if (xUNT3$Type$I != $CruiseMissile$Code)
#        {
      # only check ROE when this is not a TakeUsingSAM order SMM 4/99 (E1969)
      if (xUNT$TakeUsingSAM$I != $YES)
        {
         # does this target meet the ROEs?
         call Ckroe(UNT$Pointer, LCL$Pointer, AEG$MeetsROE$I)
 
         # save whether target meets ROE
         putAEG$MeetsROE$I
         # if the ROE have not been met, skip this target
         if (AEG$MeetsROE$I == $no)  next
        } # end if dealing with a TakeUsingSAM order
 
     # get the target altitude to store later
     target_alt = (xLCL$Altitude$I * 100)
 
     if (target_alt <= 0) next
 
     # get the number of targets in flight just in
     # case it was a multiple flight that lost some a/c
     AEG$AircraftFlag$I = xAEG$AircraftFlag$I
     if (AEG$AircraftFlag$I == $yes)
        {
         AEG$NumberInFlight$I = xUNT3$NbrAc$I
         putAEG$NumberInFlight$I
        }
     else
        {
         AEG$NumberInFlight$I = xAEG$NumberInFlight$I
         if (AEG$NumberInFlight$I == 0)  AEG$NumberInFlight$I = 1
        }
 
     # if the a/c was destroyed, it's number in flight
     # will be zero, so check first
     if (AEG$NumberInFlight$I >= 1)
        {
         total_tgts = total_tgts + AEG$NumberInFlight$I
 
         # fill in the tgt_list information for each target
         for (num_of_tgts = num_of_tgts + 1;
              num_of_tgts <= total_tgts;
              num_of_tgts = num_of_tgts + 1)
            {
             # fill in target list information
             tgt_list[1,num_of_tgts] = AEG$Pointer
             tgt_list[2,num_of_tgts] = 9999
             tgt_list[3,num_of_tgts] = 9999
             tgt_list[4,num_of_tgts] = AEG$AircraftFlag$I
             tgt_list[5,num_of_tgts] = target_alt
             tgt_list[6,num_of_tgts] = LCL$Pointer
 
             if (num_of_tgts == total_tgts) break
            } # loop through number of targets
        } # if there is 1 or more in the flight
    } # end of for loop through the linked list of AEG tracks
 
 if (total_tgts > 0)                                     # smm 5/95 (E1372)
    {
     # check for targets within range of the SAM
     call check_the_range(tgt_list, total_tgts,
                          SAM_eqlist, AdvancedSAMs_found,
                          max_simul, still_viable_tgts)
 
     # check that the max simultaneous is not exceeded   # smm 5/95 (E1372)
     if (xUNT$SAMsAirborne$I >= max_simul)
        return
 
     # as long as the number of targets is greater than one (and also zero),
     # sort the target list, send in tgt_list and total_tgts and receive the
     # target list sorted in new_list
     if (still_viable_tgts > 0)
        {
         if (total_tgts > 1)
            call sort_tgt_list(tgt_list,total_tgts,new_list)
         else # move tgt_list data over to new_list
            if (total_tgts == 1)
            {
             new_list[1,total_tgts] = tgt_list[1,total_tgts]
             new_list[2,total_tgts] = tgt_list[2,total_tgts]
             new_list[3,total_tgts] = tgt_list[3,total_tgts]
             new_list[4,total_tgts] = tgt_list[4,total_tgts]
             new_list[5,total_tgts] = tgt_list[5,total_tgts]
             new_list[6,total_tgts] = tgt_list[6,total_tgts]
            }
 
        call SAM_assignment(still_viable_tgts, new_list, SAM_eqlist,
                            AdvancedSAMs_found, UNT$Pointer)
        }
    } #  if (total_tgts > 0)    smm 5/95 (E1372)
 
return # Find_and_fire
end

 
Subroutine Check_the_range(tgt_list,    # receive the list of targets
                           num_of_tgts, # receive the number of targets
                           SAM_eqlist,  # receive list of SAMs on unit
                           AdvancedSAMs_found, # receive number of SAMs on unit
                           max_simul,   # return max SAMs in air
                           still_viable_tgts) # return number of good targets
#######################################################################
#$% Purpose:   Check_the_range
#$%
#$% Called By: Find_and_fire
#$%
#$% Calls:     Find_SAM_range   RCPA   Min_to_target   RLL2RB
#$%
#$% Date:      Mar. 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer tgt_list[6,400], num_of_tgts, AdvancedSAMs_found, SAM_eqlist[5,30]
 
integer AEG$Pointer, LCL$Pointer, UNT2$Pointer, target_alt, bad_target
integer this_SAM, fire_index, tgt_num, SAM_altitude
real    AEG$CPATime$F
integer SAM_range, SAM_speed, max_simul, still_viable_tgts, AEG$CPADistance$I
integer local_range
real    AEG$SAMInterceptTime$F
real    target_course, target_speed, UNT2$TrueSpeed$F, UNT2$TrueCourse$F
real    initial_bearing, CPA_time, CPA_distance, LCL$Range$F
real    time_on_tgt, max_flight_time
 
 still_viable_tgts = num_of_tgts
 
 # loop thru the list of targets
 for (tgt_num = 1; tgt_num <= num_of_tgts; tgt_num = tgt_num + 1)
    {
     AEG$Pointer = tgt_list[1,tgt_num]
     target_alt = tgt_list[5,tgt_num]
     LCL$Pointer = tgt_list[6,tgt_num]
 
     # SAM intercept time has past, then fire a SAM
     if ((xAEG$SAMInterceptTime$f + 1 < Game$Time) |
         (xAEG$SAMInterceptTime$f == 0.0))
        {
         # get the defended unit
         UNT2$Pointer$To xAEG$DefendedUNTIndex$I
 
         ## Calculate Time of Closest Point of Approach and store
         # get the defended units course and speed
         UNT2$TrueCourse$F = xUNT2$TrueCourse$F
         UNT2$TrueSpeed$F = xUNT2$TrueSpeed$F
 
         # get course and bearing
         target_course = (xLCL$Course$I * $PI / 180.0)
         initial_bearing = (xLCL$Bearing$I * $PI / 180.0)
         target_speed = FLOAT(xLCL$Speed$I)
         local_Range = INT(xLCL$Range$F)
         LCL$Range$F = FLOAT(local_range)
 
         # find the SAM range for this altitude, return the SAM_altitude
         # and SAM_range for the target_altitude and flag this_SAM,
         # which indicates whether there is a SAM with the required range
         # return SAM_speed, SAM_range, SAM_altitude
         call Find_SAM_Range(SAM_eqlist, AdvancedSAMs_found,
                             target_alt, SAM_range, SAM_altitude,
                             this_SAM, SAM_speed, fire_index, max_simul)
 
         # if both the target and defended unit have a speed of 0
         # and the target is out of range, skip it
         if ((((target_speed == 0.0) & (UNT2$TrueSpeed$F == 0.0)) &
              (LCL$Range$F > SAM_range)) | (this_SAM == $no))
             bad_target = $yes
 
         if (bad_target != $yes)
            {
             # calculate the closest point of approach from the target
             # to the defended unit
             CPA_distance = 0.0
             CPA_time = 0.0
             call RCPA(CPA_distance,   # returns the CPA distance (nmi)
                       UNT2$TrueCourse$F,  # send defended unit course (radians)
                       UNT2$TrueSpeed$F,   # send defended unit speed (knots)
                       target_course,      # send target course (radians)
                       target_speed,       # send target speed (knots)
                       LCL$Range$F,        # send target range (nmi)
                       initial_bearing,    # send target bearing (radians)
                       CPA_time)           # returns the CPA time (minutes)
 
             # If time for closest point of approach is returned as -7,
             # range btwn the two units is not decreasing, if -12 is
             # returned, no CPA in next 12 hours.  Otherwise two positive
             # reals are returned.
             # if the range is not decreasing, then a CPA_distance of 0
             # is returned, so use the LCL track range
             if ((CPA_distance == 0.0) & (CPA_Time == -7.0))
                CPA_distance = LCL$Range$F 
             AEG$CPADistance$I = CPA_distance 
             AEG$CPATime$f = CPA_time

             # calculate the max flight time for max range SAM
             if (SAM_speed != 0)
                max_flight_time = (float(SAM_range)/float(SAM_speed))*60
 
             # if the target will not be in range at CPA, it's a bad target
             if ((LCL$Range$F > SAM_range) &
                 ((CPA_distance > SAM_range) | (CPA_Time > max_flight_time)))
                bad_target = $yes
 
             if (((CPA_time == -12.0) & (target_speed >= SAM_speed)) |
                 ((CPA_time == -7.0) &
                  ((LCL$Range$F > SAM_range) | (target_speed >= SAM_speed))) )
                {
                 AEG$CPATime$f = CPA_time
                 bad_target = $yes
                }
 
             if ((bad_target != $yes) &
                 ((CPA_time >= 0.0) |
                 ((LCL$Range$F <= SAM_range) & (CPA_time == -7.0))))
                {
                 if (CPA_time == -7.0)
                    {
                     call Rmin_to_target(0.0,# send intercept distance
                               target_course,    # send target course
                               target_speed,     # send target speed
                               FLOAT(SAM_speed), # send SAM max speed
                               LCL$Range$F,      # send target range in nmi
                               initial_bearing,  # send target bearing in rad.
                               time_on_tgt)      # returns min. to target
                     # if -3 is returned, target is already in range,
                     # if -1 is returned, no practical solution,
                     # if -7 is returned, intercept time > 12 hours
                     # else a positive integer (elapsed min.) is returned
                     if (time_on_tgt > 0.0) CPA_time = time_on_tgt
                     else
                        {
                         if ((time_on_tgt == -1.0) | (time_on_tgt == -7.0))
                            {
                             bad_target = $yes
                             AEG$CPATime$f  = 9999.
                            }
                         else  CPA_time = 0.0  # (time_on_tgt == -3.0)
                        }
					  AEG$CPATime$f = CPA_time
                    } # if the CPA_time = -7, range not decreasing
                } # CPA time is a positive value
              putAEG$CPADistance$I
             tgt_list[2,tgt_num] = AEG$CPADistance$I
             putAEG$CPATime$f
             tgt_list[3,tgt_num] = AEG$CPATime$f
            } # good target
 
         if (bad_target == $yes)
            { # don't save a target that is out of range
             AEG$CPADistance$I = 9999
             AEG$CPATime$f = 9999.
             AEG$SAMInterceptTime$f = 0.0
 
             tgt_list[2,tgt_num] = AEG$CPADistance$I
             tgt_list[3,tgt_num] = AEG$CPATime$f
             still_viable_tgts = still_viable_tgts - 1
 
             putAEG$CPADistance$I
             putAEG$CPATime$f
             putAEG$SAMInterceptTime$f
 
             # reset the flag
             bad_target = $no
            }
        } # end if intercept time has past
    } # end of loop thru targets
 
return # Check_the_range
end

 
Subroutine Sort_tgt_list(tgt_list,      # receive list of targets
                         num_of_tgts,   # receive number of targets
                         new_list)      # return sorted list of targets
#######################################################################
#$% Purpose:   Sort_tgt_list sorts the tgt_list, putting the cruise
#$%            missiles at the start of the array, then sorting by
#$%            increasing CPA time.
#$%            tgt_list[1,num_of_tgts] = AEG$Pointer
#$%            tgt_list[2,num_of_tgts] = AEG$CPADistance$I
#$%            tgt_list[3,num_of_tgts] = AEG$CPATime$f
#$%            tgt_list[4,num_of_tgts] = AEG$AircraftFlag$I # yes if A/C
#$%            tgt_list[5,num_of_tgts] = target_alt
#$%            tgt_list[6,num_of_tgts] = LCL$Pointer
#$%
#$% Called By: Fill_CPA_info
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer tgt_list[6,400], num_of_tgts, new_list[6,400]
 
integer n, m, save
 
 m = 1
 for (n = 1; n <= num_of_tgts; n = n+1)
    {
      if (tgt_list(4,n) != $no) next    # only look at cruise missile targets
      else
        {
         new_list[1,m]=tgt_list[1,n];
         new_list[2,m]=tgt_list[2,n];
         new_list[3,m]=tgt_list[3,n];
         new_list[4,m]=tgt_list[4,n];
         new_list[5,m]=tgt_list[5,n];
         new_list[6,m]=tgt_list[6,n];
         m = m + 1
        }
     }
 for (n = 1; n <= num_of_tgts; n = n+1)
    {
      if (tgt_list(4,n) == $no) next    # only look at aircraft
      else
        {
         new_list[1,m]=tgt_list[1,n];
         new_list[2,m]=tgt_list[2,n];
         new_list[3,m]=tgt_list[3,n];
         new_list[4,m]=tgt_list[4,n];
         new_list[5,m]=tgt_list[5,n];
         new_list[6,m]=tgt_list[6,n];
         m = m + 1
        }
     }
 
 # sort target list by increasing CPA time and cruise missiles first
 for (n = 1; n <= num_of_tgts; n = n+1)
    {
     if (new_list(4,n) != $no) next    # only look at cruise missile targets
     for (m = n+1; m <= num_of_tgts; m = m+1)
        {
         if (new_list(4,m) != $no) next  # only look at cruise missile targets
         if (new_list[3,n] <= new_list[3,m]) next
 
         save=new_list[1,n]; new_list[1,n]=new_list[1,m]; new_list[1,m]=save
         save=new_list[2,n]; new_list[2,n]=new_list[2,m]; new_list[2,m]=save
         save=new_list[3,n]; new_list[3,n]=new_list[3,m]; new_list[3,m]=save
         save=new_list[4,n]; new_list[4,n]=new_list[4,m]; new_list[4,m]=save
         save=new_list[5,n]; new_list[5,n]=new_list[5,m]; new_list[5,m]=save
         save=new_list[6,n]; new_list[6,n]=new_list[6,m]; new_list[6,m]=save
       }
    }
 for (n = 1; n <= num_of_tgts; n = n+1)
    {
     if (new_list(4,n) == $no) next  # only look at aircraft targets
     for (m = n+1; m <= num_of_tgts; m = m+1)
        {
         if (new_list(4,m) == $no) next  # only look at aircraft targets
         if (new_list[3,n] <= new_list[3,m]) next
 
         save=new_list[1,n]; new_list[1,n]=new_list[1,m]; new_list[1,m]=save
         save=new_list[2,n]; new_list[2,n]=new_list[2,m]; new_list[2,m]=save
         save=new_list[3,n]; new_list[3,n]=new_list[3,m]; new_list[3,m]=save
         save=new_list[4,n]; new_list[4,n]=new_list[4,m]; new_list[4,m]=save
         save=new_list[5,n]; new_list[5,n]=new_list[5,m]; new_list[5,m]=save
         save=new_list[6,n]; new_list[6,n]=new_list[6,m]; new_list[6,m]=save
        }
    }
 
return
end # Sort_tgt_list

 
Subroutine SAM_assignment(num_of_tgts,         # receive num of targets
                          tgt_list,            # receive the list of targets
                          SAM_eqlist,          # receive the list of SAMs
                          AdvancedSAMs_found,  # receive num of SAMs found
                          UNT$Pointer)         # receive firing UNT pointer
#######################################################################
#$%
#$% Purpose:   SAM_assignment processes the assignment of SAMs to each
#$%            eligible target.
#$%
#$% Called By: Find_and_fire
#$%
#$% Calls:     SAM_equip_loop
#$%
#$% Tables:    AEG   CMC   DEQ   UNT
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 6/9/95 (E1414)
#$%            Changed the variable to no_room to outcome to handle
#$%            the case of an unsuccessful SAM launch.
#$%
#######################################################################
BBcommon
 
integer num_of_tgts, tgt_list[6,400], SAM_eqlist[5,30], AdvancedSAMs_found
integer UNT$Pointer
 
integer m, save_index, tgt_index, index, outcome
 
 index = 0
 m = 0
 save_index = 0
 tgt_index = 0
 outcome = 0
 
 # tgt_list contains only those targets that are within range and
 # are in order by cruise missile first and ordered by increasing
 # range, followed by aircraft in increasing range
 # SAM_eqlist is ordered in increasing missile range
 
 # loop through the targets
 for (index=1; index <= num_of_tgts; index=index+1)
    {
     # loop through the advanced SAM inventory
     call SAM_equip_loop(index,               # send the target index
                         tgt_list,            # send the list of targets
                         SAM_eqlist,          # send the list of SAMs
                         AdvancedSAMs_found,  # send num of SAMs found
                         UNT$Pointer,         # send firing UNT pointer
                         outcome)             # receive if room in UNT
 
     # SMM 6/95 PER E1414
     if (outcome != $noroom)   # reset outcome if it isn't
       outcome = 0             # set to $noroom
     else                      # otherwise the UNT table is full
       break
    } # end of for loop through number of targets
 
return
end # SAM_assignment

 
Subroutine Fire_adv_SAM(UNT$Pointer,   # receive firing unit pointer
                        CMC$Pointer,   # receive selected SAM characteristic
                        outcome,       # return flag if room in UNT table
                        tgt_list,      # receive target list
                        target_index,  # receive index into target list
                        UNT2$pointer,  # return SAM UNT pointer
                        SAM_eqlist,    # receive eqlist array
                        SAM_index)     # receive index of SAM fired
#######################################################################
#$%
#$% Purpose:   Fire_adv_SAM
#$%            where UNT$Pointer is firing platform
#$%                  UNT2$Pointer is the SAM
#$%                  UNT3$Pointer is the target
#$%
#$% Called By: SAM_assignment
#$%
#$% Calls:     UNTGET   smovv   send   write_eng_rec
#$%            Build_adv_SAM   RANDOM   Calc_SAM_intercept
#$%
#$% Tables:    AEG   CMC   UNT
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Jonathan Richardson - 9/94 (JECEWSI Interface)
#$%            Added the degrading of the probability of launch
#$%            when the game is defines as participating with JECEWSI.
#$%
#$%            Susan Miller - 6/9/95 (E1414)
#$%            Changed the variable no_room to outcome (set to $noroom
#$%            when no unt slots are available and $unsuccessful
#$%            when and unsuccessful SAM launch occurrs).
#$%
#$%            Susan Miller - 7/97 (E1587)
#$%            Added SAM_eqlist and SAM_index to the routine interface.
#$%            Changed cannot launch SAM due to full UNT table message
#$%            to indicate the shooter.  Added platform_type and target
#$%            name to postgame engagement log.  Added setting of
#$%            DEQ$Pointer prior to call Find_ADS_Slot to make sure the
#$%            is set correctly and added unsuccessful launch message
#$%            following call Find_ADS_Slot.
#$%
#######################################################################
BBcommon
encommon
 
integer UNT$Pointer, CMC$Pointer, UNT2$Pointer
integer outcome, tgt_list[6,400], target_index
integer SAM_eqlist[5,30], SAM_index # SMM 7/97 (E1587)
 
integer AEG$Pointer, AEG$SAMAssigned$I, nfind[11], len, nuclear
Character msg[ARB]
real    random_num, X, RANDOM, CMC$ProbLaunch$F
literal CSTRIP8
data x/0.0/
 
real*4   launch_factor      # degrade factor received from JECEWSI
integer  UNT3$pointer       # target, needed for JECEWSI routine
integer DEQ$Pointer # SMM 7/97 (E1587)
 
 # send in the number of slots needed and recieve the UNT$Pointer
 call UNTGET(1,nfind)
 unt2$pointer = 0
 # if not enough slots found, send error message
 if (nfind[1] == 0)
    {
     len = 0
     call smovhn(xUNT$Name$C, $$MaxLit,msg,len)
     call smovv(" cannot launch SAM.  (Unit array full).  ",msg,len)
     call send_ (xUNT$View$I,0,len,msg)
     outcome = $noroom
     return
    }
 
 # else there was room in the UNT table to launch a SAM,
 # so calculate the intercept range and time
 AEG$Pointer = tgt_list[1,target_index]
 call Calc_SAM_intercept(UNT$Pointer, CMC$Pointer, AEG$Pointer)
 
 CMC$ProbLaunch$F = xCMC$ProbLaunch$F  # get launch probability
 
 if (JECEWSI$Game != $no)              # adjust the probability of
   {                                   # launch - jfr 9/20/94
     # Note:  The JECEWSI factors are for the firing platform
     UNT3$Pointer$To  (xAEG$TargetUNTIndex$I)
     call get_jecewsi_factor (UNT$Pointer, UNT3$Pointer,
                              $LaunchFac, launch_factor)
     CMC$ProbLaunch$F = CMC$ProbLaunch$F * launch_factor
    }
 
 
 random_num = Random(x)                # get random number
 If (CMC$ProbLaunch$F >= random_num)   # if prob of launch is greater than
    {                                 # random number, then launch the SAM
     # get unit pointer for the SAM to be fired
     UNT2$Pointer = nfind[2]
 
     nuclear = $no
     call Build_adv_SAM(UNT$Pointer,UNT2$Pointer,CMC$Pointer,
                             AEG$Pointer,nuclear)
 
     # set flag to yes for assigned track
     AEG$SAMAssigned$I = $yes
     putAEG$SAMAssigned$I
 
     if (log$engage != $no)    # if engagement log desired
        {
         call engdata (unt$pointer, unt2$pointer)
         PUTeng$Time$f( game$time )
         PUTeng$Weapon$c( xCMC$Type$C )     # SAM Type
         putENG$PlatformType$C (xCMC$Type$C)  # smm 7/97 (E1587)
 
         # add target to engagement record -- clf 7/21/94
         # get the target UNT pointer
         UNT3$Pointer$To xAEG$TargetUNTIndex$I
         putENG$Target$C(xUNT3$Name$C)      # Target Name
 
         PUTeng$Result$i( eng$Launch$code )
 
         call write_eng_rec
        } # end if Engagement Log desired
    }
 else     # the Advanced SAM did not launch successfully
    {
     if (log$engage != $no)
        {
         call engdata(unt$pointer, unt2$pointer)
         putENG$Track$C    ("ADV SAM ")
         putENG$Weapon$C   (xCMC$Type$C)
         putENG$Result$I   (ENG$Unsuccessful$Code)
         putENG$ResultPH$F (CMC$ProbLaunch$F * 100.0)
         putENG$PlatformType$C (xCMC$Type$C)  # smm 7/97 (E1587)
         if (AEG$Pointer$Valid)               # smm 7/97 (E1587)
            putENG$Target$C  (xAEG$TargetUNTName$C)
         call write_eng_rec
        }  # end if Engagement Log desired
 
     outcome = $unsuccessful        # SMM #E1414 6/95
     DEQ$Pointer$To SAM_eqlist[1,SAM_index]     # SMM 7/97 (E1587)
     call Find_ADS_Slot (UNT$Pointer, 0,        # SMM 7/97 (E1587)
                         CMC$Pointer, DEQ$Pointer,
                         tgt_list, target_index, outcome)
 
     if (trace$engage$exe != $no)
        {
         call echor
         call echov (" Unsuccessful SAM launch:  Prob launch = ")
         call echof (CMC$ProbLaunch$F, 3)
         call echov (" and random draw = ")
         call echof (random_num, 3)
         call echor
        }
    }    # end of if Advanced SAM did not launch successfully
 
return
end # Fire_adv_SAM

 
Subroutine Calc_SAM_intercept (UNT$Pointer, # receive firing UNT pointer
                               CMC$Pointer, # receive SAM characteristic pointer
                               AEG$Pointer) # receive target AEG pointer
#######################################################################
#$% Purpose:   Calc_SAM_intercept calculates the intercept time and
#$%            range and fills in the following data:
#$%            AEG$SAMInterceptTime$f, AEG$SAMInterceptRange$I,
#$%            AEG$SAMAssigned$I, AEG$CMCIndex$I
#$%
#$% Called By: Fire_adv_SAM
#$%
#$% Calls:     RLL2RB
#$%
#$% Tables:    UNT   LCL   AEG
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer UNT$Pointer, CMC$Pointer, AEG$Pointer
 
integer LCL$Pointer, UNT3$Pointer, AEG$SAMInterceptRange$I
integer AEG$CMCIndex$I
real    AEG$SAMInterceptTime$f
real    tgt_lat, tgt_lon, tgt_course, firing_lat, firing_lon, tgt_speed
real    cos_tgt_lat, cos_firing_lat, range, brg_tgt_to_SAM, SAM_speed
real    AOB, detected_range, altered_altitude, SAM_LA, slant_range
real    Time_of_flight, SAM_intercept_range, inter1, inter2, inter3
 
## Calculate SAM Intercept time = current game time + SAM time of flight
##                           Ti = T + TOF
## where time of flight =
## (slant_range * 3600)/(tgt_speed * COS(AOB) * SAM_speed * COS(SAM_LA))
##                  TOF = Sr * 3600/((St * COS(AOB)) + (Ss * COS(SAM_LA)))
## where slant_range = SQRT((LCL$Range$F)^2 + ((LCL$Altitude$I * 100)/6000)^2)
##                Sr = SQRT(R^2 + (A/6000)^2)
## where SAM lead angle =
##   (-1)EXP(tgt_speed) ((tgt_speed/SAM_speed) * SIN(AOB))
##               SAM_LA = ARCSIN ((St/Ss) * SIN(AOB))
## where angle on the bow = AOB = bearing to target - tgt_course
 
 # get the LCL pointer
 LCL$Pointer$To xAEG$LCLPntrIndex$I
 
 # get the target UNT pointer
 UNT3$Pointer$To xAEG$TargetUNTIndex$I
 
 # get track latitude, longitude, and course
 tgt_lat = xLCL$ApparentLat$F
 tgt_lon = xLCL$ApparentLon$F
 tgt_course = xUNT3$AssumedCourse$F
 cos_tgt_lat = COS(tgt_lat)
 
 # get firing platforms latitude and longitude
 firing_lat = xUNT$TrueLatitude$F
 firing_lon = xUNT$TrueLongitude$F
 cos_firing_lat = COS(firing_lat)
 
 # calculate bearing from the attacker to the target
 call RLL2RB(tgt_lat,
             tgt_lon,
             cos_tgt_lat,
             firing_lat,
             firing_lon,
             cos_firing_lat,
             range,             # returned
             brg_tgt_to_SAM)    # returned
 
 # calculate angle on the bow
 AOB = brg_tgt_to_SAM - tgt_course
 $angpi (AOB)   # adjust btwn -pi and pi
 if (AOB < 0.0) AOB = -1.0 * AOB # 0 to pi
 
 # calculate slant range
 detected_range = xLCL$Range$F                    # get the stored range
 detected_range = detected_range * detected_range # square it
 altered_altitude = xLCL$Altitude$I * 100.0 # divided by 100 when placed in LCL
 altered_altitude = altered_altitude/6000 # as per equation in model description
 altered_altitude = altered_altitude * altered_altitude # square it
 slant_range = SQRT(detected_range + altered_altitude)
 
 # save the SAM characteristic pointer index
 AEG$CMCIndex$I = CMC$Pointer$Index
 putAEG$CMCIndex$I
 
 # calculate SAM lead angle in radians
 tgt_speed = FLOAT(xLCL$Speed$I)
 SAM_speed = FLOAT(xCMC$AvgSpeed$I)
 if (tgt_speed != 0.0)
    {
     inter1 = SIN(AOB)
     inter2 = (tgt_speed/SAM_speed)
     inter3 = inter1 *inter2
     # make sure inter3 positive and is 1 or less
     inter3 = MIN(1.0,ABS(inter3))
     SAM_LA = ASIN (inter3)
    }
 else
    SAM_LA = 0
 
 # calculate SAM time of flight in seconds
 Time_of_flight = (slant_range * 3600.0)/_
                      ((tgt_speed * COS(AOB)) + (SAM_speed * COS(SAM_LA)))
 # convert the time of flight in seconds to minutes before adding to current time
 AEG$SAMInterceptTime$f = (Time_of_flight/60.0 + 1) + Game$Time
 putAEG$SAMInterceptTime$f
 
 # calculate SAM intercept range
 SAM_intercept_range = SAM_speed * (Time_of_flight/3600.0)
 AEG$SAMInterceptRange$I = INT(SAM_intercept_range)
 putAEG$SAMInterceptRange$I
 
return # Calc_SAM_intercept
end

 
Subroutine Build_adv_SAM(UNT$Pointer,  # receive firing UNT pointer
                         UNT2$Pointer, # receive missile UNT pointer
                         CMC$Pointer,  # receive missile characteristic pointer
                         AEG$Pointer,  # receive
                         nuclear)      # receive yes or no
#######################################################################
#$% Purpose:   Build_adv_SAM
#$%            where UNT$Pointer is firing platform
#$%                  UNT2$Pointer is the SAM
#$%
#$% Called By: Fire_adv_SAM
#$%
#$% Calls:     Partial_CM_build    RLL2RB
#$%
#$% Tables:    AEG   UNT   CMC   LCL
#$%
#$% Date:      Dec. 1993
#$%
#$% Author:    Susan Miller
#######################################################################
BBcommon
 
integer UNT$Pointer, UNT2$Pointer, AEG$Pointer, CMC$Pointer, nuclear
 
integer UNT2$Type$I, UNT2$TrueAltDepth$I, UNT2$OrderedAltDepth$I
integer UNT2$AssignedTarget$I, UNT2$AttackIndx$I
real     unt2$TimeMissileFired$f
integer AEG$TargetUNTIndex$I, AEG$SAMInterceptRange$I, LCL$Pointer
integer LCL$Altitude$I, UNT2$LaunchIndx$I
real    UNT2$TrueCourse$F, UNT2$AssumedCourse$F, UNT2$SAMElevationAngle$F
real    UNT2$OrderedCourse$F, temp_angle, range_to_tgt, brg_SAM_to_tgt
real    tgt_lat, tgt_lon, cos_tgt_lat
 
 UNT2$Type$I = $SAMissile$code       # advanced SAM type
 putUNT2$Type$I
 
 # fill in part of the missile information and assign a unique name
 call Partial_CM_build(UNT$Pointer, UNT2$Pointer, CMC$Pointer, nuclear)
 
 # save the launching platform's UNT index
 UNT2$LaunchIndx$I = UNT$Pointer$Index
 putUNT2$LaunchIndx$I
 
 # calculate elevation angle = arctan(target_alt/intercept_range * 6000)
 LCL$Pointer$To xAEG$LCLPntrIndex$I
 LCL$Altitude$I = xLCL$Altitude$I * 100
 AEG$SAMInterceptRange$I = xAEG$SAMInterceptRange$I
 temp_angle = (LCL$Altitude$I/(AEG$SAMInterceptRange$I * 6000.0))
 UNT2$SAMElevationAngle$F = ATAN(temp_angle)
 putUNT2$SAMElevationAngle$F
 
 unt2$TimeMissileFired$f = Game$Time
 putunt2$TimeMissileFired$f
 
 UNT2$TrueAltDepth$I = xUNT$TrueAltDepth$I
 putUNT2$TrueAltDepth$I
 
 UNT2$OrderedAltDepth$I = LCL$Altitude$I # SAM should try to attain alt of target
 putUNT2$OrderedAltDepth$I
 
 # get target information
 tgt_lat = xLCL$ApparentLat$F
 tgt_lon = xLCL$ApparentLon$F
 cos_tgt_lat = COS(tgt_lat)
 
 # calculate bearing from the SAM to the target
 call RLL2RB(xUNT2$TrueLatitude$F,
             xUNT2$TrueLongitude$F,
             xUNT2$COSTrueLat$F,
             tgt_lat,
             tgt_lon,
             cos_tgt_lat,
             range_to_tgt,      # returned
             brg_SAM_to_tgt)    # returned
 
 UNT2$TrueCourse$F = brg_SAM_to_tgt
 putUNT2$TrueCourse$F
 
 UNT2$AssumedCourse$F = UNT2$TrueCourse$F
 putUNT2$AssumedCourse$F
 
 UNT2$OrderedCourse$F = UNT2$TrueCourse$F
 putUNT2$OrderedCourse$F
 
 AEG$TargetUNTIndex$I = xAEG$TargetUNTIndex$I
 UNT2$AssignedTarget$I = AEG$TargetUNTIndex$I
 putUNT2$AssignedTarget$I
 
 UNT2$AttackIndx$I = AEG$TargetUNTIndex$I
 putUNT2$AttackIndx$I
 
return
end # Build_adv_SAM

 
Subroutine Find_ADS_Slot(UNT$Pointer,   # receive firing UNT pointer
                         UNT2$Pointer,  # receive SAM UNT pointer
                         CMC$Pointer,   # receive SAM characteristic pointer
                         DEQ$Pointer,   # receive SAM weapon DEQ pointer
                         tgt_list,      # receive target list
                         tgt_index,     # receive index number
                         outcome)       # receive outcome   SMM 7/97 (E1587)
#######################################################################
#$% Purpose:   Find_ADS_Slot finds an empty ADS slot and calls
#$%            Fill_ADS_slot to fill it with the appropriate data.  It
#$%            also checks that the max ADS slots is not exceeded for
#$%            this view and reuses older slots if the max has been reached.
#$%
#$% Called By: SAM_assignment
#$%
#$% Calls:     Find_active_RMT
#$%
#$% Tables:    ADS   UNT   CMC   DEQ   VUE
#$%
#$% Date:      Jan. 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 7/97 (E1587)
#$%            Added parameter outcome which is now an argument of
#$%            Fill_ADS_slot (replacing the view).
#$%
#######################################################################
BBcommon
 
integer UNT$Pointer, UNT2$Pointer, CMC$Pointer
integer DEQ$Pointer, tgt_list[6,400], tgt_index
integer outcome         # SMM 7/97 (E1587)
 
integer number_used
integer UNT2$View$I, VUE$Pointer, VUE$FirstADSIndex$I, VUE$NumberADSEntries$I
real    engagement_info[2], ADS$InitialReportTime$F, check_time
integer ADS$Pointer, ADS$NextIndex$I
integer first_ADS_index, i
 
 
 engagement_info[1] = 0.0
 engagement_info[2] = 0.0
 check_time = 9999.9
 number_used = 0
 
 # get the view of the SAM
 UNT2$View$I = xUNT2$View$I
 VUE$Pointer$To UNT2$View$I
 VUE$FirstADSIndex$I = xVUE$FirstADSIndex$I
 
 # if this view has no ADS slots filled, use the first free slot
 if (VUE$FirstADSIndex$I == 0)
    {
     # as long as the first free ADS slot is not zero use it
     if (ADS$First$Free != 0)
        {
         # point to the first free slot
         ADS$Pointer$To ADS$First$Free
 
         # reset the first ADS slot free
         ADS$NextIndex$I = xADS$NextIndex$I
         ADS$First$Free = ADS$NextIndex$I
 
         # set next ADS slot in the linked list for this view
         ADS$NextIndex$I = 0
         putADS$NextIndex$I
 
         # save the first ADS index for this view
         VUE$FirstADSIndex$I = ADS$Pointer$Index
         putVUE$FirstADSIndex$I
 
         number_used = 1
        }
    }
 
 # if this view has ADS slots filled or there are no free slots...
 # need to count the number of slots filled and keep track of the oldest
 # entry
 else if ((VUE$FirstADSIndex$I != 0) | (ADS$First$Free == 0))
    {
     # first count the number of slots that are filled for this view
     first_ADS_index = VUE$FirstADSIndex$I
     for (i = first_ADS_index; i != 0;)
        {
         # keep track of how many tracks this view has
         number_used = number_used + 1
 
         # set pointer
         ADS$Pointer$To i
 
         # get the initial time of the engagement and save the oldest time
         ADS$InitialReportTime$f = xADS$InitialReportTime$f
 
         # save the oldest time of engagement (which is the smallest)
         if (ADS$InitialReportTime$f < check_time)
            {
             engagement_info[1] = ADS$InitialReportTime$f
             engagement_info[2] = FLOAT(ADS$Pointer$Index)
             check_time = ADS$InitialReportTime$f
            }
 
         # get the next index in the linked list
         i = xADS$NextIndex$I
 
         # if there are 200 slots filled break out of the loop
         if (number_used == 200) break
 
         # if this was the last one...
         if (i == 0) break
        } # end of for loop through the linked list of AEG tracks
     # if the number of slots filled is equal to the max, then
     # clear out the oldest one
     if (number_used >= MaxADSslots$per$view)
        {
         # point to the slot to be used
         ADS$Pointer$To INT(engagement_info[2])
         # save the next index in the list
         ADS$NextIndex$I = xADS$NextIndex$I
 
         # clear out this slot
         ADS$Zero
 
         # save the next index in the list
         putADS$NextIndex$I
        }
      else
        {
         # first set the last ADS slot next index to this new ADS slot
         ADS$NextIndex$I = ADS$first$free
         putADS$NextIndex$I
 
         # set pointer to first free slot
         ADS$Pointer$To ADS$first$free
 
         # reset the first ADS slot free
         ADS$NextIndex$I = xADS$NextIndex$I
         ADS$First$Free = ADS$NextIndex$I
 
         # set next index to zero and store it
         ADS$NextIndex$I = 0
         putADS$NextIndex$I
 
         number_used = number_used + 1
        }
    } # end if this view has an ADS list
 
 # save then number of ADS slots being used
 VUE$NumberADSEntries$I = number_used
 putVUE$NumberADSEntries$I
 
 call Fill_ADS_slot(UNT$Pointer, UNT2$Pointer, CMC$Pointer, ADS$Pointer,
                    DEQ$Pointer, tgt_list, tgt_index, outcome)
 
return
end

 
Subroutine Fill_ADS_Slot(UNT$Pointer,   # receive firing UNT pointer
                         UNT2$Pointer,  # receive SAM UNT pointer
                         CMC$Pointer,   # receive SAM characteristic pointer
                         ADS$Pointer,   # receive ADS pointer
                         DEQ$Pointer,   # receive SAM weapon DEQ pointer
                         tgt_list,      # receive target list
                         tgt_index,     # receive target index number
                         outcome)       # receive outcome of launch
#######################################################################
#$% Purpose:   Fill_ADS_Slot fills an empty ADS slot appropriate data.
#$%
#$% Called By: Find_ADS_Slot
#$%
#$% Calls:     Find_active_RMT   Fill_target_info
#$%
#$% Tables:    ADS   ACC   AEG   UNT   CMC   DEQ
#$%
#$% Date:      Jan. 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 7/97 (E1587)
#$%            Changed parameter UNT2$View$I to outcome.  Added declaration
#$%            of variable name_len.  Changed setting of ADS$View to be
#$%            view of the launching platform.  Added setting of SAM unit
#$%            name to FAIL when there is an unsuccesful launch.  Removed
#$%            UNT2$Pointer parameter in call to Fill_target_info and added
#$%            outcome.  Added code to set ADS$Result$I and decrement
#$%            ADS$NbrSAMsRemaining$I when a launch is unsuccessful.
#$%
#######################################################################
BBcommon
 
integer UNT$Pointer, UNT2$Pointer, CMC$Pointer, ADS$Pointer
integer DEQ$Pointer, tgt_list[6,400], tgt_index, outcome
 
integer ADS$SAMCMCIndex$I, AEG$Pointer, ADS$AircraftFlag$I
integer ADS$NbrSAMsRemaining$I
real    AEG$SAMInterceptTime$f, ADS$InitialReportTime$f
integer ADS$Result$I, ADS$AssocAEGIndex$I, ADS$View$I, name_len
literal ADS$SAMUNTName$C, ADS$FiringUNTName$C
literal CSTRIP8
 
# tgt_list[1,num_of_tgts] = AEG$Pointer
# tgt_list[2,num_of_tgts] = AEG$CPADistance$I
# tgt_list[3,num_of_tgts] = AEG$CPATime$f
# tgt_list[4,num_of_tgts] = AEG$AircraftFlag$I # yes if A/C
# tgt_list[5,num_of_tgts] = target_alt
 
 # UNT name of unit that fired the SAM
 ADS$FiringUNTName$C = xUNT$Name$C
 putADS$FiringUNTName$C
 
 # save the view    # SMM 7/97 (E1587)
 ADS$View$I = xUNT$View$I
 putADS$View$I
 
 if (outcome == $unsuccessful)  # SMM 7/97 (E1587)
    {
     name_len = 0       # jb E2144  smovV, next 5 lines 8/7/00
     call smovV  ("F",ADS$SAMUNTName$C,name_len)
     call smovV  ("A",ADS$SAMUNTName$C,name_len)
     call smovV  ("I",ADS$SAMUNTName$C,name_len)
     call smovV  ("L",ADS$SAMUNTName$C,name_len)
     call smovV  (" ",ADS$SAMUNTName$C,name_len)
     call smov  (EOS,ADS$SAMUNTName$C,name_len)
    }
 else
     # UNT name of SAM
     ADS$SAMUNTName$C = xUNT2$Name$C
 putADS$SAMUNTName$C
 
 # CMC index of SAM
 ADS$SAMCMCIndex$I = CMC$Pointer$Index
 putADS$SAMCMCIndex$I
 
 # get the AEG pointer
 AEG$Pointer = tgt_list[1,tgt_index]
 ADS$AircraftFlag$I = tgt_list[4,tgt_index]
 
 # SMM 7/97 (E1587)
 if (outcome == $unsuccessful)
      AEG$SAMInterceptTime$F = 0.0
 else AEG$SAMInterceptTime$F = xAEG$SAMInterceptTime$F
 
 call Fill_target_info(ADS$Pointer, AEG$Pointer, ADS$AircraftFlag$I,
                       AEG$SAMInterceptTime$F, outcome)
 
 # time this slot was filled
 ADS$InitialReportTime$f = Game$Time
 putADS$InitialReportTime$f
 
 if (outcome == $unsuccessful)      # SMM 7/97 (E1587)
    {
     ADS$Result$I = $unsuccessful
     # remaining SAM on board the firing unit
     ADS$NbrSAMsRemaining$I = xDEQ$Remaining$I - 1
    }
 else  # initilize the result to 0 so it is neither a hit nor a miss
    {
     ADS$Result$I = $initial
     # remaining SAM on board the firing unit
     ADS$NbrSAMsRemaining$I = xDEQ$Remaining$I
    }
 putADS$Result$I
 putADS$NbrSAMsRemaining$I
 
 # save the associated AEG index, AEG slot cleared when a hit is assessed
 ADS$AssocAEGIndex$I = AEG$Pointer$Index
 putADS$AssocAEGIndex$I
 
return
end # Fill_ADS_Slot

 
Subroutine Fill_target_info(ADS$Pointer,  # receive ADS pointer
                            AEG$Pointer,  # receive AEG pointer
                            ADS$AircraftFlag$I, # receive aircraft flag
                            AEG$SAMInterceptTime$f, # receive intercept time
                            outcome)      # receive launch outcome
#######################################################################
#$% Purpose:   Fill_target_info fills in target info in appropriate ADS slot.
#$%
#$% Called By: Fill_ADS_slot
#$%
#$% Tables:    ADS   AEG   UNT   RMT   ACC   CMC   RVU
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 7/97 (E1587)
#$%            Removed parameter UNT$Pointer and added outcome.
#$%            Changed code to get the RVU pointer from the ADS$View$I
#$%            rather than UNT$View$I.  Added code to only store the
#$%            ADS$Pointer$index when the outcome is successful.
#$%
#######################################################################
BBcommon
 
integer ADS$Pointer, AEG$Pointer, ADS$AircraftFlag$I
real    AEG$SAMInterceptTime$f
integer outcome
 
integer AEG$TargetUNTIndex$I, UNT2$Pointer, ACC$Pointer, CMC$Pointer
integer ADS$TargetACCPointer$I, ADS$TargetCMCPointer$I, RMT$Pointer
integer RVU$Pointer, class_len
real    ADS$InterceptTime$f
integer AEG$ADSIndex$I
literal ADS$TargetUNTName$C, ADS$TrackNumber$C, ADS$TargetClass$C
literal RMT$UserClass$C, AEG$TargetUNTName$C
literal CSTRIP, CSTRIP8, a_track
integer an_a / "A" /
 
# tgt_list[1,num_of_tgts] = AEG$Pointer
# tgt_list[2,num_of_tgts] = AEG$CPADistance$I
# tgt_list[3,num_of_tgts] = AEG$CPATime$f
# tgt_list[4,num_of_tgts] = AEG$AircraftFlag$I # yes if A/C
# tgt_list[5,num_of_tgts] = target_alt
 
 AEG$TargetUNTIndex$I = xAEG$TargetUNTIndex$I
 UNT2$Pointer$To AEG$TargetUNTIndex$I
 AEG$TargetUNTName$C = xAEG$TargetUNTName$C
 ADS$TargetUNTName$C = AEG$TargetUNTName$C
 putADS$TargetUNTName$C
 
 putADS$AircraftFlag$I
 # either CMC or ACC target characteristic index
 if (ADS$AircraftFlag$I == $yes)
    {
     ACC$Pointer = xUNT2$AccPntr$I
     ADS$TargetACCPointer$I = ACC$Pointer
     putADS$TargetACCPointer$I
    }
 else
    {
     CMC$Pointer = xUNT2$CMCPntr$I
     ADS$TargetCMCPointer$I = CMC$Pointer
     putADS$TargetCMCPointer$I
    }
 
 # get the RMT pointer
 RMT$Pointer$To xAEG$RMTPointerIndex$I
 RVU$Pointer$To xADS$View$I
 
 ADS$TrackNumber$C = a_track(xRVU$TrackCode$C, an_A, xRMT$TrackNumber$i)
 putADS$TrackNumber$C
 
 # get the class
 class_len =  0
 # if the track is a missile, store MSL
 if (ADS$AircraftFlag$I == $no)
    {       # jb E2144  smovV, next 5 lines 8/7/00
     call smovV  (" ",ADS$TargetClass$C,class_len)
     call smovV  ("M",ADS$TargetClass$C,class_len)
     call smovV  ("S",ADS$TargetClass$C,class_len)
     call smovV  ("L",ADS$TargetClass$C,class_len)
     call smovV  (" ",ADS$TargetClass$C,class_len)
     call smov  (EOS,ADS$TargetClass$C,class_len)
    }
 else # it must be an aircraft
    {
     RMT$UserClass$C = xRMT$UserClass$C
     # if the user classified this track, use the user class name
     if (RMT$UserClass$C != 0)
        {
         ADS$TargetClass$C = RMT$UserClass$C
        }
     else # no user entered class name, store ACFT
        {          # jb E2144  smovV, next 5 lines 8/7/00
         call smovV  (" ",ADS$TargetClass$C,class_len)
         call smovV  ("A",ADS$TargetClass$C,class_len)
         call smovV  ("C",ADS$TargetClass$C,class_len)
         call smovV  ("F",ADS$TargetClass$C,class_len)
         call smovV  ("T",ADS$TargetClass$C,class_len)
         call smov  (EOS,ADS$TargetClass$C,class_len)
        }
    }
 putADS$TargetClass$C
 
 # time the SAM will intercept the target
 ADS$InterceptTime$f = AEG$SAMInterceptTime$f
 putADS$InterceptTime$f
 
 if (outcome != $unsuccessful)  # SMM 7/97 (E1587)
    {
     # store the ADS index in the corresponding AEG slot
     AEG$ADSIndex$I = ADS$Pointer$Index
     putAEG$ADSIndex$I
    }
 
return
end # Fill_target_info

Subroutine Compute_SAM_Alt(unt$pointer)
########################################################################
#$% Purpose:    Compute_SAM_Alt computes the altitude of the advanced SAM
#$%             based on how long the SAM has been in the air and the
#$%             elevation angle which was calculated at the time of launch
#$%             and is stored in the UNT table.  If the SAM's altitude
#$%             exceeds the maximum altitude characteristic for this SAM,
#$%             delete the SAM.
#$%
#$% Called By:  ALTDEP
#$%
#$% Calls:      ADS_loop_search
#$%
#$% Tables:     UNT
#$%
#$% Date:       Jan 1994
#$%
#$% Author:     Susan Miller
#$%
#$% Modified:   Susan Miller - 7/97 (E1587)
#$%             Changed reference $no to $miss.  Added platform_type
#$%             to postgame engagement log.
#$%
########################################################################
BBcommon
encommon
 
integer UNT$Pointer
 
real    UNT$TrueSpeed$F, UNT$SAMElevationAngle$F, tan_EA, altitude
real    conversion_factor
integer UNT$TrueAltDepth$I, UNT$OrderedAltDepth$I
real    unt$TimeMissileFired$f, time_in_air
integer CMC$Pointer, UNT$Status$I, UNT$AssignedTarget$I
integer CMC$SAMMaxAlt$I, UNT2$Pointer
integer UNT3$Pointer, UNT3$SAMsAirborne$I, ADS$Pointer, AEG$Pointer
literal CSTRIP8
real    range, brng, mburange
 
# SAM altitude changes with time in relation to the elevation angle
# ((Game$Minute - SAM firing time) * SAM_speed * 0.6) * TAN(elevation angle)
# altitude at fire time will be the same as the launching platform
 
 UNT$TrueAltDepth$I = xUNT$TrueAltDepth$I
 UNT$OrderedAltDepth$I = xUNT$OrderedAltDepth$I
 
 # calculate the new altitude for this game$time
 UNT$TrueSpeed$F = xUNT$TrueSpeed$F
 unt$TimeMissileFired$f = xunt$TimeMissileFired$f
 UNT$SAMElevationAngle$F = xUNT$SAMElevationAngle$F
 
 tan_EA = TAN(UNT$SAMElevationAngle$F)
 time_in_air = (Game$time - unt$TimeMissileFired$f)
 # conversion_factor is 6000 ft per nmi * 1 hr per 60 min
 conversion_factor = 6000.0/60.0
 altitude = (time_in_air * UNT$TrueSpeed$F * conversion_factor) * tan_EA
 
 UNT$TrueAltDepth$I = altitude
 putUNT$TrueAltDepth$I
 
 CMC$Pointer = xUNT$CMCPntr$I
 # get the max altitude
 CMC$SAMMaxAlt$I = xCMC$SAMMaxAlt$I
 
 # find the ADS slot and put in a miss
 call ADS_loop_search(UNT$Pointer, ADS$Pointer)
 
 # get the AEG pointer
 AEG$Pointer$To xADS$AssocAEGIndex$I
 
 # get the firing platform index
 UNT3$Pointer$To xUNT$LaunchIndx$I
 
 # if new altitude is greater than max altitude and the time is
 # past its intercept time, delete the SAM
 if ((UNT$TrueAltDepth$I > CMC$SAMMaxAlt$I) &
     (xAEG$SAMInterceptTime$F > Game$Time))
    {
     putADS$Result$I ($miss)  # a miss
 
     UNT2$Pointer$To xUNT$AssignedTarget$I
 
     if (log$engage != $no)              # if engagement log desired
        {
         call engdata (unt$pointer, unt2$pointer)
         PUTeng$Weapon$c( xCMC$Type$C )        # CM Type
         PUTeng$Time$f( game$time )
         PUTeng$Result$i( eng$Miss$Code )
         putENG$PlatformType$C (xCMC$Type$C)   # smm 7/97 (E1587)
 
         if (UNT2$Pointer$Valid)        # check for valid assigned target
           {
             PUTeng$Target$c( xUNT2$Name$C )       # the target
 
             # get the firing unit index
             UNT3$Pointer$To xUNT$LaunchIndx$I
             call RLL2RB( _         #Rhumb line Lat/Lon to Range/Bearing
                  xUNT2$TrueLatitude$F,     #latitude of TARGET
                  xUNT2$TrueLongitude$F,    #longitude of TARGET
                  xUNT2$CosTrueLat$F,       #cos of lat of TARGET
                  xUNT3$TrueLatitude$F,     #latitude of firing platform
                  xUNT3$TrueLongitude$F,    #longitude of firing platform
                  xUNT3$CosTrueLat$F,       #cos of lat of firing platform
                  RANGE,       #range (output)
                  BRNG)        #bearing (output) Tgt to Interceptor
             PUTeng$Range$f( range )         # range to target
             PUTeng$MBURange$f( MBURange(UNT2$Pointer) ) # get range to MBU
             PUTeng$ResultPh$f( xCMC$ProbHit$F * 100 )
           }
         else
           {
             PUTeng$Target$c   (xADS$TargetUNTName$C)
             PUTeng$Range$f    (-1)
             PUTeng$MBURange$f (-1)
             PUTeng$ResultPh$f (0.0)
           }
 
         call write_eng_rec
         call Log_Run_Time_Termination (UNT$Pointer, CMC$Pointer)
        }
 
     UNT$Status$I = $BeingDeleted$Code
     putUNT$Status$I
     UNT$AssignedTarget$I = $no
     putUNT$AssignedTarget$I
 
     # clear the assigned flag for dead SAMs assigned target
     putAEG$SAMAssigned$I ($no)
     putAEG$SAMInterceptTime$F (0.0)
 
     # decrement the number of SAMs airborne for the launching platform
     UNT3$SAMsAirborne$I = xUNT3$SAMsAirborne$I
     if (UNT3$SAMsAirborne$I > 0)
        {
         UNT3$SAMsAirborne$I = UNT3$SAMsAirborne$I - 1
         putUNT3$SAMsAirborne$i
        }
    }
 
return
end # Compute_SAM_Alt

Subroutine Check_SAM_Range(UNT$Pointer) # receive UNT pointer of SAM
########################################################################
#$% Purpose:   Check_SAM_Range calculates the range a SAM can travel
#$%            in a given altitude band in order to prosecute a target.
#$%            Calculate whether a SAM has exceeded it's range and should
#$%            be deleted.
#$%
#$% Called By: Motion
#$%
#$% Calls:     ADS_loop_search
#$%
#$% Tables:    UNT
#$%
#$% Date:      Jan. 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 7/97 (E1587)
#$%            Changed references to $no to $miss.  Added platform_type
#$%            to postgame log.
#$%
########################################################################
BBcommon
encommon
 
integer UNT$Pointer
 
integer UNT$Status$I, CMC$Pointer, CMC$BND$Altitude$I, UNT$TrueAltDepth$I
integer CMC$NbrOfAltBands$I, CMC$BND$Index
integer max_range, UNT3$Pointer, UNT3$SAMsAirborne$I
integer ADS$Pointer, AEG$Pointer, UNT$AssignedTarget$I
integer UNT2$Pointer
real    distance_traveled, time_in_air
literal CSTRIP8
real    range, brng, mburange
 
 # get the launching platform
 UNT3$Pointer$To xUNT$LaunchIndx$I
 
 # get the missile characteristic pointer for this SAM
 CMC$Pointer = xUNT$CMCPntr$I
 # if this SAM does have altitude bands, find the altitude band
 # the SAM is currently inside
 CMC$NbrofAltBands$I = xCMC$NbrofAltBands$I
 if (CMC$NbrofAltBands$I > 0)
    {
     # get the SAM's current altitude
     UNT$TrueAltDepth$I = xUNT$TrueAltDepth$I
 
     for (CMC$BND$Index = 1;
          CMC$BND$Index <= CMC$NbrofAltBands$I ; # loop through
          CMC$BND$Index = CMC$BND$Index + 1)     # alt. bands
        {
         CMC$BND$Altitude$I = xCMC$BND$Altitude$I
         # is the SAM's altitude within this band?
         if (UNT$TrueAltDepth$I <= CMC$BND$Altitude$I)
            {
             # in this band, so save this range
             max_range = xCMC$BND$MaxRange$I
             break
            }
        }
     # if max_range is still zero, meaning the current altitude
     # of the SAM was not less than the max altitude of all the bands,
     # so need to set max_range to something other than zero...
     if (max_range == 0)
        max_range = xCMC$SamMaxRange$I
    } # end if this SAM has defined altitude bands
 else # just get the max range
    max_range = xCMC$SamMaxRange$I
 
 # since the SAM has a constant speed the range it has traveled
 # can be calculated based on the time in the air and it's true speed
 # rather than getting the launching platform's UNT pointer and using
 # the routine RLL2RB, this also allows for calculating the total
 # distance a SAM may have traveled if it made some turns rather than
 # just calculating the distance from the firing unit
 time_in_air = (Game$Time - xunt$TimeMissileFired$f)
 # convert speed from nmi/hour to nmi/min
 distance_traveled = (time_in_air * (xUNT$TrueSpeed$F / 60.0))
 
 # if the distance traveled is greater than the max range for this SAM,
 # delete it
 if (distance_traveled >= max_range)
    {
     # find the ADS slot and put in a miss
     call ADS_loop_search(UNT$Pointer, ADS$Pointer)
     if (ADS$Pointer != 0)
       {
        putADS$Result$I ($miss)  # a miss   # SMM 7/97 (E1587)
 
        # get the AEG pointer
        AEG$Pointer$To xADS$AssocAEGIndex$I
       }
 
     UNT2$Pointer$To xUNT$AssignedTarget$I
 
     if (log$engage != $no)              # if engagement log desired
        {
         call engdata (unt$pointer, unt2$pointer)
         PUTeng$Weapon$c( xCMC$Type$C )        # CM Type
         PUTeng$Time$f( game$time )
         PUTeng$Result$i( eng$Miss$Code )
         putENG$PlatformType$C (xCMC$Type$C)   # smm 7/97 (E1587)
 
         if (UNT2$Pointer$Valid)        # check for valid assigned target
           {
             PUTeng$Target$c( xUNT2$Name$C )       # the target
 
             call RLL2RB( _         #Rhumb line Lat/Lon to Range/Bearing
                  xUNT2$TrueLatitude$F,     #latitude of TARGET
                  xUNT2$TrueLongitude$F,    #longitude of TARGET
                  xUNT2$CosTrueLat$F,       #cos of lat of TARGET
                  xUNT3$TrueLatitude$F,     #latitude of firing platform
                  xUNT3$TrueLongitude$F,    #longitude of firing platform
                  xUNT3$CosTrueLat$F,       #cos of lat of firing platform
                  RANGE,       #range (output)
                  BRNG)        #bearing (output) Tgt to Interceptor
             PUTeng$Range$f( range )         # range to target
             PUTeng$MBURange$f( MBURange(UNT2$Pointer) ) # get range to MBU
             PUTeng$ResultPh$f( xCMC$ProbHit$F * 100 )
           }
         else
           {
             PUTeng$Target$c   (xADS$TargetUNTName$C)
             PUTeng$Range$f    (-1)
             PUTeng$MBURange$f (-1)
             PUTeng$ResultPh$f (0.0)
           }
 
         call write_eng_rec
         call Log_Run_Time_Termination (UNT$Pointer, CMC$Pointer)
        }
 
     UNT$Status$I = $BeingDeleted$Code
     putUNT$Status$I
     UNT$AssignedTarget$I = $no
     putUNT$AssignedTarget$I
 
     # clear the assigned flag for dead SAMs assigned target
     putAEG$SAMAssigned$I ($no)
     putAEG$SAMInterceptTime$f (0)
 
     # decrement the number of SAMs airborne for the launching platform
     UNT3$SAMsAirborne$I = xUNT3$SAMsAirborne$I
     if (UNT3$SAMsAirborne$I > 0)
        {
         UNT3$SAMsAirborne$I = UNT3$SAMsAirborne$I - 1
         putUNT3$SAMsAirborne$i
        }
    }
 
return
end # Check_SAM_Range

 
Subroutine Proc_SAM_Attack(UNT$Pointer)
#######################################################################
#$%
#$% Purpose:   Proc_SAM_Attack evaluates the actions of an advanced SAM
#$%            on its currently assigned target.  At this point, the
#$%            assigned target is not being deleted (that would be taken
#$%            care of in EINIT which is called prior to this routine),
#$%            so a hit or missed is assessed.  If a miss is assessed,
#$%            the SAM continues on its current course until it reaches
#$%            it's max range or target and then ceases to exist.
#$%
#$% Called By: Engage
#$%
#$% Calls:     SAM_Hit_or_Miss
#$%
#$% Tables:    UNT   ADS   VUE
#$%
#$% Date:      Jan 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 6/95 (E1414)
#$%            Changed debug message to show the name of the
#$%            SAM that is not being matched in ADS table.
#$%
#$%            Susan Miller - 7/97 (E1587)
#$%            Removed else part of if ((VUE$FirstADSIndex$I != 0) and
#$%            changed the logic statement so that the error message
#$%            would be displayed whenever ADS_found is $no.
#$%
#$%            Jim Allen - 12/02 (E2317)
#$%            Change min_to_target to rmin_to_target
#$%
#######################################################################
BBcommon
 
integer UNT$Pointer
Integer LCOMP           # jb AAI01/LCOMP    2/14/01
integer ADS$Pointer, VUE$Pointer, UNT$AssignedTarget$I, UNT2$Pointer
integer index, ADS_found, target_found, can_intercept
integer VUE$FirstADSIndex$I
real    range, bearing, intercept_time
literal CSTRIP8, ADS$SAMUNTName$C
 
 ADS_found = $no
 target_found = $no
 can_intercept = $no
 
 # get the view of this SAM
 VUE$Pointer$To  xUNT$View$I
 
 # get the target UNT2 pointer
 UNT$AssignedTarget$i = xUNT$AssignedTarget$i
 UNT2$Pointer$To UNT$AssignedTarget$I
 
 # get range from SAM to target
 call GETRB_M(UNT$Pointer,  #pass SAM pointer
              UNT2$Pointer, #pass target pointer
              range,        #receive range from guide
              bearing)      #receive bearing from guide
 
 call RMIN_TO_TARGET(1.0,      # Desig intercept dist. = 1.0 mile
            xUNT2$TrueCourse$F,# (radians) course of TARGET  real
            xUNT2$TrueSpeed$F, # (knots) speed of TARGET real
            xUNT$TrueSpeed$F,  # (knots) max INTERCEPTOR speed real
            range,             # (n.mi.) Initial rng between units real
            bearing,           # (radians) init. brg FROM tgt TO INTERCEPTOR
            intercept_time) # RETURNED value (min.) elapsed time to reach RADIUS
 
 if (intercept_time == -3 | intercept_time == 0) # less than 1 min. to arrival
    can_intercept = $yes
 
 if (can_intercept == $no) return
 
 # get the first ADS pointer for this view
 VUE$FirstADSIndex$I = xVUE$FirstADSIndex$I
 
 # check that it is not zero
 if (VUE$FirstADSIndex$I != 0)
    { # loop thru linked list to find this SAM
     for (index = VUE$FirstADSIndex$I; index != 0;)
        {
         # set pointer
         ADS$Pointer$To index
 
         # if this slot is a match, break out of the loop
         if (LCOMP(xADS$SAMUNTName$C,xUNT$Name$C)==0) # jb AAI01/LCOMP 2/14/01
            {
             ADS_found = $yes
             break
            }
         # else get the next index in the linked list
         else
            index = xADS$NextIndex$I
        }
    } # end if first ADS index is not zero
 
 # if ADS slot match not found, there is an error in the table
 if (ADS_found != $yes)     # SMM 7/97 (E1587)
    {
     call echor
     call echov  (" Error in ADS table, no match found for ")
     ADS$SAMUNTName$C = xADS$SAMUNTName$C
     call echohn (ADS$SAMUNTName$C, $$MaxLit)
     call echov  ("!! ")
     call echor
     return
    }
 
 if (xUNT2$Status$I == $BeingDeleted$Code)
     call Eval_SAM_miss(UNT$Pointer, ADS$Pointer, -1.0)
 
 # determine whether SAM has hit or miss
 call SAM_Hit_or_Miss(UNT$Pointer, ADS$Pointer, UNT2$Pointer)
 
return
end # Proc_SAM_Attack

 
Subroutine SAM_Hit_or_Miss(UNT$Pointer,    # receive SAM UNT pointer
                           ADS$Pointer,    # receive SAM ADS pointer
                           UNT2$Pointer)   # receive assigned target UNT pointer
########################################################################
#$% Purpose:   SAM_Hit_or_Miss calculates the probability of hit based
#$%            on altitude bands if they have been entered in BUILD,
#$%            or uses the probability of hit matrix, or, last resort,
#$%            uses the single probability of hit entered in BUILD
#$%            for the SAM.
#$%
#$% Called By: Proc_SAM_Attack
#$%
#$% Calls:     RLL2RB   RANDOM   write_eng_rec
#$%            Eval_SAM_hit   After_hit_clear_AEG
#$%
#$% Tables:    UNT   ADS   CMC   ACC   AML
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Jonathan Richardson - 9/94 (JECEWSI Interface)
#$%            Adjust the probability of hit when JECEWSI is defined to
#$%            be a participant - potential self protect or comm jamming.
#$%
#$%            Susan Miller - 6/13/95 (E1416)
#$%            Moved JEW Table access within the if game was initialized
#$%            to participate with JECEWSI (otherwise the table is not
#$%            created and the swar crashes).
#$%
########################################################################
BBcommon
Eng$ProbHits        # contains eph[], eph_loaded
Eng$ProbIndx        # contains T_indx, W_indx
 
literal cstrip8
integer UNT$Pointer, ADS$Pointer, UNT2$Pointer, UNT$TargetType$I
 
integer CMC$Pointer, CMC$NbrofAltBands$I, CMC$BND$Index
integer ACC$Pointer, CMC$BND$Altitude$I
real    random_num, X, RANDOM, probability_of_hit, range, bearing
 
real*4   spj_factor                    # self protective jamming factor
integer  UNT3$Pointer                  # SAM launching platform
integer  JEW$Pointer, JEW$C3Factor$F   # JECEWSI data for launching platform
data x/0.0/		# Get next random number in sequence
 
 probability_of_hit = 0
 # target is still available to destroy, so try it
 CMC$Pointer = xUNT$CMCPntr$I
 
 # get the range and bearing
 call RLL2RB(xUNT$TrueLatitude$F,   # lat of SAM
             xUNT$TrueLongitude$F,  # lon of SAM
             xUNT$CosTrueLat$F,     # COS of lat of SAM
             xUNT2$TrueLatitude$F,  # lat of target
             xUNT2$TrueLongitude$F, # lon of target
             xUNT2$CosTrueLat$F,    # COS of lat of target
             range,                 # return range from SAM to target
             bearing)               # return bearing of SAM to target
 
 # if the altitude of the target is beyond the max altitude of the
 # SAM, then evaluate a miss
 if (xUNT2$TrueAltDepth$I > xCMC$SAMMaxAlt$I)
    {
     call Eval_SAM_miss(UNT$Pointer, ADS$Pointer, probability_of_hit)
     return
    }
 
 CMC$NbrofAltBands$I = xCMC$NbrofAltBands$I
 # if this SAM has altitude bands
 if (CMC$NbrofAltBands$I > 0)
    {
     for (CMC$BND$Index = 1;
          CMC$BND$Index <= CMC$NbrofAltBands$I;  # loop through
          CMC$BND$Index = CMC$BND$Index + 1)     # alt. bands
        {
         # find the matching altitude
         CMC$BND$Altitude$I = xCMC$BND$Altitude$I
         if (xUNT2$TrueAltDepth$I <= CMC$BND$Altitude$I)
            {
             probability_of_hit = xCMC$BND$ProbHit$I
             break
            }
        } # end of for loop through altitude bands
    } # end if this SAM has defined altitude bands
 else # no altitude bands so try the probability of hit matrix
    {
     # get weapon index here before the CMC pointer is changed
     W_Indx = xCMC$WeaponIndex$I
     if (xADS$AircraftFlag$I == $yes)
        {
         ACC$Pointer = xADS$TargetACCPointer$I
         T_indx = xACC$TargetIndex$I
        }
     else
        {
         CMC$Pointer = xADS$TargetCMCPointer$I
         T_indx = xCMC$TargetIndex$I
        }
 
     If (T_indx < 1 | W_indx < 1)
        {
         # get the CMC weapon pointer since it may have been
         # changed above
         CMC$Pointer = xUNT$CMCPntr$I
         probability_of_hit = xCMC$ProbHit$F
        }
     else
        {
         probability_of_hit = eph[T_indx,W_indx] / 100.0
        }
    } # end else no altitude bands
 
 
 if (JECEWSI$Game != $no)     # if JECEWSI is participating,
    {                         # adjust the ph - jfr 9/20/94
     UNT3$Pointer$To   (xUNT$LaunchIndx$I)    # Launching unit (unit with jecewsi data)
     call get_jecewsi_factor (UNT3$Pointer, UNT2$Pointer, $spj, spj_factor)
     probability_of_hit = probability_of_hit * spj_factor
 
     JEW$Pointer$To  (UNT3$Pointer$Index)      # compute intercept degradation
     if (JEW$Pointer$Valid)                    # (applied to prob kill due to intercept algorithm)
       {
        JEW$C3Factor$F = xJEW$C3Factor$F       # JECEWSI comm jamming factor
        probability_of_hit = probability_of_hit * JEW$C3Factor$F
       }
   }
if (xUNT2$GhostedUnit$I == $yes & ALSP$Active == $yes)
{
   UNT$TargetType$I = xUNT$TargetType$I
   call ALSP_Send_CM_Engage (UNT$Pointer, UNT2$Pointer, UNT$TargetType$I)
   call Log_ALSP_Engagement_Engdata (UNT$Pointer,UNT2$Pointer,xCMC$Type$C,0,1)
   putUNT$Hits$I (100)
}
 
else
{
	# get random number
	random_num = Random(x)
	# if prob of hit is greater than a random number and this target
	# has not beed destroyed yet, then a hit occurred
	If ((probability_of_hit >= random_num) &
        (xUNT2$Status$I != $BeingDeleted$Code))
	{
		call Eval_SAM_hit(UNT$Pointer, CMC$Pointer, ADS$Pointer)
    }
	else # a miss due to probability of hit or target is destroyed
    {
		call Eval_SAM_miss(UNT$Pointer, ADS$Pointer, probability_of_hit)
    } # end if a miss occurred
}
 
return
end # SAM_hit_or_miss

 
Subroutine Eval_SAM_hit(UNT$Pointer,    # receive SAM UNT pointer
                        CMC$Pointer,    # receive SAM CMC pointer
                        ADS$Pointer)    # receive ADS pointer
########################################################################
#$% Purpose:   Eval_SAM_hit does all the things necessary to register
#$%            that a target was hit by a SAM.
#$%
#$% Called By: SAM_hit_or_miss
#$%
#$% Calls:     MBURange
#$%            Generate_eng_rec
#$%            Process_CM_Hit    <wgmdeng.rat>
#$%
#$% Tables:    UNT   AML   CMC
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Carol Kropp - 4/5/94
#$%            Replaced calls to Who_To_Kill, AC_hit_by_Miss, and
#$%            Update_Destroyed_Aircraft with a call to Process_CM_Hit.
#$%            The AML$Pointer of the destroyed A/C was required for
#$%            ADS table update, so AML$Pointer was added as a return
#$%            parameter of Process_CM_Hit.
#$%
#$%            Susan Miller - 3/22/95
#$%            Added check for target being a ghosted unit
#$%
#$%            Susan Miller - 7/97 (E1587)
#$%            Added platform type to postgame engagement log.
#$%            Changed $yes to $hit.
#$%
#$%            Susan Miller - 3/99 (E1969)
#$%            Update the RMT$Remaining and LCL$Remaining
#$%            Clear the unt$TakeUsingSAM$I flag once engagement
#$%            is completed.
#$%
########################################################################
BBcommon
encommon
real mburange
integer UNT$Pointer, CMC$Pointer, ADS$Pointer
Integer LCOMP           # jb AAI01/LCOMP    2/14/01
integer UNT2$Pointer, AML$Pointer, UNT2$GhostedUnit$I, ADS$Result$I
integer AEG$Pointer, AEG$NumberInFlight$I, UNT3$Pointer, UNT3$SAMsAirborne$I
literal CSTRIP8, missile_name, ADS$TargetUNTName$C
real    range, brng
integer RMT$Pointer, RMT$Remaining$I  # SMM 3/99 (E1969)
integer LCL$Pointer, LCL$Remaining$I  # SMM 3/99 (E1969)
integer kk
 
 # get the firing unit index
 UNT3$Pointer$To xUNT$LaunchIndx$I
 
 # get the target
 UNT2$Pointer$To xUNT$AssignedTarget$I
 missile_name = xCMC$Type$C
 
 # get the associated AEG pointer and set TargetUNTDestroyed
 AEG$Pointer$To xADS$AssocAEGIndex$I
 
 # if engagement log desired
 If (log$engage != $no)
    {
    call engdata (unt$pointer, unt2$pointer)
    if (!unt2$pointer$valid) PUTeng$Target$c(xADS$TargetUNTName$C)
    PUTeng$Weapon$c( xCMC$Type$C )
    putENG$PlatformType$C (xCMC$Type$C)   # smm 7/97 (E1587)
 
    call RLL2RB( _         #Rhumb line Lat/Lon to Range/Bearing
              xUNT2$TrueLatitude$F,     #latitude of TARGET
              xUNT2$TrueLongitude$F,    #longitude of TARGET
              xUNT2$CosTrueLat$F,       #cos of lat of TARGET
              xUNT3$TrueLatitude$F,     #latitude of firing platform
              xUNT3$TrueLongitude$F,    #longitude of firing platform
              xUNT3$CosTrueLat$F,       #cos of lat of firing platform
              RANGE,       #range (output)
              BRNG)        #bearing (output) Tgt to Interceptor
    PUTeng$Range$f( range )         # range to target
 
    PUTeng$MBURange$f( MBURange(UNT2$Pointer) )           # get range to MBU
    PUTeng$Result$i( eng$Hit$code )
    call write_eng_rec
    }
 
 # AML$Pointer is returned as 0 if the target is a ghosted unit SMM 3/25/95
 # OR.... if all side numbers already shot down.....                # DEW 12/99
 call Process_CM_HIT (UNT$Pointer, CMC$Pointer,
                      UNT2$Pointer, AML$Pointer)
 
 # if target is not an a/c and not a ghosted unit(SMM 3/22/95),
 # set the status to being deleted 5/11/94
 UNT2$GhostedUnit$I = xUNT2$GhostedUnit$I
 If ((xUNT2$Type$I != $AIR$CODE) & (UNT2$GhostedUnit$I != $YES))
    putUNT2$Status$I ($BeingDeleted$Code)
 
 If (UNT2$GhostedUnit$I == $YES)
    {
     if (xUNT2$DISId$I != 0)
        ADS$Result$I = $detonation
     else if (xUNT2$ALSPId$I != 0)
        ADS$Result$I = $attemptedhit
 
     putADS$Result$I
    }
 else  # not a ghosted target so it was a successful hit  SMM 3/22/95
    putADS$Result$I ($hit)  # a hit
 
 AEG$NumberInFlight$I = xAEG$NumberInFlight$I
 putAEG$SAMAssigned$I ($No)     # deassign
 
 if (UNT2$GhostedUnit$I != $YES) # if not a ghosted target  SMM 3/25/95
    {
     if (AEG$NumberInFlight$I > 1)
        {
         # if more than one a/c in flight
         if (aml$pointer$valid)
            {
            # Sometimes the PROCESS_CM_HIT routine returns a Zero
            # AML Pointer (All Side numbers already shot down)
            # The VALID test (above) should protect us              # DEW 12/99
 
            ADS$TargetUNTName$C = xAML$SideNumber$C
            putADS$TargetUNTName$C
            }
         else
            {
            # If we had a bogus AML Pointer, flag the existing name
            # with Asterisks                                        # DEW 12/99
 
            ADS$TargetUNTName$C = '@@@@@@@@'
            kk = 0
            call smovhn (xADS$TargetUNTName$C,$$MaxLit-1,   # Guarantee 1 "*"
                         ADS$TargetUNTName$C,kk)
            putADS$TargetUNTName$C
            }
 
         AEG$NumberInFlight$I = AEG$NumberInFlight$I - 1
         putAEG$NumberInFlight$I  # SMM 4/99 (E1969)
 
         # update the rmt and lcl track remaining info SMM 3/99 (E1969)
         RMT$Pointer$To xAEG$RMTPointerIndex$I
         RMT$Remaining$I = xRMT$Remaining$I - 1
         putRMT$Remaining$I
 
         LCL$Pointer$To xAEG$LCLPntrIndex$I
         if (LCL$Pointer$Valid)
            {
             LCL$Remaining$I = xLCL$Remaining$I - 1
             putLCL$Remaining$I
            }
        }
     else
        {
        # if this was a Take using SAM engagement, clear the flag SMM 4/99 (E1969)
        if (xUNT3$TakeUsingSAM$I == $Yes) putUNT3$TakeUsingSAM$I ($No)
 
         putAEG$TargetUNTDestroyed$I ($yes)
 
         # loop thru the AEG table and flag any other detections of this
         # unit as being destroyed
         for (AEG$Pointer$First; AEG$Pointer$Ok; AEG$Pointer$Next)
            {
             if ((xAEG$TargetUNTIndex$I != UNT2$Pointer$Index) &
                 LCOMP(xAEG$TargetUNTName$C,xUNT2$Name$C)!=0) NEXT #jb 2/14/01
             else # match, mark it as being destroyed
                putAEG$TargetUNTDestroyed$I ($yes)
            }
        }
    }
 
 # SAM has exploded, so delete the unit, leave the ADS slot
 putUNT$Status$I ($BeingDeleted$Code)
 
 # decrement the number of SAMs airborne for the launching platform
 UNT3$SAMsAirborne$I = xUNT3$SAMsAirborne$I
 if (UNT3$SAMsAirborne$I > 0)
    {
     UNT3$SAMsAirborne$I = UNT3$SAMsAirborne$I - 1
     putUNT3$SAMsAirborne$i
    }
 
return
end # Eval_SAM_hit

 
Subroutine Eval_SAM_miss(UNT$Pointer,    # receive SAM UNT pointer
                         ADS$Pointer,    # receive ADS pointer
                         probability_of_hit) # receive
########################################################################
#$% Purpose:   Eval_SAM_miss does all the things necessary to register
#$%            that a SAM missed it's target.
#$%
#$% Called By: SAM_hit_or_miss
#$%
#$% Calls:     write_eng_rec
#$%
#$% Tables:    UNT   AML   CMC
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  SMM 5/95 PER #1372 added the decrementing of the number of
#$%            SAMs airborne.
#$%
#$%            Susan Miller - 7/97 (E1587)
#$%            Added platform type to postgame engagement log.
#$%            Changed $no to $miss and -1 to $initial.
#$%
#$%
#$%            Jim Allen - 6/03 (E2346)
#$%            Call engdata before logging engagement
#$%
#$%
########################################################################
BBcommon
encommon
 
integer UNT$Pointer, ADS$Pointer
real    probability_of_hit
 
integer UNT$AssignedTarget$I, UNT$SAMMissedTarget$I, AEG$Pointer
integer UNT$AttackIndx$I, UNT$Status$I, UNT2$Pointer, CMC$Pointer
integer UNT3$Pointer, UNT3$SAMsAirborne$I
literal CSTRIP8
real    range, brng, mburange
 
 UNT2$Pointer$To xUNT$AssignedTarget$I
 CMC$Pointer = xUNT$CMCPntr$I
 
 # get the firing unit index
 UNT3$Pointer$To xUNT$LaunchIndx$I
 
 UNT$AssignedTarget$I = $no
 putUNT$AssignedTarget$I
 
 UNT$AttackIndx$I = $no
 putUNT$AttackIndx$I
 
 UNT$SAMMissedTarget$I = $Yes
 putUNT$SAMMissedTarget$I
 
 UNT$Status$I = $BeingDeleted$Code    # 3/29/94
 putUNT$Status$I
 
 AEG$Pointer$To xADS$AssocAEGIndex$I
 
 if ((log$engage != $no) &              # if engagement log desired
     (probability_of_hit >= 0))
    {
     call engdata (unt$pointer, unt2$pointer) # joa 6/03 (E2346)
     PUTeng$Weapon$c( xCMC$Type$C )        # CM Type
     PUTeng$Result$i( eng$Miss$Code )
     putENG$PlatformType$C (xCMC$Type$C)   # smm 7/97 (E1587)
 
     if (UNT2$Pointer$Valid)        # check for valid assigned target
       {
 
         call RLL2RB( _         #Rhumb line Lat/Lon to Range/Bearing
              xUNT2$TrueLatitude$F,     #latitude of TARGET
              xUNT2$TrueLongitude$F,    #longitude of TARGET
              xUNT2$CosTrueLat$F,       #cos of lat of TARGET
              xUNT3$TrueLatitude$F,     #latitude of firing platform
              xUNT3$TrueLongitude$F,    #longitude of firing platform
              xUNT3$CosTrueLat$F,       #cos of lat of firing platform
              RANGE,       #range (output)
              BRNG)        #bearing (output) Tgt to Interceptor
         PUTeng$Range$f( range )         # range to target
         PUTeng$MBURange$f( MBURange(UNT2$Pointer) ) # get range to MBU
         PUTeng$ResultPh$f( xCMC$ProbHit$F * 100 )
       }
     else
       {
         PUTeng$Target$c   (xADS$TargetUNTName$C)
         PUTeng$Range$f    (-1)
         PUTeng$MBURange$f (-1)
         PUTeng$ResultPh$f (0.0)
       }
 
     call write_eng_rec
     call Log_Run_Time_Termination (UNT$Pointer, CMC$Pointer)
    }
 
 if (ADS$Pointer$Valid)
    { # ADS$Result could have been set if the target was a ghosted
      # unit.  Not sure if we need to change this later or not. SMM 3/22/95
     if (xADS$Result$I == $initial)   # no result has been logged SMM 3/22/95
        putADS$Result$I ($miss)  # a miss
 
     putAEG$SAMAssigned$I ($No)     # deassign
     putAEG$SAMInterceptTime$f (0)
    }
 
 # decrement the number of SAMs airborne for the launching platform  SMM 5/95
 UNT3$SAMsAirborne$I = xUNT3$SAMsAirborne$I                 # PER E1372
 if (UNT3$SAMsAirborne$I > 0)
    {
     UNT3$SAMsAirborne$I = UNT3$SAMsAirborne$I - 1
     putUNT3$SAMsAirborne$i
    }
 
return
end # Eval_SAM_miss

 
Subroutine Find_LCL(UNT$Pointer,    # receive
                    RMT$Pointer,    # receive
                    LCL$Pointer,    # return
                    found_it)       # return
########################################################################
#$% Purpose:   Find_LCL loops through the LCL linked list for the UNT
#$%            and locates the active detection that has a matching
#$%            detectee with the RMT track.  Returns the LCL$Pointer and
#$%            the flag found_it set to yes if found.
#$%
#$% Called By: Fill_AEG_slot
#$%
#$% Tables:    UNT   LCL
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
########################################################################
BBcommon
 
integer UNT$Pointer, RMT$Pointer, LCL$Pointer, found_it
 
integer LCL$NextIndx$I, LCL$DetectionType$I
 
 # get LCL next index
 LCL$NextIndx$I = xUNT$FirstLclIndx$I
 
 # while LCL next index is valid
 while (LCL$NextIndx$I != 0)
   {
    # set LCL index to next pointer
    LCL$Pointer$To LCL$NextIndx$I
    LCL$NextIndx$I = xLCL$NextIndx$I
 
    # if detectee is not target, get next
    if (xLCL$Detectee$I != xRMT$Detectee$I) next
 
    # get detection type
    LCL$DetectionType$I = xLCL$DetectionType$I
 
    # if detection type is not active visual or active non visual, get next
    if (LCL$DetectionType$i != $ActiveVisual$code  &
        LCL$DetectionType$i != $ActiveNonVisual$code) next
    else # found it
        {
         found_it = $yes
         break
        }
   }
 
return
end # Find_LCL

 
Subroutine odefend_unit(UNT$Pointer,  # receive unit to execute the order
                        ILEX)         # receive the order
########################################################################
#$% Purpose:   odefend_unit allows an AEGIS SHC type ship to defend a
#$%            unit other than itself against a/c or missile targets as
#$%            long as it is in the same view.  If the unit to be
#$%            defended is valid and found, loop thru the firing unit's
#$%            AEG list and if the AEG target has not yet been assigned
#$%            change the defended unit to the new unit and let the CPA
#$%            calculations be done in Fill_CPA_info.
#$%
#$% Called By: EXEORD
#$%
#$% Tables:    UNT   SHC
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
########################################################################
BBcommon
 
#                 ILEX[1]              ILEX[2]
# FOR <addressee> DEFEND (with SAMs) <addressee>
 
integer UNT$Pointer
literal ILEX[20]
 
integer SHC$Pointer, UNT$DefendedUNTIndex$I, msglen
integer UNT2$Pointer, unit_found, UNT$FirstAEGIndex$I, AEGindex
integer AEG$Pointer, AEG$DefendedUNTIndex$I
integer SAM_eqlist[5,30], advancedSAMs_found
Character msg[ARB]
literal name, UNT2$Name$C, cstrip8
 
 unit_found = $no
 AdvancedSAMs_found = 0
 
 # prepare the beginning of the message
 msglen = 0
 call smovhn(xUNT$Name$C, $$MaxLit, msg, msglen)
 
 # get the unit's ship characteristics pointer
 SHC$Pointer = xUNT$SHCPntr$I
 # if this is an AEGIS ship, execute this order
 if (xSHC$AEGISType$I == $yes)
    {
     # see if this unit has any advanced SAMs
     call DEQGET(UNT$Pointer,
             $AdvancedSAM$Code,
             AdvancedSAMs_found,     # total num. of advanced SAMs on this unit
             SAM_eqlist)
 
     # if this unit has no advanced SAMs on board, send message and return
     if (AdvancedSAMs_found == 0)
        {
         call smovv(" cannot defend unit, ",msg,msglen)
         call smovhn(ILEX[2], $$MaxLit, msg, msglen)
         call smovv(".  Insufficient SAM inventory.  ",msg,msglen)
         call send_ (xUNT$View$I,0,msglen,msg)
         return
        }
 
     # first get the UNT pointer index for the unit to be defended
     for(UNT2$Pointer$First;still_ok(UNT2);UNT2$Pointer$Next) #search
        {
         UNT2$Name$C = xUNT2$Name$C
         name = UNT2$Name$C
 
         if(name == ILEX[2]) # if unit found
            {
             if (xUNT2$View$I == xUNT$View$I) # if in the same view
                {
                 UNT$DefendedUNTIndex$I = UNT2$Pointer$Index
                 putUNT$DefendedUNTIndex$I
 
                 msglen = 0
                 call smovhn(xUNT$Name$C, $$MaxLit, msg, msglen)
                 call smovv(" is now defending unit, ",msg,msglen)
                 call smovhn(ILEX[2], $$MaxLit, msg, msglen)
                 call smovv(".  ",msg,msglen)
                 call send_ (xUNT$View$I,0,msglen,msg)
 
                 UNT$FirstAEGIndex$I = xUNT$FirstAEGIndex$I
                 for (AEGindex = UNT$FirstAEGIndex$I; AEGindex > 0;)
                    {
                     # set pointer and the next index
                     AEG$Pointer$To AEGindex
                     AEGindex = xAEG$NextIndex$I
 
                     # as long as this AEG target has not been targeted by a SAM
                     if (xAEG$SAMAssigned$I != $yes)
                        {
                         AEG$DefendedUNTIndex$I = UNT$DefendedUNTIndex$I
                         putAEG$DefendedUNTIndex$I
                        }
                    }
 
                 unit_found = $yes
                }
             else # not in the same view
                {
                 call smovv(" cannot defend unit, ",msg,msglen)
                 call smovhn(ILEX[2], $$MaxLit, msg, msglen)
                 call smovv(".  It is not in the same view.  ",msg,msglen)
                 call send_ (xUNT$View$I,0,msglen,msg)
 
                 unit_found = $no
                 break
                }
            }
         else # not a match yet, so keep looking
             next
        }
    }
 else # this is not an AEGIS ship
    {
     call smovv(" is not an AEGIS ship, and cannot alter",msg,msglen)
     call smovv(" it's defended unit.  ",msg,msglen)
     call send_ (xUNT$View$I,0,msglen,msg)
	 return
    }
 
if (unit_found != $yes)
    {
     call smovv(" cannot defend a non-existent unit, ",msg,msglen)
     call smovhn(ILEX[2], $$MaxLit, msg, msglen)
     call smovv(".  ",msg,msglen)
     call send_ (xUNT$View$I,0,msglen,msg)
    }
 
return
end # odefend_unit

 
Subroutine Take_using_SAM(UNT$Pointer,  # receive unit to execute the order
                          iword,        # receive number of words in the order
                          ILEX,         # receive the order
                          ORD$Pointer)  # receive the order number
########################################################################
#$%
#$% Purpose:   Take_using_SAM processes the user entered order to take
#$%            a track using an advanced SAM.  Verifies whether the track
#$%            is valid and sends appropriate messages.
#$%
#$% Called By: OTake    AIRRAD
#$%
#$% Calls:     SAM_equip_loop
#$%            clear_maneuver_all
#$%
#$% Tables:    UNT   ORD   RMT
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller - 6/9/95 (E1414)
#$%            Changed the variable no_room to outcome to handle
#$%            unsuccessful SAM launch as well as no room in the UNT table.
#$%
#$%            Susan Miller - 6/12/95 (E1304)
#$%            Added code to handle if a non AEGIS ship is given a
#$%            TAKE (using) SAM order.  Changed last parameter to TAKE_TRACK
#$%            from ORD$Pointer to has_SAMs. Added if loop to return out
#$%            of this routine if unit has no SAMs.
#$%
#$%            Susan Miller - 7/97 (E1587)
#$%            Removed unused variable SHC$AEGISType$I.  Changed valid_check
#$%            logic from != $yes to == $no since valid_check can have a
#$%            valid value of 2.
#$%
#$%            Jim Allen - 12/97 (E1370)
#$%            Added call to clear_maneuver_all to prevent beamings and
#$%            added order id to the take_track call.
#$%
#$%            Susan Miller - 4/99 (E1969)
#$%            Added code to handle occurrences when ORD$Pointer is sent
#$%            in as 0 (done when unit has been given a TAKE using SAM
#$%            order and is still trying to kill the track), this causes
#$%            this routine to be called from AIRRAD.  Added saving
#$%            the assigned target so it can continue to be prosecuted.
########################################################################
BBcommon
 
integer UNT$Pointer, iword, ORD$Pointer
literal ILEX[20]
 
integer nuclear, use_guns, RMT$Pointer, valid_track, advancedSAMs_found
integer len, SAM_eqlist[5,30], save_length, index, num_of_tgts
integer tgt_list[6,400], outcome, SHC$Pointer, found_it
Character msg[ARB]
literal Cstrip8
integer has_sams, DEQ$Pointer
integer RMT$Detectee$I, UNT$AssignedTarget$I, UNT$TakeUsingSAM$I    # SMM 4/99 (E1969)
integer ORD$Id$I    # SMM 4/99 (E1969)
 
 #ilex[1]  ilex[2]        ilex[3]
 # TAKE <track-no> (using) SAM
 
 # SAM_eqlist[1,nfound] = DEQ$Pointer$index  # save index of equipment
 # SAM_eqlist[2,nfound] = Xdeq$pntr$i        #   equipment pointer
 # SAM_eqlist[3,nfound] = deq$remaining$i    #   equipment count
 # SAM_eqlist[4,n] = MAX(1,CMC$SamMaxRange$I) # save the max range later
 # SAM_eqlist[5,n] = xCMC$SAMSimul$I   # simul. in flight and guided later
 
 advancedSAMs_found = 0
 nuclear = $no
 use_guns = $no
 valid_track = 2 # send a 2 to indicate this is a take command
 num_of_tgts = 0
 found_it = 0
 outcome = 0
 has_sams = $no
 
 # set up error message
 len = 0
 call smovv  ("SAM not fired at ", msg, len)
 call smovhn (ilex[2], $$MaxLit, msg, len)
 
 SHC$Pointer = xUNT$SHCPntr$I
 
 # E1304 - if this is not an AEGIS ship, execute this order if there
 # is any other type of SAM on board, else cancel order.  SMM 4/19/95
 if (xSHC$AEGISType$I != $yes)
    {
     for_DEQ_chain (UNT$Pointer$Index)
        { # does this unit have any sams?
         if ((xDEQ$Ident$I == $SAM$Code) & (xDEQ$Remaining$I > 0))
            {
             has_sams = $yes    # yes it does have sams
             break
            }
        }
     if (has_sams != $yes)  # no sams found
        {
         call smovv  (".  ", msg, len)
         call smovhn (xUNT$Name$C, $$MaxLit, msg, len)
         call smovv  (" does not have any SAMs.  ", msg, len)
         call send_  (xUNT$View$I, 0, len, msg)
 
         if (ord$pointer != 0) # clear the order
             putord$Phase$i (0)
         return
        }
    }  # end of if not an AEGIS ship (specified in build)
 else   # if (xSHC$AEGISType$I == $yes)
    {
     call DEQGET (UNT$Pointer, $AdvancedSAM$Code, AdvancedSAMs_found, SAM_eqlist)
 
     # sort equipment list by increasing range
     call sort_eqlist (SAM_eqlist, AdvancedSAMs_found, 4)
 
     # if this unit has no advanced SAMs on board, send message and return
     if (AdvancedSAMs_found == 0)
        {
         for_DEQ_chain (UNT$Pointer$Index)
            { # does this unit have any sams?
             if ((xDEQ$Ident$I == $SAM$Code) & (xDEQ$Remaining$I > 0))
                {
                 has_sams = $yes    # yes it does have sams
                 break
                }
            }
         if (has_sams == $no)
            {
             call smovv (".  Insufficient SAM inventory.  ", msg, len)
             call send_  (xUNT$View$I, 0, len, msg)
             return
            }    # end of if platform has no regular SAMs
        }     # end of if platform has no Advanced SAMs
    }      # end of if it is an aegis type ship
 
 if (ORD$Pointer == 0) # SMM 4/99 (E1969)
         ORD$Id$I = 0
 else    ORD$Id$I = xORD$Id$I
 
 # validates the track by checking the RMT table but doesn't fire a SAM
 call Take_Track(UNT$Pointer,  # send detecting UNT
                 xORD$Id$I,    # send order id
                 ILEX,         # send order
                 nuclear,      # send whether missile is nuclear
                 use_guns,     # send whether to use guns
                 RMT$Pointer,  # receive the target RMT pointer
                 valid_track,  # send 2 to indicate a TAKE command and receive
                               # $no if error message sent or $yes, not sent
                 iword,        # receive number of words in the order
                 has_SAMs)     # yes or no, SMM 6/95 PER #E1304
 
 # if valid_track is returned as $no, then a non-valid track message
 # was sent from Take_Track and so order is canceled.
 if (valid_track == $no) return     # SMM 7/97 (E1587)
 
 # if has_sams is yes, then we aren't firing an explicit SAM but we are
 # firing any other SAM that may have been found on the unit, so do that
 # here and then return since we don't want to mess with the AEG table.
 if (has_sams != $no)
    {
     return        # E1304 SMM 6/95
    }
 
 save_length = len
 # if we are here, track has passed validity checks, now do SAM specific checks
 # get the units first AEG index and loop through list until match is found
 call AEG_loop_search(UNT$Pointer,  # send detecting UNT pointer
                      RMT$Pointer,  # send track RMT pointer
                      SAM_eqlist,   # send SAM equipment list
                      advancedSAMs_found, # send number of advanced SAMs found
                      msg, len,     # send/receive error message and length
                      tgt_list,     # receive target list
                      num_of_tgts,  # receive number of targets
                      ORD$Pointer)  # send SMM 4/99 (E1969)
 # if the length of the message returned from AEG_loop_search is
 # greater than when it went in, a check has not passed, so send the
 # message and don't fire a SAM
 if (len > save_length)
    {
     call send_ (xUNT$View$I,0,len,msg)
     return
    }
 
 if (num_of_tgts == 0)
    {
     if (ORD$Pointer != 0) # SMM 4/99 (E1969)
        {
         call smovv(".  No local track.  ",msg,len)
         call send_ (xUNT$View$I,0,len,msg)
        }
     return
    }
 else # fire a SAM at the assigned target
    {
     if (ORD$Pointer != 0) # SMM 4/99 (E1969)
         call clear_maneuver_all (xORD$Code$I, xORD$Id$I, xUNT$View$I, UNT$Pointer)
 
     # save the assigned track SMM 4/99 (E1969)
     RMT$Detectee$I = xRMT$Detectee$I
     UNT$AssignedTarget$I = RMT$Detectee$I
     putUNT$AssignedTarget$I
     UNT$TakeUsingSAM$I = $yes
     putUNT$TakeUsingSAM$I
 
     # loop through the targets
     for (index=1; index <= num_of_tgts; index=index+1)
        {
         # loop through the advanced SAM inventory
         call SAM_equip_loop(index,      # send target index
                             tgt_list,   # send list of targets
                             SAM_eqlist, # send list of SAMs
                             AdvancedSAMs_found, # send num of SAMs found
                             UNT$Pointer,# send firing UNT pointer
                             outcome)    # receive flag if space in UNT
 
         # SMM #E1414 6/95
         if (outcome != $noroom)   # reset outcome if it is
           outcome = 0             # not set to $noroom
         else                      # otherwise the UNT table is full
           break
        }   # end of loop through the platform's targets
    }
 
return
end # Take_using_SAM

 
Subroutine AEG_loop_search(UNT$Pointer,      # receive firing unit's UNT pointer
                           RMT$Pointer,      # receive the RMT pointer of target
                           SAM_eqlist,       # receive list of SAMs on UNT
                           advancedSAMs_found, # receive number of SAMs found
                           msg, len,         # rec. the message and it's length
                           tgt_list,         # return target list
                           num_of_tgts,      # return the number of targets
                           ORD$Pointer)      # receive
########################################################################
#$% Purpose:   AEG_loop_search loops thru the firing units AEG list looking
#$%            for a match to the RMT track.  If match is found, check
#$%            for max simultaneous SAMs in the air, SAM has a large enough
#$%            range and altitude for this target.  If all the criteria
#$%            has been met, fill the array tgt_list with the vital
#$%            information about the target.
#$%
#$% Called By: Take_using_SAM
#$%
#$% Calls:     SMOV...   RLL2RB
#$%
#$% Tables:    UNT   AEG   RMT   CMC
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  Susan Miller 4/99 (E1969)
#$%            Added parameter ORD$Pointer so we know whether this is
#$%            a current order or is a re-engagement.
########################################################################
BBcommon
 
integer UNT$Pointer, RMT$Pointer, advancedSAMs_found, SAM_eqlist[5,30]
integer tgt_list[6,400], len, num_of_tgts
Character msg[ARB]
integer ORD$Pointer # SMM 4/99 (E1969)
 
integer AEGindex, AEG$Pointer, CMC$Pointer, CMC$SamMaxRange$I
integer AEG$NumberInFlight$I, UNT$FirstAEGIndex$I, target_alt
integer index, CMC$BND$Index
integer CMC$NbrofAltBands$I, max_altitude, CMC$BND$Altitude$I, max_range
real    RMT$ApparentLat$F, UNT$TrueLatitude$F, target_range, target_bearing
 
 UNT$FirstAEGIndex$I = xUNT$FirstAEGIndex$I
 for (AEGindex = UNT$FirstAEGIndex$I; AEGindex > 0;)
    {
     # set pointer and the next index
     AEG$Pointer$To AEGindex
     AEGindex = xAEG$NextIndex$I
 
     # if this index matches the index associated with the RMT track
     # and it is already assigned, send a message
     if ((xAEG$RMTPointerIndex$I == RMT$Pointer$Index) &
         (xAEG$TargetUNTIndex$i == xRMT$Detectee$I))
        {
         if (xAEG$SAMAssigned$I == $yes)
            {
             if (ORD$Pointer != 0)  # SMM 4/99 (E1969)
                 call smovv(".  Already being engaged.  ",msg,len)
             return
            }
         else # found the target and it is not being engaged by another SAM
            {
             for (index = 1; index <= AdvancedSAMs_found; index = index + 1)
                {
                 CMC$Pointer = SAM_eqlist[2,index]       # get CMC pointer
                 CMC$SamMaxRange$I = xCMC$SamMaxRange$I    # get range
                 SAM_eqlist[4,index] = MAX(1,CMC$SamMaxRange$I) # save the max range
                 SAM_eqlist[5,index] = xCMC$SAMSimul$I # simul. in flight and guided
 
                 # if the firing unit has the max allowed SAMs in the air
                 if (xUNT$SAMsAirborne$I >= SAM_eqlist[5,index])
                    {
                     if ((AdvancedSAMs_found > 1) &
                         (index < AdvancedSAMs_found)) next
                     else
                        {
                         call smovv(".  Engagement limit currently maximum.  ",
                                    msg,len)
                         return
                        }
                    }
 
                 # get the target altitude and get the altitude band
                 target_alt = xRMT$Altitude$I * 100
                 CMC$NbrofAltBands$I = xCMC$NbrofAltBands$I
                 if (CMC$NbrofAltBands$I > 0)
                    {
                     for (CMC$BND$Index = CMC$NbrofAltBands$I;
                          CMC$BND$Index > 0;                     # loop through
                          CMC$BND$Index = CMC$BND$Index - 1)     # alt. bands
                        {
                         CMC$BND$Altitude$I = xCMC$BND$Altitude$I
                         if (target_alt < CMC$BND$Altitude$I)
                            {
                             max_altitude = CMC$BND$Altitude$I
                             max_range = xCMC$BND$MaxRange$I
                            }
                        }
                    } # end if this SAM has defined altitude bands
                 else
                    {
                     max_altitude = xCMC$SAMMaxAlt$I
                     max_range = xCMC$SamMaxRange$I
                    }
 
                 # need to double check the range since this RMT
                 # track could be held by another unit in which
                 # case the range could be completely wrong.
                 RMT$ApparentLat$F = xRMT$ApparentLat$F
                 UNT$TrueLatitude$F = xUNT$TrueLatitude$F
                 call RLL2RB (RMT$ApparentLat$F,    # lat of target
                              xRMT$ApparentLon$F,   # lon of target
                              COS(RMT$ApparentLat$F), # cos lat of target
                              xUNT$TrueLatitude$F,  # lat of firing unit
                              xUNT$TrueLongitude$F, # lon of firing unit
                              COS(UNT$TrueLatitude$F), # cos lat of firing unit
                              target_range,         # return range to target
                              target_bearing)       # return bearing to target
 
                 # if the target is beyond the range of the SAM
                 if (INT(target_range) > max_range)
                    {
                     if ((AdvancedSAMs_found > 1) &
                         (index < AdvancedSAMs_found)) next
                     else
                        {
                         call smovv(".  Track intercept beyond range.  ",
                                    msg,len)
                         return
                        }
                    }
 
                 if (target_alt > max_altitude)
                    {
                     if ((AdvancedSAMs_found > 1) &
                         (index < AdvancedSAMs_found)) next
                     else
                        {
                         call smovv(".  Altitude limits exceeded.  ",msg,len)
                         return
                        }
                    }
                } # loop thru number of advanced SAMs on board
 
             # if we are here, the target must be good
             # get the number of targets in flight
             AEG$NumberInFlight$I = xAEG$NumberInFlight$I
 
             # fill in the tgt_list information for each target
             for (num_of_tgts = 1;
                  num_of_tgts <= AEG$NumberInFlight$I;
                  num_of_tgts = num_of_tgts + 1)
                {
                 # fill in target list information
                 tgt_list[1,num_of_tgts] = AEG$Pointer
                 tgt_list[2,num_of_tgts] = xAEG$CPADistance$I
                 tgt_list[3,num_of_tgts] = xAEG$CPATime$f
                 tgt_list[4,num_of_tgts] = xAEG$AircraftFlag$I # yes if A/C
                 tgt_list[5,num_of_tgts] = target_alt
                }
             num_of_tgts = num_of_tgts - 1 # reduce last increment
            } # target not assigned by other SAMs
        } # AEG match
    } # loop thru UNT's AEG list
 
return
end # AEG_loop_search

 
Subroutine SAM_equip_loop(index,      # receive target index
                          tgt_list,   # receive list of targets
                          SAM_eqlist, # receive list of SAMs
                          AdvancedSAMs_found, # receive num of SAMs found
                          UNT$Pointer,# receive firing UNT pointer
                          outcome)    # return flag if space in UNT
########################################################################
#$%
#$% Purpose:   SAM_equip_loop loops through the SAM equipment looking for
#$%            the best SAM to fire at each target in the list.
#$%
#$% Called By: SAM_assignment
#$%
#$% Calls:     Fire_adv_SAM   Find_ADS_Slot
#$%
#$% Tables:    UNT   CMC   DEQ
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
#$%
#$% Modified:  SMM 5/95 PER #1372 added a check so max simul is not exceeded
#$%
#$%            Susan Miller - 6/9/95 (E1414)
#$%            Changed the variable no_room to outcome to handle
#$%            unsuccessful launches and no room in the UNT table.
#$%
#$%            Susan Miller - 7/97 (E1430)
#$%            Send a message when all advanced SAMs are expended.
#$%
#$%            Susan Miller - 7/97 (E1587)
#$%            Added parameters, SAM_eqlist and SAM_index, to Fire_adv_SAM
#$%            call.  Added check for successful launch prior to call to
#$%            Find_ADS_Slot.
#$%
#$%            Susan Miller - 3/99 (E1968)
#$%            Removed multiple incrementing of UNT$SAMsAirborne$i so that
#$%            the proper number of SAMs could be launched.
#$%
########################################################################
BBcommon
 
integer index, tgt_list[6,400], SAM_eqlist[5,30], AdvancedSAMs_found
integer UNT$Pointer, outcome
 
integer SAM_index, CMC$Pointer, CMC$SAMMaxAlt$I, CMC$BND$Altitude$I
integer tgt_index, UNT2$Pointer, DEQ$Pointer, DEQ$Remaining$I
integer UNT$SAMsAirborne$I, AEG$Pointer, LCL$Pointer, track_range
integer RMT$Pointer, target_alt, CMC$BND$Index, max_altitude, max_range
integer CMC$NbrofAltBands$I, CPA_distance
integer msglen
character msg[ARB]
literal cstrip8
 
 target_alt = tgt_list[5,index]
 CPA_distance = tgt_list[2,index]
 
 for (SAM_index=1; SAM_index <= AdvancedSAMs_found; SAM_index=SAM_index+1)
    {
     if (SAM_eqlist[3,Sam_index] <= 0) next    # out of stock, get next one
 
     # get the SAM characteristic pointer
     CMC$Pointer = SAM_eqlist[2,SAM_index]
     CMC$SAMMaxAlt$I = xCMC$SAMMaxAlt$I
 
     if (xUNT$SAMsAirborne$I >= xCMC$SAMSimul$I)     # SMM 5/19/95 PER #1372
        return
 
     CMC$NbrofAltBands$I = xCMC$NbrofAltBands$I
     if (CMC$NbrofAltBands$I > 0)
        {
         for (CMC$BND$Index = CMC$NbrofAltBands$I;
              CMC$BND$Index > 0;                     # loop through
              CMC$BND$Index = CMC$BND$Index - 1)     # alt. bands
            {
             CMC$BND$Altitude$I = xCMC$BND$Altitude$I
             if (target_alt <= CMC$BND$Altitude$I)
                {
                 max_altitude = CMC$BND$Altitude$I
                 max_range = xCMC$BND$MaxRange$I
                }
            }
        } # end if this SAM has defined altitude bands
     else
        {
         max_altitude = CMC$SAMMaxAlt$I
         max_range = SAM_eqlist[4,SAM_index]
        }
 
     # if the CPA distance of the target is less than or equal to
     # this SAM range at target altitude, use this one as long as
     # there are some in stock.
     if ((CPA_distance <= max_range) &
         (SAM_eqlist[3,SAM_index] != 0))
        {
         # if the CPAdistance is 0, check the range of the track
         if (CPA_distance == 0)
            {
             track_range = 0   # initialize to zero
             AEG$Pointer = tgt_list[1,index]
             LCL$Pointer$To xAEG$LCLPntrIndex$I
             if (LCL$Pointer != 0)
                track_range = INT(xLCL$Range$F)
             else
                {
                 RMT$Pointer$To xAEG$RMTPointerIndex$I
                 if (RMT$Pointer != 0)  track_range = INT(xRMT$Range$F)
                }
             # if the track range is greater than this missile range,
             # check the next missile in the list
             if (track_range > max_range) next
             # else go ahead and continue to process with this missile
            }
 
         # check to see whether this missile can attain the
         # altitude of the target, if so, fire a missile
         if (target_alt <= max_altitude)
            {
             tgt_index = index
             call Fire_adv_SAM(UNT$Pointer,  # send firing unit pointer
                               CMC$Pointer,  # send SAM characteristic pointer
                               outcome,      # receive no room flag
                               tgt_list,     # send list of targets
                               tgt_index,    # send target index
                               UNT2$Pointer, # receive SAM UNT pointer
                               SAM_eqlist,   # send eqlist array        3/97
                               SAM_index)    # send index of SAM fired  3/97
             # if the UNT table is full right now, return
             if (outcome == $noroom) return
             else
                {# decrement the number of remaining SAMs
                 DEQ$Pointer$To (SAM_eqlist[1,SAM_index])
                 DEQ$Remaining$I = xDEQ$Remaining$I
                 if (DEQ$Remaining$I != 0)
                    {
                     DEQ$Remaining$I = xDEQ$Remaining$I - 1
                     putDEQ$Remaining$I
 
                     if (DEQ$Remaining$I == 0)  # notify unit if it has
                        {                       # no more adv sams - smm 7/97 (E1430)
                         CMC$Pointer = xDEQ$Pntr$I
 
                         msglen = 0
                         call smovhn (xUNT$Name$C, $$MaxLit, msg, msglen)
                         call smovv  (" has expended all " ,msg, msglen)
                         call smovhn (xCMC$Type$C, $$MaxLit, msg, msglen)
                         call smovv  (" SAMs.  " ,msg, msglen)
                         call smov   ($bell, msg, msglen)
                         call smov   ($bell, msg, msglen)
                         call send_  (xUNT$View$I,0,msglen,msg)
                       }   # end of if out of munitions
                    }
 
                 # decrement here too!! SMM 6/95 E1414
                 if (SAM_eqlist[3,Sam_index] != 0)
                     SAM_eqlist[3,Sam_index] = SAM_eqlist[3,Sam_index] - 1
 
                 if (outcome != $unsuccessful)  # SMM #E1414 6/95
                    {
                     # increment the number of SAMs airborne
                     UNT$SAMsAirborne$i = xUNT$SAMsAirborne$i + 1
                     putUNT$SAMsAirborne$i
                    }
                }
             if (outcome != $unsuccessful)  # SMM 7/97 (E1587)
                {
                 # make sure the DEQ pointer is set correctly  SMM 3/97
                 DEQ$Pointer$To (SAM_eqlist[1,SAM_index])
                 call Find_ADS_Slot(UNT$Pointer,  # send firing UNT pointer
                                    UNT2$Pointer, # send SAM UNT pointer
                                    CMC$Pointer,  # send SAM characteristic pointer
                                    DEQ$Pointer,  # send SAM DEQ pointer
                                    tgt_list,     # send target list
                                    index,        # send target index number
                                    outcome)      # send outcome
                }
             return
            }
         # target too high for this missile, try another missile
         else
            {
             # if this is the last SAM, then we don't have a SAM
             # with the Altitude range
             if (SAM_index == AdvancedSAMs_found)
                {
                if (trace$engage$exe != $no)
                   {
                     call echor
                     call echov(" No SAM with the required altitude range")
                     call echov(" for this target.  ")
                     call echor
                   }
                }
             # there are more SAMs to check
             else next
            } # end else the target is too high for this missile
        } # end of target within SAM range
    } # end of for loop through number of advanced SAMs
 
return
end # SAM_equip_loop

 
Subroutine ADS_loop_search(UNT$Pointer,ADS$Pointer)
########################################################################
#$% Purpose:   ADS_loop_search searches this views ADS list looking for
#$%            a UNT name match to the SAM name
#$%
#$% Called By: Compute_SAM_Alt   Check_SAM_Range
#$%
#$% Tables:    UNT   ADS   VUE
#$%
#$% Date:      Feb 1994
#$%
#$% Author:    Susan Miller
########################################################################
BBcommon
 
integer UNT$Pointer, ADS$Pointer
Integer LCOMP           # jb AAI01/LCOMP    2/14/01
integer VUE$Pointer, UNT$View$I, VUE$FirstADSIndex$I, ADSindex
literal Cstrip8
 
 # get the view of the SAM
 UNT$View$I = xUNT$View$I
 VUE$Pointer$To UNT$View$I
 VUE$FirstADSIndex$I = xVUE$FirstADSIndex$I
 
 # if this view has no ADS slots filled, return
 if (VUE$FirstADSIndex$I == 0)
    return
 else # look thru list for the SAM
    {
     for (ADSindex = VUE$FirstADSIndex$I; ADSindex > 0;)
        {
         # set pointer and the next index
         ADS$Pointer$To ADSindex
 
         # if this slot is a match, break out of the loop
         if (LCOMP(xADS$SAMUNTName$C,xUNT$Name$C)==0) # jb AAI01/LCOMP 2/14/01
             break
         # else get the next index in the linked list
         else
            {
             ADSindex = xADS$NextIndex$I
             ADS$Pointer = 0
             # if this is the end of the linked list, get out
             if (ADSindex == 0) break
            }
        }
    }
 
return
end # ADS_loop_search

 
Subroutine Find_SAM_Range(SAM_eqlist,   # receive list of SAMs
                          AdvancedSAMs_found, # receive num of SAMs found
                          target_alt,   # receive target altitude
                          max_range,    # return max SAM range
                          max_altitude, # return max SAM altitude
                          this_SAM,     # return flag for SAM
                          max_speed,    # return the SAM speed
                          fire_index,   # return index of SAM to fire
                          max_simul)    # return the number of simul SAMs in flt
########################################################################
#$% Purpose:   Find_SAM_range loops through the list of SAMs for the firing
#$%            unit looking for the altitude band in which the target is
#$%            flying and returns the max range for that SAM at that altitude.
#$%
#$% Called By: Check_the_range
#$%
#$% Tables:    CMC
#$%
#$% Date:      Mar. 1994
#$%
#$% Author:    Susan Miller
########################################################################
BBcommon
 
integer SAM_eqlist[5,30], AdvancedSAMs_found, target_alt, max_range
integer max_altitude, this_SAM, max_speed, fire_index, max_simul
 
integer CMC$Pointer, SAM_index, CMC$SAMMaxAlt$I, CMC$NbrofAltBands$I
integer CMC$BND$Index, CMC$BND$Altitude$I, CMC$BND$MaxRange$I, CMC$AvgSpeed$I
integer CMC$SAMSimul$I
 
 max_altitude = 0
 max_range = 0
 this_SAM = $no
 max_speed = 0
 fire_index = 0
 max_simul = 0
 
 # loop through list of SAMs and find the greatest range for this altitude
 for (SAM_index=1; SAM_index <= AdvancedSAMs_found; SAM_index=SAM_index+1)
    {
     if (SAM_eqlist[3,Sam_index] <= 0) # out of stock, get next one
        next
 
     # get the SAM characteristic pointer
     CMC$Pointer = SAM_eqlist[2,SAM_index]
     CMC$SAMMaxAlt$I = xCMC$SAMMaxAlt$I
     CMC$AvgSpeed$I = xCMC$AvgSpeed$I
     CMC$NbrofAltBands$I = xCMC$NbrofAltBands$I
     CMC$SAMSimul$I  = xCMC$SAMSimul$I
 
     if (target_alt > CMC$SAMMaxAlt$I)
        {
         this_SAM = $no
         next
        }
     else
        {
         if ((target_alt <= CMC$SAMMaxAlt$I) &
             (max_range < SAM_eqlist[4,SAM_index]) &
             (CMC$NbrofAltBands$I == 0))
            {
             max_altitude = CMC$SAMMaxAlt$I
             max_speed = CMC$AvgSpeed$I
             max_range = SAM_eqlist[4,SAM_index]
             this_SAM = $yes
             fire_index = SAM_index
             if (max_simul < CMC$SAMSimul$I) max_simul = CMC$SAMSimul$I
            }
        }
 
     if (CMC$NbrofAltBands$I > 0)
        {
         for (CMC$BND$Index = CMC$NbrofAltBands$I;   # loop through
              CMC$BND$Index > 0;                     # alt. bands in
              CMC$BND$Index = CMC$BND$Index - 1)     # reverse
            {
             CMC$BND$Altitude$I = xCMC$BND$Altitude$I
             CMC$BND$MaxRange$I = xCMC$BND$MaxRange$I
             if (target_alt <= CMC$BND$Altitude$I)
                {
                 max_altitude = CMC$BND$Altitude$I
                 max_range = CMC$BND$MaxRange$I
                 max_speed = CMC$AvgSpeed$I
                 this_SAM = $yes
                 fire_index = SAM_index
                 if (max_simul < CMC$SAMSimul$I) max_simul = CMC$SAMSimul$I
                }
            }
        } # end if this SAM has defined altitude bands
    } # loop through the list of SAMs
 
return
end # find_SAM_range
