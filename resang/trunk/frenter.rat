 
######################################################################
#$%
#$% Information on the programs and subroutines located in FRENTER.RAT
#$% along with those that are called is provided in DOC.WHO.
#$%
#$% Flowcharts illustrating the interrelationships of the programs
#$% and subprograms for this program are contained in FRMAIN.HIR
#$%
######################################################################
 
 
#####   version 3.1  dated-  7apr81
 
#####   version 3.0  dated- 22dec80
 
define ($DEBUG,$DEBUGE)
 
include "bbcode.inc"
include "plplay.inc"
include "frmain.inc"              # jb FRMAIN.inc includes MACROS.inc 2/3/00
include "ascii.inc"
 
define (ForceImplicit, Implicit None)                  # MJC 6/9/2K (E2145)
subroutine fecomm (nargs,args)
 
###############################################################
#$%
#$% Purpose:   FECOMM processes communication pathway data.
#$%
#$% Called By: FRENTER
#$%
#$% Calls:     ECHOH      ECHOI      FINSEO
#$%            FSUSE      ECHOR      FINTPT
#$%            FVOTHR     FCUSE
#$%
#$% Tables:    NODE       PATH
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
###############################################################
 
ForceCommon
integer KNODE,
        KPATH,
        K,
        IPNT,
        IINC,
        I                                               # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],name,cat
literal cat0 / 0 /
 
#$% initialize error count
errcnt = 0
 
#$% get commpath name
name = args[3]
#$% get node index
node$index = args[4]
 
#$% if node index is not within limits
if (node$index < 1 | node$index > 8)
   {
    #$% display warning message to user and return
    call echov ("Node numbers must be between 1 and 8.")
    call echor
    return
   }
 
#$% set path index to zero
path$index = 0
 
#$% for each path entered
for (k=1; k<=npaths; k=k+1)
   {
    #$% if path not found, get next
    if (wrpaths[1,1,k] != name) next
    #$% if found, set path index
    path$index = k
    break
   }
 
#$% if path not found after going through all npaths
if (path$index == 0)
   {
    #$% if reason not found is that maximum allowed paths are exceeded
    if (npaths >= $paths)
       {
        #$% display error message and return
        call echoi ($paths)
        call echov (" paths are entered and that is the maximum allowed.")
        call echor
        call echov ("This path cannot be entered.")
        call echor
        return
       }
    #$% increment path index to account for new path input
    path$index = npaths + 1
    #$% update number of paths in use
    npaths = path$index
 
    call fintpt (path$index,1,2)        # initialize path values nodes 1-8
 
    #$% save path name
    path$name= name
   }
 
#$% if relay nodes are entered
if (node$index > path$nodes)
   {
    #$% initialize path index
    call fintpt (path$index,path$nodes+1,node$index)
    #$% set path nodes to equal the number of relay nodes entered
    path$nodes = node$index
   }
 
#$% for each commpath entry starting with 5th postition to
#$% accomodate five values entered in previous node basic inputs ie.
#$% name, node #, mu, rho, pair.
for (ipnt = 5; ipnt <= nargs; ipnt = ipnt + iinc)
   {
    #$% increment by one for next array position
    iinc = 1
    #$% if there is a category entered
    if      (args[ipnt] == $lex$category$)
       {
        #$% allow for three positions in array (name, node, category)
        iinc = 3
        #$% if last node of path
        if (node$index == path$nodes)
           {
            #$% display reminder to user
            call echov ("Category does not apply to the")
            call echov (" last node of the path (Reminder only).")
            call echor
           }
        #$% get compath name
        name = args[ipnt+2]
 
        #$% if category is air
        if (args[ipnt+1] == $lex$air$)
           {
            #$% get air and allow for ASCII name
            cat = 'AIR'
            name = $BLANKLIT
            #$% allow two more array positions
            iinc = 2
           }
 
        #$% else if category is buoy
        else if (args[ipnt+1] == $lex$BUOY$)
           {
            #$% get buoy
            cat = 'BUOY'
           }
 
	#$% else if category is ground unit              #JFR  5/9/91
	else if (args[ipnt+1] == $lex$GROUND$)           #JFR  5/9/91
	   {                                             #JFR  5/9/91
	    #$% get groundunit                           #JFR  5/9/91
	    cat = 'UNIT'                                #JFR  5/9/91
            name = $BLANKLIT
            #$% allow two more array positions       # JFR 12/5/91
            iinc = 2                                 # JFR 12/5/91
	   }                                             #JFR  5/9/91
 
        #$% else if category is shore
        else if (args[ipnt+1] == $lex$SHORE$)
           {
            #$% get shore
            cat = 'SHORE'
           }
 
        #$% else if category is ship
        else if (args[ipnt+1] == $lex$SHIP$)
           {
            #$% get ship and allow for ASCII name
            cat = 'SHIP'
            name = $BLANKLIT
            #$% allow two more array positions
            iinc = 2
           }
 
        #$% if first node of path
        if (node$index == 1)
           {
            #$% display warning message to user and get next node
            call echov ("Category and Class do not apply to the")
            call echov (" first node of the path.")
            call echor
            next
           }
 
        #$% save category (air, buoy, ship or shore) and name (buoy
        #$% name or shore name)
        path$cat   = cat
        path$class = name
       }
 
    #$% else if next entry not a category but is MU
    else if (args[ipnt] == $lex$MU$)
       {
        #$% allow two more array positions
        iinc = 2
        #$% get MU
        path$mu = args[ipnt+1]
       }
 
    #$% else if category is RHO
    else if (args[ipnt] == $lex$RHO$)
       {
        #$% allow two more array positions
        iinc = 2
        #$% get rho
        path$rho = args[ipnt+1]
       }
 
    #$% else if category is pair
    else if (args[ipnt] == $lex$PAIR$)
       {
        #$% allow two more array positions
        iinc = 2
        #$% get pair name
        name = args[ipnt+1]
 
        #$% if last node and at least two nodes have been entered
        if (name == 'END' & node$index > 1) # jb E3141  12/13/99
           {
            #$% save the node number
            wipaths[$halfquad,2,1,path$index] = node$index
           }
        #$% else if not last node
        else
           {
            #$% set error count flag
            i = errcnt
            #$% find equipment in compair - if not found errcnt is incremented
            #$% by one in subroutine fgerr2
            call finseq (ncommp,wrcommp,$commpair,name,cat0,"Commpair  ")
 
            #$% if equipment found
            if (i == errcnt)
                #$% verify if equipment is in the BUILD File
                call FVothr (build$name,$litc,commp$file,ncommp,wrcommp,"Commpair  ")
 
            #$% if equipment not found, get next path pair
            if (i != errcnt) next
           }
 
        #$% set path pair
        path$pair = name
       }
 
    #$% else if user input is YES or NO (response to ROGER?)
    else if (args[ipnt] == $lex$NO$ | args[ipnt] == $lex$YES$)
       {
        #$% allow one more array position
        iinc = 1
        #$% if first node
        if (node$index == 1)
           {
            #$% send message
            call echov ("The Roger flag does not apply to the")
            call echov (" first node of the path.")
            call echor
            #$% get next
            next
           }
 
        #$% if yes, set path roger flag to YES
        if (args[ipnt] == $lex$YES$) path$roger = $yes
        #$% else, set path roger flag to NO
        else                         path$roger = $no
       }
 
   }
 
#$% if verified, save equipment
if (errcnt == 0) call FSuse             # save eq
#$% else if not verified
else
     {
   #$% display warning message to user
   call echov ("Equipment not entered.")
   call echor
   #$% clear in-use flag
   call FCuse                           # clear eq
  }
 
return
end
 

 
 
 
subroutine fintpt (ipath,ilo,ihi)
 
########################################################################
#$%
#$% Purpose:   FINTPT initializes path values nodes from low to high.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
########################################################################
 
ForceCommon
integer KPATH,
        IPATH,
        KNODE,
        ILO,
        IHI                                         # MJC 6/9/2K (E2145)
 
#$% initialize path values nodes
#    call fintpt (path$index,path$nodes,node$index)
 
#$% save path index
path$index = ipath
 
#$% for each path values nodes from low to high
for (node$index = ilo; node$index <= ihi; node$index=node$index+1)
   {
    #$% if first node
    if (node$index == 1)
       {
        #$% set number of nodes high
        path$nodes = ihi    # set number of nodes
       }
 
    #$% else not first node
    else #(node$index != 1)
       {
        #$% load dashes
        path$pair  = $BLANKLIT # jb E2141  /8-char names 12/13/99
        path$cat   = $BLANKLIT
        path$class = $BLANKLIT # jb E2141  /8-char names 12/13/99
       }
    #$% initialize parameters
    path$mu    = 0
    path$rho   = 0
    path$roger = $no
   }
 
#$% for each node entry
for (node$index = 1; node$index < ilo; node$index=node$index+1)
   {
    #$% if end, set path pair as dashes
    if(path$pair == 'END') path$pair = $BLANKLIT # jb E2141/12/99
   }
 
return
end

 
 
 
subroutine FECkt (nargs,args)
 
###########################################################################
#$%
#$% Purpose:   FECKT processes circuit number of communication pathways.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
###########################################################################
 
ForceCommon
integer MCKT,
        MPATH,
        KPATH                                       # MJC 6/9/2K (E2145)
 
integer nargs,ickt
literal args[$max$args],name
 
#$% set error count to zero
errcnt = 0
 
#$% get circuit number
ickt = args[3]
#$% get circuit name
name = args[4]
 
#$% set circuit flag to indicate it does not now exist
mckt = 0
#$% set path flag to indicate it does not now exist
mpath = 0
 
#$% for each path entry
for (path$index=1; path$index<=npaths; path$index=path$index+1)
   {
    #$% if path name found and does not now exist, set flag to indicate
    #$% that it exists from now on
    if (path$name == name & mpath == 0) mpath = path$index
 
    #$% if circuit number found and does not now exist, set flag to
    #$% indicate that it exists from now on
    if (path$ckt  == ickt  & mckt  == 0) mckt  = path$index
   }
 
#$% if circuit number found and not a duplicate
if (ickt != 0 & mckt != 0)
   {
    #$% display information message to user and return
    call echor
    call echov ("Circuit # ")
    call echoi (ickt)
    call echov (" is assigned to path ")
    path$index = mckt
    call echohN (path$name,$$MAXname) # jb E2141/8-char's 12/13/99
    call echor
    return
   }
 
#$% if path does not now exist
if (mpath == 0)
   {
    #$% display warning message to user and return
    call echor
    call echov ("Path ")
    call echohn (name,$$MAXname)    # jb E2141/8-char's 12/13/99
    call echov (" does not exist.")
    call echor
    return
   }
 
#$% save path index
path$index = mpath
 
#$% save circuit number
path$ckt = ickt
 
#$% display message to user that data has been entered ok
call echov (" OK")
call echor
 
return
end

 
 
 
 
subroutine fememb (nargs,args)
 
#########################################################################
#$%
#$% Purpose:   FEMEMB processes communications membership matrix from
#$%            user input.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#########################################################################
 
ForceCommon
integer ISTAT,
        KFORCE,
        KORG,
        KAIR,
        KCLASS,
        IPNT,
        KPATH,
        KMEMBR,
        KMEMNM                                      # MJC 6/9/2K (E2145)
integer nargs, lcomp_v
literal args[$max$args],path,name
 
#$% get name of new commpath member
name = args[3]
#$% initialize status flag
istat = $no
 
#$% for each force entered
for (force$index = 1; force$index <= nforce; force$index = force$index + 1)
   {
    #$% if force name not found, get next
    if (name != force$name) next
    #$% when force name found,set status flag to YES and break
    istat = $yes
    break
   }
 
#$% if org name not found - check organizations -- JFR 6/3/91
if (istat == $no)
   {
   #$% for each org entered
   for (org$index = 1; org$index <= norg; org$index = org$index + 1)
       {
        #$% if org name not found, get next
        if (name != org$name) next
        #$% when org name found,set status flag to YES and break
        istat = $yes
        break
       }
   }
 
#$% if force name not found
if (istat == $no)
   {
    #$% search air names
    for (air$index = 1; air$index <= nair; air$index = air$index + 1)
       {
        #$% if not air name, get next
        if (name != air$name) next
        #$% if air name found, set status to YES and break
        istat = $yes
        break
       }
   }
 
#$% if force name not found, added 4/91, reh
if (istat == $no)
   {
    #$% search Class names
    for (Class$index = 1; Class$index <= nClass; Class$index = Class$index + 1)
        {
        if (lcomp_v(Class$Type, "BOAT") != 0) next
 
        #$% if not Class name, get next
        if (name != Class$name) next
 
        #$% if (BOAT) Class name found, set status to YES and break
        istat = $yes
        break
        }
    }
 
#$% if name still not found
if (istat == $no)
   {
    #$% display warning message to user and return
    call echov ("That force cannot be found.")
    call echor
    return
   }
 
#$% for each path entry
for (ipnt = 4; ipnt <= nargs; ipnt = ipnt + 1)
   {
    #$% get path
    path = args[ipnt]
    #$% display info message to user
    call echov ("Path ")
    call echoh (path,$$MAXname) # jb E2141/8-char's 12/13/99
    call echor
 
    #$% see if path currently exists
    call FFmem (path,istat)
 
    #$% if path does not exits
    if (istat == $no)
       {                                # no.... (add it)
        #$% set status to NO
        istat = $no
 
        #$% for each path entry
        for (path$index = 1; path$index <= npaths; path$index = path$index+1)
           {
            #$% if not path name, get next
            if (path != path$name) next
            #$% when path name found, set status to YES and break
            istat = $yes
            break
           }
 
        #$% if path cannot be found
        if (istat == $no)
           {
            #$% display message that path cannot be found and get next
            call echov ("That path cannot be found.")
            call echor
            next
           }
 
        #$% if membership table is full
        if (nmembr+3 > $membersize)
           {
            #$% display message that table cannot accept path and get next
            call echov ("The Membership Table is full.")
            call echov ("  Cannot add this path.")
            call echor
            next
           }
 
        #$% increment index counter
        member$index = nmembr + 1
        nmembr = nmembr + 3
 
        #$% save path and set length
        member$path = path
        member$len  = 3
 
        #$% set name index and save name
        name$index = 1
        member$name = name
 
        next
       }
 
    #$% set membership index to status
    member$index = istat                        # found path. check for name
    #$% for each name entry
    for (name$index=1; name$index<name$index$limit; name$index=name$index+1)
       {
        #$% if name is found, break loop
        if (member$name == name) break
       }
 
    #$% if name is found, get next
    if (member$name == name) next              # dup entry.... skip it
 
    #$% if member table is full
    if (nmembr >= $membersize)
       {
        #$% display message that membership full and get next
        call echov ("The Membership Table is full.")
        call echov ("  Cannot add to this path.")
        call echor
        next
       }
 
    #$% increment membership count
    nmembr = nmembr + 1
 
    #$% increment length
    member$len  = member$len + 1
 
    #$% move entry to the right
    call fsrite (wrmembr,member$index+2,member$index+3,nmembr)
 
    #$% set name index
    name$index = 1
    #$% save membership name
    member$name = name
   }
 
return
end
 

 
 
 
subroutine ffmem  (path,istat)
 
############################################################################
#$%
#$% Purpose:   FFMEM determines if a specified communication link exists
#$%            by searching the membership matrix.  The matrix slot is
#$%            returned if one is determined.
#$%
#$% Called By: FFMEMB     FDMEM1
#$%
#$% Calls:     None
#$%
#$% Tables:    MEMBER
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
############################################################################
 
ForceCommon
integer KMEMBR,
        INC,
        ISTAT                                       # MJC 6/9/2K (E2145)
literal path
 
#$% for each membership entry
for (member$index = 1; member$index <= nmembr; member$index=member$index+inc)
   {
    #$% get membership length
    inc = member$len
 
    #$% if path not found, get next
    if (member$path != path) next
 
    #$% when found, set status flag to index number
    istat = member$index
    return
   }
 
#$% set status to zero (member not found)
istat = 0
 
return
end

 
subroutine feesm  (nargs,args)
 
############################################################
#$%
#$% Purpose:   FEESM processes fingerprint emitter data.
#$%
#$% Called By: FRENTER
#$%
#$% Calls:     ECHOH      ECHOR
#$%
#$% Tables:    EMITTER
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
############################################################
 
ForceCommon
integer IPNT,
        KEMITR                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],esm,name
 
#$% for each path entry
for (ipnt = 3; ipnt <= nargs; ipnt = ipnt + 2)
   {
    #$% get fingerprinted emitter
    esm  = args[ipnt]
    #$% get platform name
    name = args[ipnt+1]
 
    #$% for each emitter entry
    for (emitter$index=1; emitter$index<=nemit; emitter$index=emitter$index+1)
       {
        #$% if emitter or platform not same, get next
        if (emitter$name != esm | emitter$plat != name) next
        #$% when emitter and platform found make name zero and break
        name = 0
        break
       }
    #$% if emitter and platform found, get next one
    if (name == 0) next
 
    #$% if table full
    if (nemit >= $emitters)
       {
        #$% display message and get next entry
        call echov ("Sorry,  ")
        call echoh (esm,$$MAXname)  # jb E2141/8-char's 12/13/99
        call echov (" for ")
        call echoh (name,$$MAXname) # jb E2141/8-char's 12/13/99
        call echov (" cannot be added, the ESM table is full.")
        call echor
        next
       }
 
    #$% if no problems increment counter and save data
    nemit = nemit + 1
    emitter$name = esm
    emitter$plat = name
   }
 
return
end

 
 
 
subroutine feplan (nargs,args)
 
#########################################################
#$%
#$% Purpose:   FEPLAN processes contingency plan data.
#$%
#$% Called By: FRENTER
#$%
#$% Calls:     ECHOH      FSMOVE     ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#########################################################
 
ForceCommon
PlayCommon
integer ISIZE,
        IPLAN,
        INUSE,
        KPLANS,
        KSPLAN                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],side,name
 
#$% if side is blue, set side blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side orange
else                       side = 'ORANG'
 
#$% get plan name
name = args[4]
#$% if all is used as a plan name
if (name == 'ALL') # jb E2141/8-char names 12/13/99
   {
    #$% send warning message to user and return
    call echov ("Sorry, but the name ALL is reserved.  ")
    call echor
    return
   }
#$% set size
isize = stkpnt
 
#$% initialize plan to zero
iplan = 0
 
call fcheckdup (side, name, inuse)
if (inuse == 1)
   {
    return
   }
 
#$% for each plan entry
for (plans$index = 1; plans$index <= nplans; plans$index = plans$index + 1)
   {
    #$% if plan side and name are found
    if (plans$side == side &
        plans$name == name )
       {
        #$% get plan index and break
        iplan = plans$index
        break
       }
   }
 
#$% if plan is not found
if (iplan == 0)
   {
    #$% and if plan table is full
    if (nplans >= $plans)
      {
       #$% display warning message and return
       call echov ("Sorry, but the plan table is too full.")
       call echor
       return
      }
    #$% increment counter and save data
    nplans = nplans + 1
    iplan = nplans
    plans$side = side
    plans$name = name
    plans$size = isize
   }
##$% else plan is a duplicate
#else
#   {
#    #$% send message that input rejected and return
#    call echov ("Sorry, Duplicate PLAN....  Input Rejected.")
#    call echor
#    return
#   }
 
#$% for each entry
for (subplans$index = 2; subplans$index <=  stkpnt;
                         subplans$index =  subplans$index + 1)
   {
    #$% move plan data
    call fsmove (stack[1,subplans$index],subplans$data,$ParserRecLen)
   }
 
return
end

 
 
 
subroutine feordr (nargs,args)
 
#####################################################
#$%
#$% Purpose:   FEORDR processes prestored orders.
#$%
#$% Called By: FRENTER
#$%
#$% Calls:     ECHOH      FSMOVE     ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#####################################################
 
ForceCommon
PlayCommon
integer ICNT,
        K                                               # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
#$% decrement counter
icnt = stkpnt - 1
 
#$% if orders table is full
if (norder + icnt > $orders)
   {
    #$% display warning message and return
    call echov ("Sorry, but the order table is too full. ")
    call echor
    return
   }
 
#$% for each entry
for (k = 2; k <= stkpnt; k = k + 1)
   {
    #$% increment counter
    norder = norder + 1
    #$% move order data
    call fsmove (stack[1,k],wrorder[1,norder],$ParserRecLen)
   }
 
return
end

 
 
subroutine fesear (nargs,args)
 
#####################################################
#$%
#$% Purpoe:    FESEAR processes search plan data.
#$%
#$% Called By: FRENTER
#$%
#$% Calls:     ECHOH      FSMOVE     ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#####################################################
 
ForceCommon
PlayCommon
integer ISIZE,
        IPLAN,
        INUSE,
        KSEARC,
        KSSEAR                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],side,name
 
#$% if side is blue, set side blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side orange
else                       side = 'ORANG'
 
#$% get search plan name
name = args[4]
#$% if all is entered for search plan name
if (name == 'ALL')     # jb E2141/8-char's 12/13/99
   {
    #$% display warning message and return
    call echov ("Sorry, but the name ALL is reserved.  ")
    call echor
    return
   }
 
#$% get size
isize = stkpnt
#$% initialize plan to zero
iplan = 0
 
call fcheckdup (side, name, inuse)
if (inuse == 1)
   {
    return
   }
 
#$% for each search plan entry
for (search$index = 1; search$index <= nsearc
                     ; search$index = search$index + 1)
   {
    #$% if same side and same name
    if (search$side == side &
        search$name == name )
       {
        #$% set plan to index number and break
        iplan = search$index
        break
       }
   }
 
#$% if plan not found
if (iplan == 0)
   {
    #$% if search plan table is full
    if (nsearc >= $search)
      {
       #$% display wasrning message and return
       call echov ("Sorry, but the Search Plan table is too full.")
       call echor
       return
      }
    #$% increment counter and save data
    nsearc = nsearc + 1
    iplan = nsearc
    search$index = iplan
    search$side = side
    search$name = name
    search$size = isize
   }
##$% else search plan is a duplicate
#else
#   {
#    #$% display message that input rejected and return
#    call echov ("Sorry, Duplicate SEARCH Plan....  Input Rejected.")
#    call echor
#    return
#   }
 
#$% for each entry
for (subsearch$index = 2; subsearch$index <= stkpnt;
                          subsearch$index = subsearch$index + 1)
   {
    #$% move search plan data
    call fsmove (stack[1,subsearch$index],subsearch$data,$ParserRecLen)
   }
return
end

 
subroutine feact (nargs,args)
 
#####################################################
#$%
#$% Purpoe:    FEACT processes action plan data.
#$%
#$% Date:      JUNE 83
#$%
#$% Author:    T.D. BURZETTE
#$%
#####################################################
 
ForceCommon
PlayCommon
integer ISIZE,
        IPLAN,
        INUSE,
        KACT,
        KSACT                                       # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],side,name
 
#$% if side is blue, set side blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side orange
else                       side = 'ORANG'
 
#$% get action plan name
name = args[4]
#$% if all is entered for action plan name
if (name == 'ALL') # jb E2141/8-char's 12/13/99
   {
    #$% display warning message and return
    call echov ("Sorry, but the name ALL is reserved.  ")
    call echor
    return
   }
 
#$% get size
isize = stkpnt
#$% initialize plan to zero
iplan = 0
 
call fcheckdup (side, name, inuse)
if (inuse == 1)
   {
    return
   }
 
#$% for each action plan entry
for (act$index = 1; act$index <= nact;
     act$index = act$index + 1        )
   {
    #$% if same side and same name
    if (act$side == side &
        act$name == name  )
       {
        #$% set plan to index number and break
        iplan = act$index
        break
       }
   }
 
#$% if plan not found
if (iplan == 0)
   {
    #$% if plan table is full
    if (nact>= $action)
      {
       #$% display warning message and return
       call echov ("Sorry, but the Action Plan table is too full.")
       call echor
       return
      }
    #$% increment counter and save data
    nact  = nact + 1
    iplan = nact
    act$index = iplan
    act$side  = side
    act$name  = name
    act$size  = isize
   }
##$% else action plan is a duplicate
#else
#   {
#    #$% display message that input rejected and return
#    call echov ("Sorry, Duplicate ACTION Plan....  Input Rejected.")
#    call echor
#    return
#   }
 
#$% for each entry
for (subact$index = 2; subact$index <= stkpnt;
     subact$index = subact$index + 1          )
   {
    #$% move action plan data
    call fsmove (stack[1,subact$index],subact$data,$ParserRecLen)
   }
return
end

 
 
subroutine fewet (nargs,args)
 
#####################################################
#$%
#$% Purpose:   FEWET processes weather region data.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#####################################################
 
ForceCommon
PlayCommon
integer KWET,
        KWETA,
        JSTAT                                       # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
#$% get WET pointer
wet$pointer$to (args[3]+1)
 
#$% display header message to user
call echov (" Weather region # ")
call echoi (int(args[3]))
 
#$% if WET pointer is not valid
if (! wet$pointer$valid)
   {
    #$% display message that it does not exist and return
    call echov (" does not exist.")
    call echor
    return
   }
 
wet$map
#$% if slot in use
if (wet$InUse != $no)
   {
    #$% display message to user and return
    call echov (" is already defined.")
    call echor
    return
   }
 
#$% set status flag to NO
jstat = $no
#$% if maximum wave height exceeded
if (args[4] > 50)                        # check wave height
   {
    #$% display warning message
    call echor
    call echov ("wave height must be < 50 feet")
    #$% reset status to YES
    jstat = $yes
   }
 
#$% if maximum wind speed exceeded
if (args[6] > 200)                       # check wind speed
   {
    #$% display warning message
    call echor
    call echov ("wind speed must be < 200 knots")
    #$% set status to YES
    jstat = $yes
   }
 
#$% if maximum ceiling exceeded
if (args[9] > 100000)                    # check ceiling
   {
    #$% display warning message
    call echor
    call echov ("cloud ceiling must be < 100000 feet")
    #$% set status to YES
    jstat = $yes
   }
 
#$% if maximum cloud tops exceeded
if (args[9]+args[10] > 100000)           # check cloud tops
   {
    #$% display warning message
    call echor
    call echov ("ceiling+depth must be < 100000 feet")
    #$% set status to YES
    jstat = $yes
   }
 
#$% if any parameter above is exceeded, return
if (jstat == $yes)
   {
    call echor
    return
   }
 
#$% otherwise, load WET table
wet$waveheight     = args[4]
wet$wavedirection  = args[5]
wet$windspeed      = args[6]
wet$winddirection  = args[7]
wet$cloudcover     = args[8]
wet$ceiling        = args[9]
wet$clouddepth     = args[10]
wet$visibility     = args[11]
 
#$% find category and load
if      (args[12] == $lex$rain$ ) wet$category = 'RAIN'
else if (args[12] == $lex$fog$  ) wet$category = 'FOG'
else if (args[12] == $lex$haze$ ) wet$category = 'HAZE'
else if (args[12] == $lex$clear$) wet$category = 'CLEAR'
#$% increment counter
nweath = nweath + 1
return
end

 
 
 
subroutine fesos (nargs, args)
 
#####################################################
#$%
#$% Purpose:   FESOS processes SOSUS region data.
#$%
#$% Date:      June 83
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#####################################################
 
ForceCommon
PlayCommon
integer KSOS,
        KSOSA,
        I,
        ISOSXX,
        KSOSX1,
        MODEP,
        IDEEP,
        KCLASS,
        IOWFL,
        K,
        KSOSX2,
        KSOSX3                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
#$% if SOSUS region (as opposed to SOSUS submarine class)
if (args[3]==$lex$region$)
   {
    #$% display message to user
    call echov (" Sosus region #")
    call echoi (int(args[4]))
    #$% if entry is not valid
    if (args[4]<1 | args[4]>$sosus)
       {
        #$% display warning message and return
        call echov (" cannot be entered")
        call echor
        return
       }
 
    #$% set SOS pointer
    sos$pointer$first
    sos$map
 
    #$% for each SOSUS entry
    for (i=1; i<=nsos; i=i+1)           #loop thru entered regions
       {
        #$% if region number found, break loop
        if (sos$regnumber == args[4]) break
        #$% set SOS pointer to next
        sos$pointer$next
        sos$map
       }
 
     #$% if region number not found
     if (i > nsos)
        {
         #$% increment counter and increment number of sets to zero
         nsos = nsos + 1
         sos$zap
         sos$numberofsets = 0
        }
 
     #$% load SOSUS region data
     sos$regnumber = args[4]
     sos$meanaxislength = args[5]
     sos$sigmalength = args[6]
     sos$boundarydepth = args[7]
 
     #$% set for max number of points defining a SOSUS area
     i = 8
     #$% for each entry
     for (sos$pos$index=1; sos$pos$index<=sos$pos$slots;
          sos$pos$index=sos$pos$index+1)
        {
         #$% if maximum number of points exceeded
         if (i > nargs)
            {
             #$% set lat/long to excess
             sos$pos$lat = 99999
             sos$pos$lon = 99999
            }
         #$% else if max points not exceeded
         else
            {
             #$% load latitude and longitude
             sos$pos$lat = args[i]
             sos$pos$lon = args[i+1]
            }
         #$% increment counter
         i=i+2
        }
 
    #$% display message to user
    call echov (" has been entered.")
    call echor
   }
#$% else user entering SOSUS submarine class
else
   {
    #$% display message
    call echov (" Sosus sub class ")
    call echohN (args[4],$$MAXname) # jb E2141/8-char's 12/13/99
    call echov (" in region #")
    call echoi (int(args[5]))
 
    #$% if entry is not valid
    if (args[5]<1 | args[5]>$sosus)
       {
        #$% display message that it cannot be entered and return
        call echov (" cannot be entered")
        call echor
        return
       }
 
    #$% if diesel, set prop mode to YES
    if (args[nargs] == $lex$diesel$) modep = $yes
    #$% else, set to NO
    else                             modep = $no
    #$% if shallow, set depth to NO
    if (args[6] == $lex$shallow$)    ideep = $no
    #$% else, set to YES
    else                             ideep = $yes
 
    #$% for each class entry
    for (class$index=1; class$index<=nclass; class$index = class$index+1)
       {
        #$% if class name found
        if (class$name == args[4])
           {
            #$% if type is "SURF"
            if (class$type == 'SURF')
               {
                #$% send message that it is not a submarine and return
                call echov (" is not a submarine.")
                call echor
                return
               }
            #$% if type is "NSUB" and prop mode is YES (diesel)
            if (class$type == 'NSUB' &
                modep == $yes)
               {
                #$% display message and return
                call echov (" is a NSUB and mode is diesel.")
                call echor
                return
               }
           }
       }
 
    #$% zero pointer
    iowfl = 0
    #$% set SOS pointer
    sos$pointer$first
    sos$map
 
    k= 1
    #$% for each SOSUS entry
    for (i=1; i<=nsos; i=i+1)
       {
        #$% if not SOS region number
        if (sos$regnumber != args[5])
           {
            #$% set pointer, get next entry
            sos$pointer$next
            sos$map
            next
           }
        #$% for each number of sets
        for (k=1; k<=sos$numberofsets; k=k+1)
           {
            #$% set SUB index
            sos$sub$index = k
            #$% set and load SUB table
            if (sos$sub$class     == args[4] &
                sos$sub$depth     == ideep   &
                sos$sub$propmode  == modep    )
               {
                #$% reset flag and break
                iowfl = 1
                break
               }
           }
 
        break
       }
 
    #$% if slots are full
    if (k>sos$sub$slots)
       {
        #$% display message that it cannot be entered and return
        call echov (" cannot be entered")
        call echor
        return
       }
 
    #$% set SUB index
    sos$sub$index = k
 
    #$% if SOSUS region not found
    if (i>nsos)
       {
        #$% load SOS table
        nsos = nsos + 1
        sos$zap
        sos$regnumber = args[5]
        sos$numberofsets = 0
        sos$sub$index = 1
       }
 
    if (iowfl == 0) sos$numberofsets = sos$numberofsets + 1
 
    #$% load SOS table
    sos$regnumber    = args[5]
    sos$sub$class    = args[4]
    sos$sub$depth    = ideep
    sos$sub$propmode = modep
 
    #$% for each detection index entry
    for (sos$det$index=1; sos$det$index<=sos$det$slots;
         sos$det$index=sos$det$index+1)
       {
        #$% SUB detection is entry
        sos$sub$det$prob = args[sos$det$index+6]
       }
 
    #$% display message that it has been entered
    call echov (" has been entered.")
    call echor
   }
 
return
end
 

 
subroutine febistatic (nargs, args)
 
#####################################################
#$%
#$% Purpose:   FEBISTATIC processes BISTATIC pair and
#$%            region data.
#$%
#$% Date:      June 91
#$%
#$% Author:    C. Leaf
#$%
#####################################################
 
ForceCommon
PlayCommon
integer KSOS,
        KSOSA,
        I,
        KBIS,
        KBISA,
        IBISXX                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
  #$% if BISTATIC SOSUS region (as opposed to BISTATIC pair)
  if (args[3] == $lex$SOSUS$)
    {
     #$% display message to user
     call echor
     call echov ("Bistatic characteristics for sosus region #")
     call echoi (int(args[4]))
     #$% if entry is not valid
     if (args[4] < 1 | args[4] > $sosus)
       {
        #$% display warning message and return
        call echov (" cannot be entered")
        call echor
        call echov ("WARNING - Invalid Sosus Region")
        call echor
        return
       }
 
     #$% set SOS pointer
     sos$pointer$first
     sos$map
 
     #$% for each SOSUS entry
     for (i = 1; i <= nsos; i = i + 1)      #loop thru entered regions
       {
        #$% if region number found, break loop
        if (sos$regnumber == args[4])
          break
 
        #$% set SOS pointer to next
        sos$pointer$next
        sos$map
       }
 
     #$% if region number not found
     if (i > nsos)
       {
        #$% display warning message
        call echov (" cannot be entered")
        call echor
        call echov ("WARNING - Sosus Region not found")
        call echor
       }
     else
       {
        #$% load BISTATIC SOSUS region data and display message to user
        sos$bis$RegionArea = args[5]
        sos$bis$NodeDensity = args[6]
        sos$bis$Range = args[7]
        call echov (" have been entered")
        call echor
       }
    }
  #$% else user entering a BISTATIC pair
  else
    {
     #$% display message
     call echov (" Bistatic pair (active source) ")
     call echoh (args[4], $$MAXname)    # jb E2141/8-char's 12/13/99
     call echov (" (passive receiver) ")
 
     if (args[5] == $lex$BDS$)
       {
        args [6] = 'BDS'
       }
 
     call echoh (args[6], 5)
 
     #$% if slots are full
     if (nbis >= $bpairs)
       {
        #$% display message that it cannot be entered and return
        call echov (" cannot be entered - ")
        call echoi ($bpairs)
        call echov (" already entered.")
        call echor
         return
       }
 
     #$% set BIS pointer
     BIS$Pointer$First
     BIS$map
 
     #$% for each BISTATIC PAIR entry
     for (i = 1; i <= nbis; i = i + 1)      #loop thru entered pairs
       {
        #$% if pair found, break loop
        if (BIS$ActiveSource == args[4] & BIS$PassiveReceiver == args[6])
            break
 
        #$% set BIS pointer to next
        bis$pointer$next
        bis$map
       }
 
     if (i > nbis)
       {
        #$% increment counter and clear unwanted data
        nbis = nbis + 1
        BIS$zap
       }
 
     #$% enter BISTATIC pair data
     BIS$ActiveSource = args[4]
     BIS$PassiveReceiver = args[6]
 
     #$% display message that it has been entered
     call echov (" has been entered.")
     call echor
    }
 
return
end
 

 
subroutine feswabs (nargs, args)
 
#####################################################
#$%
#$% Purpose:   FESWABS processes SWABS region data.
#$%
#$% Date:      February 1991
#$%
#$% Author:    Carol Kropp and Susan Miller
#$%
#####################################################
ForceCommon
PlayCommon
integer KSWB,
        KSWBA,
        I,
        KSWBX1,
        KCLASS,
        IOWFL,
        K,
        KSWBX2,
        KSWBX3                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
integer region_number
 
  #$% if SWABS region (as opposed to SWABS submarine class)
  if (args[3]==$lex$region$)
    {
     if (args[5] == $lex$blue$)
       {
        call echov (" Blue SWABS region #")
        region_number = args[4]
       }
     else  #Orange SWABS region
       {
        call echov (" Orange SWABS region #")
        region_number = args[4] + $SWABS$Orange$offset
       }
     call echoi (int(args[4]))
 
     #$% if entry is not valid
     if (args[4] < 1 | args[4] > ($SWABSregions - $SWABS$Orange$offset))
       {
        #$% display warning message and return
        call echov (" cannot be entered because ")
        call echoi (int(args[4]))
        call echor
        call echov (" is not a valid Region Number")
        call echor
        return
       }
 
     if (args[6] > 255 | args[7] > 255)
       {
        call echov (" cannot be entered because the entered value(s) for")
        call echor
        call echov (" location error and/or sigm exceed the max of 255.")
        call echor
        return
       }
 
     #$% set SWABS pointer
     swb$pointer$to  region_number
     swb$map
 
     #$% load SOSUS region data
     nswb = nswb + 1
     swb$regnumber = region_number
     swb$regdefined = $yes
     swb$locationerror = args[6]
     swb$sigma = args[7]
 
     #$% set for max number of points defining a SWABS area
     i = 8
     #$% for each entry
     for (swb$pos$index = 1; swb$pos$index <= swb$pos$slots;
                                    swb$pos$index = swb$pos$index + 1)
       {
        #$% if maximum number of points exceeded
        if (i > nargs)
          {
           #$% set lat/long to excess
           swb$pos$lat = 99
           swb$pos$lon = 99
          }
        else
          {
           #$% load latitude and longitude
           swb$pos$lat = args[i]
           swb$pos$lon = args[i+1]
          }
        #$% increment counter
        i = i + 2
       }
 
     #$% display message to user
     call echov (" has been entered.")
     call echor
    }
  else      #$% else user entering SWABS submarine class
    {
     call echov (" SWABS sub class ")
     call echoh (args[4], $$MAXname) # jb E2141/8-char's 12/14/99
     if (args[5] == $lex$blue$)
       {
        call echov (" in Blue region #")
        region_number = args[6]
       }
     else  #Orange SWABS region
       {
        call echov (" in Orange region #")
        region_number = args[6] + $SWABS$Orange$offset
       }
     call echoi (int(args[6]))
 
     #$% if entry is not valid
     if (args[6] < 1 | args[6] > $SWABSregions)
       {
        #$% display message that it cannot be entered and return
        call echov (" cannot be entered because ")
        call echoi (int(args[6]))
        call echor
        call echov (" is not a valid Region Number")
        return
       }
 
     #$% for each class entry
     for (class$index = 1; class$index <= nclass; class$index = class$index + 1)
       {
        #$% if class name found
        if ((class$name == args[4]) & (class$type == 'SURF'))
          {
           #$% send message that it is not a submarine and return
           call echov (" is not a submarine.")
           call echor
           return
          }
       }
 
     #$% set SWB pointer
     swb$pointer$to  region_number
     swb$map
 
     iowfl = 0
 
     #$% for each number of sets
     for (k = 1; k <= swb$numberofsets; k = k + 1)
       {
        #$% set SUB index
        swb$sub$index = k
        #$% set and load SUB table
        if (swb$sub$class == args[4])
          {
           #$% reset flag and break
           iowfl = 1
           break
          }
       }
 
     #$% if slots are full
     if (k > swb$sub$slots)
       {
        #$% display message that it cannot be entered and return
        call echov (" cannot be entered because 20 submarine")
        call echor
        call echov ("classes have already been entered.")
        call echor
        return
       }
 
     #$% set SUB index
     swb$sub$index = k
 
     if (iowfl == 0)
       swb$numberofsets = swb$numberofsets + 1
 
     #$% load SWB table
     if (swb$InUse == $no)             # if the region was not previously in use
       swb$regnumber = region_number   # assign the region number
     swb$sub$class = args[4]
     for (swb$det$index = 1; swb$det$index <= swb$det$slots;
                                        swb$det$index = swb$det$index + 1)
        swb$sub$det$prob = args[swb$det$index + 6] * 0.01    #      3/13/91
 
     #$% display message that it has been entered
     call echov (" has been entered.")
     call echor
    }
 
return
end
 

 
subroutine feson (nargs, args)
 
##############################################################
#$%
#$% Purpose:   FESON processes Sonar Environment Region data.
#$%
#$% Date:      June 83
#$%
#$% Author:    J. P. Kvederis
#$%
#################################################################
 
ForceCommon
PlayCommon
integer KSON,
        KSONA,
        I,
        ISONXX,
        KSONX1                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
#$% display prompt message to user
call echov (" Sonar Environment Region # ")
call echoi (int(args[3]))
 
#$% if region number is not valid
if (args[3]<1 | args[3]>$sonev)
  {
   #$% display warning message and return
   call echov (" cannot be entered because ")
   call echoi (int(args[3]))
   call echor
   call echov (" is not a valid Region Number")
   call echor
   return
  }
#$% if environment file number is not valid - 4 files available
if (args[4]<1 | args[4]>$snrenv)
  {
   #$% display warning message and return
   call echov (" cannot be entered because ")
   call echoi (int(args[4]))
   call echor
   call echov (" is not a valid Environment File Number")
   call echor
   return
  }
 
#$% set SONAR Environment pointer
son$pointer$first
son$map
 
#$% for each Sonar Environment Region entry
for (i=1; i<=nson; i=i+1)           #loop thru entered regions
   {
    #$% if region number found, break loop
    if (son$regnumber == args[3]) break
    #$% set Sonar Environment Region pointer to next
    son$pointer$next
    son$map
   }
 
#$% if region number not found
if (i > nson)
   {
    #$% increment counter and increment number of sets to zero
    nson = nson + 1
    son$zap
    # son$numberofsets = 0
   }
 
#$% load Sonar Environment Region data
son$regnumber = args[3]
son$sonarenv = args[4]
 
 
#$% set points defining a Sonar Environment Region
i = 5
#$% for each entry
for (son$pos$index=1; son$pos$index<=son$pos$slots;
     son$pos$index=son$pos$index+1)
   {
    #$% if maximum number of points exceeded
    if (i > nargs)
       {
        #$% set lat/long to excess
        son$pos$lat = 99
        son$pos$lon = 99
       }
    #$% else if max points not exceeded
    else
       {
        #$% load latitude and longitude
        son$pos$lat = args[i]
        son$pos$lon = args[i+1]
       }
    #$% increment counter
    i=i+2
   }
 
#$% display message to user
call echov (" has been entered.")
call echor
 
 
return
end
 

 
 
subroutine fehfd (nargs,args)
 
########################################################################
#$%
#$% Purpose:   FEHFD processes High Frequency Detection Finder data.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
########################################################################
 
ForceCommon
integer KHFD,
        KHFDA,
        I,
        IHFDXX,
        IE,
        K,
        KHFDX                                       # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
#$% display message
call echov (" Hfdf Base ")
call echoh (args[3],$$MAXname)  # jb E2141/8-char's 12/14/99
 
#$% set HFD pointer
hfd$pointer$first
hfd$map
#$% for each HFD pointer
for (i=1; i<=nhfdf; i=i+1)
   {
    #$% if HFD basename found, break loop
    if (hfd$basename == args[3]) break
    #$% set HFD pointer
    hfd$pointer$next
    hfd$map
   }
 
#$% if HFD table is full or name not found and number of stations exceeded
if (args[4] > 10 |
    (i>nhfdf & nhfdf>=$hfdf))
   {
#$% display message that it cannot be entered and return
    call echov (" cannot be entered.")
    call echor
    return
   }
    #$% if name cannot be found (no duplicate)
    if (i>nhfdf)
   {
    #$% increment counter
    nhfdf = nhfdf+1
    hfd$zap
   }
 
#$% get HFD basename
hfd$basename = args[3]
    ie = 10 * (args[4]-1)
#$% for each HFD entry
for (k=1; k<=10; k=k+1)
   {
#$% load HFD index and prob
    hfd$index = ie + k
    hfd$prob = args[4+k]
   }
 
    #$% display message that data has been entered
    call echov (" has been entered.")
    call echor
return
end
 

 
 
 
subroutine feair (nargs,args)
 
############################################################
#$%
#$% Purpose:   FEAIR processes air maintenance log data.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#$% Modified:  Carol Kropp - 4/95 (E1394)
#$%            Added squadron name (args[10]) and optional
#$%            default mission (args[11]) information.
#$%
############################################################
 
ForceCommon
integer K,
        ILEN,
        IT_IS_DUP,
        ISRCH,
        INOW,
        KAML,
        KAMLA,
        LITCMP,
        INS,
        M,
        IPNT                                        # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],name
integer squadron_index
integer default_mission
 
 
if (nargs >= 10)
  {
   call fesquadron (args[10], squadron_index)
   if (squadron_index == 0)
     {     # then there was an error
      call echov ("ENTER AIR command not processed due ")
      call echov ("to the above error(s).")
      call echo ($Bell)
      call echor
      return
     }
  }
 
if (nargs >= 11)
  {
   call Lex_to_Mission_Code (args[11], default_mission)
   if (default_mission == -1)
     default_mission = $NoneAssigned$Code
  }
else
   default_mission = $NoneAssigned$Code
 
#$% for each aml entry
for (k=0; k<args[5]; k=k+1)                     #loop thru # of aml entries
   {
    #$% initialize line length and name
    ilen = 0
    name = $BLANKLIT
    #$% move data to output buffer
    call smovhn (args[3],2,name,ilen)               #pack side number id and
    call smoviz (int(args[4])+k,3,name,ilen)        # seq number
 
    call check_force_name ( name, it_is_Dup )       # DEW 4/2/90
 
    if ( it_is_dup == $YES )                        # DEW 4/2/90
        {
        call echov ("The side number ")
        call echohn (name,$$MAXname)    # jb E2141/8-char's 12/14/99
        call echov (" duplicates the name of an existing Force.")
        call echor
 
        next                        # do not add this side-number
        }
 
    call check_bml_name ( name, it_is_Dup )         # DEW 4/2/90
 
    if ( it_is_dup == $YES )                        # DEW 4/2/90
        {
        call echov ("The side number ")
        call echohn (name,$$MAXname) # jb E2141/8-char's 12/14/99
        call echov (" duplicates the name of a boat.")
        call echov (" It is not added.")
        call echor
 
        next                        # do not add this side-number
        }
 
    isrch=0
    repeat                                      #loop looking for place
       {                                        # to put in entry
        #$% increment counter
        isrch = isrch + 1
        inow = isrch
        #$% set AML pointer to search
        aml$pointer$to isrch
        aml$map
        #$% if side number found
        if (name == aml$sidenumber)             #if matches side number
           {                                    # already in table
            #$% display message
            call echov ("Overwriting ")
            call echoh (aml$sidenumber,$$MAXname) # jb E2141/8/12/14/99
            call echor
            #$% decrement pointer
            naml = naml - 1
           }
        #$% else if side number not found
        else if (litcmp(name,aml$sidenumber) < 0)
           {
            #$% if AML table is full
#           if (naml >= 1000)
            if (naml >= $airlog)     # reh 10/4/89
               {
                #$% display message that it cannot be entered and return
                call echov ("Can't enter ")
                call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
                call echov (" because AML table limits reached")
                call echor
                return
               }
            #$% for each entry
            for (ins=naml; ins>=inow; ins=ins-1) #move entries one place to
               {                                 # make room for insertion
                #$% set pointer to insert
                aml$pointer$to ins
                aml$map
                #$% for each AML entry
                for (m=0; m<aml$entry; m=m+1)
                   {
                    #$% set pointer and increment
                    ipnt = aml$address+m
                    #$% save work file
                    work$file$r[ipnt+aml$entry] = work$file$r[ipnt]
                   }
                }
              }
 
        #$% else if at end of entries
        else if (isrch >= naml) inow = naml + 1
        #$% else get next
        else next
 
        #$% if AML table is full
        if (naml >= $airlog)     #reh 10/4/89   #if table already full
           {
            #$% display message that it cannot be entered and return
            call echov ("Can't enter ")
            call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
            call echov (" because AML table limits reached")
            call echor
            return
           }
 
        #$% increment counter and load AML table
        naml = naml + 1
        aml$pointer$to inow
        aml$map
        aml$sidenumber = name                  #put new entry in table
        aml$type = args[6]
        aml$basename = args[7]
        aml$timeflown = args[8]
        aml$timeup = args[9]
        aml$sqdindx = squadron_index
        aml$defaultmission = default_mission
 
        break
         #$% until AML table covered
       } until (isrch > naml)
   }
 
call echor
 
return
end

 
 
 
subroutine fesst (nargs,args)
 
##############################################################
#$%
#$% Purpose:   FESST processes surveillance satellite data.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
##############################################################
 
ForceCommon
integer I,
        KSST,
        KSSTA,
        IEFLAG                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],stype
 
#$% for each SURVSAT entry
for (i=1; i<=nssts; i=i+1)              #search for duplicate survsat name
   {
    #$% set SST pointer
    sst$pointer$to i
    sst$map
 
    if (sst$name == args[3])
       {
        call echor
        call echov ("Survsat ")
        call echoh (args[3],$$MAXname) # jb E2141/8-char's 12/14/99
        call echov (" has been skipped - it was previously entered.")
        call echor
        return
       }
   }
 
#$% if SURVSAT table is full
if (nssts == $survsats &
    i > nssts)
   {
    #$% send message that it cannot be entered
    call echov ("Survsat ")
    call echoh (args[3],$$MAXname) # jb E2141/8-char's 12/14/99
    call echov (" cannot be entered because...")
    call echor
    call echov ("...the maximum number of Satellites allowed has been exceeded.")
    call echor
    return
   }
 
#$% get SURVSAT type
stype = args[4]
#$% set flag to NO
ieflag = $no
 
#$% load SURVSAT equipment
call fchsat (stype,ieflag)
 
#$% display message
call echov (" Survsat ")
call echoh (args[3],$$MAXname) # jb E2141/8-char's 12/14/99
 
#$% if there is a problem loading equipment
if (ieflag != 0)
   {
    #$% display message to user and return
    call echov (" not entered.")
    call echor
    return
   }
 
#$% if SURVSAT not found (not a duplicate), increment counter
if (i > nssts) nssts = nssts + 1
 
#$% set pointer/map and load SURVSAT data
sst$pointer$to i
sst$map
sst$name = args[3]
sst$type = args[4]
sst$groundstation = args[5]
sst$altitude = args[6]
sst$dutycycle = args[7]
if (args[8] == $lex$orbital$)
   {
    sst$orbit = $yes
    sst$period = args[9]
    sst$inclination = int( args[10] )*100 + mod( int( args[11] ),100 )
    sst$xtime = args[12]
    sst$xlongitude = args[13]
   }
else   # == $lex$stationary$
   {
    sst$orbit = $no
    sst$latitude = args[9]
    sst$longitude = args[10]
   }
 
#sst$period = args[5]
#sst$altitude = args[6]
#sst$inclination = int( args[7] )*100 + mod( int( args[8] ),100 )
#sst$xtime = args[9]
#sst$xlongitude = args[10]
#sst$dutycycle = args[11]
#sst$groundstation = args[12]
 
#$% display message that data has been entered
call echov (" has been entered.")
call echor
 
return
end

 
 
 
subroutine fchsat (stype,ieflag)
 
##################################################################
#$%
#$% Purpose:   FCHSAT finds, verifies and loads SURVSAT equipment.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
#########################################################################
 
ForceCommon
integer IEFLAG                                      # MJC 6/9/2K (E2145)
literal CAT                                         # MJC 6/9/2K (E2145)
literal stype
 
#$% initialize error count and category
errcnt = 0
cat = 0
 
#$% verify and load SURVSAT equipment
call Finseq (nsat,wrsat,$sats,stype,cat,"SURVSAT   ")
 
#$% verify SURVSAT data
call FVsat
 
#$% verify radar/esm equipment carried by SURVSAT
call FVothr (build$name,$litc,sensor$file,nsenso,wrsenso,"Radar/ESM ")
 
#$% if equipment verified, save it
if (errcnt == 0) call FSuse
#$% else if equipment not verified
else
   {
    #$% clear in use slot
    call FCuse
    #$% reset flag to YES
    ieflag = $yes
    #$% reset error count to zero
    errcnt = 0
   }
 
return
end

 
 
 
subroutine feemco (nargs,args)
 
##############################################################
#$%
#$% Purpose:   FEEMCO processes emission control plan data.
#$%
#$% Date:      AUGUST 82
#$%
#$% Author:    R. Kleiman/J. Kvederis
#$%
##############################################################
 
ForceCommon
PlayCommon
integer KEMCON,
        KEMCOX                                      # MJC 6/9/2K (E2145)
integer nargs,iplan
literal args[$max$args],side,name
 
#$% if entry is blue, set side to blue
if (args[3] == $lex$blue$) side = 'BLUE'
#$% else set side to orange
else                       side = 'ORANG'
 
#$% get EMCON plan name
name = args[4]
 
#$% if ALL entered as the EMCON plan name
if (name == 'ALL') # jb E2141/8-char's 12/14/99
    {
     #$% display warning message to user and return
     call echov ("Sorry, but the name ALL is reserved. ")
     call echor
     return
    }
 
#$% initialize plan to zero
iplan = 0
#$% search the index for number of emcon plans
for (emcon$index = 1; emcon$index <= nemcon; emcon$index = emcon$index + 1)
   {
    #$% if the EMCON plan for a given side is not matched, look at the next one
    if (emcon$side != side |
        emcon$name != name  ) next
 
    #$% set plan to EMCON index and break
    iplan = emcon$index
    break
   }
 
#$% if plan is found
if (iplan != 0)
   {
    #$% display message that input is rejected and return
    call echov ("Sorry duplicate Emcon plan.  Input rejected.  ")
    call echor
    return
   }
 
#$% if EMCON table is full
if (nemcon >= $emcon)
   {
    #$% display message that it cannot be entered and return
    call echov ("Sorry, but the emcon plan table is full. ")
    call echor
    return
   }
 
#$% increment counter,set index and load EMCON table
nemcon = nemcon + 1
emcon$index = nemcon
emcon$name = name
emcon$side = side
 
 
               #here the different sections are inserted
               ###########################################
 
#$% for each EMCON option entry (ie. surface, air, sonar, etc. 8 max)
# JFR 5/9/91  (9 vice 8)
for (emcon$option$index = 1 ;emcon$option$index <= 9;
     emcon$option$index = emcon$option$index + 1)
    {
     #$% if user entry is YES (equipment is to be activated), set option to on
     if (args[emcon$option$index + 4] == $lex$yes$) emcon$option$on
 
     #$% else set option to NO (equipment not to be activated)
     else                                           emcon$option$off
    }
return
end
 

 
subroutine fephit (nargs, args)
 
#####################################################################
#$%
#$% Purpose:   FEPHIT processes entered Probabilities of Hit data.
#$%
#$% Date:      November 83
#$%
#$% Author:    J. P. Kvederis
#$%
######################################################################
 
ForceCommon
PlayCommon
integer KEPH,
        KEPHA,
        I                                       # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
#$% display response message to user
call echor
call echov (" Probability of hit against target type ")
call echohN (args[3], $$MAXname) #(vice 8) jb E2141/8-char's 12/14/99
call echov ("with weapon ")
call echohN (args[4], $$MAXname) #(vice 8) jb E2141/8-char's 12/14/99
call echor
 
if (args[5] < 0 | args[5] > 100)
   {
    call echov (" Cannot be entered - Prob Hit must be between 0 and 100%")
    call echor
    call echov (" Input is rejected")
    return
   }
 
#$% if Probability of Hit table is full
if (neph >= $eph)
   {
    #$% display message that it cannot be entered and return
    call echov (" Sorry, but the Probabilty of Hit table is full. ")
    call echor
    call echov (" Input is rejected")
    return
   }
 
eph$pointer$first
eph$map
 
#$% for each Probability of Hit entry
for (i=1; i<=neph; i=i+1)           #loop thru all probabilities
   {
    #$% if region number found, break loop
    if (eph$target == args[3] & eph$weapon == args[4])
       {
        eph$percent = args[5]
        call echov (" is replaced.")
        call echor
        return
       }
 
    #$% set Probability of Hit pointer to next
    eph$pointer$next
    eph$map
   }
 
#$% increment counter,set index and load EMCON table
neph = neph + 1
eph$pointer$to neph
eph$map
 
eph$target = args[3]
eph$weapon = args[4]
eph$percent = args[5]
 
#$% display message that data has been entered
call echov (" has been entered.")
call echor
 
return
end

 
Subroutine fcheckdup (side, name, inuse)
 
######################################################################
#$%
#$% Purpoe:    FCHECKDUP checks for duplicate names that the operator
#$%            may have tried to use in naming SEARCH, CONTINGENCY
#$%            or ACTION plans and returns  inuse = 1 if name is duplicate
#$%             and inuse = 0 if name is not a duplicate.
#$%
#$% Date:      June 1983
#$%
#$% Author:    J. P. Kvederis
#$%
############################################################################
 
ForceCommon
PlayCommon
integer INUSE,
        KSEARC,
        KPLANS,
        KACT                                        # MJC 6/9/2K (E2145)
literal name, side
 
inuse = 0
 
for (search$index = 1; search$index <= nsearc
                     ; search$index = search$index + 1)
   if (search$side == side & search$name == name )
      {
       inuse = 1
       call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
       call echov (" is an invalid entry!")
       call echor
       call echov ("That name is already in use for a Search Plan")
       return
      }
 
for (plans$index = 1; plans$index <= nplans; plans$index = plans$index + 1)
    if (plans$side == side & plans$name == name )
       {
        inuse = 1
        call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
        call echov (" is an invalid entry!")
        call echor
        call echov ("That name is already in use for a Contingency Plan")
        return
       }
 
for (act$index = 1; act$index <= nact; act$index = act$index + 1)
    if (act$side == side & act$name == name)
       {
        inuse = 1
        call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
        call echov (" is an invalid entry!")
        call echor
        call echov ("That name is already in use for an Action Plan")
        return
       }
return
end
 
 

 
subroutine feboat (nargs,args)
 
############################################################
#$%
#$% Purpose:   FEBOAT adds boat classification to ship class
#$%            table and builds boat maintenance log data.
#$%
#$% Note:      The boat maintenance log (bml) entries of the
#$%            work record are sorted by boat name
#$%
#$% Called By: EXEORD
#$%
#$% Calls:     ECHOR      ECHOH      SMOVHN
#$%            FCUSE      FSUSE      ADD_BOAT_CLASS
#$%
#$% Tables:    BML
#$%
#$% Date:      5/8/89
#$%
#$% Author:    R. Hundt
#$%
############################################################
 
ForceCommon
integer ISTAT,
        IT_IS_DUP,
        ISRCH,
        INOW,
        KBML,
        KBMLA,
        LITCMP,
        INS,
        M,
        IPNT                                        # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args],name, class, type
 
type  = 'BOAT'
class = args [ 4 ]
name  = args [ 3 ]
 
istat = $NO
 
call add_boat_class(class, type, istat)
 
call check_force_name ( name, it_is_Dup )
 
if ( it_is_dup == $YES )
    {
    call echov ("The boat name ")
    call echohn (name,$$MAXname)    # jb E2141/8-char's 12/14/99
    call echov (" duplicates the name of an existing Force.")
    call echor
 
    istat = $no
    }
 
call check_aml_name ( name, it_is_Dup )
 
if ( it_is_dup == $YES )
    {
    call echov ("The boat name ")
    call echohn (name,$$MAXname) # jb E2141/8-char's 12/14/99
    call echov (" duplicates the name of an aircraft.")
    call echor
 
    istat = $no
    }
 
# if error adding boat and assoc equip to work records
if (istat == $no)
    {
    #$% clear in use flag
    call FCuse
    #$% send message
    call echov ("The boat ")
    call echohn (name,$$MAXname) # jb E2141/8-char's 12/14/99
    call echov (" is not loaded because of the above errors.")
    call echor
    return
    }
else
   {
    #$% set in use flag
    call FSuse
   }
 
isrch=0
 
# build the boat maintenance log
repeat                  #loop thru bml looking for place to put entry
    {
    #$% increment counter
    isrch = isrch + 1
    inow = isrch
    #$% set BML pointer to search
    bml$pointer$to isrch
    bml$map
    #$% if side number found
    if (name == bml$name)    #if bml matches new boat name, already in table
        {
        #$% display message
        call echov ("Overwriting Boat ")
        call echoh (bml$name,$$MAXname) # jb E2141/8-char's 12/14/99
        call echor
        #$% decrement pointer
        nbml = nbml - 1
        }
    #$% else if boat name not found
    #$% if entered boat name should be inserted before current entry,
    #$% sort entries by name
    else if (litcmp(name,bml$name) < 0)
        {
        #$% if bml table is full
        if (nbml >= $boatlog )
            {
            #$% display message that it cannot be entered and return
            call echov ("Can't enter ")
            call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
            call echov (" because BML table limits reached")
            call echor
            return
            }
        #$% for each entry which must be shifted to right
        for (ins=nbml; ins>=inow; ins=ins-1) #move entries one place to
            {                                 # make room for insertion
            #$% set pointer to insert
            bml$pointer$to ins
            bml$map
            #$% for each bml field
            for (m=0; m<bml$entry; m=m+1)
                {
                #$% set pointer and increment
                ipnt = bml$address+m
                #$% save work file
                work$file$r[ipnt+bml$entry] = work$file$r[ipnt]
                }
            }
        } ##end, boat name is not found in bml
 
    #$% else if at end of bml entries used
    else if (isrch >= nbml) inow = nbml + 1
    #$% else get next
    else next
 
    #$% if bml table is full
#    if (nbml >= 1000)                       #if table already full
    if (nbml >= $boatlog)        #reh 10/4/89 if table already full
        {
        #$% display message that it cannot be entered and return
        call echov ("Can't enter ")
        call echoh (name,$$MAXname) # jb E2141/8-char's 12/14/99
        call echov (" because bml table limits reached")
        call echor
        return
        }
 
    #$% increment counter and load bml table
    nbml = nbml + 1
    bml$pointer$to inow
    bml$map
    bml$name = name                  #put new entry in table
    bml$class = args[4]
    bml$basename = args[5]
 
    break
    #$% until bml table covered
    } until (isrch > nbml)
 
return
end

subroutine check_force_name ( name, it_is_Dup )
 
#########################################################
#$%
#$% Purpose:   CHECK_FORCE_NAME looks for a matching name
#$%
#$% Called By: FEBOAT  FEAIR
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      4/2/90
#$%
#$% Author:    D.E. Wills
#$%
#########################################################
 
ForceCommon
integer KFORCE                                      # MJC 6/9/2K (E2145)
integer it_is_dup
literal name
 
it_is_dup = $NO
 
for (force$index = 1; force$index<=nforce; force$index=force$index+1)
    {
    if (force$name == name)
        {
        it_is_dup = $YES
        break
        }
    }
 
end
 

subroutine check_org_name ( name, it_is_Dup )
 
#########################################################
#$%
#$% Purpose:   CHECK_ORG_NAME looks for a matching name
#$%            OF AN ORGANIZATION
#$%
#$% Called By: FXSHIP
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      5/30/91
#$%
#$% Author:    J. Richardson
#$%
#########################################################
 
ForceCommon
integer KORG                                        # MJC 6/9/2K (E2145)
integer it_is_dup
literal name
 
it_is_dup = $NO
 
for (org$index = 1; org$index<=norg; org$index=org$index+1)
    {
    if (org$name == name)
        {
        it_is_dup = $YES
        break
        }
    }
 
end
 

subroutine check_org_task ( itask, isame_task )
 
#########################################################
#$%
#$% Purpose:   CHECK_ORG_TASK looks for a matching task number
#$%            OF AN ORGANIZATION
#$%
#$% Called By: FXSHIP
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      5/30/91
#$%
#$% Author:    J. Richardson
#$%
#########################################################
 
ForceCommon
integer KORG,
        ITASK                                       # MJC 6/9/2K (E2145)
integer isame_task
 
isame_task = $NO
 
for (org$index = 1; org$index<=norg; org$index=org$index+1)
    {
    #$% if same task number
    if (org$task == itask)
       {
        isame_task = isame_task + 1
       }
    }
 
end
 

subroutine check_frc_task ( itask, isame_task )
 
#########################################################
#$%
#$% Purpose:   CHECK_FRCORG_TASK looks for a matching task number
#$%            OF A FORCE
#$%
#$% Called By: FXUNIT
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      5/30/91
#$%
#$% Author:    J. Richardson
#$%
#########################################################
 
ForceCommon
integer KFORCE,
        ITASK                                       # MJC 6/9/2K (E2145)
integer isame_task
 
isame_task = $NO
 
#$% for each force entry
for (force$index = 1; force$index<=nforce; force$index=force$index+1)
   {
    #$% if same task number
    if (force$task == itask)
       {
        isame_task = isame_task + 1
       }
   }
 
end
 

subroutine check_frc_name ( name, it_is_Dup )
 
#########################################################
#$%
#$% Purpose:   CHECK_FRC_NAME looks for a matching name
#$%            OF A NAVAL FORCE
#$%
#$% Called By: FXUNIT
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      5/30/91
#$%
#$% Author:    J. Richardson
#$%
#########################################################
 
ForceCommon
integer KFORCE                                      # MJC 6/9/2K (E2145)
integer it_is_dup
literal name
 
it_is_dup = $NO
 
for (force$index = 1; force$index<=nforce; force$index=force$index+1)
    {
    if (force$name == name)
        {
        it_is_dup = $YES
        break
        }
    }
 
end
 

subroutine check_aml_name ( name, it_is_Dup )
 
#########################################################
#$%
#$% Purpose:   CHECK_AML_NAME looks for a matching name
#$%
#$% Called By: FEBOAT
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      4/2/90
#$%
#$% Author:    D.E. Wills
#$%
#########################################################
 
ForceCommon
integer K,
        KAML,
        KAMLA                                       # MJC 6/9/2K (E2145)
integer it_is_dup
literal name
 
it_is_dup = $NO
 
for (k = 1; k <= naml; k = k + 1)
   {
    aml$pointer$to k
    aml$map
 
    if ( name == aml$sidenumber )
        {
        it_is_dup = $YES
        break
        }
   }
 
end
 
 
 

subroutine check_bml_name ( name, it_is_Dup )
 
#########################################################
#$%
#$% Purpose:   CHECK_BML_NAME looks for a matching name
#$%
#$% Called By: FEAIR
#$%
#$% Calls:
#$%
#$% Tables:    None
#$%
#$% Date:      4/2/90
#$%
#$% Author:    D.E. Wills
#$%
#########################################################
 
ForceCommon
integer K,
        KBML,
        KBMLA                                       # MJC 6/9/2K (E2145)
integer it_is_dup
literal name
 
it_is_dup = $NO
 
for (k = 1; k <= nbml; k = k + 1)
   {
    bml$pointer$to k
    bml$map
 
    if ( name == bml$name )
        {
        it_is_dup = $YES
        break
        }
   }
 
end
 
 

subroutine feuav (nargs,args)
 
#########################################################
#$%
#$% Purpose:   FEUAV processes unmanned aerial vehicle data.
#$%
#$% Called By: FRENTER
#$%
#$% Calls:     ECHOH      FSMOVE     ECHOR
#$%
#$% Tables:    None
#$%
#$% Date:      2/5/90
#$%
#$% Author:    R. Hundt
#$%
#########################################################
 
ForceCommon
PlayCommon
integer KUVP                                        # MJC 6/9/2K (E2145)
real    SAVE_NUM_RANGES,
        SAVE_RANGE,
        SAVE_DETECT,
        SAVE_RECOG,
        SAVE_IDENT,
        TEMP_RANGE,
        TEMP_DETECT,
        TEMP_RECOG,
        TEMP_IDENT                                  # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
integer*4   tgt_index
integer*4   iuvp
 
iuvp = 0
 
tgt_index = args [3]
 
#$% for each uav entry
for (uvp$index = 1; uvp$index <= nuvp; uvp$index = uvp$index + 1)
   {
    #$% if uvp side and name are found
    if (uvp$TargTypeIndex == tgt_index )
        {
        #$% get uvp index and break
        iuvp = uvp$index
        break
        }
    }
 
#$% if uvp is not found
if (iuvp == 0)
   {
    #$% and if uvp table is full
    if (nuvp >= $uvp)
      {
       #$% display warning message and return
       call echov ("Sorry, but the uvp table is too full.")
       call echor
       return
      }
    #$% increment counter and save data
    nuvp = nuvp + 1
    uvp$index = nuvp
   }
 
uvp$TargTypeIndex = tgt_index
 
#$% if updating type of target corresponds to mobile
if (args[4] == $LEX$MOBILE$)
    {
    uvp$Type = $UAV$Mobile
    }
 
#$% else updating type of target corresponds to a fixed object (eg. bridge)
else if ( args [4] == $LEX$STATIONARY$)
    {
    uvp$Type = $UAV$Fixed
    }
 
#$% else if setting probabilities with respect to range
else if ( args [4] == $LEX$RANGE$)
    {
     IF ( args [ 5 ] < 0 |
          args [ 5 ] > $UAV$MaxRange)
        {
         #$% display warning message and return
         call echov ("Sorry, Range Value not between ")
         call echoi(0)
         call echov(" thru ")
         call echoi($UAV$MaxRange)
         call echor
         return
        }
 
     IF ( UVP$NumRanges >= $UAV$NumRangesPerType)
        {
         #$% display warning message and return
         call echov ("Sorry, the maximum number of ranges has already ")
         call echov ("been entered for target index ")
         call echoi(uvp$TargTypeIndex)
         call echor
         return
        }
     Else            # increment the number of ranges
        UVP$NumRanges = UVP$NumRanges + 1
 
     save_num_ranges = UVP$NumRanges
     save_range  = args[5]
     save_detect = args[6]
     save_recog  = args[7]
     save_ident  = args[8]
 
     If (UVP$NumRanges > 1)
        {
         UVP$NumRanges = 1  # start at the beginning
         # loop through the ranges
         while (UVP$NumRanges <= save_num_ranges)
            {
             if (UVP$Range == save_range)      # duplicate range, discard
                {
                 # display warning message and return
                 call echov ("Sorry, the last range entered is a duplicate ")
                 call echor
                 UVP$NumRanges = save_num_ranges - 1 # reset before we return
                 return
                }
 
             # if old range is greater than new range, rearrange ranges & data
             else if (UVP$Range > save_range)
                {
                 temp_range = UVP$Range       # save data for larger range
                 temp_detect= UVP$DetectPb
                 temp_recog = UVP$RecognitionPb
                 temp_ident = UVP$IdentPb
 
                 UVP$Range         = save_range   # put new data in
                 UVP$DetectPb      = save_detect  # previously filled slot
                 UVP$RecognitionPb = save_recog   # for smaller range
                 UVP$IdentPb       = save_ident
 
                 save_range  = temp_range
                 save_detect = temp_detect
                 save_recog  = temp_recog
                 save_ident  = temp_ident
 
                 # increment range index and check the next range
                 UVP$NumRanges = UVP$NumRanges + 1
                }
 
             else if (UVP$Range < save_range) # range greater than prev. range
                {
                 UVP$NumRanges = UVP$NumRanges + 1  # increment and check
                }
 
            } # end while UVP$Numranges <= save_num_ranges
 
        } # end if more than one range
 
     UVP$NumRanges     = save_num_ranges # reset before putting data
 
     UVP$Range         = save_range   # put data in slot
     UVP$DetectPb      = save_detect
     UVP$RecognitionPb = save_recog
     UVP$IdentPb       = save_ident
 
    } # end if args[4] is range
 
return
end
 

subroutine femdr (nargs, args)
#####################################################################
#$%
#$% Purpose:   FEMDR processes entered "sonobuoy median detection
#$%             ranges". MDRs are loaded in sonobuoy-sorted order.
#$%
#$% Date:      6/90
#$%
#$% Author:    R. Hundt
#$%
######################################################################
 
ForceCommon
PlayCommon
integer KMDR,
        INSERT_INDEX,
        I,
        KMDR2                                       # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
integer*4   class_exists
integer*4   sonobuoy_exists
literal     Sonobuoy_Name
literal     submarine_class
 
submarine_class = args [ 4 ]
Sonobuoy_Name    = args[3]
 
#$% display response message to user
call echor
call echov (" Sonobuoy ")
call echoh (Sonobuoy_Name,$$MAXname) # jb E2141/8-char's 12/14/99
call echov (" detection against submarine class ")
call echoh (submarine_class, $$MAXname) # jb E2141/8-char's 12/14/99
 
#$% if Probability of Hit table is full
if (nmdr >= $mdr)
    {
    #$% display message that it cannot be entered and return
    call echov (" Sorry, but Median Detection Range table is full. ")
    call echor
    call echov (" Input is rejected")
    return
    }
 
call find_Submarine(Submarine_Class,class_exists)
 
if ( class_exists == $no )
    {
    call echov(", Submarine Class ")
    call echoh(Submarine_Class,$$MAXname) # jb E2141/8-char's 12/14/99
    call echov(" not valid.")
    call echor
    return
    }
 
call find_sonobuoy(Sonobuoy_Name,Sonobuoy_exists)
 
if ( Sonobuoy_exists == $no )
    {
    call echov(", Sonobuoy ")
    call echoh(Sonobuoy_Name,$$MAXname) # jb E2141/8-char's 12/14/99
    call echov(" not valid.")
    call echor
    return
    }
 
#$% for each Probability of Hit entry, loop thru all probabilities
for (MDR$Index=1; MDR$Index<=nmdr; MDR$Index=MDR$Index+1)
    {
    #$% if data already entered for this pair
    if (mdr$SonoBuoyName == SonoBuoy_Name & MDR$SubClass == Submarine_Class)
        {
        MDR$GoodENVDetectRange = args[5]
        MDR$FairENVDetectRange = args[6]
        MDR$PoorENVDetectRange = args[7]
        MDR$DefaultENVDetectRange = args[8]
        call echov (" is replaced.")
        call echor
        return
        }
    else
        {
        #$% index used to maintain a MDR array sorted by Sonobuoy name
        if ( mdr$SonoBuoyName > Sonobuoy_Name )
            {
            Break
            }
        }
    }
 
#$% index where entered data will be inserted
insert_index = MDR$Index
 
#$% for all entries higher in the sort sequence, move higher in  array
FOR ( i = nmdr; i >= Insert_Index; i = i - 1 )
    {
    MDR2$Index = i + 1
    MDR$Index = i
 
    mdr2$SonoBuoyName = mdr$SonoBuoyName
    MDR2$SubClass = MDR$SubClass
    MDR2$GoodENVDetectRange = MDR$GoodENVDetectRange
    MDR2$FairENVDetectRange = MDR$FairENVDetectRange
    MDR2$PoorENVDetectRange = MDR$PoorENVDetectRange
    MDR2$DefaultENVDetectRange = MDR$DefaultENVDetectRange
    }
 
#$% increment counter,set index and load EMCON table
nmdr = nmdr + 1
 
mdr$index = insert_index
 
mdr$SonoBuoyName = Sonobuoy_Name
MDR$SubClass = Submarine_Class
MDR$GoodENVDetectRange = args[5]
MDR$FairENVDetectRange = args[6]
MDR$PoorENVDetectRange = args[7]
MDR$DefaultENVDetectRange = args[8]
 
#$% display message that data has been entered
call echov (" has been entered.")
call echor
 
return
end
 
define($Insert_Into_IPE, INTRA$Class   = Lit_Force_Class
                         INTRA$Victim  = Lit_Force_Victim
                         INTRA$Percent = Lit_Force_Percent
                         INTRA$Culprit = Lit_Force_Culprit)

subroutine find_submarine(Name,found)
ForceCommon
integer KCLASS                                      # MJC 6/9/2K (E2145)
literal name
integer*4   found
 
found = $no
 
#$% for each class entry
for (class$index=1; class$index<=nclass; class$index = class$index+1)
    {
    if ( Name == class$name )
        {
        if ( Class$Type == 'NSUB' | Class$Type == 'DSUB' )
            {
            found = $yes
            break
            }
        }
    }
 
return
end
 

subroutine Verify_Class(Name,found)
ForceCommon
integer KCLASS                                      # MJC 6/9/2K (E2145)
literal name
integer*4   found
 
found = $no
 
#$% for each class entry
for (class$index=1; class$index<=nclass; class$index = class$index+1)
    {
    if ( Name == class$name )
        {
        found = $yes
        break
        }
    }
 
return
end
 

subroutine Verify_Air(Name,found)
ForceCommon
integer KAIR                                        # MJC 6/9/2K (E2145)
literal name
integer*4   found
 
found = $no
 
#$% for each air entry
for (Air$index=1; Air$index<=nair; Air$index = Air$index+1)
    {
    if ( Name == Air$name )
        {
        found = $yes
        break
        }
    }
 
return
end
 

subroutine find_sonobuoy(Name,found)
ForceCommon
integer KSONOB                                      # MJC 6/9/2K (E2145)
literal name
integer*4   found
 
found = $no
 
#$% for each sonob entry
for (sonob$index=1; sonob$index<=nsonob; sonob$index = sonob$index+1)
    {
    if ( Name == sonob$name )
        {
        found = $yes
        break
        }
    }
 
return
end

 
subroutine felidar (nargs, args)
 
##############################################################
#$%
#$% Purpose:   FELIDAR processes LIDAR Environment Region data.
#$%
#$% Date:      February 1991
#$%
#$% Author:    S. Miller & C. Kropp
#$%
#################################################################
 
ForceCommon
PlayCommon
integer KLDR,
        KLDRA,
        I,
        KLDRX1                                      # MJC 6/9/2K (E2145)
integer nargs
literal args[$max$args]
 
  #$% display prompt message to user
  call echov (" LIDAR Environment Region # ")
  call echoi (int(args[3]))
 
  #$% if region number is not valid
  if (args[3] < 1 | args[3] > $LIDARregions)
    {
     #$% display warning message and return
     call echov (" cannot be entered because ")
     call echoi (int(args[3]))
     call echor
     call echov (" is not a valid Region Number")
     call echor
     return
    }
 
  ldr$pointer$to args[3]
  ldr$map
 
  nldr = nldr + 1
  #$% load LIDAR Region data
  ldr$regnumber = args[3]
  ldr$Kvalue = (args[4]*0.01)
 
  #$% set points defining a LIDAR Environment Region
  i = 5
  #$% for each entry
  for (ldr$pos$index=1; ldr$pos$index<=ldr$pos$slots;
                        ldr$pos$index=ldr$pos$index+1)
    {
     #$% if maximum number of points exceeded
     if (i > nargs)
       {
        #$% set lat/long to excess
        ldr$pos$lat = 99
        ldr$pos$lon = 99
       }
     #$% else if max points not exceeded
     else
       {
        #$% load latitude and longitude
        ldr$pos$lat = args[i]
        ldr$pos$lon = args[i+1]
       }
     #$% increment counter
     i=i+2
    }
 
  #$% display message to user
  call echov (" has been entered.")
  call echor
 
return
end
 

#$% enter frequency omission plan
subroutine fenter_fom (nargs,args)
 
#####################################################
#$%
#$% Purpose:    Fenter_fom processes frequency omission plan.
#$%
#$% Date:      6/91
#$%
#$% Author:    Hundt
#$%
#####################################################
 
ForceCommon
PlayCommon
integer     KFREQ_OMISSION,
            KFREQ_OMISSION_ITEM                                     # MJC 6/9/2K (E2145)
integer*4   insert_flag
integer*4   iplan_found
integer*4   item_num
 
 
integer nargs
integer*4   overflow
literal args[$max$args],Plan_name
 
#$% get frequency action plan name
Plan_name = args[3]
 
#$% if all is entered for action plan name
if (Plan_name == 'ALL') # jb  E2141 (9-char. names) 12/14/99
    {
    #$% display warning message and return
    call echov ("Sorry, but the name ALL is reserved.  ")
    call echor
    return
    }
 
if (args[4] == $LEX$COMMPATH$)
    {
    #$% determine if freq omission plan already exists
    call chk_FOM_Plan ( Plan_Name,              # in
                        iplan_found,            # out
                        insert_flag,            # out
                        freq_omission$index)    # out,
 
    #$% if plan not found
    if (iplan_found == $no)
        {
        call chk_FOM_overflow (overflow)      # out
        if (overflow == $yes)
            {
            return
            }
 
        #$% allocate a slot and if necessary, shift remaining entries
        #$% to maintain alphabetic sequence of plans
        call allocate_FOM_plan ( insert_flag,           # in
                                 freq_omission$index)   # in
 
        freq_omission$plan_name  = Plan_name
        freq_Omission$path_name = Args [ 5 ]
        }#$% end plan not found
    else
        {
        freq_Omission$path_name = Args [ 5 ]
        }
    }
else if (args[4] == $LEX$ITEM$)
    {
    item_num = args[5]
 
    if (item_num > $MaxFomItems |
        item_num <= 0 )
        {
        #$% display warning message and return
        call echov ("Item number for ")
        call echohn(Plan_name,$$MAXname) # jb E2141 (vs '8') 12/14/99
        call echov (" is out of range.")
        call echor
        return
        }
 
    if ( args[6] >= args [7] )
        {
        #$% display warning message and return
        call echov (" For ")
        call echohn(Plan_name,$$MAXname) # jb E2141/vs '8'/ 12/14/99
        call echov (", Low frequency is greater or equal to High Frequency.")
        call echor
        return
        }
 
    #$% determine if freq omission plan already exists
    call chk_FOM_Plan ( Plan_Name,              # in
                        iplan_found,            # out
                        insert_flag,            # out
                        freq_omission$index)    # out,
 
    #$% if plan not found
    if (iplan_found == $no)
        {
        call chk_FOM_overflow (overflow)      # out
        if (overflow == $yes)
            {
            return
            }
 
        #$% allocate a slot and if necessary, shift remaining entries
        #$% to maintain alphabetic sequence of plans
        call allocate_FOM_plan ( insert_flag,           # in
                                 freq_omission$index)   # in
 
        freq_omission$plan_name  = Plan_name
 
        #$% if path name has not yet been entered
        if (freq_omission$path_name == 0)
            {
            #$% set up for formatted print
            freq_omission$path_name = $BLANKLIT
            }
 
        freq_omission$item_index = args [5]
        freq_omission$LowFreq = args[6]             # KHz
        freq_omission$HiFreq = args[7]              # KHz
        } # end plan not found
    else # else plan is found
        {
        call build_FOM_Boundaries (nargs,
                                   args,
                                   freq_omission$index)   # in
        }
    } # end if this is adding an item to the plan
 
return
end
 

#$% determine if freq omission plan already exists
subroutine chk_FOM_Plan (_
                    Plan_Name,              # in
                    plan_found,             # out
                    insert_flag,            # out, set if new plan must be inserted
                    freq_omission$index)    # out
ForceCommon
integer     LITCMP                                      # MJC 6/9/2K (E2145)
Literal     Plan_Name
integer*4   plan_found
integer*4   insert_flag
integer*4   freq_omission$index
 
plan_found = $no
insert_flag = $no
 
#$% for each freq omission plan entry
for (freq_omission$index = 1;
     freq_omission$index <= nfom;
     freq_omission$index = freq_omission$index + 1)
    {
    #$% if frequency plan already exists
    if (freq_omission$plan_name == Plan_name)
        {
        plan_found = $yes
        break
        }
    #$% if a slot is found with alphabetically greater plan name
    else if (litcmp(freq_omission$plan_name, Plan_name ) > 0 )
        {
        insert_flag = $yes
        break
        }
    }
return
end
 
 

subroutine chk_FOM_overflow (overflow)      # out
ForceCommon
integer OVERFLOW                                        # MJC 6/9/2K (E2145)
overflow = $no
 
#$% if freq omission plan table is full
if (nfom>= $fomplan)
    {
    #$% display warning message and return
    call echov ("Sorry, the Frequency Omission Plan table is full.")
    call echor
    overflow = $yes
    }
return
end
 

#$% allocate a slot and if necessary, shift remaining entries
#$% to maintain alphabetic sequence of plans
subroutine allocate_FOM_plan ( insert_flag,           # in
                               freq_omission$index)   # in
ForceCommon
integer     INSERT_FLAG,
            KFREQ2_OMISSION,
            KFREQ_OMISSION                                      # MJC 6/9/2K (E2145)
integer*2   slots_to_move
 
#$% if no freq omission slots used
if ( nfom == 0 )
    {
    nfom = 1
    }
else
    {
    #$% increment counter and save data
    nfom  = nfom + 1
 
    if (insert_flag == $yes)
        {
        #$% point to next entry
        freq_omission$index2 = freq_omission$index + 1
 
        slots_to_move = nfom - freq_omission$index
        call LIB$MOVC3 ($fomplanlen * 8 * slots_to_move,
                        freq_omission$plan_name,
                        freq_omission$plan_name2)
 
        #$% clear out the "new" slot
        call LIB$MOVC5(0,0,0,$fomplanlen * 8, freq_omission$plan_name)
        }
    else
        {
        freq_omission$index = nfom
        }
    }
 
return
end
 

subroutine build_FOM_Boundaries ( nargs,
                                  args,
                                  freq_omission$index )   # in
ForceCommon
integer     KFREQ_OMISSION_ITEM,
            KFREQ_OMISSION                                      # MJC 6/9/2K (E2145)
integer*4   nargs
Literal     args [ nargs ]
 
integer*4   icenter_freq1
integer*4   icenter_freq2
integer*4   iwidth1
integer*4   iwidth2
 
#$% loop thru boundaries to determine if frequency overlap occurs
for (freq_omission$item_index = 1;
     freq_omission$item_index <= $maxFomItems;
     freq_omission$item_index = freq_omission$item_index + 1)
    {
    if (freq_omission$LowFreq == 0 )
        {
        next
        }
 
    icenter_freq1 = (args [ 6 ] + args [ 7 ])/2.0
    iwidth1 = args [ 7 ] - args [ 6 ]
 
    icenter_freq2 = (freq_omission$HiFreq + freq_omission$LowFreq)/2.0
    iwidth2 = freq_omission$HiFreq - freq_omission$LowFreq
 
    #$% if frequency overlaps with exiting boundaries
    if ( ABS(icenter_Freq1 - icenter_Freq2) <=
         ((iwidth1 + iwidth2) / 2.0 ))
        {
        #$% display warning message and return
        call echov ("Frequency overlap with existing boundary for ")
##        call echohn(Plan_name,$$MaxLit) #jb (Not available_ 12/14/99
        call echov (", item ")
        call echoi (freq_omission$item_index)
        call echor
 
        return
        }
    } # for all freq boundaries
 
freq_omission$item_index = args [5]
 
#$% if item number is already used
if ( freq_omission$LowFreq != 0 |
     freq_omission$HiFreq != 0 )
    {
    #$% display message that input rejected and return
    call echov ("Sorry, item #")
    call echoi (freq_omission$item_index)
    call echov (" is currently in use.")
    call echor
    return
    }
else
    {
    freq_omission$item_index = args [5]
    freq_omission$LowFreq = args[6]             # KHz
    freq_omission$HiFreq = args[7]              # KHz
 
    #$% if path name has not yet been entered
    if (freq_omission$path_name == 0)
        {
        #$% set up for formatted print
        freq_omission$path_name = $BLANKLIT
        }
    }
 
return
end

 
subroutine fesquadron (squadron_name, index)
###############################################################
#$%
#$% Purpose:   fesquadron will determine if there is room in
#$%            the sqd table for the name.  If there is room
#$%            a check for uniqueness will be done.  If the
#$%            checks fail, a index value = 0 will be returned.
#$%
#$% Called By: feair
#$%
#$% Calls:     echo..
#$%
#$% Tables:    SQD
#$%
#$% Date:      April 1995
#$%
#$% Author:    Carol Kropp
#$%
###############################################################
ForceCommon
integer  KSQD,
         KSQDA                                       # MJC 6/9/2K (E2145)
literal  squadron_name
integer  index
 
logical  failure
integer  i
 
 
  failure = .false.
  index = 0     # default to an invalid index
  if (nsquadrons >= $MaxSquadrons)
    {
     call echov ("The maximum number of squadrons have been exceeded.")
     call echo  ($Bell)
     call echor
     failure = .true.
    }
  else   # there is room in the table, check the name
    {
     for (i = 1; i <= nsquadrons; i = i + 1)
       {
        SQD$Pointer$To  i
        SQD$Map
 
        if (squadron_name == SQD$SquadronName)
          {
           call echov  ("The squadron name ")
           call echohn (squadron_name, $$MaxName) # jb E2141/vs LIT/
           call echov  (" is a duplicate.")
           call echo   ($Bell)
           call echor
           failure = .true.
           break
          }     # end of if squadron name is a duplicate
       }     # end of loop through the existing squadrons
    }     # end of if/else table full
 
  if (failure == .false.)
    {
      nsquadrons = nsquadrons + 1
      SQD$Pointer$To  nsquadrons
      SQD$Map
      SQD$SquadronName = squadron_name
      index = nsquadrons
    }
 
return
end     # end fesquadron
