 ########################   RGOUTPUT.RAT   ############################
#
#  Takes data from message delay file and builds RAINFORM messages.
#
######################################################################

include "rgmain.inc"         
define (bbimplicit, implicit none)



Subroutine buildmsg
#######################################################################
###
###  Acts as executive for building appropriate RAINFORM/GOLD messages.
###
### Modified:   Jim Allen 6/03 (E2344)
###             Do not report contacts that have OTH report type
########################################################################

bbcommon
rfcommon
rgcommon
msgcommon
tmpcommon
whocommon
ptr1common
ptr2common

integer ispfirst, igdfirst, irosfirst, iwosfirst, itefirst
integer ibfcnt, imsgtype
integer status

BBDeclare(MSG$MSGTOR$I)

#call remark_v ("Subroutine buildmsg has been called")   ##debug

ispfirst = $yes
igdfirst = $yes
irosfirst = $yes
iwosfirst = $yes
itefirst = $yes

ibfcnt = 0

for (msg$pointer$first; msg$pointer$ok; msg$pointer$next)
   {
    MSG$MsgTOR$I = xMSG$MsgTOR$I 
    if (MSG$MsgTOR$I == 0) next
    
    if (MSG$MsgTOR$I > msg_minute) next

    # Do not report contacts of neutral or orange units reporting own location
    call get_status (Xmsg$tbldctee$i, status)
    if (status == $OTH$rship) next

    imsgtype = xmsg$msgtype$i
    
    if      (imsgtype == $Red$RMsg)    {call redmsg}
    else if (imsgtype == $STS$RMsg)    {call stsmsg}
    else if (imsgtype == $ESM$RMsg)    {call esmmsg}
    else if (imsgtype == $SOSUS$RMsg)  {call sosmsg}
    else if (imsgtype == $HFDF$RMsg)   {call hfdmsg}
    else if (imsgtype == $SELOR$RMsg)  {call selmsg}
   }

for (msg$pointer$first; msg$pointer$ok; msg$pointer$next)
   {
    MSG$MsgTOR$I = xMSG$MsgTOR$I 
    if (MSG$MsgTOR$I == 0) next
    
    if (MSG$MsgTOR$I > msg_minute) next

    # Do not report contacts of neutral or orange units reporting own location
    call get_status (Xmsg$tbldctee$i, status)
    if (status == $OTH$rship) next
    imsgtype = xmsg$msgtype$i

    if (imsgtype == $GHFDF$RMsg   |
        imsgtype == $GSELOR$RMsg  |
        imsgtype == $GWIZARD$RMsg |
        imsgtype == $GSOSUS$RMsg)  
       {
        igdfirst = YES
        call goldallmsg (igdfirst)
        call endln 
       }
   }

for (msg$pointer$first; msg$pointer$ok; msg$pointer$next)
   {
    MSG$MsgTOR$I = xMSG$MsgTOR$I 
    if (MSG$MsgTOR$I == 0) next
    
    if (MSG$MsgTOR$I > msg_minute) next

    # Do not report contacts of neutral or orange units reporting own location
    call get_status (Xmsg$tbldctee$i, status)
    if (status == $OTH$rship) next

    imsgtype = xmsg$msgtype$i
        
    if (imsgtype == $GOLD$RMsg   |
        imsgtype == $GOLDP$RMsg  |
        imsgtype == $GESM$RMsg   |
        imsgtype == $gsonba$rmsg |
        imsgtype == $gsonbp$rmsg |
        imsgtype == $gsontp$rmsg |
        imsgtype == $gsonp$rmsg  |
        imsgtype == $gIR$rmsg    )
       {
        igdfirst = YES
        call goldallmsg (igdfirst)
        call endln 
       }
   }

for (msg$pointer$first; msg$pointer$ok; msg$pointer$next)
   {
    MSG$MsgTOR$I = xMSG$MsgTOR$I 
    if (MSG$MsgTOR$I == 0) next

    # Do not report contacts of neutral or orange units reporting own location
    call get_status (Xmsg$tbldctee$i, status)
    if (status == $OTH$rship) next

    if (MSG$MsgTOR$I > msg_minute) next

    imsgtype = xmsg$msgtype$i

    if (imsgtype == $OSRed$RMsg |
        imsgtype == $OSRedP$RMsg ) call osredmsg (irosfirst)
   }

if (irosfirst == $no) call endln 

for (msg$pointer$first; msg$pointer$ok; msg$pointer$next)
   {
    MSG$MsgTOR$I = xMSG$MsgTOR$I 
    if (MSG$MsgTOR$I == 0) next
    
    if (MSG$MsgTOR$I > msg_minute) next

    # Do not report contacts of neutral or orange units reporting own location
    call get_status (Xmsg$tbldctee$i, status)
    if (status == $OTH$rship) next

    imsgtype = xmsg$msgtype$i

    if (imsgtype == $OSWht$RMsg |
        imsgtype == $OSWhtP$RMsg) call oswhtmsg (iwosfirst)
   }

if (iwosfirst == $no) call endln 

for (msg$pointer$first; msg$pointer$ok; msg$pointer$next)
   {
    MSG$MsgTOR$I = xMSG$MsgTOR$I 
    if (MSG$MsgTOR$I == 0) next
    
    if (MSG$MsgTOR$I > msg_minute) next

    imsgtype = xmsg$msgtype$i

    if (imsgtype == $Special$RMsg) 
       {
        ibfcnt = ibfcnt + 2     # moved down and change to 2 (from 1) since 
                                # each call generates two message lines.
                                # clf 7/22/91

        call spgldmsg (ispfirst)
        #-------------------------------------------------------------------------
        #   Messages with more than 100 lines (including address lines, etc.) will
        #   not be processed properly in JOTS and probably other TDA's.  The line
        #   count is kept to 75 of CTC and POS lines which will keep the message
        #   overall well under 100 lines.
        #-------------------------------------------------------------------------
        if (ibfcnt >= 75)  
           {
            call endln 
            ispfirst = $yes
            ibfcnt = 0        
           }
       }
   }


if (ispfirst == $no) 
   {
    call endln 
   }

return
end



Subroutine redmsg 
#####################################################################
#
#      Builds Red message and sends via network
#
####################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

BBDeclare( MSG$Sensor$I)

#call remark_v ("Subroutine redmsg has been called")  ##debug

call untype                      ## what type contact ie, air, sub, surface,
                                 ## then generate appropriate msg line
msg$sensor$i = xmsg$sensor$i
if (msg$sensor$i == $sonpas$rsens | msg$sensor$i == $tass$rsens)
   {
    call brngln
    call timln
   }
else call tmposln

call endln 

msg$zero
ioslots = ioslots + 1

return
end



Subroutine stsmsg 
#####################################################################
#
#      Builds Red Evaluated SURTAS message and sends via network
#
####################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

#call remark_v ("Subroutine stsmsg has been called")  ##debug

call untype                      ## what type contact ie, air, sub, surface,
                                 ## then generate appropriate msg line
call elipln
call timln
call endln 

msg$zero
ioslots = ioslots + 1

return
end



Subroutine esmmsg 
#####################################################################
##
##     Builds Red-ESM message and sends via network
##
#####################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

#call remark_v ("Subroutine ESMMSG has been called")    ## debug

call untype
call rdidln
call rdpaln
call brngln
call timln
call endln 

msg$zero
ioslots = ioslots + 1

return
end



Subroutine sosmsg
####################################################################
#
#      Build SOSUS Red message and sends via network
#
####################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

#call remark_v ("Subroutine SOSMSG has been called")

call untype 

if (xmsg$lines$i == $yes)  
    {
     call elipln
     call timln
    }
else
    {
     call tmposln
    }

call endln 

msg$zero
ioslots = ioslots + 1

return
end



Subroutine hfdmsg
####################################################################
#
#      Build HFDF Red message and sends via network
#
####################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

literal digraph

#call remark_v ("Subroutine HFDMSG has been called")

call msghd
call msgidln
call hfdfln (digraph)

if (xmsg$elpsexists$i == 0) call lobsln (digraph)
else                        call elipln 

call endln 

msg$zero
ioslots = ioslots + 1

return
end



Subroutine selmsg
####################################################################
#
#      Build SELOR Red message and sends via network
#
####################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

#call remark_v ("Subroutine SELMSG has been called")

call msghd
call msgidln
call idenln
call poseln

if (xmsg$selrad$i == $no)               # if ESM satellite
  {
   call rdidln
   call rdpaln
  }

call endln 

msg$zero
ioslots = ioslots + 1

return
end



Subroutine untype
#####################################################################
#
#      Builds Red message and sends via network
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common

integer status
integer  iunttype
literal cstrip8
BBDeclare(MSG$TblDctor$I, MSG$TblDctee$I,MSG$DcteeName$C)

#call remark_v ("Subroutine untype has been called")  ##debug

msg$tbldctor$i = xmsg$tbldctor$i
msg$tbldctee$i = xmsg$tbldctee$i

iunttype = xmsg$unittype$i
if      (iunttype == $Air$RType)   call airln
else if (iunttype == $Sub$RType)   call subln
else if (iunttype == $Surf$RType | iunttype == $Surfwac$RType)
   {
    if (xmsg$classified$i == $no) call unkln
    else
       {
        msg$dcteename$c = xmsg$dcteename$c
        call get_status (msg$tbldctee$i, status)
        if      (status == $mer$rship) call merln
        else if (status == $fsh$rship) call fshln
        else                           call navln 
        # if (status == $nav$rship)
#       else                           call unkln
       }
   }
else if (iunttype == $unk$rtype)   call unkln
else                               call unkln

return
end



Subroutine airln
####################################################################
#
#      Builds line AIR
#
#  modified: John McCormick 5/99 (E2087)
#            Classification from current RESA rmt table, not track #.
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

character  class[32], name[16]
integer    isize, length,iside, x   # jb E2145  9/18/00
real	   random2
BBDeclare(MSG$TblDctee$I)

#call remark_v ("Subroutine AIRLN has been called")  ## debug

call msghd 
call msgidln

ilen = 0
call smovv ("AIR/", cline, ilen)

msg$tbldctee$i = xmsg$tbldctee$i

if (xmsg$classified$i == $yes)
   {
    call get_class (msg$tbldctee$i, class)       # get a/c type
    isize = length (class)
    call smovh (class, isize, cline, ilen)         # type of a/c in msg
    call smovv ("/", cline, ilen)

    if (RGCPX$OUT == $yes | RGPOST$OUT == $yes)  
       {
        call get_name (msg$tbldctee$i, name)
        isize = length (name)
        call smovh (name, isize, cline, ilen)    
       }
    else  call smovv ("UNKNOWN", cline, ilen) 

    call smovv ("/", cline, ilen)
    call smovi (xmsg$composition$i, cline, ilen)
    call smovv ("//", cline, ilen)              # credibility

    iside = xMSG$TargetID$I          # JHM 5/99 (E2087)
                                     # get which side from rmt table  

    if      (iside == $blue$code)    call smovv ("US/", cline, ilen)
    else if (iside == $orange$code)  call smovv ("UR/", cline, ilen)
    else if (iside == $neutral$code) call smovv ("UN/", cline, ilen)
    else                             call smovv ("UN/", cline, ilen)

    call smovv ("ALT", cline, ilen)
    call smovi (xmsg$altdepth$i, cline, ilen)
    call smovv ("/", cline, ilen)
   }
else if (xmsg$msgtype$i == $esm$rmsg)
   {
    call smovv ("UNKNOWN///UN//", cline, ilen)
   }
else
   {
    call smovv ("UNKNOWN", cline, ilen)
    call smovv ("/", cline, ilen)
    call smovi (xmsg$composition$i, cline, ilen)
    call smovv ("//", cline, ilen)              # credibility
    call smovv ("UN/", cline, ilen)
    call smovv ("ALT", cline, ilen)
    call smovi (xmsg$altdepth$i, cline, ilen)
    call smovv ("/", cline, ilen)
   }

if (xmsg$classified$i == $yes)
   {
    if (random2(x) <= .75)  call smovv ("NPH", cline, ilen)
    else                   call smovv ("PHT", cline, ilen)
   }
else {call smovv ("NPH", cline, ilen)}
   
call pline 

return
end



Subroutine subln
####################################################################
#
#      Builds line SUB
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon

integer   length, get_case
character type[9], numb[8], class[32], name[16]
literal   cstrip8
integer   index, iyear, isize
BBDeclare(MSG$DcteeName$C, MSG$TblDctee$I, MSG$TblDctor$I)

call msghd 
call msgidln

ilen = 0
call smovv ("SUB/", cline, ilen)

msg$dcteename$c = xmsg$dcteename$c
msg$tbldctee$i = xmsg$tbldctee$i
msg$tbldctor$i = xmsg$tbldctor$i

if (RGTMark$IN == YES)                  # Should Trademark be included?
   {
    if (xmsg$msgtype$i == $SOSUS$RMsg)
      {
       call smovv ("CASE L", cline, ilen)
       index = get_case (msg$tbldctee$i)
#      call smovi (xmsg$sosusreg$i, cline, ilen)

#      if (xMSG$SWABStrk$I == $YES) call get_swdindx (msg$dcteename$c, index)
#      else                         call get_sosindx (msg$dcteename$c, index)
       call smoviz (index, 3, cline, ilen)
       call smovv (" ",       cline, ilen)    # JB 7/23/90
       iyear = mod(RGyear, 100)
       call smoviz (iyear, 2, cline, ilen)    # JB 7/23/90
      }                                        
   else
      {
       if (xmsg$classified$i == $yes)
          {
           call get_name (msg$tbldctee$i, name)
           isize = length (name)
           call smovh (name, isize, cline, ilen)
          }
       else
          {
           call get_type (msg$tbldctor$i, type)
           isize = length (type)
           call smovh (type, isize, cline, ilen)   
           call get_numb (msg$tbldctor$i, numb)
           isize = length (numb)
           call smovh (numb, isize, cline, ilen)    
           call smovv ("CONT", cline, ilen)
           call smovi (imnth, cline, ilen)
           call smovv ("-", cline, ilen)
           call smovi (isqnumb, cline, ilen)       # from msgcommon
          }
      }
   }

call smovv ("/POSS2/UR/", cline, ilen)

#msg$propmode$i = xmsg$propmode$i 
#if      (msg$propmode$i == $nuclear$prop) call smovv ("NUC/", cline, ilen)
#else if (msg$propmode$i == $diesel$prop)  call smovv ("DSL/", cline, ilen)
#else                                      call smovv ("UNK/", cline, ilen)

call smovv ("/", cline, ilen)

call get_class (msg$tbldctee$i, class)
isize = length (class)
call smovhn (class, isize, cline, ilen)

call smovv ("/MED/NPH", cline, ilen)

call pline 

return
end



Subroutine merln
####################################################################
#
#  Determines type of ship line to create (NAV, MER, FSH).
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

integer     equal_hv
character   name[16], type[9], class[32]
integer	    isize, length, x   # jb E2145  9/18/00
real        random2
BBDeclare(MSG$TblDctee$I)

if (xmsg$msgtype$i != $osred$rmsg & xmsg$msgtype$i != $oswht$rmsg)
   {
    call msghd 
    call msgidln
   }

msg$tbldctee$i = xmsg$tbldctee$i

ilen = 0
call smovv ("MER/", cline, ilen)

call get_name (msg$tbldctee$i, name)
isize = length (name)
call smovh (name, isize, cline, ilen)        # Name of ship

call smovv ("/", cline, ilen)

#----------------------------------------------------------------------------
#   Get the type of merchantman from the init file.  If it is listed as 
#   "UNK", the TYPE field will be left blank.
#-----------------------------------------------------------------------------
call get_type (msg$tbldctee$i, type)    
if (equal_hv(type,"UNK") == $no)
   {
    isize = length (type)
    call smovh (type, isize, cline, ilen)   
   }

call smovv ("/", cline, ilen)

call get_class (msg$tbldctee$i, class)       # used for merchant flag
isize = length (class)
call smovh (class, isize, cline, ilen)        

if (xmsg$classified$i == $yes)
   {
    if (random2(x) <= .25)  call smovv ("/NPH", cline, ilen)
    else                   call smovv ("/PHT", cline, ilen)
   }
else                       call smovv ("/NPH", cline, ilen)
   
call pline 

return
end



Subroutine fshln
####################################################################
#
#      Builds line FSH for a Rainform message.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

character   name[16], type[9], class[32], numb[8]
integer     equal_hv
integer     isize, length
BBDeclare(MSG$TblDctee$I)

#call remark_v ("Subroutine FSHLN has been called")  ## debug

if (xmsg$msgtype$i != $osred$rmsg & xmsg$msgtype$i != $oswht$rmsg)
   {
    call msghd 
    call msgidln
   }

msg$tbldctee$i = xmsg$tbldctee$i

ilen = 0
call smovv ("FSH/", cline, ilen)

call get_name (msg$tbldctee$i, name)
isize = length (name)
call smovh (name, isize, cline, ilen)        

call smovv ("/", cline, ilen)

#----------------------------------------------------------------------------
#   Get the type of fishing boat from the init file.  If it is listed as 
#   "UNK", the TYPE field will be left blank.
#-----------------------------------------------------------------------------
call get_type (msg$tbldctee$i, type)          
if (equal_hv(type,"UNK") == $no)
   {
    isize = length (type)
    call smovh (type, isize, cline, ilen)   
   }

call smovv ("/", cline, ilen)
  
call get_class (msg$tbldctee$i, class)       # used for fisherman flag
isize = length (class)
call smovh (class, isize, cline, ilen)        

call smovv ("/", cline, ilen)

call get_numb (msg$tbldctee$i, numb)        # used to get # of fishing boats
isize = length (numb)                        # in company
call smovh (numb, isize, cline, ilen)    

call pline 

return
end



Subroutine navln
####################################################################
#
#      Builds line NAV for a Rainform message.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

character  name[16], type[9]
integer    equal_hv
integer    jsize, length, isize, x   # jb E2145  9/18/00
real       random2
character  numb[8]
BBDeclare(MSG$Classified$I, MSG$TblDctee$I)

call msghd 
call msgidln

#call remark_v ("Subroutine NAVLN has been called")  ## debug

msg$classified$i = xmsg$classified$i 
msg$tbldctee$i = xmsg$tbldctee$i

ilen = 0
call smovv ("NAV/", cline, ilen)

call get_name (msg$tbldctee$i, name)
jsize = length (name)
call smovh (name, jsize, cline, ilen)         

#call smovv ("CL-", cline, ilen)
#call get_class (msg$tbldctee$i, class)
#isize = length (class)                     # Class of target
#call smovh (class, isize, cline, ilen)        

call smovv ("/", cline, ilen)

#----------------------------------------------------------------------------
#   Get the type of navy ship from the init file.  If it is listed as 
#   "UNK", the TYPE field will be left blank.
#-----------------------------------------------------------------------------
call get_type (msg$tbldctee$i, type)    
if (equal_hv(type,"UNK") == $no)
 {
  isize = length (type)
  call smovh (type, isize, cline, ilen)   
 }

call smovv ("/UR/", cline, ilen)

call get_numb (msg$tbldctee$i, numb)
isize = length (numb)
call smovh (numb, isize, cline, ilen)    
   
if (msg$classified$i == $yes)
   {
    if (random2(x) <= .50)  call smovv ("/NPH", cline, ilen)
    else                   call smovv ("/PHT", cline, ilen)
   }
else                      {call smovv ("/NPH", cline, ilen)}

call pline 

return
end



Subroutine unkln
####################################################################
#
#      Builds line UNK
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon

character name[32]
integer   jsize, length, isize
character numb[8], type[9]
BBDeclare(MSG$MsgType$I,MSG$TblDctee$I, MSG$TblDctor$I)

#call remark_v ("Subroutine UNKLN has been called")  ## debug

call msghd 
call msgidln

ilen = 0
call smovv ("UNK/", cline, ilen)

msg$msgtype$i = xmsg$msgtype$i 
msg$tbldctee$i = xmsg$tbldctee$i
msg$tbldctor$i = xmsg$tbldctor$i

if (RGTMark$IN == YES)                       # Should Trademark be included?
   {
    if (msg$msgtype$i == $gsosus$rmsg)
      {
       call smoviz (xmsg$sosusreg$i, 5, cline, ilen)
       call smovv  ("-", cline, ilen)
       call smovhn (msg$tbldctee$i, 3, cline, ilen)
      }
    else if (msg$msgtype$i == $ghfdf$rmsg | msg$msgtype$i == $gselor$rmsg)
      {
       call get_name (msg$tbldctor$i, name)
       jsize = length (name)
       call smovh (name, jsize, cline, ilen)         
       call smovv  ("CONT", cline, ilen)
       call smovi (isqnumb, cline, ilen)       # from msgcommon
      }
   else
      {
       call get_type (msg$tbldctor$i, type)
       isize = length (type)
       call smovh (type, isize, cline, ilen)   
       call get_numb (msg$tbldctor$i, numb)
       isize = length (numb)
       call smovh (numb, isize, cline, ilen)    
       call smovv ("CONT", cline, ilen)
       call smovi (imnth, cline, ilen)
       call smovv ("-", cline, ilen)
       call smovi (isqnumb, cline, ilen)       # from msgcommon
      }
   }

call smovv ("/", cline, ilen)

if      (msg$msgtype$i == $sosus$rmsg) call smovv ("SOSUS", cline, ilen)
else if (msg$msgtype$i == $esm$rmsg)   call smovv ("ESM", cline, ilen)
else if (msg$msgtype$i == $red$rmsg |
         msg$msgtype$i == $sts$rmsg)   call get_sensor

call pline 

return
end



Subroutine hfdfln (digraph)
####################################################################
#
#      Builds line HFDF
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

integer Msg_DTG
character callsign[4]
literal digraph
integer imsgtime, idtg, ickdig
BBDeclare(MSG$TblDctee$I)

#call remark_v ("Subroutine HFDFLN has been called")    ## debug

imsgtime = xmsg$senstime$i
msg$tbldctee$i = xmsg$tbldctee$i

ilen = 0
call smovv ("HFDF/", cline, ilen)

idtg = Msg_DTG (imsgtime*1.0)
call smoviz (idtg, 6, cline, ilen)
call smovv ("Z", cline, ilen)

call ckdig (idtg, ickdig)
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/", cline, ilen)

# Flash number BLANK

call smovv ("/", cline, ilen)

call get_callsign (msg$tbldctee$i, callsign)  

call smovh (callsign, 4, cline, ilen)
call smovv ("/", cline, ilen)

call smovi (xmsg$hfdfreq$i, cline, ilen)
call smovv ("HZ/", cline, ilen)

call hfdigraph (digraph)
call smovh (digraph, 2, cline, ilen)

#if (idigraph > HFDSTA_count) idigraph = 1		
#call smovh (HFDSTA_code[1,idigraph], 2, cline, ilen)	

call pline

return
end



Subroutine contactln
####################################################################
#
#      Builds line CONTACT
#
# Modified: Jim Allen - 8/98 (E2027)
#           Merchant and fishing boats reported as MER and FSH instead
#           of UNEQUATED.
#
# Modified: John McCormick - 5/99 (E2083) 
#           IFF Mode2 now output where equipment on and mode 2 set.
# 
# Modified: John McCormick - 5/99 (E2087)
#           Get classification (CTC force field) from RESA rmt
#           table rather than by track number assigned at start
#           from the initialization file.
#
# Modified: Jim Allen - 6/03 (E2348)
#           Add SCONUM, if present, to classified contact
#           
#
####################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon
whocommon

integer   length, status, equal_hv, ctoi, get_case
literal   category
character name[32], class[32], type[9], numb[8], nosic[4]
character trackcode[1], flag[4]
character nosic_name[32]
character SCONUM[7]
integer   iff_mode2_octal,base_10_to_base_8   # JHM 5/99 (E2083)
literal   cstrip8, cstrip
integer   iside, jlen, icat, isize, jsize, noctal, index, iyear
integer   ialert, inosic, itype, iran, ipnt, iforce, x   # jb E2145  9/18/00
real      random2
BBDeclare(MSG$DcteeName$c, MSG$UnitType$I, MSG$MsgType$I, MSG$Sensor$I,
	  MSG$Classified$I, MSG$FingerPrinted$I,MSG$TblDctee$I, 
	  MSG$TblDctor$I, MSG$TrackCode$C, MSG$TargetID$I,
	  MSG$IFFMode2$I, unt2$pointer)

#call remark_v ("Subroutine CONTACTLN has been called")    ## debug

msg$dcteename$c = xmsg$dcteename$c
msg$unittype$i = xmsg$unittype$i
msg$msgtype$i = xmsg$msgtype$i
if (xMSG$ROTHRtrk$I == $YES) MSG$Sensor$I = $RADAR$RSens
else                         msg$sensor$i = xmsg$sensor$i
msg$classified$i = xmsg$classified$i
msg$FingerPrinted$i  = xmsg$FingerPrinted$i
msg$tbldctee$i = xmsg$tbldctee$i
msg$tbldctor$i = xmsg$tbldctor$i
msg$trackcode$c = xmsg$trackcode$c
msg$targetID$I = xmsg$targetID$I

# The following "Side" can be overridden by Active Track
# info from the RESA RMT table              # dew (E2087)
#unt2$pointer$to msg$tbldctee$i
#call whside(Xunt2$view$i,iside)
iside = MSG$TargetId$i                 # JHM 4/03 Back to orig E2087 concept
 
jlen = 0; call smovh (msg$trackcode$c, 1, trackcode, jlen)

ilen = 0
call smovv ("CTC/", cline, ilen)      # Hardcoded line ID

##-----------------------------------------------------------------------
##   Track number for POTSHOT mode has a special numbering system, other
##   modes use the RESA/BGTT track number system.  If the contact is from
##   SELOR and has not been fingerprinted, there will be no track number.
##-----------------------------------------------------------------------
##   This code used in Navy POTSHOTS training to supress the track number
##   if the contact was from SELOR and it was NOT classified.  Now ALL
##   contacts will have a track number.
##
##if      (msg$msgtype$i == $gselor$rmsg &          # Field 1: Track Number
##         msg$FingerPrinted$i == $no)      continue
##------------------------------------------------------------------------

#---------------------------------------------------------------------------
#   Field 1 : Track Number:
# 
#             If ptrknum called, track number is "T" plus four digits
#             if trknumb called, track number same as RESA track number
#
#----------------------------------------------------------------------------
if (RGPSHOT$OUT == YES | RGPOST$OUT == YES) call ptrknum   
else                                        call trknumb   

call smovv ("/", cline, ilen)                  # Field 2: Class-name
if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92

#----------------------------------------------------------------------
#    If target is fingerprinted or classified (See rginput.rat)
#----------------------------------------------------------------------
if (msg$FingerPrinted$i == $yes | msg$classified$i == $yes)       
   {
    iside = xMSG$TargetId$i                 # Override w/RMT, DEW E2087
    icat = msg$unittype$i 

    #-------------------------------------------------------------------
    #      If target is an aircraft and classified or fingerprinted.
    #-------------------------------------------------------------------
    if (icat == $air$rtype) 
       {
        call get_class (msg$tbldctee$i, class)
        isize = length (class)

        call ambig (class, isize, RGClass$Tgt)
        call smovv ('-', cline, ilen)              
        if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92
        
        #-----------------------------------------------------------------
        # Show the init file name if running CPX or game name if tgt
        #     is not listed in the init file otherwise show it as unknown.
        #------------------------------------------------------------------
        if (RGCPX$OUT == $yes)  
           {                                         
            call get_name (msg$tbldctee$i, name)
            jsize = length (name)
            call ambig (name, jsize, RGName$Tgt)
           }
        else if (RGntds$Vue != $NO)
           {
            if (length(RGntds$Vue) == 1)         # Use RESA track
                {
                call get_octal (msg$tbldctee$i, noctal)
                call smovi (noctal, cline, ilen)                
                }                                # new naming below JA 8/98 E2027
            else  # Name for unknown tracks = <NTDStrkcode>UNK<nosic-id>
                {
                call get_nosic_name (msg$tbldctee$i, nosic_name)
                isize = length(nosic_name)
                call smovh (nosic_name, isize, cline, ilen)
                }                                # end E2027
           }
        else   call smovv ("UNKNOWN", cline, ilen)   
       }
    #-------------------------------------------------------------------
    #  Else if target is a ship or sub and classified or fingerprinted.
    #-------------------------------------------------------------------
    else                                                  
       {              
        call get_status (msg$tbldctee$i, status)
        #---------------------------------------------------------------
        #  Is it a merchant 
        #---------------------------------------------------------------
        if (status == $mer$rship)           # UFL98 JA E2027
           {
            call smovv ("MER-", cline, ilen)   # show class of target
            if (RGlive == YES) call smovv ('X', cline, ilen)   # clf 8/5/92
            call get_name (msg$tbldctee$i, name)
            jsize = length (name)
            call ambig (name, jsize, RGName$Tgt)
           }
        #---------------------------------------------------------------
        #  Is it a fisherman
        #---------------------------------------------------------------
        else if (status  == $fsh$rship)     # UFL98 JA E2027
           {
            call smovv ("FSH-", cline, ilen)   # show class of target
            if (RGlive == YES) call smovv ('X', cline, ilen)   # clf 8/5/92
            call get_name (msg$tbldctee$i, name)
            jsize = length (name)
            call ambig (name, jsize, RGName$Tgt)
           }
        #---------------------------------------------------------------
        #  Else it must be a naval surface unit or sub
        #---------------------------------------------------------------
        else
           {
            call get_class (msg$tbldctee$i, class)       
            isize = length (class)
            call ambig (class, isize, RGClass$Tgt)
            call smovv ("-", cline, ilen)             
            if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92
 
            # if (msg$FingerPrinted$i == $yes)
            if (.true.)                                     # DEW 4/5/00 (E2087)
              {
              call get_name (msg$tbldctee$i, name)
              jsize = length (name)
              call ambig (name, jsize, RGName$Tgt)
              }
            else # just classified
              {
              if (RGNtds$Vue != $NO)
                {
                if (length(RGntds$Vue) == 1)         # Use RESA track
                    {
                    call get_octal (msg$tbldctee$i, noctal)
                    call smovi (noctal, cline, ilen)                
                    }                               # JA 8/98 E2027- new naming
                else  # Name for unknown tracks = <NTDStrkcode>UNK<nosic-id>
                    {
                    call get_nosic_name (msg$tbldctee$i, nosic_name)
                    isize = length(nosic_name)
                    call smovh (nosic_name, isize, cline, ilen)
                    }            
                }
              else   call smovv ("UNKNOWN", cline, ilen)   
              }
           }
        }
   }
######################################################################
#      Else the target has NOT been classified or fingerprinted.
#######################################################################
else                                                      
   {
    #------------------------------------------------------------------
    #   Has the tgt been detected by passive sonar, including TASS 
    #   give unit class.
    #------------------------------------------------------------------
    if (msg$msgtype$i == $gsonp$rmsg | 
        msg$msgtype$i == $gsontp$rmsg)
       {
        call get_class (msg$tbldctee$i, class)       
        isize = length (class)
        call ambig (class, isize, RgClass$Tgt)
        call smovv ("-", cline, ilen)              
        if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92
       }
    #------------------------------------------------------------------
    #   If not detected by sonar/TASS...
    #------------------------------------------------------------------
    else
        {
        call smovv ("UNEQUATED-", cline, ilen)
        if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92
        }

    #------------------------------------------------------------------
    #   Is this a SOSUS detection ?
    #------------------------------------------------------------------
    if (msg$msgtype$i == $gsosus$rmsg)
       {
        call smovv ("CASE L", cline, ilen)
        index = get_case (msg$tbldctee$i)
#       call smovi (xmsg$sosusreg$i, cline, ilen)

#       if (xMSG$SWABStrk$I == $YES) call get_swdindx (msg$dcteename$c, index)
#       else                         call get_sosindx (msg$dcteename$c, index)
        call smoviz (index, 3, cline, ilen)
        call smovv (" ",       cline, ilen)    # JB 7/23/90
        iyear = mod(RGyear, 100)
        call smoviz (iyear, 2, cline, ilen)    # JB 7/23/90
       }                                        
    #------------------------------------------------------------------
    #   Is this an active sonar detection ?
    #------------------------------------------------------------------
    else if (msg$msgtype$i == $gold$rmsg & msg$sensor$i == $SonAct$RSens)
       {
        call smovv ("CASE L", cline, ilen)
        index = get_case (msg$tbldctee$i)
 
        call smoviz (index, 3, cline, ilen)
        call smovv (" ",       cline, ilen)    # JB 7/23/90
        iyear = mod(RGyear, 100)
        call smoviz (iyear, 2, cline, ilen)    # JB 7/23/90
       }                                        
    #---------------------------------------------------------------------
    #   If the tgt name is not listed in the init file, show the game name
    #----------------------------------------------------------------------
    else if (msg$tbldctee$i == notlisted) 
           call smovv ("UNKNOWN"      , cline, ilen)
    else                        
       {
        #---------------------------------------------------------------------
        #   If output is for CPX & msg type is none of the above...
        #        Put in name field "UNK" plus the Init table location
        #        E.g. UNK5, UNK32, UNK123, etc.
        #----------------------------------------------------------------------
        #-----------------------------------------------------------------
        # Show the init file name if running CPX or game name if tgt
        #     is not listed in the init file otherwise show it as unknown.
        #------------------------------------------------------------------
        if (RGCPX$OUT == $yes)
           {
            call smovv ("UNK", cline, ilen)
            call smovi (msg$tbldctee$i, cline, ilen)                
           }
        else if (RGNtds$Vue != $NO)
           {
           if (length(RGntds$Vue) == 1)         # Use RESA track
               {
               call get_octal (msg$tbldctee$i, noctal)
               call smovi (noctal, cline, ilen)                
               }                              # JA 8/98 E2027 - new naming
           else  # Name for unknown tracks = <NTDStrkcode>UNK<nosic-id>
               {
               call get_nosic_name (msg$tbldctee$i, nosic_name)
               isize = length(nosic_name)
               call smovh (nosic_name, isize, cline, ilen)
               }            
           }
        else call smovv ("UNKNOWN", cline, ilen)
       }
   }                                          # end not classified

if (equal_hv(alert_code,"NONE") == $yes) ialert = $no   # no alert field
else                                  ialert = $yes

inosic = $no        #JA 9/98 E2027

if (msg$classified$i == $yes   |     # detectee is classified or...
    msg$FingerPrinted$i == $yes)     # detectee is fingerprinted.
#----------------------------------------------------------------------------
#   If the tgt is in the init file or classified or finger printed... this 
#   leads to several other possibilities.
#----------------------------------------------------------------------------
   {
    call smovv ("//", cline, ilen)       # Field 4: Type (CG, DD, etc)

    if (msg$unittype$i != $air$rtype)       # if an aircraft, leave field blank
       {  
        call get_type (msg$tbldctee$i, type)
        if (equal_hv(type,"UNK") == $no)
           {
            isize = length (type)
            call smovh (type, isize, cline, ilen)   
           }
       }    

    call smovv ("/", cline, ilen)       # Field 5: Category (AIR, NAV, etc)

    itype = msg$unittype$i 

    if      (itype == $air$rtype)     category = 'AIR'
    else if (itype == $airsub$rtype |
             itype == $sub$rtype    ) category = 'SUB'
    else if (itype == $surf$rtype   |
             itype == $surfwac$rtype)     
           {              
            call get_status (msg$tbldctee$i, status)
            if      (status == $mer$rship)    category = 'MER'
            else if (status == $fsh$rship)    category = 'FSH'
            else if (status == $nav$rship)    category = 'NAV'
            else if (status == $navnru$rship) category = 'NAV' #JA 8/98 E2027
            else                              category = 'UNK'
           }
    else                                   category = 'UNK'
   
    call smovhn (category, 4, cline, ilen)

    call smovv ("/", cline, ilen)       # Field 6 & 7: Pendant number/Flag

    #---------------------------------------------------------------------
    #   Is the tgt a surface unit...
    #--------------------------------------------------------------------
    if (icat == $surf$rtype | icat == $surfwac$rtype)       
       {
        call get_status (msg$tbldctee$i, status)
        if (status == $nav$RShip |
            status == $navnru$rship)                     # if naval ship
           {                                             # JA 8/98 E2027
            #--------------------------------------------------------------
            #   Show the pendant number
            #   Note:  Current thinking (3/24/88) is that Soviet Bloc ship's
            #          hull numbers are useless since they change them often
            #          and sometimes put a different number on each side.  
            #          Therefore, hull numbers are commented out for now.
            #--------------------------------------------------------------
            # Revised thinking (3/27/00) is that if we have the info, 
            # share it.                     # DEW (E2111)

            call get_numb (msg$tbldctee$i, numb)
            isize = length (numb)
            call smovh (numb, isize, cline, ilen)    
            call smovv ("/", cline, ilen)
            #------------------------------------------------------------------
            #   Is the tgt US or UR... if neutral, leave the field blank
            #------------------------------------------------------------------
            if (RGex_trk == YES)
              {
              if      (msg$TargetId$i == $Friendly$code) call smovv ("YY", cline, ilen)
              else if (msg$TargetID$i == $Enemy$code)    call smovv ("XX", cline, ilen)
              else if (msg$TargetId$i == $Neutral$code)  call smovv ("ZZ", cline, ilen)
              else                                       call smovv ("  ", cline, ilen)
              }
            else
              {
              # the following "FLAG" info may be inconsistant with the
              # flag associated with the "Side" of the RMT track (if overridden)
              call get_flag (msg$tbldctee$i,flag)
              call smovh (flag, 2, cline, ilen)
              }
           }
        else if (status == $mer$rship |          # else mechant or
                 status == $fsh$rship)           # fisherman
           {                                                  
            #---------------------------------------------------------------
            #   If merchant/fisherman leave the pendant number blank, but if
            #   it is classified, show its nationality (flag)
            #---------------------------------------------------------------
            call smovv ("/", cline, ilen)
            call get_flag (msg$tbldctee$i,flag)
            call smovh (flag, 2, cline, ilen)
            #call get_class (msg$tbldctee$i, class)     
            #isize = length (class)
            #call smovh (class, isize, cline, ilen)        
          }
        else call smovv ("/UN", cline, ilen)
      }
    #---------------------------------------------------------------------
    #   Else the tgt a sub or aircraft unit...
    #--------------------------------------------------------------------
    else                                                   # if a/c, sub
       {
       call smovv ("/", cline, ilen)
       if (RGex_trk == YES)
         {
         if      (msg$TargetId$i == $Friendly$code) call smovv ("YY", cline, ilen)
         else if (msg$TargetID$i == $Enemy$code)    call smovv ("XX", cline, ilen)
         else if (msg$TargetId$i == $Neutral$code)  call smovv ("ZZ", cline, ilen)
         else                                       call smovv ("  ", cline, ilen)
         }
       else
         {
         # the following "FLAG" info may be inconsistant with the
         # flag associated with the "Side" of the RMT track (if overridden)
         call get_flag (msg$tbldctee$i,flag)
         call smovh (flag, 2, cline, ilen)
         }
       }

    call smovv ("/", cline, ilen)       # Field 8: SCONUM
    call get_SCONUM(msg$tbldctee$i, SCONUM)
    call smovhn (SCONUM, 6, cline, ilen)
    }
else
   {
    #---------------------------------------------------------------------
    #   Else the tgt is not listed in the init file or is not classified nor
    #   fingerprinted...BUT there is an Alert field.
    #----------------------------------------------------------------------
    if (msg$unittype$i == $air$rtype) 
        call smovv ("///AIR///", cline, ilen)
    else                               
        call smovv ("//////", cline, ilen)
    }

if (inosic == $yes)           # have nosic nbr
    {
    iran = int(random2(x) * 100)

    call smovi (iran, cline, ilen)           # random one digit number

    index = msg$tbldctee$i
    call get_nosic (index, nosic)

    ipnt = 1
    inosic = ctoi (nosic, ipnt)             # convert to integer
    inosic = inosic - iran                  # disguise inosic

    call smoviz (inosic, 4, cline, ilen)
    }

  MSG$IFFMode2$i = xMSG$IFFMode2$i   #JHM 5/99 (E2083), iff mode 2 
    if (MSG$IFFMode2$i > 0)
       {
        call smovv ("/", cline, ilen)
        iff_mode2_octal =  base_10_to_base_8(MSG$IFFMode2$i)
        call smoviz(iff_mode2_octal,4,cline,ilen)
        call smovv ("/", cline, ilen)
       } 
    else          
       call smovv ("//", cline, ilen)   # end JHM 5/99 (E2083)
 
if (ialert == $yes)
    call smovh (alert_code, 3, cline, ilen)

call smovv ("/", cline, ilen)

# Field 11 - Force Code (mandatory)
itype = msg$unittype$i 
if (msg$FingerPrinted$i == $yes | msg$classified$i == $yes |
    msg$targetID$I != $Unknown$Code)       
    {
    if      (itype == $air$rtype)
        {
        if      (msg$targetID$i == $Friendly$code)   iforce = $FC$air$friendly
        else if (msg$targetID$i == $Enemy$code)      iforce = $FC$air$hostile
        else if (msg$targetID$i == $Neutral$code)    iforce = $FC$air$neutral
        else                                         iforce = $FC$air$unknown
        }
    else if (itype == $airsub$rtype |
             itype == $sub$rtype    )
        {
        if      (msg$targetID$i == $Friendly$code)   iforce = $FC$sub$friendly
        else if (msg$targetID$i == $Enemy$code)      iforce = $FC$sub$hostile
        else if (msg$targetID$i == $Neutral$code)    iforce = $FC$sub$neutral
        else                                         iforce = $FC$sub$unknown
        }
    else if (itype == $surf$rtype   |
             itype == $surfwac$rtype)     
        {
        if      (msg$targetID$i == $Friendly$code)   iforce = $FC$surf$friendly
        else if (msg$targetID$i == $Enemy$code)      iforce = $FC$surf$hostile
        else if (msg$targetID$i == $Neutral$code)    iforce = $FC$surf$neutral
        else                                         iforce = $FC$surf$unknown
        }
    else                                iforce = $FC$unk$unknown
    }
else
    {
    if      (itype == $air$rtype)     iforce = $FC$air$unknown
    else if (itype == $airsub$rtype |
             itype == $sub$rtype    ) iforce = $FC$sub$unknown
    else if (itype == $surf$rtype   | 
             itype == $surfwac$rtype) iforce = $FC$surf$unknown
    else                              iforce = $FC$unk$unknown
    }
call smoviz (iforce, 2, cline, ilen)
#if (RGex_trk == YES)                tmb always send this 9-5-17
    call smovv  ("//3",  cline, ilen)
                            # Indicate simulated training  track  -- clf 8/5/92

call pline

return
end



Subroutine get_octal (idigit, noctal)
########################################################################
#
#  Purpose:  Provides an octal value output for decimal value input.
#  
#  By:  Jim Kvederis
#
#  Date:  5 December 1988
#
#########################################################################
implicit none
integer   ctoi
character onumb[7], bdigit[5]
integer   kdigit, idigit, ldigit, ilen, itoc, ii, k, j
integer   ipnt, noctal


#-----------------------------------------------------------------------
#   NTDS track numbers must be between 128 and 4094 (200 and 7776 octal).
#   OTH-T GOLD unique platform numbers go from 1 to 400.  By adding 128 
#   and multiplying by 6 gives a range of NTDS track numbers from 768 to 
#   3768 (1400 to 7270 octal).  This puts the OTH-T GOLD
#   generator fairly well in the middle of the NTDS track number range.
#------------------------------------------------------------------------
kdigit = idigit + 128
ldigit = kdigit * 6
        
ilen = itoc (ldigit, bdigit, 5)
ilen = ilen + 1

#call echor; call echor
#call echov ("Input digit # = ")
#call echoi (idigit)
#call echor
#call echov ("Bdigit = ")
#call echoh (bdigit, 5)
#call echor
#call echov ("The Octal Value Is: ")

ii = 0
for (k=(ilen-1)*3; k>=0; k=k-3)
   {
    j = istrip (ldigit, k, M3Bits)
    call smov ((j+$dig0), onumb, ii)
   }

ipnt = 1
noctal = ctoi (onumb, ipnt)             # convert to integer

return
end




Subroutine ambig (unit, isize, iambig)
########################################################################
#
#  Purpose:  Creates ambiguous name of class or unit for non-Blue units.
#  
#  By:  Jim Kvederis
#
#  Date:  5 Feb 88
#
#########################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

character unit[32], ambigunit[32]
integer   krand, iambig, irand, isize, klen, x   # jb E2145  9/18/00
real      random2

krand = INT(random2(x)*100.)

if (krand < iambig)  # if class/name to be ambiguous
   {
    irand = INT(random2(x)*7.)
    if      (irand <= 4) call dropchars  (unit, isize, ambigunit, klen)
    else if (irand == 5) call transpose (unit, isize, ambigunit, klen)
    else                 call garblechars (unit, isize, ambigunit, klen)

    call smovh (ambigunit, klen, cline, ilen)     # Garbaged class/name 
   }    
else  call smovh (unit, isize, cline, ilen)       # Good name/class

return
end



Subroutine aircat
####################################################################
#
#  Puts "type" field in CTC line for aircraft
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

integer nair

nair = xmsg$airtype$i

if      (nair == $helo$acc)   call smovv ("HELO", cline, ilen)
else if (nair == $prop$acc)   call smovv ("PROP", cline, ilen)
else if (nair == $jet$acc)    call smovv ("JET", cline, ilen)
else                          call smovv ("UNK", cline, ilen)

return
end




Subroutine goldallmsg (igdfirst)
#####################################################################
#
#      Builds GOLD message types and sends them via the network.
#
####################################################################

bbcommon
rfcommon
rgcommon
msgcommon
ptr2common

integer imsgtype, isensor, igdfirst, ibfl

#call remark_v ("Subroutine goldallmsg has been called")  ##debug

imsgtype = xmsg$msgtype$i
if (xMSG$ROTHRtrk$I == $YES) isensor = $RADAR$RSens
else                         isensor = xmsg$sensor$i  

if (igdfirst == $yes)
   {
    call msghd
    call msgidln
    igdfirst = $no
   }

call contactln

ibfl = $no

if (imsgtype == $gesm$rmsg) 
   {
    call radln
    call lobln
   }
else if ((imsgtype == $gselor$rmsg | imsgtype == $gwizard$rmsg) & 
           (xmsg$selrad$i == $no))
  {
   call posln
   call radln
  }
else if (imsgtype == $gsonbp$rmsg | imsgtype == $gsonp$rmsg |
        (imsgtype == $ghfdf$rmsg & xMSG$ElpsExists$I == $no))
  {
   call lobln
   }
else  
   {   
    call posln  
   }

if (RGTruePos$Rmks == $yes | RGDetector$Rmks == $yes) call rmksln (ibfl)

#if (rgrmks$out == YES) call rmksln

msg$zero
ioslots = ioslots + 1

return
end



Subroutine osredmsg (irosfirst)
######################################################################
###
### This Subroutine is used to generate OSIS RED messages.
###
########################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

integer status
integer irosfirst
BBDeclare(MSG$TblDctee$I)

#call remark_v ("Subroutine redosis has been called")

msg$tbldctee$i = xmsg$tbldctee$i

if (irosfirst == $yes)
   {
    call msghd 
    call msgidln
    irosfirst = $no
   }

call get_status (msg$tbldctee$i, status)
if      (status == $mer$rship) {call merln}
else if (status == $fsh$rship) {call fshln}
#else                           {call unkln}

call tmposln

msg$zero
ioslots = ioslots + 1

return
end



Subroutine oswhtmsg (iwosfirst)
######################################################################
###
### This Subroutine is used to generate OSIS White messages.
###
########################################################################

bbcommon
rgcommon
rfcommon
msgcommon
ptr2common

integer status
integer iwosfirst
BBDeclare(MSG$TblDctee$I)

#call remark_v ("Subroutine whtosis has been called")


msg$tbldctee$i = xmsg$tbldctee$i

if (iwosfirst == $yes)
   {
    call msghd 
    call msgidln
    iwosfirst = $no
   }

#if (imsgtype == $OSRedP$RMsg)
#   {
#    call depart_msg
#
#    msg$zero
#    ioslots = ioslots + 1
#   }
#else

call get_status (msg$tbldctee$i, status)
if      (status == $mer$rship) {call merln}
else if (status == $fsh$rship) {call fshln}

call tmposln

msg$zero
ioslots = ioslots + 1

return
end



Subroutine spgldmsg (ispfirst)
####################################################################
#
#      Builds CONTACT line for BFLOC - GOLD format
#
#  modified: 5/99 John McCormick (E2083) 
#            Includes mode2 output now.
#
#            5/99 John McCormick (E2103)
#            Speed zero needs to be sent to GCCS
#            
#            6/03 Jim Allen (E2344)
#            Blue is friendly; neutral is neutral; orange is hostile
####################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon
auditcommon

integer   length, equal_hv, Msg_DTG
literal   category
REAL      range, alat,along, tlat,tlong, bearing # jb E2207 vs literal  9/18/00
character name[32], class[32], type[9], numb[8]
character ambigname[32], stime[8], trulat[7], trulong[8]
character abearing[4], arange[4], detectee[6]
integer   iff_mode2_octal,base_10_to_base_8   # JHM 5/99 (E2083)
integer   ispfirst, jsize, krand, irand, klen, inosic, isize
integer   icat, i_switch_1, ialert, itype, iforce, imsgtime, idtg
integer   ii, ickdig, iformat, iaudit, len, i, ibearing, jj
integer   imiles, ibfl, x   # jb E2145 (x)  9/18/00
integer   iside
real	  random2
literal   cstrip8
character ambigclass[32], flag[4], nosic[4], applat[7], applong[8]
character tline[7]
BBDeclare(MSG$UnitType$I, MSG$MSGType$I, MSG$Sensor$I, 
	  MSG$TblDctee$I, MSG$Classified$I, MSG$IFFMode2$I,
	  MSG$Course$I, MSG$Speed$I, MSG$AltDepth$I, unt2$pointer)

#call remark_v ("Subroutine SPGLDMSG has been called")    ## debug

if (ispfirst == $yes)
   {
    call msghd 
    call msgidln
    ispfirst = $no
   }

msg$unittype$i = xmsg$unittype$i
msg$msgtype$i = xmsg$msgtype$i
msg$sensor$i = xmsg$sensor$i
msg$tbldctee$i = xmsg$tbldctee$i

unt2$pointer$to msg$tbldctee$i
call whside(Xunt2$view$i,iside)

ilen = 0
call smovv ("CTC/", cline, ilen)      # Hardcoded line ID

call ptrknum                             # Field 1: Track number

call smovv ("/", cline, ilen)         # Field 2: Class-name
if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92

msg$classified$i = xmsg$classified$i

call get_class (msg$tbldctee$i, class)
jsize = length (class)

#-----------------------------------------------------------------------
#   Make the BFLOC unit name ambiguous in one of three ways:
#      1.  Add "USS" to the ship name.
#      2.  Transpose characters.
#      3.  Drop characters/words such as:
#          a. First and middle names.
#          b. One character when to adjacent characters are the same.
#          c. A character at random.
#      4.  Garble characters.
#-----------------------------------------------------------------------
krand = INT(random2(x)*100.)

if (krand < RGClass$Blu)  # if name to be ambiguous
   {
    irand = INT(random2(x)*8.)
    if      (irand <= 4) call dropchars  (class, jsize, ambigclass, klen)
    else if (irand == 5) 
       {
        klen = 0
        call smovv ("USS ", ambigclass, klen)           # add "USS"
        call smovh (class, jsize, ambigclass, klen)        # class of Blue ship
       }
    else if (irand == 6) call transpose (class, jsize, ambigclass, klen)
    else                 call garblechars (class, jsize, ambigclass, klen)

    call smovh (ambigclass, klen, cline, ilen)     # Garbaged class of Blue ship
   }    
else call smovh (class, jsize, cline, ilen)        # Class of Blue ship

call smovv ("-", cline, ilen)              
if (RGlive == YES) call smovv ('X', cline, ilen)     # clf 8/5/92

call get_name (msg$tbldctee$i, name)
jsize = length (name)

krand = INT(random2(x)*100.)

if (krand < RGName$Blu)  # if name to be ambiguous
   {
    irand = INT(random2(x)*8.)
    if      (irand <= 4) call dropchars  (name, jsize, ambigname, klen)
    else if (irand == 5) 
       {
        klen = 0
        call smovv ("USS ", ambigname, klen)           # add "USS"
        call smovh (name, jsize, ambigname, klen)         # Name of Blue ship
       }
    else if (irand == 6) call transpose (name, jsize, ambigname, klen)
    else                 call garblechars (name, jsize, ambigname, klen)

    call smovh (ambigname, klen, cline, ilen)     # Garbaged name of Blue ship
   }    
else  call smovh (name, jsize, cline, ilen)        # Good name of Blue ship

call smovv ("//", cline, ilen)                     

inosic = $no
  
msg$unittype$i  = xmsg$unittype$i 

call get_type (msg$tbldctee$i, type)        # Field 4: Type (CG, DD, etc)
isize = length (type)
call smovh (type, isize, cline, ilen)   

call smovv ("/", cline, ilen)       # Field 5: Category (AIR, NAV, etc)

icat = msg$unittype$i 

switch (icat)     
   {
    case $air$rtype:                  {category = 'AIR'}
    case $sub$rtype:                  {category = 'SUB'}
    case $surf$rtype, $surfwac$rtype: {category = 'NAV'}
    default:                          {category = 'UNK'}
   }

call smovhn (category, 4, cline, ilen)

call smovv ("/", cline, ilen)            # Field 6 & 7: Pendant number/Flag

if (icat == $surf$rtype | icat == $surfwac$rtype |   # if surface
    icat == $sub$rtype)                     # or subsurf -- clf 7/27/93
   {
    call get_numb (msg$tbldctee$i, numb)
    if (equal_hv(numb,"UNKNOWN") == $yes | 
        equal_hv(numb,"UNK") == $yes )  call smovv ('/', cline, ilen)
    else
       {
        isize = length (numb)
        call smovh (numb, isize, cline, ilen)    
        call smovv ("/", cline, ilen)
       }
   }
else call smovv ("/", cline, ilen)

if (RGex_trk == YES)
  {
         if      (iside == $blue$code)   call smovv ("YY", cline, ilen)
         else if (iside == $orange$code) call smovv ("XX", cline, ilen)
         else                            call smovv ("ZZ", cline, ilen)
  }
else
  {
  call get_flag (msg$tbldctee$i,flag)
  call smovh (flag, 2, cline, ilen)
  }

if (equal_hv(alert_code,"NONE") == $yes) ialert = $no   # no alert field
else                                  ialert = $yes

if ((inosic == $yes) & (ialert == $yes)) # have nosic nbr & alert field 
   {
    call smovv ("/", cline, ilen)
    index = msg$tbldctee$i
    call get_nosic (index, nosic)
    klen = length(nosic)
    call smovhn (nosic, klen, cline, ilen)

    MSG$IFFMode2$i = xMSG$IFFMode2$i   #JHM 5/99 (E2083)
    if (MSG$IFFMode2$i > 0)            # include mode2 output if applicable
       {
        call smovv ("/", cline, ilen)
        iff_mode2_octal = base_10_to_base_8(MSG$IFFMode2$i)
        call smoviz(iff_mode2_octal,4,cline,ilen)
        call smovv ("/", cline, ilen)
       } 
    else          
       call smovv ("//", cline, ilen)   # end  JHM 5/99 (E2083)
   
    call smovh (alert_code, 3, cline, ilen)
   }
else if ((inosic == $no) & (ialert == $yes))
   {
    MSG$IFFMode2$i = xMSG$IFFMode2$i    #JHM 5/99 (E2083)
    if (MSG$IFFMode2$i > 0)
       {
        call smovv ("//", cline, ilen)
        iff_mode2_octal = base_10_to_base_8(MSG$IFFMode2$i)
        call smoviz(iff_mode2_octal,4,cline,ilen)
        call smovv ("/", cline, ilen)
       } 
    else          
       call smovv ("///", cline, ilen)  # end JHM 5/99 (E2083)
   
    call smovh (alert_code, 3, cline, ilen)
   }
else if ((inosic == $yes) & (ialert == $no))
   {
    call smovv ("/", cline, ilen)
    index = msg$tbldctee$i
    call get_nosic (index, nosic)
    klen = length(nosic)
    call smovhn (nosic, klen, cline, ilen)

    MSG$IFFMode2$i = xMSG$IFFMode2$i         # JHM 5/99 (E2083)
    if (MSG$IFFMode2$i > 0)
       {
        call smovv ("/", cline, ilen)
        iff_mode2_octal = base_10_to_base_8(MSG$IFFMode2$i)
        call smoviz(iff_mode2_octal,4,cline,ilen)
        call smovv ("/", cline, ilen)
       } 
    else          
      call smovv ("//", cline, ilen)          # end (E2083)
   }
else  #  (inosic == $no) & (ialert == $no)     # clf 8/19/92
   {
    MSG$IFFMode2$i = xMSG$IFFMode2$i          #JHM 5/99 (E2083)
    if (MSG$IFFMode2$i > 0)
       {
        call smovv ("//", cline, ilen)
        iff_mode2_octal = base_10_to_base_8(MSG$IFFMode2$i)
        call smoviz(iff_mode2_octal,4,cline,ilen)
        call smovv ("/", cline, ilen)
       } 
    else          
     call smovv ("///", cline, ilen)         # end (E2083)
   }

# Field 11 - Force Code (mandatory)            # clf 8/19/92  
call smovv ('/', cline, ilen)                   # clf 8/19/92

itype = msg$unittype$i                         # clf 8/19/92
if (iside == $Blue$code)
{
    if      (itype == $air$rtype)     iforce = $FC$air$friendly  # clf 8/19/92
    else if (itype == $airsub$rtype |                            # clf 8/19/92
             itype == $sub$rtype    ) iforce = $FC$sub$friendly  # clf 8/19/92
    else if (itype == $surf$rtype   |                            # clf 8/19/92 
             itype == $surfwac$rtype) iforce = $FC$surf$friendly # clf 8/19/92
    else                              iforce = $FC$unk$unknown   # clf 8/19/92
}
else if (iside == $Orange$code)
{
    if      (itype == $air$rtype)     iforce = $FC$air$hostile
    else if (itype == $airsub$rtype |                         
             itype == $sub$rtype    ) iforce = $FC$sub$hostile
    else if (itype == $surf$rtype   |                         
             itype == $surfwac$rtype) iforce = $FC$surf$hostile
    else                              iforce = $FC$unk$unknown 
}
else
{
    if      (itype == $air$rtype)     iforce = $FC$air$neutral
    else if (itype == $airsub$rtype |                         
             itype == $sub$rtype    ) iforce = $FC$sub$neutral
    else if (itype == $surf$rtype   |                         
             itype == $surfwac$rtype) iforce = $FC$surf$neutral
    else                              iforce = $FC$unk$unknown
}
call smoviz (iforce, 2, cline, ilen)                         # clf 8/19/92  

if (RGex_trk == YES)
    call smovv  ("//3",  cline, ilen)
                            # Indicate simulated training  track  -- clf 8/5/92
call pline

ilen = 0
call smovv ("POS/", cline, ilen)

imsgtime = xmsg$senstime$i                      # get DTG
idtg = Msg_DTG (imsgtime*1.0)                   # JA 8/98 E2023
ii = 0
call smoviz (idtg, 6, stime, ii)	
call smovv ("Z", stime, ii)

call smovh (stime, 7, cline, ilen)    
call ckdig (idtg, ickdig)                # get checksum
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/", cline, ilen)

call smovh (mnth, 3, cline, ilen)             #field 2 - month

call smovv ("/", cline, ilen)

alat = xmsg$latitude$f
along = xmsg$longitude$f
tlat = xmsg$truelat$f
tlong = xmsg$TrueLong$f

iformat = cksum$nocomma
call latlon (alat, along, iformat)
call smovh (posit(2), 7, cline, ilen)     # latitude
call smovv ("/", cline, ilen)   
call smovh (posit(4), 8, cline, ilen)     # longitude

#----------------------------------------------------------------------------
#   (RGAudit$Msg == $yes) is used when an audit trail is desired for postgame 
#   analysis.  The first two characters determine the sensor source (in this,
#   OW for OWN).  They are concatonated to four digits that make up a unique 
#   number for each Blue unit.  The message generator NOSIC number is used for 
#   this purpose.  This combined alphanumeric is placed in the SENSOR SOURCE 
#   field of the POS line.
#-------------------------------------------------------------------------
if (RGAudit$Msg == $yes) 
   {
    call smovv ("/OW", cline, ilen)
    index = msg$tbldctee$i

    iaudit = index + mod(idtg,10000)
    call smoviz (iaudit, 4, cline, ilen)
#   iran = int(random2(x) * 10)
#   if (iran == 10) iran = 1           # don't want a 2 digit #, i.e. 10

#   iaudit = index + iran                # make so audit # always different

#   call smoviz (iaudit, 3, cline, ilen)
#   call smovi (iran, cline, ilen)
   }
else   call smovv ("/OWN", cline, ilen)

#---------------------------------------------------------------------
#   Put data in trupos file
#--------------------------------------------------------------------
if (RGTruPos$Out == YES)
   {
    ii = 0; call smoviz (index, 3, audit, ii)
    len = 3
    for (i=1; i<=len; i=i+1) call putch (audit[i], RGTruBlu$File)
#    call putlin (audit, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    ii = 0; call smovhn (xmsg$dcteename$c, $$MaxName, detectee, ii) # SMM 11/99 E2141
    call putlin (detectee, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    iformat = $nocksumcomma
    #iformat = comma$nocksum
    call latlon (tlat, tlong, iformat)
    ii = 0; call smovh (posit(2), 7, trulat, ii)     # true latitude
    call putlin (trulat, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    ii = 0; call smovh (posit(4), 8, trulong, ii)    # true longitude
    call putlin (trulong, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    iformat = $nocksumcomma
    #iformat = comma$nocksum
    call latlon (alat, along, iformat)
    ii = 0; call smovh (posit(2), 7, applat, ii)    # apparent latitude
    call putlin (applat, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    ii = 0; call smovh (posit(4), 8, applong, ii)   # apparent longitude
    call putlin (applong, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    call rll2rb (tlat,tlong,COS(tlat),alat, along, COS(alat),
                 range,bearing)

    call ang2PI(bearing)		

    ibearing = bearing * (180./$pi) + .5
    ii = 0; call smoviz (ibearing, 3, abearing, ii)
    ii = 0; call smovf (range, 2, arange, ii)

    call putlin (abearing, RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 
    call putlin (arange, RGTruBlu$File)

    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 
    call putlin_v ("XXXXX", RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    call putlin_v ("BFL", RGTruBlu$File)
    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 
    call putlin (stime, RGTruBlu$File)                # Time of Event

    if (iform == 1) call putlin_v (".....", RGTruBlu$File)
    else            call putlin_v (",", RGTruBlu$File) 

    idtg = Msg_DTG (msg_minute*1.0)	# Changed to Msg_DTG 
    jj = 0                          # 8/98 E2023
    call smoviz (idtg, 6, tline, jj)
    call smovv ("Z", tline, jj)

    call putlin (tline, RGTruBlu$File)               # Time of Receipt
    call putlin (NEWLINE, RGTruBlu$File)
   }

switch (icat)     
   {
    case $air$rtype:                  {imiles = 10}
    case $sub$rtype:                  {imiles = 1}
    case $surf$rtype, $surfwac$rtype: {imiles = 1}
    default:                          {imiles = 25}
   }

call smovv ("/000T/", cline, ilen)
call smovi (imiles, cline, ilen)
call smovv ("NM/", cline, ilen)
call smovi (imiles, cline, ilen)
call smovv ("NM/", cline, ilen)

msg$course$i = xmsg$course$i
msg$speed$i = xmsg$speed$i

#if (msg$speed$i > 0)   jhm 5/99 speed_zero needs sending (E2103)
#   {
    call smoviz (msg$course$i, 3, cline, ilen)
    call smovv ("T/", cline, ilen)
    call smovi (msg$speed$i, cline, ilen)
    call smovv ("K", cline, ilen)
 #  }              end  jhm 5/99 (E2103)
#else call smovv ("/", cline, ilen)

msg$altdepth$i = xmsg$altdepth$i
if (msg$altdepth$i > 0)
   {
    if (xmsg$unittype$i == $Air$RType)  
       {
        call smovv  ("/", cline, ilen)
        call smovv  ("ALT", cline, ilen)
        call smoviz (msg$altdepth$i, 3, cline, ilen)
       }  
    else if (xmsg$unittype$i == $Sub$RType)
       {
        call smovv ("/", cline, ilen)
        call smovi (msg$altdepth$i, cline, ilen)
        call smovv ("FT", cline, ilen)
       }
    else if (RGTruePos$Rmks == $yes) call smovv ("/", cline, ilen)
   }

call pline

ibfl = $yes
if (RGTruePos$Rmks == $yes | RGDetector$Rmks == $yes) call rmksln (ibfl)

msg$zero
ioslots = ioslots + 1

return
end



Subroutine msghd
######################################################################
###
### This is Subroutine msghd which is used to generate an address
### heading for each rainform message that is made up.
###
########################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon

integer length, Msg_DTG 
integer icount / 0 /
integer isecret, itmsg, idtg, iyear, isize, jsize
integer ksize, lsize, msize, nsize
BBDeclare(MSG$MsgType$I)

msg$msgtype$i = xmsg$msgtype$i
if (msg$msgtype$i == $esm$rmsg  | 
    msg$msgtype$i == $gesm$rmsg |
    msg$msgtype$i == $selor$rmsg|
    msg$msgtype$i == $gwizard$rmsg|
    msg$msgtype$i == $gselor$rmsg) isecret = YES
else                               isecret = NO

ilen = 0
if (RGPSHOT$OUT == YES | RGPOST$OUT == YES) 
   {
    if (isecret == YES) call smovv ("ZNY SSSSS", cline, ilen)
    else                call smovv ("ZNY CCCCC", cline, ilen)
   }
else 
   {
    call smovv ("VZCZCNMAA", cline, ilen)
    icount = icount + 1   
    call smoviz (icount, 5, cline, ilen)
   }
call pline 

ilen = 0
call smovv ("O ", cline, ilen)
itmsg = xmsg$msgdtg$i 
idtg = Msg_DTG (itmsg*1.0)	                   # Changed to Msg_DTG 
call smoviz (idtg, 6, cline, ilen)		       # JA 8/98 E2023
call smovv ("Z ", cline, ilen)		
call smovhn (mnth, 3, cline, ilen)
call smovv (" ",       cline, ilen)    # JB 7/23/90
iyear = mod(RGyear, 100)
call smoviz (iyear, 2, cline, ilen)    # JB 7/23/90
call pline 

ilen = 0
call smovv ("FM ", cline, ilen)

isize = length (bforig_txt)
jsize = length (rforig_txt)
# SMM 6/00 tassorig_txt not referenced anyplace else
# in RG rat or inc files.
#ksize = length (tassorig_txt)
lsize = length (stsorig_txt)
msize = length (gldorig_txt)
nsize = length (gesmorig_txt)

msg$msgtype$i = xmsg$msgtype$i
if (msg$msgtype$i == $gold$rmsg    |
    msg$msgtype$i == $gsosus$rmsg  |
    msg$msgtype$i == $ghfdf$rmsg   |
    msg$msgtype$i == $gsonba$rmsg  |
    msg$msgtype$i == $gsonbp$rmsg  |
    msg$msgtype$i == $gsontp$rmsg  |
    msg$msgtype$i == $gsonp$rmsg)
     {
      call smovh (gldorig_txt, msize, cline, ilen)  # gold msgs
     }
else if (msg$msgtype$i == $gesm$rmsg    |
         msg$msgtype$i == $gwizard$rmsg |
         msg$msgtype$i == $gselor$rmsg)  
     {
      call smovh (gesmorig_txt, nsize, cline, ilen)
     }
else if (msg$msgtype$i == $special$rmsg)                # bfl msgs
     {
      call smovh (bforig_txt, isize, cline, ilen)
     }
else if (msg$msgtype$i == $sts$rmsg | msg$msgtype$i == $gsontp$rmsg) 
     {
      call smovh (stsorig_txt, lsize, cline, ilen)
     }
else
     {
      call smovh (rforig_txt, jsize, cline, ilen)      # Red msgs
     }

call pline 

ksize = length (actadd_txt)

ilen = 0
call smovv ("TO ", cline, ilen)
call smovh (actadd_txt, ksize, cline, ilen)
call pline 

ilen = 0
call smovv ("BT", cline, ilen)
call pline 

ilen = 0
if (isecret == YES) call smovv ("SECRET", cline, ilen)
else                call smovv ("CONFIDENTIAL", cline, ilen)

call pline

return
end



Subroutine msgidln 
####################################################################
#
#      Builds line MSGID
#
#   5/23/90 Modified the MSGID line, Command Field so that all
#   GOLD ELINT msgs have one Command ID (FOSIC PAC) while all the
#   other GOLD msgs have another Command ID (FOTC PAC).  This is needed
#   in the FDDS so it will filter out ELINT msgs and POST will filter
#   out non-ELINT msgs.
#
####################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon
whocommon

integer length, isos[10], ihfd[max$unts], isel[max$unts], irednum[max$unts]
integer lampnum[max$unts, max$unts]
character name[32]
integer IGLD        / 0 /
integer ISOSNUM     / 0 /
integer IHFDNUM     / 0 /
integer ISELNUM     / 0 /
integer IOSREDNUM   / 0 /
integer IOSWHTNUM   / 0 /
literal cstrip8
integer iamp, isize, iampnum, ipnt, kpnt
BBDeclare(MSG$DctorName$C, MSG$MsgType$I, MSG$TblDctor$I, MSG$TblDctee$I)

#call remark_v ("Subroutine MSGIDLN has been called")  ##debug

#ilen = 0
#call smovv ("Detector/Detectee = ", cline, ilen)
#call smovi (xmsg$tbldctor$i, cline, ilen)
#call smovv (" / ", cline, ilen)
#call smovi (xmsg$tbldctee$i, cline, ilen)
#call pline

msg$dctorname$c = xmsg$dctorname$c
msg$msgtype$i = xmsg$msgtype$i 
msg$tbldctor$i = xmsg$tbldctor$i
msg$tbldctee$i = xmsg$tbldctee$i

iamp = NO

ilen = 0
call smovv ("MSGID/", cline, ilen)

if (msg$msgtype$i == $sosus$rmsg)
   {
    call smovv ("SOS ", cline, ilen)
    call smoviz (xmsg$sosusreg$i, 3, cline, ilen)
   }
else if (msg$msgtype$i == $Red$RMsg     |       # moved up 8/19/91 -clf
         msg$msgtype$i == $ESM$RMsg     |
         msg$msgtype$i == $STS$RMsg     )
   {
    call get_name (msg$tbldctor$i, name)
    isize = length (name)
    call smovh (name, isize, cline, ilen)   
   }

else if (msg$msgtype$i == $gsosus$rmsg & xMSG$SWABStrk$I == $YES)
    call smovh (MSG_reporters[1,$GSWABS$RMsg], 16, cline, ilen)
else call smovh (MSG_reporters[1,MSG$MsgType$I], 16, cline, ilen)
call smovv ("/", cline, ilen)
#########################################################
# END of detector field                                 #
#########################################################

if (msg$msgtype$i == $gold$rmsg    |
    msg$msgtype$i == $gesm$rmsg    |
    msg$msgtype$i == $gsosus$rmsg  |
    msg$msgtype$i == $ghfdf$rmsg   |
    msg$msgtype$i == $gselor$rmsg  |
    msg$msgtype$i == $gwizard$rmsg |
    msg$msgtype$i == $gsonba$rmsg  |
    msg$msgtype$i == $gsonbp$rmsg  |
    msg$msgtype$i == $gsontp$rmsg  |
    msg$msgtype$i == $gsonp$rmsg   |
    msg$msgtype$i == $gIR$rmsg     |
    msg$msgtype$i == $special$rmsg)
   {
    call smovv ("GOLD/", cline, ilen)
    igld = igld + 1
#   itotgld = 1000 + igld
    call smoviz(igld, 4, cline, ilen)      # start at 1 vs 1001 clf 8/5/92
   }
else if (msg$msgtype$i == $sosus$rmsg) 
   {
    call smovv ("SOSUS RED/", cline, ilen)

    isosnum = isosnum + 1
    
    call smovi (isosnum, cline, ilen)

    isos[sosregion] = isos[sosregion] + 1
    if (isos[sosregion] > 1) 
       {
        iamp = YES
        iampnum = isos[sosregion] 
       }
   }
else if (msg$msgtype$i == $hfdf$rmsg)
   {
    call smovv ("HFDF RED/", cline, ilen)

    ihfdnum = ihfdnum + 1
    
    call smovi (ihfdnum, cline, ilen)

    ihfd[msg$tbldctee$i] = ihfd[msg$tbldctee$i] + 1
    if (ihfd[msg$tbldctee$i] > 1) 
       {
        iamp = YES
        iampnum = ihfd[msg$tbldctee$i] - 1
       }
   }
else if (msg$msgtype$i == $selor$rmsg)
   {
    call smovv ("SELOR RED/", cline, ilen)

    iselnum = iselnum + 1
    
    call smovi (iselnum, cline, ilen)

    isel[msg$tbldctee$i] = isel[msg$tbldctee$i] + 1
    if (isel[msg$tbldctee$i] > 1) 
       {
        iamp = YES
        iampnum = isel[msg$tbldctee$i] - 1
       }
   }
else if (msg$msgtype$i == $osred$rmsg)
   {
    call smovv ("OSIS RED/", cline, ilen)

    iosrednum = iosrednum + 1
    
    call smovi (iosrednum, cline, ilen)
   }
else if (msg$msgtype$i == $oswht$rmsg)
   {
    call smovv ("OSIS WHITE/", cline, ilen)

    ioswhtnum = ioswhtnum + 1
    
    call smovi (ioswhtnum, cline, ilen)
   }
else 
   {
    call smovv ("RED/", cline, ilen)
        
    if (msg$tbldctor$i < max$unts) 
       {
        irednum[msg$tbldctor$i] = irednum[msg$tbldctor$i] + 1
        call smovi (irednum[msg$tbldctor$i], cline, ilen)
       }

    #--------------------------------------------------------------
    #  If both detector and detectee are in the Initialization File.
    #--------------------------------------------------------------
    if (msg$tbldctor$i < max$unts & msg$tbldctee$i < max$unts) 
       {
        ipnt = msg$tbldctor$i        
        kpnt = msg$tbldctee$i        
        lampnum[kpnt, ipnt] = lampnum[kpnt, ipnt] + 1
        isqnumb = lampnum[kpnt, ipnt]                # put into msgcommon

        if (lampnum[kpnt, ipnt] > 1) 
           {
            iamp = YES
            iampnum = lampnum[kpnt, ipnt] - 1
           }
       }
    }

call smovv ("/", cline, ilen)
call smovhn (mnth, 3, cline, ilen)
call smovv ("/", cline, ilen)

#if (msg$msgtype$i == $special$rmsg) 
#   {
#    call smovv ("BLUE FORCE LOCATOR", cline, ilen)
#   }
#else

isize = length (OPNAME_txt)
call smovh (OPNAME_txt, isize, cline, ilen)

#--------------------------------------------------------------------
#   Formerly used with Navy POTSHOT Program for track ID purposes.
#--------------------------------------------------------------------
#if ((RGPSHOT$OUT == YES) & (msg$msgtype$i != $special$rmsg))
#   {
#    call smovv ("-", cline, ilen)
#    idnumb = msg$tbldctee$i
#    call smovi (idnumb, cline, ilen)
#   }

if (iamp == YES) 
   {
    call smovv ("/AMP/", cline, ilen)
    call smovi(iampnum, cline, ilen)
   }

call pline 

return
end



Subroutine msgid_tacrep
####################################################################
#
#      Builds line a MSGID line for TACREP messages.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon

character name[32]
integer isize, length
BBDeclare(MSG$TblDctor$I)

msg$tbldctor$i = xmsg$tbldctor$i

ilen = 0
call smovv ("MSGID/", cline, ilen)

call smovv ("TACREP/", cline, ilen)

call get_name (msg$tbldctor$i, name)
isize = length (name)
call smovh (name, isize, cline, ilen)   

#jsize = length (rforig_txt)
#call smovh (rforig_txt, jsize, cline, ilen)

call smovv ("//", cline, ilen)

call pline 

return
end



Subroutine tmposln
####################################################################
#
#      Builds line TMPOS
#
####################################################################

bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon

REAL    tlat, tlon  # jb E2207  (vice literal, for LATLON)  9/18/00
integer Msg_DTG
integer imsgtime, idtg, ickdig, itype, iformat

ilen = 0
call smovv ("TMPOS/", cline, ilen)

imsgtime = xmsg$senstime$i
idtg = Msg_DTG (imsgtime*1.0)     # from game_dtg, JA 8/98 E2023
call smoviz (idtg, 6, cline, ilen)	
call smovv ("Z", cline, ilen)

call ckdig (idtg, ickdig)
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/", cline, ilen)

itype = xmsg$sensor$i 

if (itype == $SonPas$RSens) 
   {
    call smovv ("///", cline, ilen)
    call smovv ("SONPAS", cline, ilen)
   }
else if (itype == $ESM$RSens) 
   {
    call smovv ("///", cline, ilen)
    call smovv ("ESM", cline, ilen)
   }
else if (itype == $AESM$RSens) 
   {
    call smovv ("///", cline, ilen)
    call smovv ("AESM", cline, ilen)
   }
else
   {     
    tlat = xmsg$latitude$f
    tlon = xmsg$longitude$f
    iformat = cksum$nocomma
    call latlon (tlat, tlon, iformat)
    call smovh (posit(2), 7, cline, ilen)    # latitude
    call smovv ("/", cline, ilen)
    call smovh (posit(4), 8, cline, ilen)    # longitude
    call smovv ("/FIXED/", cline, ilen)

    if      (itype == $SOSUS$RSens)  call smovv ("SOSUS1//", cline, ilen)
    else if (itype == $SWABS$RSens)  call smovv ("SWABS//", cline, ilen)
    else if (itype == $SonAct$RSens) call smovv ("SONACT//", cline, ilen)
    else if (itype == $RADAR$RSens)  call smovv ("RADAR//", cline, ilen)
    else if (itype == $Visual$RSens) call smovv ("VISUAL//", cline, ilen)
    else                             call smovv ("//", cline, ilen)

    call smoviz (xmsg$course$i, 3, cline, ilen)         	
    call smovv ("T/", cline, ilen)         

    call smovi (xmsg$speed$i, cline, ilen)          
    call smovv ("K", cline, ilen)
    }

call pline 

return
end



Subroutine idenln
####################################################################
#
#      Builds line IDENT
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

literal category
character nosic[4], numb[4], name[32], class[32]
integer status, equal_hv
literal cstrip8
integer icat, i_switch_1, isize, length, jsize
BBDeclare(MSG$FingerPrinted$I, MSG$Classified$I, MSG$DcteeName$C,
	  MSG$TblDctee$I)

ilen = 0
call smovv ("IDENT/", cline, ilen)

msg$FingerPrinted$i = xmsg$FingerPrinted$i
msg$classified$i = xmsg$classified$i
msg$dcteename$c = xmsg$dcteename$c
msg$tbldctee$i = xmsg$tbldctee$i
icat = xmsg$unittype$i     

if (msg$FingerPrinted$i == $yes | msg$classified$i == $yes)       
   {
    call get_nosic (msg$tbldctee$i, nosic)        
    call smovhn (nosic, 4, cline, ilen)
   }

call smovv ("/", cline, ilen)

switch (icat)     
   {
    case $Surf$RType, $Surfwac$RType:  
       {
        call get_status (msg$tbldctee$i, status)
        if      (status == $mer$rship) {category = 'MER'}
        else if (status == $fsh$rship) {category = 'FSH'}
        else if (status == $nav$RShip) {category = 'NAV'}
        else if (status == $navnru$RShip) {category = 'NAV'} # JA 8/98 E2023
        else                           {category = 'UNK'}
       }
        
    case $Air$RType:                   {category = 'AIR'}              
    case $Sub$RType,$airsub$rtype:     {category = 'SUB'}              
    default:                           {category = 'UNK'}
   }

call smovh (category, 3, cline, ilen)       # field 2 - type/category

call smovv ("/", cline, ilen)

#----------------------------------------------------------------------
#      If target is fingerprinted or classified (See rginput.rat)
#----------------------------------------------------------------------
if (msg$FingerPrinted$i == $yes | msg$classified$i == $yes)       
   {
    #-------------------------------------------------------------------
    #      If target is an aircraft and classified or fingerprinted.
    #-------------------------------------------------------------------
    if (icat == $air$rtype) 
       {
        call get_class (msg$tbldctee$i, class)
        isize = length (class)

        call ambig (class, isize, RGClass$Tgt)       # field 3 - class
        call smovv ("/", cline, ilen)              
        
        #-----------------------------------------------------------------
        # Show the init file name if running CPX or game name if tgt
        #     is not listed in the init file otherwise show it as unknown.
        #------------------------------------------------------------------
        if (RGCPX$OUT == $yes)                      # field 4 - name
           {                                         
            call get_name (msg$tbldctee$i, name)
            jsize = length (name)
            call ambig (name, jsize, RGName$Tgt)
           }
        else if (msg$tbldctee$i == notlisted) 
               call smovhn (msg$dcteename$c, $$MaxName, cline, ilen) # SMM 11/99 E2141
        else   call smovv ("UNKNOWN", cline, ilen)   
       }
    #-------------------------------------------------------------------
    #  Else if target is a ship or sub and classified or fingerprinted.
    #-------------------------------------------------------------------
    else                                                  
       {              
        call get_status (msg$tbldctee$i, status)
        #---------------------------------------------------------------
        #  Is it a merchantman or fisherman
        #---------------------------------------------------------------
        if (status == $mer$rship | status == $fsh$rship)   
           {
            call smovv ("UNEQUATED/", cline, ilen)   # field 3 - class 
            call get_name (msg$tbldctee$i, name)
            jsize = length (name)
            call ambig (name, jsize, RGName$Tgt)         # field 4 - name

            call smovv ("//", cline, ilen)            # field 5 - pend nbr

            call get_class (msg$tbldctee$i, class)       # field 6 - flag
            if (equal_hv(class,"UNEQUATED") == $yes)        # for merchants, class
               {                                         # field in init file 
                call smovv ("UN", cline, ilen)        # used for flag
               }    
           else
              {
               isize = length (class)
               call smovh (class, isize, cline, ilen)    
               }
            call smovv ("/1", cline, ilen)
           }
        #---------------------------------------------------------------
        #  Else it must be a naval surface unit or sub
        #---------------------------------------------------------------
        else
           {
            call get_class (msg$tbldctee$i, class)       
            isize = length (class)
            call ambig (class, isize, RGClass$Tgt)    # field 3 - class
            call smovv ("/", cline, ilen)             
 
            call get_name (msg$tbldctee$i, name)
            jsize = length (name)
            call ambig (name, jsize, RGName$Tgt)      # field 4 - name

            call get_numb (msg$tbldctee$i, numb)      # field 5 - pendant nbr
            if (equal_hv(numb,"UNKNOWN") == $yes | equal_hv(numb,"UNK") == $yes) 
               {
                call smovv ("/", cline, ilen)
               }    
            else
               {
                isize = length (numb)
                call smovh (numb, isize, cline, ilen)    
                call smovv ("/", cline, ilen)
               }
 
            call smovv ("UR/1", cline, ilen)
           }
       }                   # end else ship or sub
   }                   # end if classified or fingerprinted
######################################################################
#      Else the target has not been classified or fingerprinted.
#######################################################################
else                                                      
   {
    call smovv ("UNEQUATED/", cline, ilen)            # field 3 - class
    #---------------------------------------------------------------------
    #   If the tgt name is not listed in the init file, show the game name
    #----------------------------------------------------------------------
    if (msg$tbldctee$i == notlisted)                      # field 4 - name
           call smovhn (msg$dcteename$c, $$MaxName, cline, ilen) # SMM 11/99 E2141
    else                        
       {
        #---------------------------------------------------------------------
        #   If output is for CPX & msg type is none of the above...
        #        Put in name field "UNK" plus the Init table location
        #        E.g. UNK5, UNK32, UNK123, etc.
        #----------------------------------------------------------------------
        if (RGCPX$OUT == $yes)
           {
            call smovv ("UNK", cline, ilen)
            call smovi (msg$tbldctee$i, cline, ilen)                
           }
        else call smovv ("UNKNOWN", cline, ilen)
       }
   }                                          # end not classified

call pline

return
end



Subroutine poseln
####################################################################
#
#      Builds POSEL (Position-Ellipse) line for SELOR msgs.
#
####################################################################

bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon

REAL    tlat, tlon  # jb E2207  (vice literal, for LATLON)  9/18/00
integer Msg_DTG
integer imsgtime, idtg, ickdig, iformat

ilen = 0
call smovv ("POSEL/", cline, ilen)

imsgtime = xmsg$senstime$i                   # get sensor time
idtg = Msg_DTG (imsgtime*1.0)                # from game_dtg, JA 8/98 E2023
call smoviz (idtg, 6, cline, ilen)
call smovv ("Z", cline, ilen)
    
call ckdig (idtg, ickdig)              # gt checksum
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/", cline, ilen)

tlat = xmsg$latitude$f
tlon = xmsg$longitude$f
iformat = cksum$nocomma
call latlon (tlat, tlon, iformat)
call smovh (posit(2), 7, cline, ilen)     # latitude
call smovv ("/", cline, ilen)   
call smovh (posit(4), 8, cline, ilen)     # longitude
call smovv ("/", cline, ilen)

call smoviz (xmsg$bearing$i, 3, cline, ilen)
call smovv ("T/", cline, ilen)         # Changed for OSISB 11/3/83
#call smovv (".0T/", cline, ilen)      # Originally entered for TFCC
call smovi (xmsg$majoraxis$i, cline, ilen)                
call smovv ("NM/", cline, ilen)
call smovi (xmsg$minoraxis$i, cline, ilen)
call smovv ("NM", cline, ilen)

call pline

return
end



Subroutine posln
####################################################################
#
#      Builds POS (Position) line for GOLD msgs
#
####################################################################
bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon
auditcommon

REAL      range, alat,along, tlat,tlong, bearing # jb E2207 vs literal  9/18/00
integer Msg_DTG
character callsign[4], trulat[7], trulong[8], detector[8], detectee[8]
character stime[8], applat[7], applong[8], abearing[4], arange[4]
integer imsgtime, idtg, ii, ickdig, iformat, imsgtype, i_switch_1
integer iaudit, len, i, ibearing, jj, iaou, iplatype, x  # E2145  x  9/18/00
real    random2
literal cstrip8
character tline[7]
BBDeclare(MSG$TblDctee$I, MSG$Sensor$I, MSG$DcteeName$C,
	  MSG$Bearing$I, MSG$MajorAxis$I, MSG$MinorAxis$I,
	  MSG$Course$I, MSG$Speed$I, MSG$AltDepth$I)

msg$tbldctee$i = xmsg$tbldctee$i

ilen = 0
call smovv ("POS/", cline, ilen)

imsgtime = xmsg$senstime$i                      # get DTG
idtg = Msg_DTG (imsgtime*1.0)                   # from game_dtg, JA 8/98 E2023
ii = 0
call smoviz (idtg, 6, stime, ii)	
call smovv ("Z", stime, ii)

call smovh (stime, 7, cline, ilen)    
call ckdig (idtg, ickdig)                # get checksum
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/", cline, ilen)

call smovh (mnth, 3, cline, ilen)             #field 2 - month

call smovv ("/", cline, ilen)

alat = xmsg$latitude$f
along = xmsg$longitude$f
tlat = xmsg$truelat$f
tlong = xmsg$truelong$f

iformat = cksum$nocomma

#-----------------------------------------------------------------------
#   Miss latitude and/or longitude on a random basis if desired.
#-----------------------------------------------------------------------
call latlon (alat, along, iformat)

if (RGMiss$Pos == YES)
   {
    if (int(random2(x)*100.) <= RGMiss$Lat) call smovv ("/", cline, ilen)   
    else
       {
        call smovh (posit(2), 7, cline, ilen)     # latitude
        call smovv ("/", cline, ilen)   
       }
    if (int(random2(x)*100.) <= RGMiss$Long) call smovv ("/", cline, ilen)   
    else
       {
        call smovh (posit(4), 8, cline, ilen)     # longitude
        call smovv ("/", cline, ilen)
       }
   }
else
   {
    call smovh (posit(2), 7, cline, ilen)     # latitude
    call smovv ("/", cline, ilen)   
    call smovh (posit(4), 8, cline, ilen)     # longitude
    call smovv ("/", cline, ilen)
    }

if (xMSG$ROTHRtrk$I == $YES) MSG$Sensor$I = $RADAR$RSens
else                         msg$sensor$i = xmsg$sensor$i

imsgtype = xMsg$MsgType$i 

#----------------------------------------------------------------------------
#   (RGAudit$Msg == $yes) is used when an audit trail is desired for postgame 
#   analysis.  The first two characters determine the sensor source e.g. SE 
#   for SELOR, ES for ESM, etc.  They are concatonated to four digits that 
#   make up a unique number for each contact.  The message generator NOSIC 
#   number is used for this purpose.  This combined alphanumeric is placed in 
#   the SENSOR SOURCE field of the POS or LOB line.
#-------------------------------------------------------------------------
if (RGAudit$Msg == $yes)             # & (rgpost$out == $no))
   {
    switch (imsgtype)
      {
       case $GSELOR$RMsg:  {call smovv ("SE", cline, ilen)}
       case $GWIZARD$RMsg: {call smovv ("WI", cline, ilen)}
       case $GHFDF$RMsg:   {call smovv ("HU", cline, ilen)}
       case $GSOSUS$RMsg:
           {
           if (xMSG$SWABStrk$I == $YES) call smovv ("SW", cline, ilen)
           else                         call smovv ("SO", cline, ilen)
           }
       case $gsontp$rmsg:  {call smovv ("ST", cline, ilen)}
       case $gsonba$rmsg:  {call smovv ("DC", cline, ilen)}
       case $GOLD$RMsg:    {call get_sensor}
       case $gIR$rmsg:     {call smovv ("IR", cline, ilen)}
       default:            {call smovv ("OT", cline, ilen)}
      }
    #----------------------------------------------------------------------
    #   For index numbers <= 900 allows for an encoding of source number.
    #   Higher numbers have to use the index number without encoding because
    #   of field size limitations.  The source field is restricted to a total
    #   of six characters, 2 alpha and 4 numeric.
    #-----------------------------------------------------------------------
    index = msg$tbldctee$i

    iaudit = index + mod(idtg,10000)
    call smoviz (iaudit, 4, cline, ilen)
   }
else 
   {
    switch (imsgtype)
     {
      case $GSELOR$RMsg:  {call smovv ("SELOR", cline, ilen)}
      case $GWIZARD$RMsg: {call smovv ("WIZARD", cline, ilen)}
      case $GHFDF$RMsg:   {call smovv ("HFDF", cline, ilen)}
      case $GSOSUS$RMsg:
          {
          if (xMSG$SWABStrk$I == $YES) call smovv ("SWABS1", cline, ilen)
          else                         call smovv ("SOSUS1", cline, ilen)
          }
      case $gsontp$rmsg:  {call smovv ("SURTAS", cline, ilen)}
      case $gsonba$rmsg:  {call smovv ("DICASS", cline, ilen)}
      case $GOLD$RMsg:    {call get_sensor}
      case $gIR$rmsg:     {call smovv ("IR", cline, ilen)}
      default:            {call smovv ("OTHER ", cline, ilen)}
     }
   }
#---------------------------------------------------------------------
#   Put data in trupos file
#--------------------------------------------------------------------
if (RGTruPos$Out == YES)
   {
    ii = 0; call smoviz (index, 4, audit, ii)
    len = 4
    for (i=1; i<=len; i=i+1) call putch (audit[i], RGTruTrk$File)
#    call putlin (audit, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    MSG$dcteename$C = xMSG$dcteename$C
    ii = 0; call smovhn (MSG$dcteename$C, $$MaxName, detectee, ii) # SMM 11/99 E2141
    call putlin (detectee, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    iformat = $nocksumcomma
    #iformat = comma$nocksum
    call latlon (tlat, tlong, iformat)
    ii = 0; call smovh (posit(2), 7, trulat, ii)     # true latitude
    call putlin (trulat, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovh (posit(4), 8, trulong, ii)    # true longitude
    call putlin (trulong, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    iformat = $nocksumcomma
    #iformat = comma$nocksum
    call latlon (alat, along, iformat)
    ii = 0; call smovh (posit(2), 7, applat, ii)    # apparent latitude
    call putlin (applat, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovh (posit(4), 8, applong, ii)   # apparent longitude
    call putlin (applong, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    call rll2rb (tlat, tlong, COS(tlat), alat, along, COS(alat),
                 range, bearing)

    call ang2PI(bearing)		

    ibearing = bearing * (180./$pi) + .5
    ii = 0; call smoviz (ibearing, 3, abearing, ii)
    ii = 0; call smovf (range, 2, arange, ii)

    call putlin (abearing, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 
    call putlin (arange, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovhn (xmsg$dctorname$c, $$MaxName, detector, ii) # SMM 11/99 E2141
    call putlin (detector, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    call putlin_v ("POS", RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 
    call putlin (stime, RGTruTrk$File)      # Time of Event (TOE)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    idtg = Msg_DTG (msg_minute*1.0)	# Changed to Msg_DTG 
    jj = 0                          # from game_dtg, JA 8/98 E2023
    call smoviz (idtg, 6, tline, jj)
    call smovv ("Z", tline, jj)

    call putlin (tline, RGTruTrk$File)      # Time of Receipt (TOR)
    call putlin (NEWLINE, RGTruTrk$File)
   }

#----------------------------------------------------------------------------
#   Area of uncertainty (AOU)
#
#   If contact is from a ship sensor, the AOU is 9 nm.  For contacts from
#   aircraft sensors, the AOU is 15 nm.  This is IAW Afloat Correlation 
#   Operating Procedures, CINLANTFLT/CINCPACFLT TACNOTE UT-4012-1-87.  For 
#   other sensors (HFDF, SURVSAT, SOSUS) the AOU is variable.
#--------------------------------------------------------------------------
msg$bearing$i   = xmsg$bearing$i
msg$majoraxis$i = xmsg$majoraxis$i
msg$minoraxis$i = xmsg$minoraxis$i
msg$course$i = xmsg$course$i
msg$speed$i = xmsg$speed$i
MSG$Sensor$I = xMSG$Sensor$I

if (imsgtype == $GOLD$RMsg | imsgtype == $gsonba$rmsg |
    imsgtype == $gIR$rmsg )                # From ship, a/c sensors
   {
    if (MSG$Sensor$I == $LIDAR$Rsens | MSG$Sensor$I == $MAD$Rsens)
      iaou = 1                                 # 1 mi. aou -- clf 10/9/92
    else
      {
      iplatype = xmsg$plattype$i
      if (iplatype == $Air$RType) iaou = 15
      else                        iaou = 9
      }

    call smovv ("/", cline, ilen)
    call smovv ("000T/", cline, ilen)     
    call smovi (iaou, cline, ilen)                
    call smovv ("NM/", cline, ilen)
    call smovi (iaou, cline, ilen)
    call smovv ("NM", cline, ilen)
   }
else                                         # From SURVSAT,HFDF, SOSUS
   {
    if (msg$majoraxis$i == 0 & msg$minoraxis$i == 0) 
       {
        if (msg$course$i == 0 & msg$speed$i == 0) 
           {
            if (RGTruePos$Rmks == $yes) call smovv ("///////", cline, ilen)
             # continue
           }
        else call smovv ("///", cline, ilen)
       }
    else
       {
        call smovv ("/", cline, ilen)
        call smoviz (msg$bearing$i, 3, cline, ilen)
        call smovv ("T/", cline, ilen)     
        call smovi (msg$majoraxis$i, cline, ilen)                
        call smovv ("NM/", cline, ilen)
        call smovi (msg$minoraxis$i, cline, ilen)
        call smovv ("NM", cline, ilen)
       }
   }

#if (msg$speed$i == 0)    #jhm 5/99 zero_speed per 
#   {
#    if (RGTruePos$Rmks == $yes) call smovv ("///", cline, ilen)
#    if (imsgtype == $GSONTP$RMsg | msg$sensor$i == $SonPas$RSens) continue
#   }
#else
#   {
    if (imsgtype == $GOLD$RMsg   | imsgtype == $GWIZARD$RMsg | 
        imsgtype == $GSELOR$RMsg | imsgtype == $GSONBA$RMsg  |
        imsgtype == $gIR$rmsg    | imsgtype == $GSOSUS$RMsg)
       {
        call smovv ("/", cline, ilen)
        call smoviz (msg$course$i, 3, cline, ilen)
        call smovv ("T/", cline, ilen)
        call smovi (msg$speed$i, cline, ilen)
        call smovv ("K", cline, ilen)

        msg$altdepth$i = xmsg$altdepth$i
        if (msg$altdepth$i <= 0)
           {
            if (RGTruePos$Rmks == $yes)
                call smovv ("/", cline, ilen)   
           }
        else if (xmsg$unittype$i == $Air$RType)  
          {
           call smovv ("/",    cline, ilen)
           if (xMSG$ROTHRtrk$I == $no)
               {
               call smovv ("ALT",        cline, ilen)
               call smovi (xmsg$altdepth$i, cline, ilen)
               }
          }  
        else if ((xmsg$unittype$i == $Sub$RType  & 
                 xmsg$sensor$i == $SonAct$RSens ) |
                 xmsg$sensor$i == $LIDAR$RSens |
                 xmsg$sensor$i == $MAD$RSens |
                 imsgtype == $GSOSUS$RMsg)
           {
            call smovv ("/",            cline, ilen)
            call smovi (msg$altdepth$i, cline, ilen)
            call smovv ("FT",        cline, ilen)
           }  
      # }  jhm 5/99 zero speed per
   }

if (RGTruePos$Rmks == $yes)
   {
    call smovv ("//", cline, ilen)   

    msg$tbldctee$i = xmsg$tbldctee$i
    call get_callsign (msg$tbldctee$i, callsign)  
    call smovh (callsign, 4, cline, ilen)
   }

call pline

return
end



Subroutine rmksln (ibfl)
####################################################################
#
#      Builds RMKS (Remarks) line for GOLD msgs.
#
#      Modified:  
#               John McCormick 5/99 (E2086)
#               Correction of extra backslash being sent for
#               detectorrmks line of OTG.
#
#               Jim Allen 6/03 (E2344)
#               Send long detector name instead of nosic id
####################################################################
bbcommon
rfcommon
rgcommon
msgcommon
ptr2common
tmpcommon

integer Msg_DTG
integer ibfl, imsgtype, imsgtime, idtg, iformat, i_switch_1
integer iaudit
integer isize, length
character name[32]
literal cstrip8
REAL    tlat, tlong  # jb E2207  (vice literal, for LATLON)  9/18/00
BBDeclare(MSG$Sensor$I, MSG$TblDctee$I, MSG$TblDctor$I, 
	  SAT$Pointer, SAT$SatelliteName$C)

if (RGTruePos$Rmks == $yes | ibfl == $NO)
    {
    ilen = 0
    call smovv ("RMKS/", cline, ilen)
    if (RGTruePos$Rmks == $yes)
        {
        tlat = xmsg$truelat$f
        tlong = xmsg$truelong$f
        imsgtype = xMsg$MsgType$i 
        msg$sensor$i = xmsg$sensor$i
        msg$tbldctee$i = xmsg$tbldctee$i
        imsgtime = xmsg$senstime$i                      # get DTG
        idtg = Msg_DTG (imsgtime*1.0)                   # from game_dtg, JA 8/98 E2023

        iformat = cksum$nocomma
        call latlon (tlat, tlong, iformat)
        call smovh (posit(2), 7, cline, ilen)     # true latitude
        call smovv ("/", cline, ilen)   
        call smovh (posit(4), 8, cline, ilen)     # true longitude
        call smovv ("/", cline, ilen)   

        if (ibfl == $yes) imsgtype = $Special$RMsg 

        if (RGAudit$Msg == $yes)             # & (rgpost$out == $no))
            {
            switch (imsgtype)
                {
                case $gsonbp$RMsg:  {call smovv ("DF", cline, ilen)}
                case $gsonp$RMsg:   {call smovv ("SP", cline, ilen)}
                case $gesm$RMsg:    
                    {
                    if      (msg$sensor$i == $esm$rsens)  
                                        call smovv ("ES",cline,ilen)
                    else if (msg$sensor$i == $aesm$rsens) 
                                        call smovv ("AE", cline,ilen)
                    }
                case $GSELOR$RMsg:  {call smovv ("SE", cline, ilen)}
                case $GWIZARD$RMsg: {call smovv ("WI", cline, ilen)}
                case $GHFDF$RMsg:   {call smovv ("HU", cline, ilen)}
                case $GSOSUS$RMsg:
                    {
                    if (xMSG$SWABStrk$I == $YES) call smovv ("SW", cline, ilen)
                    else                         call smovv ("SO", cline, ilen)
                    }
                case $gsontp$rmsg:  {call smovv ("ST", cline, ilen)}
                case $gsonba$rmsg:  {call smovv ("DC", cline, ilen)}
                case $gIR$rmsg:     {call smovv ("IR", cline, ilen)}
                case $Special$RMsg: {call smovv ("OW", cline, ilen)}
                case $GOLD$RMsg:    {call get_sensor}
                default:            {call smovv ("OT", cline, ilen)}
                }
            iaudit = msg$tbldctee$i + mod(idtg,10000)
            call smoviz (iaudit, 4, cline, ilen)
            }
        else 
            {
            switch (imsgtype)
                {
                case $GSELOR$RMsg:  {call smovv ("SELOR", cline, ilen)}
                case $GWIZARD$RMsg: {call smovv ("WIZARD", cline, ilen)}
                case $GHFDF$RMsg:   {call smovv ("HFDF", cline, ilen)}
                case $GSOSUS$RMsg:
                    {
                    if (xMSG$SWABStrk$I == $YES) call smovv ("SWABS1", cline, ilen)
                    else                         call smovv ("SOSUS1", cline, ilen)
                    }
                case $gsontp$rmsg:  {call smovv ("SURTAS", cline, ilen)}
                case $gsonba$rmsg:  {call smovv ("DICASS", cline, ilen)}
                case $gIR$rmsg:     {call smovv ("IR", cline, ilen)}
                case $Special$RMsg: {call smovv ("OWN", cline, ilen)}
                case $GOLD$RMsg:    {call get_sensor}
                default:            {call smovv ("OTHER ", cline, ilen)}
                }
            }

        }
    if (RGDetector$Rmks == $yes & ibfl == $NO)
        {
        if (RGTruePos$Rmks == $yes)
            call smovv ('/', cline, ilen)   #JHM 5/99 (E2086)
        MSG$TblDctor$I = xMSG$TblDctor$I
        if (imsgtype == $GWIZARD$RMsg | imsgtype == $GSELOR$RMsg)
            {
            sat$pointer$to MSG$TblDctor$I
            SAT$SatelliteName$C = xSAT$SatelliteName$C
            call smovhn (SAT$SatelliteName$C, $$MaxLit, cline, ilen) # SMM 11/99 E2141
            }
        else
            {
            call get_name (msg$tbldctor$i, name)
            isize = length (name)
            call smovh (name, isize, cline, ilen)   
            }
        }

    call pline
    }

return
end



Subroutine lobsln (digraph)
#####################################################################
#
#      Builds line LOBS for RED reports (see LOBLN for GOLD reports)
# 
####################################################################

bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon

literal digraph
REAL    tlat, tlon  # jb E2207  (vice literal, for LATLON)  9/18/00
integer iformat

ilen = 0
call smovv ("LOBS/", cline, ilen)

call smovh (digraph, 2, cline, ilen)
call smovv ("/", cline, ilen)

call smoviz (xmsg$bearing$i, 3, cline, ilen)
call smovv ("T/", cline, ilen)        # Changed for OSISB 11/3/83

tlat = xmsg$latitude$f
tlon = xmsg$longitude$f
iformat = cksum$nocomma
call latlon (tlat,tlon, iformat)        # radians to dddmmh
call smovh (posit(2), 7, cline, ilen)     # latitude
call smovv ("/", cline, ilen)   
call smovh (posit(4), 8, cline, ilen)     # longitude

call pline

return
end



Subroutine lobln
#####################################################################
#
#      Builds line LOB for GOLD reports (see LOBSLN for RED reports)
# rll
####################################################################
bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon
auditcommon

character stime[8], trulat[7], trulong[8], applat[7], applong[8]
character abearing[4], arange[4]
REAL      range, alat,along, tlat,tlong, bearing # jb E2207 vs literal  9/18/00
integer Msg_DTG
integer imsgtime, idtg, ii, ickdig, iformat, iran
integer iaudit, len, i, ibearing, jj, x     # jb E2145  9/18/00
literal cstrip8
real    random2
character detector[8], detectee[8], tline[7]
BBDeclare(MSG$MsgType$I, MSG$Sensor$I)

ilen = 0
call smovv ("LOB/", cline, ilen)

imsgtime = xmsg$senstime$i
idtg = Msg_DTG (imsgtime*1.0)       # from game_dtg, JA 8/98 E2023

ii = 0
call smoviz (idtg, 6, stime, ii)	
call smovv ("Z", stime, ii)

call smovh (stime, 7, cline, ilen)    
call ckdig (idtg, ickdig)
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/", cline, ilen)

call smovh (mnth, 3, cline, ilen)
call smovv ("/", cline, ilen)

alat = xmsg$latitude$f
along = xmsg$longitude$f
tlat = xmsg$truelat$f
tlong = xmsg$truelong$f

iformat = cksum$nocomma
call latlon (alat,along,iformat)	  # radians to dddmmh
call smovh (posit(2), 7, cline, ilen)     # latitude
call smovv ("/", cline, ilen)   
call smovh (posit(4), 8, cline, ilen)     # longitude
call smovv ("/", cline, ilen)

call smoviz (xmsg$bearing$i, 3, cline, ilen)
call smovv ("T", cline, ilen)        

msg$msgtype$i = xmsg$msgtype$i
msg$sensor$i  = xmsg$sensor$i  

#----------------------------------------------------------------------------
#   (RGAudit$Msg == $yes) is used when an audit trail is desired for postgame 
#   analysis.  The first two characters determine the sensor source e.g. SE 
#   for SELOR, ES for ESM, etc.  They are concatonated to four digits that 
#   make up a unique number for each contact.  The message generator NOSIC 
#   number is used for this purpose.  This combined alphanumeric is placed in 
#   the SENSOR SOURCE field of the POS or LOB line.
#-------------------------------------------------------------------------
if (RGAudit$Msg == $yes)    
   {
    if       (msg$msgtype$i == $gsonbp$rmsg)
       {
        call smovv ("/DF", cline, ilen)     
       }
    else if (msg$msgtype$i == $gsonp$rmsg)
       {
        call smovv ("/SP", cline, ilen)
       }
    else if (msg$sensor$i == $esm$rsens) 
       {
        call smovv ("/ES", cline, ilen)
       }
    else if (msg$sensor$i == $aesm$rsens) 
       {
        call smovv ("/AE", cline, ilen)
       }

    index = xmsg$tbldctee$i

    iran = int(random2(x) * 10)
    if (iran == 10) iran = 1           # don't want a 2 digit #, i.e. 10

    iaudit = index + iran                # make so audit # always different

    call smoviz (iaudit, 3, cline, ilen)
    call smovi (iran, cline, ilen)
   }
else
   {
    if       (msg$msgtype$i == $gsonbp$rmsg)
       {
        call smovv ("/DIFAR", cline, ilen)
       }
    else if (msg$msgtype$i == $gsonp$rmsg)
       {
        call smovv ("/SONPAS", cline, ilen)
       }
    else if (msg$sensor$i == $esm$rsens) 
       {
         call smovv ("/ESM", cline, ilen)
        }
    else if (msg$sensor$i == $aesm$rsens) 
       {
        call smovv ("/AESM", cline, ilen)
       }
   }

if (RGTruPos$Out == YES)
   {
    ii = 0; call smoviz (iaudit, 3, audit, ii)
    len = 3
    for (i=1; i<=len; i=i+1) call putch (audit[i], RGTruTrk$File)
#    call putlin (audit, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovhn (xmsg$dcteename$c, $$MaxName, detectee, ii) # SMM 11/99 E2141
    call putlin (detectee, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    iformat = $nocksumcomma
    #iformat = comma$nocksum
    call latlon (tlat, tlong, iformat)
    ii = 0; call smovh (posit(2), 7, trulat, ii)     # true latitude
    call putlin (trulat, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovh (posit(4), 8, trulong, ii)    # true longitude
    call putlin (trulong, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    iformat = $nocksumcomma
    #iformat = comma$nocksum
    call latlon (alat, along, iformat)
    ii = 0; call smovh (posit(2), 7, applat, ii)    # apparent latitude
    call putlin (applat, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovh (posit(4), 8, applong, ii)   # apparent longitude
    call putlin (applong, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    call rll2rb (tlat, tlong, COS(tlat), alat, along, COS(alat),
                 range, bearing)

    call ang2PI(bearing)		

    ibearing = bearing * (180./$pi) + .5
    ii = 0; call smoviz (ibearing, 3, abearing, ii)
    ii = 0; call smovf (range, 2, arange, ii)

    call putlin (abearing, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 
    call putlin (arange, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    ii = 0; call smovhn (xmsg$dctorname$c, $$MaxName, detector, ii) # SMM 11/99 E2141
    call putlin (detector, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    call putlin_v ("LOB", RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 
    call putlin (stime, RGTruTrk$File)
    if (iform == 1) call putlin_v (".....", RGTruTrk$File)
    else            call putlin_v (",", RGTruTrk$File) 

    idtg = Msg_DTG (msg_minute*1.0)	# Changed to Msg_DTG 
    jj = 0                          # from game_dtg, JA 8/98 E2023
    call smoviz (idtg, 6, tline, jj)
    call smovv ("Z", tline, jj)

    call putlin (tline, RGTruTrk$File)               # Time of Receipt
    call putlin (NEWLINE, RGTruTrk$File)
   }

call pline

return
end



Subroutine elipln
####################################################################
#
#      Builds line ELLIP
#
####################################################################

bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon

REAL    tlat, tlon  # jb E2207  (vice literal, for LATLON)  9/18/00
integer iformat, isqr, iarea
BBDeclare(MSG$MajorAxis$I, MSG$MinorAxis$I, MSG$MsgType$I)

#call remark_v ("Subroutine ELIPLN has been called")    ## debug

ilen = 0
call smovv ("ELLIP/", cline, ilen)

tlat = xmsg$latitude$f
tlon = xmsg$longitude$f
iformat = cksum$nocomma
call latlon (tlat, tlon, iformat)
call smovh (posit(2), 7, cline, ilen)    # latitude
call smovv ("/", cline, ilen)
call smovh (posit(4), 8, cline, ilen)    # longitude
call smovv ("/", cline, ilen)

msg$majoraxis$i = xmsg$majoraxis$i
msg$minoraxis$i = xmsg$minoraxis$i
msg$msgtype$i = xmsg$msgtype$i 

call smoviz (xmsg$bearing$i, 3, cline, ilen)
call smovv ("T/", cline, ilen)      # Changed for OSISB 11/3/83
call smovi (msg$majoraxis$i, cline, ilen)
call smovv ("NM/", cline, ilen)
call smovi (msg$minoraxis$i, cline, ilen)
call smovv ("NM/", cline, ilen)
isqr = iarea (msg$majoraxis$i,msg$minoraxis$i)	             # 5-digit
call smovi (isqr, cline, ilen)             
call smovv ("SQNM", cline, ilen)

call pline 

return
end



subroutine brngln
####################################################################
#
#      Builds line BRNG
#
####################################################################

bbcommon
rfcommon
rgcommon
tmpcommon
ptr2common
msgcommon

REAL    tlat, tlon  # jb E2207  (vice literal, for LATLON)  9/18/00
integer iformat

#call remark_v ("Subroutine BRNGLN has been called")    ## debug

ilen = 0
call smovv ("BRNG/", cline, ilen)
call smoviz (xmsg$bearing$i, 3, cline, ilen)
call smovv ("T/", cline, ilen)         # Changed for OSISB 11/3/83

tlat = xmsg$latitude$f
tlon = xmsg$longitude$f
iformat = cksum$nocomma
call latlon (tlat,tlon,iformat)         # radians to degrees-minutes
call smovh (posit(2), 7, cline, ilen)     # latitude
call smovv ("/", cline, ilen)   
call smovh (posit(4), 8, cline, ilen)     # longitude

#if (xmsg$msgtype$i == $red$rmsg)
#   {
#    call smovv ("///", cline, ilen)            # 1/2 width miles/degrees
#    call smovi (xmsg$rngradius$i, cline, ilen)    # 4-digit Range
#    call smovv ("NM", cline, ilen)
#   }

call pline 

return
end



Subroutine timln
####################################################################
#
#      Builds line TIME
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

integer Msg_DTG
integer imsgtime, idtg, ickdig

#call remark_v ("Subroutine TIMLN has been called")    ## debug

ilen = 0
call smovv ("TIME/", cline, ilen)

imsgtime = xmsg$senstime$i
idtg = Msg_DTG (imsgtime*1.0)        # from game_dtg, JA 8/98 E2023
call smoviz (idtg, 6, cline, ilen)		
call smovv ("Z", cline, ilen)
    
call ckdig (idtg, ickdig)                     # checksum
call smoviz (ickdig, 1, cline, ilen)
call smovv ("/HOLDING/", cline, ilen)      # event

call get_sensor 
call smovv ("/", cline, ilen)

call smovv ("//1", cline, ilen)

call pline 

return
end



Subroutine radln
####################################################################
#
#      Builds line RAD for GOLD messages
#
#  Modified:  Carol Kropp - 11/96 (E1716)
#             Rather than writing directly to cline, move text
#             into local string msg and then copy msg into cline.
#             The call to smovv to copy the string "RAD" was
#             causing the program to crash, but moving the variable
#             doesn't - unknown reasons, but output was verified
#             as correct.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
tmpcommon

literal radname
integer Msg_DTG

character msg[ARB]
integer   msg_len
integer   imsgtime, idtg, ickdig, klen
literal   cstrip8
vmschar   VSTRIP*ARB

BBDeclare(MSG$MSGType$I, RAD$CH$Index, RAD$CH$Frequency$F, RAD$FullName$v)

msg_len = 0
call smovv ("RAD", msg, msg_len)      # 8/8/91 clf
if (RGradb == $YES) call smovv ("B", msg, msg_len)
call smovv ("/", msg, msg_len)

if (RGCPX$OUT == $yes)  call smovv ("//", msg, msg_len)
else
   {
    imsgtime = xmsg$senstime$i
    idtg = Msg_DTG (imsgtime*1.0)         # from game_dtg, JA 8/98 E2023
    call smoviz (idtg, 6, msg, msg_len)
    call smovv ("Z", msg, msg_len)

    call ckdig (idtg, ickdig)
    call smoviz (ickdig, 1, msg, msg_len)
    call smovv ("/", msg, msg_len)

    call smovh (mnth, 3, msg, msg_len)
    call smovv ("/", msg, msg_len)
   }
msg$msgtype$i = xmsg$msgtype$i
if (msg$msgtype$i == $gselor$rmsg |
    msg$msgtype$i == $gwizard$rmsg) rad$pointer$to xmsg$emitpntrindx$i
else                                rad$pointer = xmsg$emitpntrindx$i

call radmode				# get radar mode of operation

if (imode == 0)				# no modes in used
   {
    call smovv ("/", msg, msg_len)

    radname = xrad$type$c		# get name of radar carried by target
    rad$FullName$v = Xrad$FullName$v
    if (RGradb == $YES) call smovvt (rad$FullName$v[1:15], msg, msg_len)
    else                call smovvt (rad$FullName$v[1:12], msg, msg_len)

    call return_active_chan ( xMSG$DctorName$c,
                              $Radar$Code,
                              radName,
                              RAD$CH$Index)  # 1/8/90 reh

    rad$CH$frequency$F = xrad$CH$frequency$F   # 1/9/90 # jb       1/22/91
    klen = NINT(rad$CH$frequency$F)            # jb                1/22/91

    if (klen != 0)                             # jb                1/22/91
       {
        call smovv ("/", msg, msg_len)
        call smovi (klen, msg, msg_len)         # jb                1/22/91
        call smovv ("MHZ", msg, msg_len)
       }
   }
else
    {
    if (RGradb == $YES) call radblnx
    else                call radlnx
    }

ilen=0
call smovh (msg, msg_len, cline, ilen)
call pline

return
end



Subroutine radlnx 
####################################################################
#
# Builds a portion of the RADLN line for a radar operating in a 
# specific from mode 1 through 3.
# 
####################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
auditcommon

literal driftinc, radnote, radstype, radfreq, jitter
literal  radpw, radsrate
literal radprr, vradpri
REAL    vradsrate,vradpw,vradfreq,vradprr,radpri # jb E2207 vs literal 9/18/00
character rdname[16]
literal cstrip8
integer isize, length, iradfreq, idig, nmbr, l, iradpri
integer iradprr, iradpw, kradpw, iradsrate, x   # jb E2145  9/18/00
real    random2
vmschar   VSTRIP*ARB
BBDeclare(rad$FullName$v)

#call remark_v ("Subroutine RADLNX has been called")    ## debug


if (imode == 1)
   {
    radnote = xrad$m1enote$c
    radfreq  = xrad$m1freq$f
    radprr   = xrad$m1prr$f
    radpw    = xrad$m1pw$f
    radsrate = xrad$m1srate$f
    radstype = xrad$m1stype$c
   }
else if (imode == 2)
   {
    radnote = xrad$m2enote$c
    radfreq  = xrad$m2freq$f
    radprr   = xrad$m2prr$f
    radpw    = xrad$m2pw$f
    radsrate = xrad$m2srate$f
    radstype = xrad$m2stype$c
   }

else if (imode == 3)
   {
    radnote = xrad$m3enote$c
    radfreq  = xrad$m3freq$f
    radprr   = xrad$m3prr$f
    radpw    = xrad$m3pw$f
    radsrate = xrad$m3srate$f
    radstype = xrad$m3stype$c
   }
call smovh (radnote, 5, cline, ilen)

call smovv ("/", cline, ilen)
rad$FullName$v = Xrad$FullName$v               
call smovvt (rad$FullName$v, cline, ilen)
call smovv ("/", cline, ilen)                

driftinc = .001
call paradrift (driftinc, radfreq, vradfreq)

iradfreq = INT(vradfreq)

if      (iradfreq < 1000)                       idig = 3
else if (iradfreq >= 1000 & iradfreq < 10000)   idig = 2
else if (iradfreq >= 10000 & iradfreq < 100000) idig = 1
else                                            idig = 0

if (idig == 0) call smovi (iradfreq, cline, ilen)
else           call smovf (vradfreq, idig, cline, ilen)

call smovv ("MHZ", cline, ilen)                
call smovv ("/", cline, ilen)                
      
call smovv ("PRI", cline, ilen)

driftinc = .0001
call paradrift (driftinc, radprr, vradprr)
if (vradprr < 1) vradpri = 0
else             vradpri = 1/vradprr * 10**6

if (RGjitter == YES)        # clf -- 10/15/92
  {
  nmbr = random2(x) * 10
  l = mod (nmbr, 2)
  if (l == 0) jitter = random2(x) * -1
  else        jitter = random2(x)
  }
else jitter = 0

radpri = vradpri + (jitter/10.0)

iradpri = INT(radpri)

if      (iradpri <= 9999)   idig = 3
else if (iradpri <= 99999)  idig = 2
else if (iradpri <= 999999) idig = 1
else                        idig = 0

if (idig == 0) call smovi (iradpri, cline, ilen)
else           call smovf (radpri, idig, cline, ilen)

if (RGCPX$OUT == $yes)  call smovv ("///", cline, ilen)
else
   {
    call smovv ("/", cline, ilen)
    call smovv ("PRF", cline, ilen)    
                                          
    radprr = 1/radpri * 10**6             # PRI & PRF must track together

    iradprr = INT(radprr)

    if      (iradpri <= 9999)   idig = 3
    else if (iradpri <= 99999)  idig = 2
    else if (iradpri <= 999999) idig = 1
    else                        idig = 0

    if (idig == 0) call smovi (iradpri, cline, ilen)
    else           call smovf (REAL(radprr), idig, cline, ilen)
                        ## jb  REAL #2297       9/18/00
    call smovv ("/PW", cline, ilen)

    driftinc = .0001
    call paradrift (driftinc, radpw, vradpw)

    iradpw = INT(radpw)

    if      (iradpw < 1)     idig = 2
    else if (iradpw < 10)    idig = 1
    else                     idig = 0

    if      (idig == 0) call smovi (iradpw, cline, ilen)
    else if (idig == 2)
       {
        kradpw = radpw * 100
        call smovv (".", cline, ilen)
        call smovi (kradpw, cline, ilen)
       }
    else                call smovf (vradpw, idig, cline, ilen)

    call smovv ("/", cline, ilen)
   }

#if (rgpost$out == $yes & rgaudit$msg == $yes)
#   {
#    index = xmsg$tbldctee$i
#    ispr = index/10
#    call smovi (ispr, cline, ilen)
#    call smovv (".", cline, ilen)
#    kspr = mod (index, 10)
#    call smovi (kspr, cline, ilen)
#   }
#else
#   {

driftinc = .001
call paradrift (driftinc, radsrate, vradsrate)

iradsrate = INT(vradsrate)

if      (iradsrate < 1)   idig = 3
else if (iradsrate < 10)  idig = 2
else if (iradsrate < 100) idig = 1
else                      idig = 0

if (idig == 0) call smovi (iradsrate, cline, ilen)
else           call smovf (vradsrate, idig, cline, ilen)

if (RGCPX$OUT == $yes) call smovv ("SPR", cline, ilen)
else
   {
    call smovv ("SPR/", cline, ilen)
    call smovh (radstype, 1, cline, ilen)
   }

return
end





Subroutine radblnx 
####################################################################
#
# Builds a portion of the RADBLN line for a radar operating in a 
# specific from mode 1 through 3.
# 
####################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon
auditcommon

literal driftinc, radnote, radfreq, jitter
literal radprr, vradpri, radpw, radsrate, radstype, fnumb
REAL vradsrate,vradfreq,vradprr,vradpw # jb E2207 vs literal/PARADRIFT 9/18/00
REAL    radpri                      # jb E2207 vs literal for smovF    9/18/00
character rdname[16]
literal cstrip8
integer isize, length, iradfreq, idig, nmbr, l
integer iradpri, iradprr, iradpw, iradsrate, x   # jb E2145  9/18/00
real    random2
vmschar   VSTRIP*ARB
BBDeclare(rad$FullName$v)
#call remark_v ("Subroutine RADLNX has been called")    ## debug


if (imode == 1)
   {
    radnote = xrad$m1enote$c
    radfreq  = xrad$m1freq$f
    radprr   = xrad$m1prr$f
    radpw    = xrad$m1pw$f
    radsrate = xrad$m1srate$f
    radstype = xrad$m1stype$c
   }
else if (imode == 2)
   {
    radnote = xrad$m2enote$c
    radfreq  = xrad$m2freq$f
    radprr   = xrad$m2prr$f
    radpw    = xrad$m2pw$f
    radsrate = xrad$m2srate$f
    radstype = xrad$m2stype$c
   }

else if (imode == 3)
   {
    radnote = xrad$m3enote$c
    radfreq  = xrad$m3freq$f
    radprr   = xrad$m3prr$f
    radpw    = xrad$m3pw$f
    radsrate = xrad$m3srate$f
    radstype = xrad$m3stype$c
   }
call smovh (radnote, 5, cline, ilen)

call smovv ("/", cline, ilen) 
rad$FullName$v = Xrad$FullName$v               
#call smovvt (rad$FullName$v, cline, ilen)
call smovv ("/", cline, ilen)                

driftinc = .001
call paradrift (driftinc, radfreq, vradfreq)

iradfreq = INT(vradfreq)

if      (iradfreq < 1000)   idig = 3
else if (iradfreq < 10000)  idig = 2
else if (iradfreq < 100000) idig = 1
else                        idig = 0

#if (idig == 0) call smovi (iradfreq, cline, ilen)
#else           call smovf (vradfreq, idig, cline, ilen)

#call smovv ("MHZ", cline, ilen)                
call smovv ("/", cline, ilen)                
      
#-----------------------------------------------
#   PRI
#---------------------------------------------
driftinc = .0001
call paradrift (driftinc, radprr, vradprr)
if (vradprr < 1) vradpri = 0
else             vradpri = 1/vradprr * 10**6

if (RGjitter == YES)        # clf -- 10/15/92
  {
  nmbr = random2(x) * 10
  l = mod (nmbr, 2)
  if (l == 0) jitter = random2(x) * -1
  else        jitter = random2(x)
  }
else jitter = 0

radpri = vradpri + (jitter/10.0)

iradpri = INT(radpri)

if      (iradpri <= 9) call smovv ("00000", cline, ilen)
else if (iradpri <= 99) call smovv ("0000", cline, ilen)
else if (iradpri <= 999) call smovv ("000", cline, ilen)
else if (iradpri <= 9999) call smovv ("00", cline, ilen)
else if (iradpri <= 99999) call smovv ("0", cline, ilen)

call smovf (radpri, 3, cline, ilen)
call smovv ("/", cline, ilen)
                                          
#-----------------------------------------------
#   PRF
#-----------------------------------------------
radprr = 1/radpri * 10**6             # PRI & PRF must track together

iradprr = INT(radprr)

if      (iradpri <= 9999)   idig = 3
else if (iradpri <= 99999)  idig = 2
else if (iradpri <= 999999) idig = 1
else                        idig = 0

#if (idig == 0) call smovi (iradpri, cline, ilen)
#else           call smovf (radprr, idig, cline, ilen)

call smovv ("/", cline, ilen)

#-----------------------------------------------
#   PW
#---------------------------------------------
driftinc = .0001
call paradrift (driftinc, radpw, vradpw)

iradpw = INT(radpw)

fnumb = radpw - iradpw

if      (fnumb == .1 | fnumb == .2 | fnumb == .3 | fnumb == .5 |
         fnumb == .6 | fnumb == .7 | fnumb == .8 | fnumb == .9)
         idig = 1
else     idig = 2

#call smovf (radpw, idig, cline, ilen)

call smovv ("/", cline, ilen)

#-----------------------------------------------
#   SCAN RATE
#---------------------------------------------
driftinc = .001
call paradrift (driftinc, radsrate, vradsrate)

iradsrate = INT(vradsrate)

if      (iradsrate < 1)   idig = 3
else if (iradsrate < 10)  idig = 2
else if (iradsrate < 100) idig = 1
else                      idig = 0

if (idig == 0) call smovi (iradsrate, cline, ilen)
else           call smovf (vradsrate, idig, cline, ilen)

call smovv ("SPR/", cline, ilen)
call smovh (radstype, 1, cline, ilen)

return
end



Subroutine rdidln
####################################################################
#
#      Builds line RADID
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr1common
ptr2common
msgcommon

literal radname
literal cstrip8
integer klen
BBDeclare(RAD$CH$Index, RAD$CH$Frequency$F)

#call remark_v ("Subroutine RDIDLN has been called")    ## debug

if (xmsg$msgtype$i == $selor$rmsg) rad$pointer$to xmsg$emitpntrindx$i
else                               rad$pointer = xmsg$emitpntrindx$i

ilen = 0
call smovv ("RADID/", cline, ilen)      # Hardcoded line ID

call smoviz (xMSG$SeqCtcNbr$I, 6, cline, ilen)

call smovv ("/", cline, ilen)                

call radmode

if (imode == 0)                         # no modes in used
   {
    call smovv ("/", cline, ilen)                

    radname = xrad$type$c        # get name of radar carried by target
    call smovh (radname, $$MaxName, cline, ilen)

    call return_active_chan ( xMSG$DctorName$c,
                              $Radar$Code,
                              radName,
                              RAD$CH$Index)  # 1/9/90 reh

#    rad$operatingfreq$i = xrad$operatingfreq$i      # operating frequency
    rad$CH$frequency$F = xrad$CH$frequency$F   # 1/9/90 # jb       1/22/91
    klen = NINT(rad$CH$frequency$F)            # jb                1/22/91

    if (klen != 0)
       {
        call smovv ("//", cline, ilen)
        call smovi (klen, cline, ilen)          # jb                1/22/91
       }
   }
else call radidx

call pline 

return
end



Subroutine radidx 
####################################################################
#
# Builds a portion of the RADID line for a radar operating in 
# a mutifunction mode.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

literal radnote, radfcode, radfreq
integer radxcntd
character rdname[16]
literal cstrip8
integer isize, length, klen
vmschar   VSTRIP*ARB

BBDeclare(RAD$CH$Index, RAD$CH$Frequency$F, rad$FullName$v)

#call remark_v ("Subroutine RADIDX has been called")    ## debug


if (imode == 1)
   {
    radnote = xrad$m1enote$c
    radfcode = xrad$m1fcode$c
    radxcntd = xrad$m1xcntd$i
    radfreq  = xrad$m1freq$f
   }
else if (imode == 2)
   {
    radnote = xrad$m2enote$c
    radfcode = xrad$m2fcode$c
    radxcntd = xrad$m2xcntd$i
    radfreq  = xrad$m2freq$f
   }
else if (imode == 3)
   {
    radnote = xrad$m3enote$c
    radfcode = xrad$m3fcode$c
    radxcntd = xrad$m3xcntd$i
    radfreq  = xrad$m3freq$f
   }
call smovh (radnote, 5, cline, ilen)

call smovv ("/", cline, ilen)                

rad$FullName$v = Xrad$FullName$v
call smovvt (rad$FullName$v, cline, ilen)         # radar name

call smovv ("/", cline, ilen)                

call smovh (radfcode, 2, cline, ilen)           # function code

call smovv ("/", cline, ilen)                

#$% somehow find the platform with radar
call return_active_chan ( xMSG$DctorName$c,
                          $Radar$Code,
                          rdName,
                          RAD$CH$Index)  # 1/9/90 reh

#rad$operatingfreq$i = xrad$operatingfreq$i      # xtal frequency
rad$CH$frequency$F = xrad$CH$frequency$F   # 1/9/90 # jb       1/22/91
klen = NINT(rad$CH$frequency$F)            # jb                1/22/91

call smovi (klen, cline, ilen)             # jb                1/22/91
call smovv ("/", cline, ilen)                
call smovi (radxcntd, cline, ilen)               # xtal countdown

return
end



Subroutine rdpaln
####################################################################
#
#      Builds line RADPA
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

literal cstrip8
integer klen
BBDeclare(RAD$CH$Index, RAD$CH$Frequency$F)

#call remark_v ("Subroutine RDPALN has been called")    ## debug

ilen = 0
call smovvn ("RADPA/", cline, ilen)

if (imode == 0)
   {
    rad$pointer = xmsg$emitpntrindx$I 

    call return_active_chan ( xMSG$DctorName$c,
                              $Radar$Code,
                              xrad$type$c,
                              RAD$CH$Index)  # 1/9/90 reh

    rad$CH$frequency$F = xrad$CH$frequency$F   # 1/9/90
    klen = NINT(rad$CH$frequency$F)            # jb                1/22/91

#    rad$operatingfreq$i = xrad$operatingfreq$i
    call smovi (klen, cline, ilen)             # jb                1/22/91
    call smovvn ("MHZ", cline, ilen)    
   }
else call radpax

call pline 

return
end



Subroutine radpax
####################################################################
#
# Builds a portion of the RADPA line for a radar operating in the
# a multifunction mode.
# 
####################################################################

bbcommon
rgcommon
rfcommon
ptr2common
msgcommon

literal radprr, radpw, radsrate, radstype, radfreq, jitter
literal vradpri, driftinc
REAL vradsrate,vradfreq,vradprr,vradpw # jb E2207 vs literal/PARADRIFT 9/18/00
REAL    radpri           # jb E2207 vs literal for smovF    9/18/00

integer ihours, iminutes, igmin
real duration
literal cstrip8
integer nmbr, l, iradpa, x   # jb E2145  9/18/00
real    random2

#call remark_v ("Subroutine RADPAX has been called")    ## debug

if (imode == 1)
   {
    radfreq  = xrad$m1freq$f
    radprr   = xrad$m1prr$f
    radpw    = xrad$m1pw$f
    radsrate = xrad$m1srate$f
    radstype = xrad$m1stype$c
   }
else if (imode == 2)
   {
    radfreq  = xrad$m2freq$f
    radprr   = xrad$m2prr$f
    radpw    = xrad$m2pw$f
    radsrate = xrad$m2srate$f
    radstype = xrad$m2stype$c
   }
else if (imode == 3)
   {
    radfreq  = xrad$m3freq$f
    radprr   = xrad$m3prr$f
    radpw    = xrad$m3pw$f
    radsrate = xrad$m3srate$f
    radstype = xrad$m3stype$c
   }

driftinc = .001
call paradrift (driftinc, radfreq, vradfreq)
call smovf (vradfreq, 3, cline, ilen)
call smovv ("MHZ/", cline, ilen)

call smovv ("PRF", cline, ilen)    # taken out for TFCC, PRI & PRF must
                                      # track together
driftinc = .01
call paradrift (driftinc, radprr, vradprr)
call smovf (vradprr, 3, cline, ilen)

call smovv ("/PRI", cline, ilen)

if (vradprr == 0) vradpri = 0
else              vradpri = 1/vradprr * 10**6

if (RGjitter == YES)        # clf -- 10/15/92
  {
  nmbr = random2(x) * 10
  l = mod (nmbr, 2)
  if (l == 0) jitter = random2(x) * -1
  else        jitter = random2(x)
  }
else jitter = 0

radpri = vradpri + (jitter/10.0)

call smovf (radpri, 3, cline, ilen)

call smovv ("/PW", cline, ilen)

driftinc = .01
call paradrift (driftinc, radpw, vradpw)

if (vradpw >= 10) 
   {
    iradpa = INT(vradpw)
    call smoviz (iradpa, 3, cline, ilen)
   }
else call smovf (vradpw, 101, cline, ilen)

call smovv ("/", cline, ilen)

driftinc = .001
call paradrift (driftinc, radsrate, vradsrate)
call smovf (vradsrate, 2, cline, ilen)

call smovv ("SPR/", cline, ilen)

call smovh (radstype, 1, cline, ilen)

call smovv ("/", cline, ilen)

igmin = msg_minute
duration = igmin - xrmt$FirstDetTime$f

ihours = duration * $Hours$Per$Minute
iminutes = duration - (ihours * $Minutes$Per$Hour)

call smoviz (ihours, 2, cline, ilen)
call smovv ("H", cline, ilen)

call smoviz (iminutes, 2, cline, ilen)
call smovv ("M", cline, ilen)

call smovv ("00S", cline, ilen)

return
end



Subroutine rdtacrep
####################################################################
#
#      Builds line EMTREW for TACREP (elint) message.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr1common
ptr2common
msgcommon

literal cstrip8
integer klen
BBDeclare(RAD$CH$Index, RAD$CH$Frequency$F)

#call remark_v ("Subroutine RDTACREP has been called")    ## debug

if (xmsg$msgtype$i == $stelnt$rmsg |
    xmsg$msgtype$i == $stcpelnt$rmsg) rad$pointer$to xmsg$emitpntrindx$i
else                                  rad$pointer = xmsg$emitpntrindx$i

ilen = 0
call smovv ("ENTREW/", cline, ilen)      # Hardcoded line ID

call radmode

if (imode == 0)                         # no modes in used
   {
    call return_active_chan ( xMSG$DctorName$c,
                              $Radar$Code,
                              xRAD$Type$c,
                              RAD$CH$Index)    # 1/9/90 reh

#    rad$operatingfreq$i = xrad$operatingfreq$i      # operating frequency
    rad$CH$frequency$F = xrad$CH$frequency$F   # 1/9/90    # jb    1/22/91
    klen = NINT(rad$CH$frequency$F)            # jb                1/22/91

    if (klen != 0)                             # jb                1/22/91
       {
        call smovi (klen, cline, ilen)         # jb                1/22/91
        call smovv ("//", cline, ilen)
       }
   }
else call rdtacrepx

call pline 

return
end



Subroutine rdtacrepx
####################################################################
#
# Builds a portion of the EMTREW (TACREP) line for a radar operating 
# A multifunction mode.
# 
####################################################################

bbcommon
rgcommon
rfcommon
ptr2common
msgcommon

literal radprr, radpw, radsrate, radstype, radfreq, radpol, jitter
literal vradpri, driftinc, radnote
literal cstrip8
REAL vradsrate,vradfreq,vradprr,vradpw # jb E2207 vs literal/PARADRIFT 9/18/00
REAL    radpri           # jb E2207 vs literal for smovF    9/18/00

integer nmbr, l, iradpa, x   # jb E2145  9/18/00
real    random2

#call remark_v ("Subroutine RDTACREPX has been called")    ## debug

if (imode == 1)
   {
    radfreq  = xrad$m1freq$f
    radprr   = xrad$m1prr$f
    radpol   = xrad$m1polar$c 
    radstype = xrad$m1stype$c
    radpw    = xrad$m1pw$f
    radnote = xrad$m1enote$c
    radsrate = xrad$m1srate$f
   }
else if (imode == 2)
   {
    radfreq  = xrad$m2freq$f
    radprr   = xrad$m2prr$f
    radpol   = xrad$m2polar$c 
    radstype = xrad$m2stype$c
    radpw    = xrad$m2pw$f
    radnote  = xrad$m2enote$c
    radsrate = xrad$m2srate$f
   }
else if (imode == 3)
   {
    radfreq  = xrad$m3freq$f
    radprr   = xrad$m3prr$f
    radpol   = xrad$m3polar$c 
    radstype = xrad$m3stype$c
    radpw    = xrad$m3pw$f
    radnote  = xrad$m3enote$c
    radsrate = xrad$m3srate$f
   }

driftinc = .01
call paradrift (driftinc, radfreq, vradfreq)
call smovf (vradfreq, 3, cline, ilen)              # Field 2 - Radar Freq
call smovv ("MHZ/", cline, ilen)

call smovv ("PRI:", cline, ilen)                # Field 3 - PRI
call paradrift (driftinc, radprr, vradprr)
if (vradprr == 0) vradpri = 0
else              vradpri = 1/vradprr * 10**6

if (RGjitter == YES)        # clf -- 10/15/92
  {
  nmbr = random2(x) * 10
  l = mod (nmbr, 2)
  if (l == 0) jitter = random2(x) * -1
  else        jitter = random2(x)
  }
else jitter = 0

radpri = vradpri + (jitter/10.0)

call smovf (radpri, 3, cline, ilen)

call smovv ("/POL:", cline, ilen)               # Field 4 - Antenna POL
call smovh (radpol, 5, cline, ilen)

call smovv ("/SCNTY:", cline, ilen)              # Field 5 - Scan Type
call smovhn (radstype, 4, cline, ilen)

call smovv ("/PD:", cline, ilen)                # Field 6 - Pulse Duration
driftinc = .01
call paradrift (driftinc, radpw, vradpw)
if (vradpw >= 10) 
   {
    iradpa = INT(vradpw)
    call smoviz (iradpa, 3, cline, ilen)
   }
else call smovf (vradpw, 101, cline, ilen)

call smovv ("/", cline, ilen)               

#call smovv ("/PRF:", cline, ilen)               # Field 7 - PRF
#driftinc = .01                          # taken out for TFCC, PRI & PRF must
#                                        # track together
call paradrift (driftinc, radprr, vradprr)
#call smovf (vradprr, 3, cline, ilen)

call smovv ("/ELNOT:", cline, ilen)             # Field 8 - ELNOTE
call smovh (radnote, 5, cline, ilen)

call smovv ("/-", cline, ilen)                  # Field 9 - PIN
call smovv ("/-", cline, ilen)                  # Field 10 - RFOM

driftinc = .001
call paradrift (driftinc, radsrate, vradsrate)     # Field 11 - Scan Rate
call smovv ("/SCNRT:", cline, ilen)
call smovf (vradsrate, 2, cline, ilen)

call smovv ("/-", cline, ilen)                  # Field 12 - ECMTQ
call smovv ("/-", cline, ilen)                  # Field 13 - PRIA
call smovv ("/-", cline, ilen)                  # Field 14 - AXIS

call smovv ("//", cline, ilen)                  # End of line

return
end



Subroutine radmode
####################################################################
#
#   Determines the mode in which a radar is operating.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr1common
ptr2common
msgcommon     # for imode

integer irdmode1, irdmode2, irdmode3, x   # jb E2145  9/18/00
real    random2, randnbr

#call remark_v ("Subroutine RADMODE has been called")    ## debug
 
irdmode1 = xrad$mode1$i 
irdmode2 = xrad$mode2$i 
irdmode3 = xrad$mode3$i 

if (irdmode1 <= 0)                         # no modes in used
   {
    imode = 0
   }
else if ((irdmode1 > 0) & (irdmode2 <= 0))    # mode 1 only
   {
    imode = 1
   }                                              
else if ((irdmode2 > 0) & (irdmode3 <= 0))    # mode 1 or 2
   {
    if (random2(x) <= .75)            imode = 1
    else                             imode = 2
   }
else if (irdmode3 > 0)                        # mode 1, 2, or 3
   {
    randnbr = random2(x)
    if (randnbr <= .75)                      imode = 1
    else if (randnbr > .75 & randnbr <= .90) imode = 2
    else                                     imode = 3
   }       

return
end



Subroutine hfdigraph (digraph)
################################################################
#
# Gets a sequencially selected digraph (two letter code) for
# insertion into the hfdf line.
#
#################################################################
implicit none
integer count / 0 /
literal digraph
integer i_switch_1

count = count + 1
if (count > 10) count = 1

switch (count)           
   {
    case 1:   {digraph = 'AB'}                                         
    case 2:   {digraph = 'RU'}
    case 3:   {digraph = 'ED'}                                         
    case 4:   {digraph = 'BM'}   
    case 5:   {digraph = 'JK'}    
    case 6:   {digraph = 'PL'}   
    case 7:   {digraph = 'YT'}                                         
    case 8:   {digraph = 'ZB'}
    case 9:   {digraph = 'VQ'}                                         
    case 10:  {digraph = 'HD'}                                         
   }

return
end



Subroutine trknumb 
####################################################################
#
# Provides the same TRACK NUMBER that is used in BGTT WARGAME.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

literal trkcode, bld_tn

#call remark_v ("Subroutine TRKNUMB has been called")

trkcode = bld_tn()
call smovhn (trkcode, $$MaxLit, cline, ilen) # SMM 11/99 E2141

return
end



Subroutine ptrknum
##########################################################################
#
# Provides a conventional track number used on OTCIXS.  The first
# character is "T".  For the following characters:
#  
#    If the table index number is between 1 and 999,  the first integer 
#    will be a 7 followed by the table index number.  This will allow
#    a simulation of an output from FDDS, JOTS or similar system up to 
#    the first 999 units.  Beyond 999 units, track number will be the same
#    as the table index number.  For exercises like TIMEX, track population
#    is not expected to go beyond 999 units so the "T7..." arrangement will
#    work ok.
#
#############################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

integer uncorr_bfl, uncorr
integer itrknum
BBDeclare(MSg$MsgType$I)

#call remark_v ("Subroutine PTRKNUM has been called")

msg$msgtype$i = xmsg$msgtype$i 

itrknum = xmsg$tbldctee$i

call smovv ("T", cline, ilen)

if (RGcorr == $NO)
    {
    if (msg$msgtype$i == $Special$RMsg) itrknum = uncorr_bfl(itrknum)
    else                                itrknum = uncorr(msg$msgtype$i)
    }

call smovi (RGtrkpre,    cline, ilen)
if (itrknum < 10000) call smoviz (itrknum, 4, cline, ilen)
else                call smovv ("0000", cline, ilen)      # tn > 9999

return
end



Subroutine endln 
####################################################################
#
#      Builds line ENDAT (End of message)
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

integer i

#call remark_v ("Subroutine ENDLN has been called")

ilen = 0
call smovv ("ENDAT/", cline, ilen)
call smovv ("DECL: OADR", cline, ilen)

call pline 

ilen = 0
call smovv ("BT", cline, ilen)
call smov ($RETURN, cline, ilen)
call smov ($RETURN, cline, ilen)

for (i = 1; i <= 8; i = i + 1)
   {
    call smov ($LINEFEED, cline, ilen)
   }

call smovv ("NNNN", cline, ilen)

call smov ($RETURN, cline, ilen)
call smov ($RETURN, cline, ilen)
call smov ($LINEFEED, cline, ilen)

call pline 

imsgcnt = imsgcnt + 1
itotmsgs = itotmsgs + 1

return
end



Subroutine pline 
####################################################################
#
#      PLINE puts lines together to form a message.
#
####################################################################

bbcommon
rfcommon
rgcommon
msgcommon

integer imax

#call remark_v ("Subroutine Pline has been called")

if (ilen > 69)                        # if line too long
   {
    imax = ilen  
    call add_line (cline, imax)
   }
else                                  # else if line length not too long
   {
    call smov ($RETURN, cline, ilen)
    call smov ($RETURN, cline, ilen)
    call smov ($LINEFEED, cline, ilen)
    call smov (EOS, cline, ilen)

    call add_buf (cline)
   }

return
end



subroutine add_line (aline, imax)
####################################################################
#
#  Adds another line when line length exceeds 69 characters
#
####################################################################
implicit none
bufcommon
msgcommon

character aline[400], bline[400]
integer ncnt, icnt, imax, nmax

for (ilen = 69; ilen >= 0; ilen = ilen - 1)
   {
    if (aline[ilen + 1] == $SLASH) break
   }

ncnt = 0
for (icnt = (ilen+1); icnt <= imax; icnt = icnt + 1)
   {
    ncnt = ncnt + 1
    bline[ncnt] = aline[icnt]
    nmax = ncnt
   }

call smov ($RETURN, aline, ilen)
call smov ($RETURN, aline, ilen)
call smov ($LINEFEED, aline, ilen)
call smov (EOS, aline, ilen)

call add_buf (aline)

call smov ($RETURN, bline, ncnt)
call smov ($RETURN, bline, ncnt)
call smov ($LINEFEED, bline, ncnt)
call smov (EOS, bline, ncnt)

call add_buf (bline)

return
end



subroutine add_buf (line)
####################################################################
#
#  Puts all messages generated in a game minute in one single buffer
#
####################################################################
implicit none
bufcommon
msgcommon

character line[400]
integer length

if (length(line)+bufpnt > $MaxBuf) 
    {
    call remark_v ("Buffer Full.......")

    return
    }

call stcopy (line, 1, pbuff, bufpnt)

bufpnt = bufpnt + 1	# increment past EOS

return
end



subroutine garble_buf (igrblcnt)
####################################################################
#
# Randomly garbles outgoing messges by "RGGrbl$Msgs" percent.
#
####################################################################
implicit none
bufcommon
rfcommon
rgcommon

character randchar[1]
literal fpcntgbl, fjnumb
integer igrblcnt, ichar, jnumb, x   # jb E2145  9/18/00
real    random2

igrblcnt = 0
for (ichar = 1; ichar <= bufpnt; ichar = ichar + 1)
   {
    if (pbuff[ichar] == EOS | 
    pbuff[ichar] == $LINEFEED | 
    pbuff[ichar] == $RETURN) next

    if (pbuff[ichar] == $LETN & 
    pbuff[ichar + 1] == $LETN &
    pbuff[ichar + 2] == $LETN &
    pbuff[ichar + 3] == $LETN)
       {
        if (int(random2(x)*100.) <= RGGrbl$Msgs)
           {
            igrblcnt = igrblcnt + 1

            jnumb = random2(x) * RGGrbl$Char
            fjnumb = float(jnumb)
            fpcntgbl = fjnumb/100.
           }
        else fpcntgbl = 0
       }
    if (random2(x) <= fpcntgbl)
       {
        call grbl_char (randchar)
        pbuff[ichar] = randchar[1]
       }
   }

return
end



subroutine grbl_char (randchar)
####################################################################
#
# Chooses random characters to insert in messages as garbles.
#
####################################################################
implicit none
character randchar[1]
integer irand, i_switch_1, x    # jb E2145  9/18/00
real    random2

irand = int(random2(x) * 55)

switch (irand)           
   {
    case 1:   {randchar[1] = $LETA}                                         
    case 2:   {randchar[1] = $LETB}
    case 3:   {randchar[1] = $LETC}                                         
    case 4:   {randchar[1] = $LETD}   
    case 5:   {randchar[1] = $LETE}    
    case 6:   {randchar[1] = $LETF}   
    case 7:   {randchar[1] = $LETG}                                         
    case 8:   {randchar[1] = $LETH}
    case 9:   {randchar[1] = $LETI}                                         
    case 10:  {randchar[1] = $LETJ}
    case 11:  {randchar[1] = $LETK}                                        
    case 12:  {randchar[1] = $LETL}                                         
    case 13:  {randchar[1] = $LETM}                                         
    case 14:  {randchar[1] = $LETN}                                         
    case 15:  {randchar[1] = $LETO}                                         
    case 16:  {randchar[1] = $LETP}                                         
    case 17:  {randchar[1] = $LETQ}                                         
    case 18:  {randchar[1] = $LETR}                                         
    case 19:  {randchar[1] = $LETS}                                         
    case 20:  {randchar[1] = $LETT}                                         
    case 21:  {randchar[1] = $LETU}                                         
    case 22:  {randchar[1] = $LETV}                                         
    case 23:  {randchar[1] = $LETW}                                         
    case 24:  {randchar[1] = $LETX}                                         
    case 25:  {randchar[1] = $LETY}                                         
    case 26:  {randchar[1] = $LETZ}                                         
    case 27:  {randchar[1] = $DIG1}                                         
    case 28:  {randchar[1] = $DIG2}                                         
    case 29:  {randchar[1] = $DIG3}                                         
    case 30:  {randchar[1] = $DIG4}                                         
    case 31:  {randchar[1] = $DIG5}                                         
    case 32:  {randchar[1] = $DIG6}                                         
    case 33:  {randchar[1] = $DIG7}                                         
    case 34:  {randchar[1] = $DIG8}                                         
    case 35:  {randchar[1] = $DIG9}                                         
    case 36:  {randchar[1] = $DIG0}                                         
    case 37:  {randchar[1] = $SLASH}                                         
    case 38:  {randchar[1] = $ASTER}                                         
    case 39:  {randchar[1] = $QUEST}                                         
    case 40:  {randchar[1] = $LPAREN}                                         
    case 41:  {randchar[1] = $RPAREN}                                         
    case 42:  {randchar[1] = $LITX}                                         
    case 43:  {randchar[1] = $DOLLAR}                                         
    case 44:  {randchar[1] = $AMPERSAND}                                         
    case 45:  {randchar[1] = $ATSIGN}                                         
    case 46:  {randchar[1] = $LITA}                                         
    case 47:  {randchar[1] = $LITG}                                         
    case 48:  {randchar[1] = $LITY}                                         
    case 49:  {randchar[1] = $LITM}                                         
    case 50:  {randchar[1] = $SPACE}                                         
    case 51:  {randchar[1] = $SPACE}                                         
    case 52:  {randchar[1] = $SPACE}                                         
    case 53:  {randchar[1] = $SPACE}                                         
    case 54:  {randchar[1] = $SPACE}                                         
    case 55:  {randchar[1] = $SPACE}                                         
   }

return
end



subroutine clear_buf (jstat)
####################################################################
#
#  Outputs msgs to the destination determined by the user.
#
####################################################################
bbcommon
rgcommon
bufcommon
msgcommon
rfcommon
ID_Common
servercommon

character  line[400], tline[40], token[400], outname[ARB]
integer    length, equal, almostequal, getwrd, open_, Msg_DTG
integer    tcp_client_connect, tcp_client_write, tcp_client_close, rc
integer    jstat, igrblcnt, ipnt, j, len, i, jj, idtg, kk, n, nmsgs
integer    itslots, klen, tcp_connection_open
integer	   file_open_time/-99999/
character  genmode[$$Maxlit]
string     eom "NNNN"
string     bt "BT"

tcp_connection_open = $no
nmsgs = 0

if (jstat == YES)
{
    if (RGGrbl$Char != 0 & RGGrbl$Msgs != 0) call garble_buf (igrblcnt)
	
	if (RGFile$Out == $YES)
	{
		if ((game$minute - file_open_time) > RGFile$Out$Duration)
		{
			if (file_open_time > 0) call close_(RGFile$NBR)

       		kk = 0
        	call smovhn(RGOut$File, $$Maxlit, outname, kk)
       		call smovv ("_", outname, kk) 
        	call smoviz(game$minute, 6, outname, kk) 
        	call smovv (".out", outname, kk)
			call smov  (EOS, outname, kk)

        	RGFile$NBR = open_ (outname, WRITE)

        	if (RGFile$NBR == ERR) 
            {
           		call echor
            	call echov ("Cannot Open The Output File: ")
            	call echoh (outname, kk)
            	#call rgexit 
            }
			else
			{
		    	call setchtype(RAW, RGFile$NBR)
				file_open_time = game$time
				call echov ("Opening New Out file: ")
            	call echoh (outname, kk)
				call echor
			}
		}
	}
    #_______________________________________________________________
    # Output the buffer to output port and/or file or neither 

    for (ipnt = 1; ipnt < bufpnt; )		#for each line in PBUFF
    {
        j = 1
        call stcopy (pbuff, ipnt, line, j)	# get a line

        ipnt = ipnt + j 			# bump pointer to next line

        len = length(line)
        #-------------------------------------------------------------------
        #      If device for output port is allocated
        #-------------------------------------------------------------------
        if (RGDevice$TTY == $$PORTOUT) 
	    {
			if (tcp_connection_open == $no)
			{
				sockfd = tcp_client_connect(server_name, server_port)
				tcp_connection_open = $yes
			}

	    	rc = tcp_client_write(sockfd, line, n)
			if (rc != 0)
			{
				call echov("Error writing message line to server")
				call echor
			}
			if (n < len)
			{
				call echov("GCCSM TCP/IP Buffer Overflow")
				call echor
			}
			# Check for end of message (NNNN)
			kk = 1
			n = getwrd(line, kk, token)
			if (almostequal(bt, token) == YES)
			{
				if (almostequal(eom, line[13]) == YES)
				{
					nmsgs = nmsgs + 1
					if (nmsgs >= 10)
					{
						# Needed so GCCS creates input buffer for each message
	    				rc = tcp_client_write(sockfd, line, n)	# Extra EOM
	    				rc = tcp_client_write(sockfd, line, n)	# Extra EOM
						nmsgs = 0
					}
					rc = tcp_client_close(sockfd)
					call delay(50)
					sockfd = tcp_client_connect(server_name, server_port)
				}
			}
		}

		#-------------------------------------------------------------------
        #    Are the messages to be scrolled by on the screen
        #-------------------------------------------------------------------
        if (RGWatch$Out == YES)
		{
            for (i = 1; i <= len; i = i + 1)
            {
                if      (line[i] == $RETURN)   continue
                else if (line[i] == $LINEFEED) call echor
                else if (line[i] == EOS)       continue
                else                           call echo (line[i])
            }
		}
        #-------------------------------------------------------------------
        #    Save the output messages to designated file
        #-------------------------------------------------------------------
        if (RGFile$OUT == YES)   
        {
            for (i = 1; i <= len; i = i + 1)
            {
                if      (line[i] == $RETURN)   continue
                else if (line[i] == $LINEFEED) call putch (NEWLINE, RGFile$NBR)
                else if (line[i] == EOS)       continue
                else                           call putch (line[i], RGFile$NBR)
            }
        }

        #--------------------------------------------------------------------
        #   Put the current DTG just after the "VZCZ..." or ZNY for
        #   the message output to be save to a file only.
        #--------------------------------------------------------------------
        if ((line[1] == $LETV & line[2] == $LETZ & line[3] == $LETC &
             line[4] == $LETZ & line[5] == $LETC & line[6] == $LETN) |
            (line[1] == $LETZ & line[2] == $LETN & line[3] == $LETY))
        {
            jj = 0
            call smovv ("TOR/", tline, jj)
            idtg = Msg_DTG (msg_minute*1.0)	# Changed to Msg_DTG 
            call smoviz (idtg, 6, tline, jj)# from game_dtg, JA 8/98 E2023
            call smovv ("Z", tline, jj)
            call smov ($RETURN, tline, jj)
            call smov ($RETURN, tline, jj)
            call smov ($LINEFEED, tline, jj)
            call smov (EOS, tline, jj)

            if (RGWatch$Out == YES) call echoh (tline, jj)  # put time on screen
            if (RGFile$OUT == YES)                     # put to designated file
            {
                for (i = 1; i <= jj; i = i + 1)
                {
                    if      (tline[i] == $RETURN)   continue
                    else if (tline[i] == $LINEFEED) 
                             call putch (NEWLINE, RGFile$NBR)
                    else if (tline[i] == EOS)       continue
                    else     call putch (tline[i], RGFile$NBR)
                }
			}
		}
	}

    itslots = used$rg$slots
    itslots = (inslots - ioslots) + itslots
    used$rg$slots = itslots

    idtg = Msg_DTG (msg_minute*1.0)	# Changed to Msg_DTG 
                                    # from game_dtg, JA 8/98 E2023
    call echor
    call echor
    call echov ("* * * * * RAINFORM Generator Message Summary * * * * *")
    call echor
    call echov ("               For Game Time = ")
    call echoiz (idtg, 6) 
    call echov ("Z")
    call echor
    call echor

    klen = 0
    if      (rgtfcc$out == YES) call smovv ("TFCC", genmode, klen)
    else if (rgpost$out == YES) call smovv ("POST", genmode, klen)
    else if (rgcpx$out == YES) call smovv  ("CPX", genmode, klen)
    else if (rgpshot$out == YES) call smovv ("FOTC", genmode, klen)

    call echov ("Generator Mode ------> ")
    call echohn(genmode, $$MaxLit)
 
    if (Number$Track$Alloc > 9999) 
    {
        call echor
        call echov (" --NOTE-- Track #'s Exceed XX9999")
    }

    call echor; call echor
    call echov ("Slots filled this game minute = ")
    call echoi (inslots)
    call echor
    call echov ("Slots emptied this game minute = ")
    call echoi (ioslots)
    call echor
    call echov ("Total slots in use = ")
    call echoi (itslots)
    call echor
    call echor
    call echov ("Messages sent this game minute = ")
    call echoi (imsgcnt)
    call echor
    call echov ("Garbled messages sent this game minute = ")
    call echoi (igrblcnt)
    call echor
    call echov ("Total messages sent in game so far = ")
    call echoi (itotmsgs)
    call echor; call echor
    call echov ("* * * * * * * * * * * * * * * * * * * * * * * * * * * ")
    call echor; call echor; call echor

    if (msgstatcnt == YES) call msgcntfile (itslots)

    inslots = 0
    ioslots = 0
}

bufpnt = 1
imsgcnt = 0

if (tcp_connection_open == YES)
	rc = tcp_client_close(sockfd)

return
end



subroutine msgcntfile (itslots)
################################################################
#$%
#$% Purpose:   Sends certain message statistics to a file for
#$%            later use.
#$%
#$% Date:      Aug 88
#$%
#$% Author:    Jim Kvederis
#$%
#################################################################
bbcommon
rfcommon
msgcommon

integer Msg_DTG
character gdtg[8], mdtg[8]
integer ndtg, idtg, ll, kk, itslots

ndtg = Msg_DTG (game$minute*1.0)  # from game_dtg, JA 8/98 E2023
idtg = Msg_DTG (msg_minute*1.0)	

ll = 0
call smoviz (ndtg, 6, gdtg, ll)
call smovv ("Z", gdtg, ll)
call smov  (EOS, gdtg, ll)

kk = 0
call smoviz (idtg, 6, mdtg, kk)
call smovv ("Z", mdtg, kk)
call smov  (EOS, mdtg, kk)

call putlin (gdtg, msgstat)
call putlin_v ("     ", msgstat)
call putlin (mdtg, msgstat)
call putlin_v ("    ", msgstat)
call putint (inslots, 3, msgstat)
call putlin_v ("       ", msgstat)
call putint (ioslots, 3, msgstat)
call putlin_v ("       ", msgstat)
call putint (itslots, 3, msgstat)
call putlin_v ("        ", msgstat)
call putint (imsgcnt, 3, msgstat)
call putlin_v ("         ", msgstat)
call putint (itotmsgs, 3, msgstat)
call putlin (NEWLINE, msgstat)

return
end



Integer function iarea(iimaj,iimin)
####################################################################
#
#      Function converts radians to integer degrees
#
####################################################################
implicit none

integer iimaj, iimin

iarea = ($pi)*(iimaj)*(iimin)

return
end



Integer function iddd(rad)
####################################################################
#
#      Function converts radians to integer degrees
#
####################################################################
implicit none

real rabsdd, rad

rabsdd = abs(rad * (180./$pi))      #real absolute degrees
iddd = int(rabsdd + .5)             #integer degrees rounded

return
end




Subroutine latlon (tlat,tlon,iformat)
#################################################################
#
#      converts lat/lon in radians to lat/lon in degrees/minutes
#
#################################################################
# LatLon fills word 2 and 4 of output buffer posit as below:
#
# word no:   ! 1  !  2  !  3   !   4   !   5   !...
#            !    !     !      !       !       !...
# contents:  !    ! lat !      ! long  !       !...
###################################################################
implicit none
tmpcommon

REAL*4  tlat, tlon      # jb E2207 vice LITERAL   9/18/00
integer jj, iformat

JJ = 0;  call amovll (tlat,'NS',posit[2],jj,iformat)
JJ = 0;  call amovll (tlon,'EW',posit[4],jj,iformat)

return
end



Subroutine amovll (radian,hems,dest,len2,iformat)
###########################################################
#$%
#$% Purpose:   AMOVLL builds ASCII representation of
#$%            a latitude or longitude into a buffer.
#$%
###########################################################
implicit none
tmpcommon

Real*4  radian              # jb E2207  9/18/00
character dest[ARB]
VMSchar     hems*2          # jb E2144  8/15/00
integer sdig
real    xbdeg, xbmin
integer imnt, i, k, len2, iformat, ickdig

xbdeg = abs(radian*(180./$pi))                 #convert to absolute degrees
ideg = int(xbdeg)                              #take integer part
xbmin = 60. * (xbdeg - float(ideg))            #convert excess to minutes
imnt= int(xbmin + .5)                         #round to nearest whole minute

if (imnt >= 60)                                 #if 60 minutes
   {
    ideg = ideg + 1                             #make one more degree
    imnt = 0                                    #and zero minutes
   }                                            #end if 60 minutes

if (radian >= 0.0) i = 1                       # N or E
else               i = 2                       # S or W

#$% determine if 2 digits for lat or 3 digits for long
if ( hems[i:i] == "N" |  hems[i:i] == "S" ) k = 2   # jb E2144  8/15/00
else                                        k = 3

#$% move degrees/minutes into array for display
call smoviz(ideg,k,dest,len2)
call smoviz (imnt,2,dest,len2)
if (iformat == comma$nocksum) call smovv (",",dest,len2)
call smovV (hems[i:i],dest,len2)        # jb E2144  8/15/00

if (iformat == cksum$nocomma)
   {
    sdig = ideg * 100 + imnt
    call ckdig (sdig, ickdig)
    call smoviz (ickdig, 1, dest, len2)
   }

return
end



Subroutine paradrift (driftinc, radpara, vradpara)
####################################################################
#
# Builds a portion of the INRAD line for a radar operating in a 
# specific from mode 1 through 3.
#
####################################################################

bbcommon
rfcommon
rgcommon
ptr2common

literal driftinc, radpara
literal cstrip8, msgname
integer imsgtype, index, pindex
real    anumb, aradpara, vradpara

#irnum = int(random2(x) * 20)
#if (irnum == 0) irnum = 1
#if (random2(x) > .50) irnum = irnum * -1
#drift = irnum * driftinc
#vradpara = radpara + drift

#vradpara = radpara 

msgname = xmsg$dcteename$c
imsgtype = xmsg$msgtype$i 

if (imsgtype == $selor$rmsg   | 
    imsgtype == $gwizard$rmsg |
    imsgtype == $gselor$rmsg ) call get_ssrindx (msgname, index)
else                           call get_rmtindx (msgname, index) 

if      (index <= 0)                pindex = 1.0
else if (index > 50 & index < 100)  pindex = (index - 50) * -1.0
else if (index >= 100)              pindex = index * .1
else                                pindex = index

anumb = pindex * driftinc                       # put inum in appropriate scale

#call echor
#call echov ("Name = ")
#call echoh (msgname, 8)
#call echor
#call echov ("Index = ")
#call echoi (index)
#call echor
#call echov ("driftinc = ")                # debug
#call echof (driftinc, 3)
#call echor
#call echov ("add to param = ")
#call echof (anumb, 3)
#call echor

aradpara = radpara * anumb
vradpara = aradpara + radpara

return
end



integer function uncorr_bfl(itn)
####################################################################
#
# Generates a track number for a Blue Force Locator Message
#
####################################################################
implicit none
rgcommon

integer itn
BBDeclare(TCR$Pointer)

for (TCR$Pointer$first; TCR$Pointer$Valid; TCR$Pointer$Next)
  {
  if (xTCR$Init$I == 0)         # empty slot
    {
    putTCR$Init$I (itn)
    putTCR$BlueForce$I ($YES)
    break
    }
  else
    {
    if (xTCR$Init$I == itn & xTCR$BlueForce$I == $YES) break
    }
  }

return (TCR$Pointer$Index)
end



integer function uncorr(itn)
####################################################################
#
# Generates a track number for a Contact report message
#
####################################################################
BBimplicit 
rgcommon

literal trknum, bld_tn
literal cstrip8
integer itn
BBDeclare(TCR$Pointer, TCR$RESATN$C)

trknum = bld_tn()

for (TCR$Pointer$first; TCR$Pointer$Valid; TCR$Pointer$Next)
  {
  if (xTCR$Init$I == 0)         # empty slot
    {
    putTCR$RESAtn$C (trknum)
    putTCR$BlueForce$I ($NO)
    break
    }
  else
    {
    TCR$RESAtn$C = xTCR$RESAtn$C
    if (TCR$RESAtn$C == trknum & xTCR$BlueForce$I == $NO) break
    }
  }

return (TCR$Pointer$Index)
end



Subroutine get_nosic_name (index, nosic_name)
####################################################################
#
# Purpose:  Generates a real-world standard OTG unknown track name
#           for a Contact report message
#
# Date:     August 1998 (E2027)
#
# Author:   Jim Allen
#
####################################################################
BBimplicit 
rgcommon
rfcommon

integer index, isize, ilen
character nosic_name[ARB]
character nosic[4]

integer length

ilen = 0

isize = length(RGntds$Vue)
call smovh (RGntds$Vue, isize, nosic_name, ilen)

call smovv ("UNK", nosic_name, ilen)

call get_nosic(index, nosic)
call smovhn (nosic,4, nosic_name, ilen)

call smov  ($NULL, nosic_name, ilen)

return
end


integer Function Msg_DTG(gmin)

bbcommon
tmpcommon
rgcommon

integer day,hrs,dtg, month
real gmin
vmschar*8 Names_v[12] / "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                        "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"/
literal   Names[12]
equivalence (names_v, names)

integer log, min

# cal for DAY and TIME
day = [(ZULU$StartTime + gmin) / (60*24)] + julian$day + RGjulian_off 

# Note: There will be a discrepancy if DAY (w/offset) exceeds the 
#       number of days in a year.           # DEW

call monday(RGYear,      # year like 1982
            day,         # Julian day
            month,       # Month(out)
            iday)        # Day(out)tmpcommon

mnth = Names[month]

log = mod(ZULU$StartTime + int(gmin), 1440)
min = mod(log,60)
hrs = log/60
dtg = iday*10000 + (hrs*100 + min)

return(dtg)
end


literal function bld_tn()
####################################################################
#
# Reconstructs the RESA track number
#
####################################################################
bbcommon
rfcommon
rgcommon
ptr2common
msgcommon

literal trknum, trkcode, a_track
integer t_class
integer itype, isens, i_switch_1, itrkno
literal cstrip
BBDeclare(MSG$MsgType$I)

t_class = $MINUS           # default...

msg$msgtype$i = xmsg$msgtype$i 

if (msg$msgtype$i == $Gold$RMsg)
    {
    itype = xmsg$unittype$i
    isens = xMSG$Sensor$I

    if      (isens == $ESM$RSens)           t_class = $LETE
    else if (isens == $AESM$RSens)          t_class = $LETE
    else if (isens == $SONPAS$RSens)        t_class = $LETP
    else if (isens == $TASS$RSens)          t_class = $LETP
    else                             
        {
        switch (itype)     
            {
            case $air$rtype:                 t_class = $LETA;
            case $sub$rtype,$airsub$rtype:   t_class = $LETU;
            case $surfwac$rtype,$surf$rtype: t_class = $LETS;
            }
        }
    }
else if (msg$msgtype$i == $GESM$RMsg)       t_class = $LETE
else if (msg$msgtype$i == $gsosus$rmsg)
    {
    if (xMSG$SWABStrk$I == $YES)            t_class = $LETT
    else                                    t_class = $LETZ
    }
else if (msg$msgtype$i == $ghfdf$rmsg)      t_class = $LETH
else if (msg$msgtype$i == $gsonbp$rmsg |
         msg$msgtype$i == $gsontp$rmsg |
         msg$msgtype$i == $gsonp$rmsg)      t_class = $LETP
else if (msg$msgtype$i == $gsonba$rmsg)     t_class = $LETU
else if (msg$msgtype$i == $gwizard$rmsg)    t_class = $LETE
else if (msg$msgtype$i == $gIR$rmsg)        t_class = $LETI
else if (msg$msgtype$i == $gselor$rmsg)   
    {
    if (xmsg$selrad$i == $no)               t_class = $LETE
    else
        {
        itype = xmsg$unittype$i
        switch (itype)     
            {
            case $air$rtype:                t_class = $LETA;
            case $sub$rtype,$airsub$rtype:  t_class = $LETU;
            case $surfwac$rtype,$surf$rtype:t_class = $LETS;
            }
        }
    }
else                                        t_class = $LETE

trkcode = xmsg$trackcode$c 
itrkno  = xmsg$trackno$i 

trknum = a_track(trkcode, t_class, itrkno)

return (trknum)
end

