##   File:     WSSITREP.RAT
##   Created:  October 1996 (E1722)
##
##   Processing of the SITREP command
 
include "bbacc.inc"
include "bbaml.inc"
include "bbord.inc"
include "bbshc.inc"
include "bbsta.inc"
include "bbunt.inc"
include "bbown.inc"
include "bbdeq.inc"
include "bbinv.inc"
include "bbgnd.inc"
include "bbmc.inc"
include "bbbom.inc"
include "bbtor.inc"
include "bbtrp.inc"
include "bbcmc.inc"
include "bbsob.inc"
include "bbson.inc"
include "bbrad.inc"
include "bbesm.inc"
include "bbiff.inc"
include "bbjam.inc"
include "bbrmt.inc"
include "bbrte.inc"
include "bbvue.inc"
include "bbjew.inc"
include "bbpim.inc"
include "bbbtt.inc"
 
include "bbctl.inc"
include "bbcode.inc"
include "ascii.inc"
include "orders.inc"
include "plplay.inc"
include "stmain.inc"
 
define (BBImplicit, Implicit None)  # MJC 4/19/2000

subroutine ositrep (nord,         # in:  order number
                    STA$Pointer,  # in:  station pointer
                    nargs,        # in:  number of arguments
                    args)         # in:  order command string
###########################################################################
#$%
#$% Purpose: to process   SITREP (for) <name>
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
Playcommon
 
literal args[20]
character sitrep_title[ARB]
character msg[ARB], sitrep_outfile[ARB]
integer nord
integer sta$pointer, iview
integer game_DTG
literal iaddr
literal unt$name$c
integer indx
integer unt$type$i
integer unt$SubType$i
integer stka[$Max$TaskGroup],cnta,flga
integer i, kk, kkh, ista_num, ilen, n       # MJC 4/19/2000
integer length, jj, nargs           # MJC 4/19/2000
integer iside
literal cstrip8                     # MJC 4/19/2000
literal sidecode2str, reportcode2str
integer astab_status
Bbdeclare      (UNT$FullName$V,
                UNT$Flag$V, UNT$Hulltype$V, UNT$Hullnumber$I,unt$pointer,
                own$pointer, unt2$pointer)
VMSchar*ARB     VSTRIP, msg2
 
iaddr = args[2]
iview = Xsta$view$I
if (iview <= $Neutral$view)
    iview = 0
 
call expord (iview,iaddr,cnta,stka,flga,nord)
 
if(cnta == 0)
 {
   kk = 0
   call smovhn (iaddr, $$MaxLit, msg, kk)
   call smovv  (" is an unknown addressee!", msg, kk)
   call echoh  (msg, kk)
   call echor
   return
 }
 
n = 0
for (i = 1; i <= cnta; i = i+1)
{
    unt$pointer = stka[i]
    if (Xunt$GhostedUnit$I == $yes) n = n + 1
}
if (n == cnta)
{
   kk = 0
   call smovhn (iaddr, $$MaxLit, msg, kk)
   call smovv  (" is an ghosted unit!", msg, kk)
   call echoh  (msg, kk)
   call echor
   return
}
ista_num = STA$Pointer$Index
 
for (i = 1; i <= cnta; i = i+1)
  {
    unt$pointer = stka[i]
    if (Xunt$GhostedUnit$I == $yes) next        # skip ghosted units
    unt$name$c = xUNT$name$c
    unt$type$i = xUNT$type$i
    unt$subtype$i = xUNT$SubType$i
 
    #$% Do not send reports on requests for single units that are not ships, boats, bases and subs
    if(cnta == 1)
     {
      if (UNT$type$i != $ShoreBase$code & UNT$type$i != $Surface$code &
          UNT$Type$i != $Air$code &             # joa 1/05
         (UNT$type$i != $SubSurface$code | unt$SubType$i != $Standard$SubCode))
       {
        kk = 0
        call smovv  (" Situation report  is not available for  ", msg, kk)
        call smovhn (unt$name$c, $$MaxLit, msg, kk)
        call echoh  (msg, kk)
        call echor
        return
       }
     }
 
    #$% Skip reports on units that are not ships, boats, bases and subs but they are in a task group
    if(cnta > 1)
     {
      if (UNT$type$i != $ShoreBase$code & UNT$type$i != $Surface$code &
          UNT$type$i != $Air$code &
         (UNT$type$i != $SubSurface$code | unt$SubType$i != $Standard$SubCode))
       {
        next
       }
     }
 
    kk=0
    call smovv ("SITREP FOR ", sitrep_title, kk)
    call smovhn (unt$name$c, $$Maxlit, sitrep_title,kk)
 
    UNT$FullName$V = xUNT$FullName$V
    if (UNT$FullName$V > " ")
        {
        call smovv(" (",sitrep_title,kk)
        call smovvt (UNT$FullName$V,sitrep_title,kk)
        call smovv(")",sitrep_title,kk)
        }
    if (Xunt$Type$i == $Air$code)
    {
        call smovv (" launched from ", sitrep_title,kk)
        unt2$pointer$to (Xunt$LaunchIndx$i)
        if (unt2$pointer$ok)
            call smovhn (Xunt2$name$c, $$Maxlit, sitrep_title,kk)
        else
            call smovv ("Unknown", sitrep_title,kk)
    }
 
    call smovv (" AS OF GAME TIME ", sitrep_title,kk)
    call smoviz (Game_DTG(Game$Time), 6,sitrep_title,kk)
    call smovv ("Z", sitrep_title,kk)
    call smov (EOS, sitrep_title,kk)
    call echoh (sitrep_title, kk)
    call echor
 
    #----------------------------------------
    # New OTG info            dew 11/2000
    kk = 0
 
    unt$flag$v        = Xunt$flag$v
    unt$hulltype$v    = Xunt$hulltype$v
    unt$hullnumber$i  = Xunt$hullnumber$i
 
    if (unt$Flag$V > " ")
        {
        call smovv ("  Flag: ",         msg, kk)
        call smovV (unt$Flag$V,         msg, kk)
        }
 
    if (unt$HullType$V > " ")
        {
        call smovv ("  Hull: ",         msg, kk)
        call smovVT(unt$HullType$V,     msg, kk)
        if (unt$hullnumber$i > 0)
            call smovi(unt$hullnumber$i,msg, kk)
        }
 
    if (kk > 0)
        {
        call echoh (msg, kk)
        call echor
        }
 
    if (UNT$type$i == $Air$code)
    {
        call report_aircraft_situation(unt$pointer)
    }
    else
    {
        call report_situation(unt$pointer)
    }
  }
 
return
end

subroutine report_situation(unt$pointer)
###########################################################################
#$%
#$% Purpose: Executive routine
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
integer unt$pointer
integer own$pointer
 
    OWN$Pointer$to  (xUNT$OwnIndx$i)
 
    call report_fuel_state(unt$pointer)
    call report_damage(unt$pointer)
 
    if(xOWN$AirCapable$i == $yes)
          call report_aircraft(unt$pointer)
 
    call report_expendables(unt$pointer)
 
    call report_ground(unt$pointer)
 
return
end

subroutine report_aircraft_situation(unt$pointer)
###########################################################################
#$%
#$% Purpose: Aircraft situation report
#$%
#$% Called By: ositrep
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       January 2005
#$%
#$% Author:    James Allen
#$%
###########################################################################
BBCommon
 
integer unt$pointer
 
call report_aircraft_sensors (unt$pointer)
call report_aircraft_tasking (unt$pointer)
call report_aircraft_flight_state(unt$pointer)
call report_aircraft_event_state(unt$pointer)
call report_aircraft_expendables(unt$pointer)
 
return
end

subroutine report_aircraft_flight_state(unt$pointer)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       January 2005
#$%
#$% Author:    James Allen
#$%
###########################################################################
BBCommon
 
integer  UNT$Pointer
 
#                      1         2         3         4         56         7
#            01234567890123456789012345678901234567890123456789012345678901234567890123456789
string MSG2 "SIDE#   NBR  LAT    LONG    GUIDE   BRG RNG CUS SPD   ALT  MISSN WPN  FUEL STAT"
string MSG3 "------   -- ------ ------- -------  --- --- --- ---- ----- ----- ---- ---- ----"
 
Literal igide, jblank, MISSN, CSTRIP8
Literal Astab_Mission       # external function 12/21/89
Literal Astab_Roe           # external function 12/21/89
LITERAL UNT$Name$C
REAL*4  OWN$Latitude$F,OWN$Longitude$F, UNT$TrueCourse$F,
        UNT$TrueLatitude$F,UNT$TrueLongitude$F
integer IC, COURSE,
        istat,iblank, ispeed,irange,
        OWN$Pointer,OWN$NbrAC$I,OWN$Guide$I,OWN$Speed$I,
        OWN$GuideBearing$I,OWN$Course$I,OWN$Altitude$I,
        OWN$Mission$I,OWN$PercentFuel$I,OWN$Status$I,
        UNT2$Pointer,UNT$Mission$I, ibyte, length
character msg[ARB]
 
Data jblank /$BLANKLIT/
Data IBLANK /$BLANKI4/
 
UNT$NAME$C = XUNT$NAME$C               # yes, get name
UNT$Mission$I = xUNT$Mission$I
OWN$Pointer$to  (xUNT$OwnIndx$i)
 
call clear_str (msg, 80)
 
#$% if unit name is valid
if(UNT$NAME$C != $NO)
   {
    IBYTE = 0
 
    #$% move unit name to the IPAGE array
    call SMOVH (UNT$NAME$C,$$MAXname,msg,IBYTE)
 
    if ((xUNT$GhostedUnit$I == $Yes) &
        ((UNT$Mission$I == $AEW$Code) |
         (UNT$Mission$I == $AirTanker$Code) |
         (UNT$Mission$I == $STtanker$Code)))
       call smovv ("*", msg, IBYTE)
   }
 
 
#$% get number of aircraft
own$nbrac$i = xown$nbrac$i
 
IBYTE = 9
 
#$% move aircraft number to the IPAGE array
call SMOVIB(_
     own$nbrac$i,
     2,                    # convert to ascii
     msg,                  # chars
     IBYTE)
 
#$% get latitude
own$latitude$f = xown$latitude$f
 
IBYTE = 12
 
#$% move latitude to the IPAGE array
call SMOVLL(_                          # convert to degrees and
     own$latitude$f,                   # minutes
     "NS",                             # DD-MM
     msg,
     IBYTE)
 
#$% get longitude
own$longitude$f = xown$longitude$f
 
IBYTE = 19
 
#$% move longitude to the IPAGE array
call SMOVLL(_
     own$longitude$f,      # convert longitude to
     "EW",
     msg,                  # degrees and minutes
     IBYTE)                            # DDD-MM
 
IGIDE = JBLANK
 
IRANGE = IBLANK
 
own$guide$i = xown$guide$i             # get guide index
 
if (own$guide$i != $NO)                # is there a guide?
   {
    UNT2$pointer$to own$guide$i        # set unt2 pointer
 
    IGIDE = XUNT2$NAME$C               # guide name.
 
    irange = xown$guiderange$i         # get guide range
 
    IBYTE = 27
 
    #$% move unit name to the IPAGE array
    call SMOVH(_
	 IGIDE,
	 $$MAXname,
	 msg,
	 IBYTE)
 
    IBYTE = 36
 
    #$% get guide bearings
    own$guidebearing$i = xown$guidebearing$i
 
    #$% move guide bearings to the IPAGE array
    call SMOVIZ(_                      # convert from radians to deg
	 own$guidebearing$i,
	 3,
	 msg,
	 IBYTE)
 
    IBYTE = 40
 
    #$% move guide range to the IPAGE array
    call SMOVIB(_                      # convert range to ascii
	 IRANGE,
	 3,
	 msg,
	 IBYTE)
 
   }
 
#$% get course
own$course$i = xown$course$i           # get assumed course
 
IBYTE = 44
 
call SMOVIZ(_
     own$course$i,                     # convert course to degrees
     3,
     msg,
     IBYTE)
 
#$% get speed
own$speed$i = xown$speed$i             # get speed
 
IBYTE = 48
 
call SMOVIB(_
     own$speed$i,                      # and convert to ascii
     4,
     msg,
     IBYTE)
 
#$% get altitude
own$altitude$i = xown$altitude$i       # get altitude
 
IBYTE = 53
 
call SMOVIB(_                          # and convert to
     own$altitude$i,                   # ascii chars
     5,
     msg,
     IBYTE)
 
#$% get mission
own$mission$i = xown$mission$i         # retrieve mission
 
if (own$mission$i != $noneassigned$code) # unit assigned a mission?
   {
    IBYTE = 59
    Missn = astab_mission(own$mission$i)
 
    call SMOVH(_
	 MISSN,         # yes, get ascii chars
	 5,             # jb Note: 5 characters frm function ASTAB_MISSION..
	 msg,
	 IBYTE)
   }                                   # for mission   endif
 
IBYTE = 65
 
call SMOVH(_
     Astab_ROE(Xown$roe$i, xOWN$NucFree$I),
     4,                                 # display array
     msg,
     IBYTE)
 
#$% get percent fuel
own$percentfuel$i = xown$percentfuel$i  # percent fuel
 
IBYTE = 71
 
#$% move percent fuel to the IPAGE array
if (AirFuelConsumption$Flag == $ON & xUNT$FuelConsumptionFlag$I == $ON)
  call SMOVIB(_
     own$percentfuel$i,                 # convert fuel to ascii
     3,                                 # chars and return in INP.
     msg,
     IBYTE)
else
  call SMOVV ("OFF",msg, IBYTE)  # jhm 3/99 E2010, fuel consum off
 
#$% if fuel warning is on
if (xown$fuelwarning$i != $no)           # is fuel warning on?
 
  {
   call SMOVV ("*",msg,IBYTE)    # yes, flag for display
  }
 
 
#$% get status:
own$status$i = xown$status$i
 
call OWNSTA (own$status$i, istat)
 
IBYTE = 75
 
call SMOVH(_
     ISTAT,                             # insert status into
     4,                                 # the display array
     msg,
     IBYTE)
 
call smov(EOS,msg,ibyte)
call echoh (msg2, length(msg2))
call echor
call echoh (msg3, length(msg3))
call echor
call echoh (msg, ibyte)
call echor
 
return
end

subroutine report_aircraft_event_state(unt$pointer)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       January 2005
#$%
#$% Author:    James Allen
#$%
###########################################################################
BBCommon
 
integer  UNT$Pointer
 
##                     1         2         3         4         5         6
##           012345678901234567890123456789012345678901234567890123456789012345
string MSG2 "CALLSIGN SIDE# MISSION# NBR  TYPE     LNCH RCVR MISSN  TARGT    TOT  REPT OBSV"
string MSG3 "-------- ----- -------- ---  ------   ---- ---- ----- -------- ----- ---- ----"
 
Literal MISS          # put MISSN array in function astab_mission 12/21/89 reh
Literal namtgt, CSTRIP8
Literal astab_Mission    # external function
LITERAL UNT$Event$C,UNT$Name$C,UNT$ForceName$C,
        ACC$Type$C
REAL*4 OWN$TimeObserved$F,OWN$TimeReported$F,
       OWN$TimeOverTarget$F
REAL*4 OWN$LaunchTime$F,OWN$RecoveryTime$F
integerGame_Time,   nbr, none,
        OWN$Pointer,OWN$Unit$I,OWN$Mission$I,
        OWN$AssignedTarget$I,OWN$View$I,
        UNT$GhostedUnit$I,
        UNT$Mission$I, ACC$Pointer, DEQ$Pointer
 
real    range_nmi, bearing
real    aircraft_speed
integer has_IFF, IFF$Pointer
integer UNT$View$I
integer ibyte
integer length
integer iff_mode, only_mode3
integer base_10_to_Base_8
 
character msg[ARB]
 
#$% get event
UNT$EVENT$C = XUNT$EVENT$C		## TPA 29NOV82
call clear_str (msg, 80)
 
#$% if event exists
if(UNT$EVENT$C != $NO)
  {
   IBYTE = 0
 
   #$% load event
   call SMOVH(_
   UNT$EVENT$C,
   $$MAXname,           # jb E2141 $$MAXname vice 5  1/6/00
   msg,
   IBYTE)
  }
 
UNT$NAME$C = XUNT$NAME$C                # get flight name
UNT$GhostedUnit$I = xUNT$GhostedUnit$I  #SMM 8/95 PER E1454
UNT$Mission$I = xUNT$Mission$I
 
##if (UNT$Name$C != $NO) # jb Omit callsign until side-number is assigned:
if(UNT$NAME$C != $NO & UNT$NAME$C != UNT$EVENT$C) # jb 1/6/00
  {
   IBYTE = 9    # jb E2141  (9 vice 7)  2/9/00
   call smovhn (UNT$Name$C, $$MaxLit, msg, ibyte)
 
   if ((xUNT$GhostedUnit$I == $Yes) & # SMM 8/95 PER E1454
       ((UNT$Mission$I == $AEW$Code) | # it's a ghosted unit with an AEW mission
        (UNT$Mission$I == $AirTanker$Code) |
        (UNT$Mission$I == $STtanker$Code)))
     {
      call smovv ("*", msg, ibyte)
     }
  }
 
UNT$ForceName$C = XUNT$ForceName$C      # get force name
 
if(UNT$ForceName$C != $NO)              # is there a force name?
  {
   IBYTE = 15    # jb E2141  (15 vice 14)  2/9/00
   call smovhn (UNT$ForceName$C, $$MaxLit, msg, ibyte)
  }
 
OWN$Pointer$to  (xUNT$OwnIndx$i)
 
nbr = xown$NbrAcTot$i                   # load number in flight
 
IBYTE = 24    # jb E2141  (25 vice 24 or 20)  2/14/00
call smovib (NBR, 3, msg, IBYTE)  # jb E2141 (3 vice 2) 2/15/00
 
acc$pointer = xown$accpntr$i            # set pointer to ACC table
 
ACC$TYPE$C  = XACC$TYPE$C                # retrieve the A/C type.
 
IBYTE = 29    # jb E2141  (29 vice 24 or 28)  2/14/00
 
call SMOVH(_
     ACC$TYPE$C,                    # insert A/C type into display array
     $$MAXname,         # jb E2141  ($$MAXname vice 5)  2/9/00
     msg,
     IBYTE)
 
OWN$LaunchTime$F = xOWN$LaunchTime$F    # retrieve A/C launch time
 
IBYTE = 38    # jb E2141  (38 vice 30)  2/14/00
 
#$% load launch time
call SMOVIZ (Game_Time(OWN$LaunchTime$F), 4,
             msg, IBYTE)
 
OWN$RecoveryTime$F = xOWN$RecoveryTime$F        # get A/C bingo time
 
#$% if bingo time non-zero
if(OWN$RecoveryTime$F != $NO)
  {
   IBYTE = 43    # jb E2141  (43 vice 35)  2/9/00
 
   #$% load recovery time tpa
   call SMOVIZ (Game_Time(OWN$RecoveryTime$F), 4,
                msg, IBYTE)
  }
 
own$mission$i = xown$mission$i                  # get A/C mission
 
if (own$mission$i != $noneassigned$code)        # unit assigned a mission?
  {
   #$% yes
   IBYTE = 48    # jb E2141  (48 vice 40)  2/15/00
 
   #$% get mission
   miss = astab_mission(own$mission$i)
 
   #$% load mission
   call SMOVH(_
	MISS,
	5,
	msg,
	IBYTE)
  }                                        # endif
 
#$% get assigned target
own$AssignedTarget$i = xown$AssignedTarget$i
 
#$% any target
if (own$AssignedTarget$i != 0)
  {
   if (OWN$AssignedTarget$I == UNT$Engaging$Position)    # clk 8/96 (E1644)
     {
      IBYTE = 55
      call smovv ("POSIT", msg, IBYTE)
      call RLL2RB (xUNT$TrueLatitude$F, xUNT$TrueLongitude$F,
                   xUNT$CosTrueLat$F,
                   xUNT$OrderedLatitude$F, xUNT$OrderedLongitude$F,
                   COS (xUNT$OrderedLatitude$F),
                   range_nmi, bearing)
      aircraft_speed = FLOAT (xOWN$Speed$I)
      aircraft_speed = MAX (0.001, aircraft_speed)
      OWN$TimeOverTarget$F = Game$Time +
                             ($Minutes$Per$Hour *
                                  (range_nmi / aircraft_speed))
      IBYTE = 63
      call smoviz (Game_Time (OWN$TimeOverTarget$F), 4, msg, IBYTE)
     }  # end of if unit is striking a position
   else
     {
      #$% yes, get view
      own$view$i = xown$view$i
 
      #$% get target data
      call GETTGT(own$AssignedTarget$i,namtgt)
 
      #$% if target exists
      if (namtgt != $BLANKLIT)
        {
         #$% load target name
         IBYTE = 55
         call smovHN(namtgt,$$MAXname, msg, IBYTE)
 
         #$% get intercept time
         OWN$TimeOverTarget$F = xOWN$TimeOverTarget$F
 
         #$% if time exists
         if (OWN$TimeOverTarget$F != 0)
           {
            IBYTE = 63
            call smovIZ(Game_Time(OWN$TimeOverTarget$F),4, msg, IBYTE)
           }
        }
     }   # end of if the assigned target is not the position code
  }   # end of if the unit has an assigned target
 
 
OWN$TimeReported$F = xOWN$TimeReported$F
 
IBYTE = 69
call SMOVIZ (Game_Time(OWN$TimeReported$F), 4,
             msg, IBYTE)
 
OWN$TimeObserved$F = xOWN$TimeObserved$F
 
IBYTE = 74
 
#$% if time non-zero, load time
if (OWN$TimeObserved$F != 0)
   call smovIZ(Game_Time(OWN$TimeObserved$F),4, msg, IBYTE)
 
call smov(EOS,msg,ibyte)
call echoh (msg2, length(msg2))
call echor
call echoh (msg3, length(msg3))
call echor
call echoh (msg, ibyte)
call echor
 
return
end

subroutine report_fuel_state(unt$pointer)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
#$% Modified:  Susan Miller - 12/97 (E1660)
#$%            Adjusted columns, changed aviation fuel units from pnds to
#$%            gals, added test to only display transfer fuel when the
#$%            ship has hoses.
#$%
###########################################################################
BBCommon
 
literal cstrip8
integer  UNT$Pointer
integer  ipercentage
character fuel_state_msg[ARB]
real fuel_remaining, fuel_capacity
real transfer_remaining, transfer_capacity
real aviation_remaining, aviation_capacity
integer  SHC$Pointer
integer  ifuel_remaining, ifuel_capacity                # MJC 4/19/2000
integer  kk, itransfer_remaining, itransfer_capacity    # MJC 4/19/2000
integer  iaviation_remaining, iaviation_capacity        # MJC 4/19/2000
integer game_DTG
 
  call echov("FUEL STATE ")
  call echor
 
  call get_fuel_propulsion(unt$pointer, ipercentage, fuel_remaining, fuel_capacity)
  ifuel_remaining = nint (fuel_remaining)
  ifuel_capacity = nint (fuel_capacity)
  kk=0
  call smovv("   PROPULSION:  ",fuel_state_msg,kk)
  call smovib(ipercentage, 3, fuel_state_msg, kk)
  call smovv("%   ONBOARD ", fuel_state_msg, kk)
  call smovib(ifuel_remaining,10,fuel_state_msg,kk)
  call smovv(" CAPACITY ", fuel_state_msg, kk)
  call smovib(ifuel_capacity,10,fuel_state_msg,kk)
  call smovv(" GALS", fuel_state_msg, kk)
  call smov(EOS,fuel_state_msg,kk)
  call echoh (fuel_state_msg, kk)
  call echor
 
  # only display transfer fuel when unit has fuel hoses - smm 12/97 (E1660)
  SHC$Pointer = xUNT$SHCPntr$I
  if (xSHC$FuelHoses$I > 0)
    {
     call get_fuel_transfer(unt$pointer, ipercentage, transfer_remaining, transfer_capacity)
     itransfer_remaining = nint (transfer_remaining)
     itransfer_capacity = nint (transfer_capacity)
     kk=0
     call smovv("   TRANSFER:    ",fuel_state_msg,kk)
     call smovib(ipercentage, 3, fuel_state_msg, kk)
     call smovv("%   ONBOARD ", fuel_state_msg, kk)
     call smovib(itransfer_remaining,10,fuel_state_msg,kk)
     call smovv(" CAPACITY ", fuel_state_msg, kk)
     call smovib(itransfer_capacity,10,fuel_state_msg,kk)
     call smovv(" GALS", fuel_state_msg, kk)
     call smov(EOS,fuel_state_msg,kk)
     call echoh (fuel_state_msg, kk)
     call echor
    } # end if (xSHC$FuelHoses$I > 0) SMM 6/97 (E1660)
 
  call get_fuel_aviation(unt$pointer, ipercentage, aviation_remaining, aviation_capacity)
  iaviation_remaining = nint (aviation_remaining)
  iaviation_capacity = nint (aviation_capacity)
  kk=0
  call smovv("   AVIATION:    ",fuel_state_msg,kk)
  call smovib(ipercentage, 3, fuel_state_msg, kk)
  call smovv("%   ONBOARD ", fuel_state_msg, kk)
  call smovib(iaviation_remaining,10,fuel_state_msg,kk)
  call smovv(" CAPACITY ", fuel_state_msg, kk)
  call smovib(iaviation_capacity,10,fuel_state_msg,kk)
  call smovv(" GALS", fuel_state_msg, kk)       # changed from pnds to gals - smm 12/97 (E1660)
  call smov(EOS,fuel_state_msg,kk)
  call echoh (fuel_state_msg, kk)
  call echor
 
 
return
end

 
subroutine get_fuel_propulsion(unt$pointer, ipercentage, fuel_remaining, fuel_capacity)
###########################################################################
#$%
#$% Purpose: Extract assumed fuel information and compute percentages
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
integer unt$pointer
integer own$pointer
integer shc$pointer
integer ipercentage
real fuel_remaining, fuel_capacity
BBDeclare  (own$tnk$index,
            own$tnk$fuelremaining$F,
            shc$tnk$index,
            shc$tnk$capacity$F)                                 # MJC 7/25/2000
 
  OWN$Pointer$to  (xUNT$OwnIndx$i)
  OWN$TNK$Index = ShipFuelTank$Index
  OWN$TNK$FuelRemaining$F = xOWN$TNK$FuelRemaining$F
 
  SHC$Pointer = xUNT$SHCPntr$I
  SHC$TNK$Index = ShipFuelTank$Index
  SHC$TNK$Capacity$F = xSHC$TNK$Capacity$F
 
  if (xUNT$Type$I == $Surface$Code)
    {
      fuel_remaining = OWN$TNK$FuelRemaining$F
      fuel_capacity = SHC$TNK$Capacity$F
 
      if (fuel_capacity == 0.0)  #represents nuclear or don't care
          ipercentage = 100
      else
          ipercentage = nint(fuel_remaining / fuel_capacity * 100.)
 
    }   # end of if a surface ship
 
  return
  end

 
subroutine get_fuel_transfer(unt$pointer, ipercentage, transfer_remaining, transfer_capacity)
###########################################################################
#$%
#$% Purpose: Extract assumed fuel information and compute percentages
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
integer unt$pointer
integer own$pointer
integer shc$pointer
integer ipercentage
real transfer_remaining, transfer_capacity
BBDeclare  (own$tnk$index,
            own$tnk$fuelremaining$F,
            shc$tnk$index,
            shc$tnk$capacity$F)                                 # MJC 7/25/2000
real shipusefuelcapacity                                        # MJC 4/20/2000
 
  OWN$Pointer$to  xUNT$OwnIndx$i
 
  OWN$TNK$Index = ShipFuelTank$Index
  OWN$TNK$FuelRemaining$F = xOWN$TNK$FuelRemaining$F
 
  SHC$Pointer = xUNT$SHCPntr$I
  SHC$TNK$Index = ShipFuelTank$Index
  SHC$TNK$Capacity$F = xSHC$TNK$Capacity$F
 
  ShipUseFuelCapacity = SHC$TNK$Capacity$F * xSHC$PctShipFuelReserve$F
 
  if (xSHC$FuelHoses$I > 0)  #represents is transfer capable
    {
     transfer_remaining = OWN$TNK$FuelRemaining$F - ShipUseFuelCapacity
 
     transfer_capacity = SHC$TNK$Capacity$F - ShipUseFuelCapacity
 
     if (transfer_capacity == 0.0)  #represents nuclear or don't care
          ipercentage = 100
     else
          ipercentage = nint(transfer_remaining / transfer_capacity * 100.)
 
    }
 
 
return
end

 
subroutine get_fuel_aviation(unt$pointer, ipercentage, aviation_remaining, aviation_capacity)
###########################################################################
#$%
#$% Purpose: Extract assumed fuel information and compute percentages
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
literal cstrip8
integer unt$pointer
integer own$pointer
integer shc$pointer
integer ipercentage
real aviation_remaining, aviation_capacity
BBDeclare  (own$tnk$index,
            own$tnk$fuelremaining$F,
            shc$tnk$index,
            shc$tnk$capacity$F,
            unt$ownindx$I)                                      # MJC 7/25/2000 (E2145)
 
  UNT$OwnIndx$i =  xUNT$OwnIndx$i
  OWN$Pointer$to  UNT$OwnIndx$i
 
  OWN$TNK$Index = AviationFuelTank$Index
  OWN$TNK$FuelRemaining$F = xOWN$TNK$FuelRemaining$F
 
  SHC$Pointer = xUNT$SHCPntr$I
  SHC$TNK$Index = AviationFuelTank$Index
  SHC$TNK$Capacity$F = xSHC$TNK$Capacity$F
 
 
  aviation_remaining = xOWN$TNK$FuelRemaining$F
  aviation_capacity = xSHC$TNK$Capacity$F
 
  if (aviation_capacity == 0.0)  #represents air capable
       ipercentage = 0
  else
       ipercentage = nint(aviation_remaining / aviation_capacity * 100.)
 
 
return
end

subroutine report_damage(unt$pointer)
###########################################################################
#$%
#$% Purpose: Executive routine
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
literal cstrip8
integer unt$pointer
character damage_msg[ARB]
integer nfound
integer kk, ispeed, i, klen, length         # MJC 4/20/2000
integer game_DTG
VMSchar*34 array_inoperable[200]
 
 call echov("DAMAGE ")
 call echor
 
  kk=0
  call smovv("   PROPULSION:  MAX SPEED ",damage_msg,kk)
  ispeed = xUNT$speed$i
  call smovib(ispeed, 2, damage_msg, kk)
  call smovv(" KTS", damage_msg,kk)
  call smov(EOS,damage_msg,kk)
  call echoh(damage_msg,kk)
  call echor
 
 call get_systems_inoperable(unt$pointer,array_inoperable, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   SYSTEMS INOPERABLE:  ",damage_msg,kk)
   call smov(EOS,damage_msg,kk)
   call echoh(damage_msg,kk)
   call echor
   for(i=1;i<=nfound;i=i+1)
     {
      kk=0
      call smovv("          ", damage_msg,kk)
      call smovv(array_inoperable[i],damage_msg,kk)
      call smov(EOS,damage_msg,kk)
      call echoh(damage_msg,kk)
      call echor
     }
  }
 
 
return
end

subroutine report_aircraft(unt$pointer)
###########################################################################
#$%
#$% Purpose: Executive routine
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
integer unt$pointer, own$pointer
 
 call echov("AIRCRAFT ")
 call echor
 
 OWN$Pointer$to  (xUNT$OwnIndx$i)
 call get_aircraft(own$pointer)
 
return
end

subroutine report_expendables(unt$pointer)
###########################################################################
#$%
#$% Purpose: Executive routine
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
literal cstrip8
integer isexp
integer unt$pointer, expendable_code, nfound
integer kk, kkh, i, klen, length, itrp       # MJC 4/20/2000
integer exp_qty[100]
integer game_DTG
literal EQCode2Str
VMSchar*34 exp_name[100]
character expendables_msg[ARB]
BBDeclare (deq$remaining$i, deq$ident$i, deq$pointer,
           tbl$pointer,tbl$FullName$v)
VMSchar vstrip*(ARB)
 
 call echov("EXPENDABLES ")
 call echor
 
 expendable_code = $CruiseMissile$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   CRUISE MISSILES: ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv (exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk = 0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 expendable_code = $AdvancedSAM$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   ADVANCED SAM:    ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv (exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk = 0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 expendable_code = $ASM$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   ASM:             ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
 }
 
 expendable_code = $BOMB$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   BOMBS:           ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 expendable_code = $AAM$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   AAM:             ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
 }
 
 expendable_code = $SAM$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   SAM:             ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 itrp = $no
 expendable_code = $Torpedo$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   itrp = $yes
   call smovv("   TORPEDOES:       ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 expendable_code = $SmartTorpedo$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk = 0
   if(itrp == $no)
       call smovv("   TORPEDOES:       ",expendables_msg,kk)
   else
       call smovv("                    ",expendables_msg,kk)
 
  for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 expendable_code = $Gun$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   GUN AMMO:      ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 6, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 expendable_code = $Sonobuoy$Code
 call get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
  if(nfound > 0)
  {
   kk=0
   call smovv("   SONOBUOYS:       ",expendables_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(exp_qty[i], 4, expendables_msg,kk)
     call smovv("  ", expendables_msg,kk)
     call smovv(exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
     kk=0
     call smovv("                    ", expendables_msg,kk)
    }
  }
 
 
return
end

subroutine report_ground(unt$pointer)
###########################################################################
#$%
#$% Purpose: Executive routine
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBCommon
 
literal cstrip8
integer isexp
integer unt$pointer, ground_code, nfound
integer kk, kkh, i, klen, length, itrp       # MJC 4/20/2000
integer ground_qty[100]
integer game_DTG
literal EQCode2Str
VMSchar*34 ground_name[100]
character ground_msg[ARB]
BBDeclare (deq$remaining$i, deq$ident$i, deq$pointer,
           tbl$pointer,tbl$FullName$v)
VMSchar vstrip*(ARB)
 
 call echov("GROUND      ")
 call echor
 
 ground_code = $EQPT$Code
 call get_ground(unt$pointer, ground_code, ground_name, ground_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   EQUIPMENT:       ",ground_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(ground_qty[i], 4, ground_msg,kk)
     call smovv("  ", ground_msg,kk)
     call smovv (ground_name[i],ground_msg,kk)
 
     call smov(EOS,ground_msg,kk)
     call echoh(ground_msg,kk)
     call echor
     kk = 0
     call smovv("                    ", ground_msg,kk)
    }
  }
 
 ground_code = $VEHIC$Code
 call get_ground(unt$pointer, ground_code, ground_name, ground_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   VEHICLE:         ",ground_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(ground_qty[i], 4, ground_msg,kk)
     call smovv("  ", ground_msg,kk)
     call smovv (ground_name[i],ground_msg,kk)
 
     call smov(EOS,ground_msg,kk)
     call echoh(ground_msg,kk)
     call echor
     kk = 0
     call smovv("                    ", ground_msg,kk)
    }
  }
 
 ground_code = $WEAP$Code
 call get_ground(unt$pointer, ground_code, ground_name, ground_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   WEAP:            ",ground_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(ground_qty[i], 4, ground_msg,kk)
     call smovv("  ", ground_msg,kk)
     call smovv (ground_name[i],ground_msg,kk)
 
     call smov(EOS,ground_msg,kk)
     call echoh(ground_msg,kk)
     call echor
     kk = 0
     call smovv("                    ", ground_msg,kk)
    }
  }
 ground_code = $PERS$Code
 call get_ground(unt$pointer, ground_code, ground_name, ground_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   call smovv("   PERSONNEL:       ",ground_msg,kk)
   for(i=1;i<=nfound;i=i+1)
    {
     call smovib(ground_qty[i], 4, ground_msg,kk)
     call smovv("  ", ground_msg,kk)
     call smovv (ground_name[i],ground_msg,kk)
 
     call smov(EOS,ground_msg,kk)
     call echoh(ground_msg,kk)
     call echor
     kk = 0
     call smovv("                    ", ground_msg,kk)
    }
  }
 
return
end
 

subroutine report_aircraft_expendables(unt$pointer)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       January 2005
#$%
#$% Author:    James Allen
#$%
###########################################################################
BBCommon
 
literal cstrip8
integer isexp
integer unt$pointer, expendable_code, nfound
integer kk, kkh, i, klen, length, itrp       # MJC 4/20/2000
integer exp_deq[100]
integer exp_qty[100]
integer exp_code[100], wexp
integer game_DTG
literal EQCode2Str
VMSchar*34 exp_name[100]
literal exp_text
character expendables_msg[ARB]
BBDeclare (deq$remaining$i, deq$ident$i, deq$pointer, deq$RippleQty$i,
           tbl$pointer,tbl$FullName$v)
BBDeclare (bom$pointer, mc$pointer)
 
VMSchar vstrip*(ARB)
 
 call echov("EXPENDABLES RIPPLE/TOTAL  RNG NAME")
 call echor
 
call clear_str (expendables_msg, 80)
 
 call get_all_expendables(unt$pointer, exp_deq, exp_code, exp_name, exp_qty, nfound)
 if(nfound > 0)
  {
   kk=0
   wexp = -1
   for(i=1;i<=nfound;i=i+1)
    {
     if (wexp != exp_code[i])
     {
        wexp = exp_code[i]
        exp_text =  EQcode2Str(exp_code[i])
        kk = 0
        call smovh(exp_text,8,expendables_msg,kk)
        call smovv("    ", expendables_msg,kk)
 
     }
     else
     {
        kk = 0
        call smovv("            ", expendables_msg,kk)
     }
     deq$pointer = exp_deq[i]
     deq$RippleQty$i = Xdeq$RippleQty$i
     if (deq$RippleQty$i == 0 & exp_code[i] != $CruiseMissile$code)
         deq$RippleQty$i = exp_qty[i]
 
     call smovi(deq$RippleQty$i, expendables_msg,kk)
     call smovv("/", expendables_msg,kk)
     call smovi(exp_qty[i], expendables_msg,kk)
     kk = 26
 
     # Get max range for asm and bomb
     if (exp_code[i] == $ASM$Code)
     {
        mc$pointer = Xdeq$Pntr$i
        call smovib(Xmc$MaxRange$i,3, expendables_msg, kk)
        call smovv (" ",expendables_msg,kk)
     }
     else if (exp_code[i] == $AAM$Code)
     {
        mc$pointer = Xdeq$Pntr$i
        call smovib(Xmc$MaxRange$i,3, expendables_msg, kk)
        call smovv (" ",expendables_msg,kk)
     }
     else if (exp_code[i] == $BOMB$Code)
     {
        bom$pointer = Xdeq$Pntr$i
        call smovib(Xbom$DropRange$i,3, expendables_msg, kk)
        call smovv (" ",expendables_msg,kk)
     }
     else
     {
         call smovv ("    ",expendables_msg,kk)
     }
     kk = 30
     call smovv (exp_name[i],expendables_msg,kk)
 
     call smov(EOS,expendables_msg,kk)
     call echoh(expendables_msg,kk)
     call echor
    }
  }
 
 
return
end

 
Subroutine get_aircraft(own$pointer)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
 
BBcommon
STATUScommon
 
integer ilen
integer unt$pointer, own$pointer, none
integer kk, kkh, in0, in4, in8, in12            # MJC 4/20/2000
integer inmnt, in16, infly, idestroyed, kkk     # MJC 4/20/2000
integer game_DTG
literal     cstrip8                                 # MJC 4/20/2000
BBDeclare  (unt$name$C,
            tbl$pointer, tbl$fullname$v)
Literal     jname
character   aircraft_msg[ARB]
VMSchar     vstrip*ARB
 
#$% get list of aircraft
call LISTAC(own$pointer,none)
 
#$% if none, return
if (none == $yes)
 {
   kk=0
   call smovv("             ----- No aircraft available ----- ", aircraft_msg, kk)
   call smov(EOS,aircraft_msg,kk)
   call echoh (aircraft_msg, kk)
   call echor
   return
 }
 
kk=0
call smovv("   TYPE                              AVAIL     "//"  MAINT    AIRBORNE        LOST ",aircraft_msg,kk)
call smov(EOS,aircraft_msg,kk)
call echoh(aircraft_msg,kk)
 
call echor
 
UNT$pointer$to xown$unit$i
UNT$NAME$C = XUNT$NAME$C
 
#$% loop thru aircraft names
repeat
   {
    #$% get availablity data
    call NXTAC(jname,in0,in4,in8,in12,inMNT,in16,infly,idestroyed)
 
    #$% if no aircraft, break loop
    if (jname == 0) break
 
    call tblfind ($$acc, jname, tbl$pointer)
 
    kk=0
    call smovv("   ",aircraft_msg,kk)
 
#    TBL$Fullname$V = xTBL$Fullname$V
#    if(TBL$Fullname$V > " ")
#        call smovvt(TBL$Fullname$V, aircraft_msg,kk)
#    else
#        call smovh (jname,$$Maxlit,aircraft_msg,kk)
 
    call smovh (jname,$$Maxlit,aircraft_msg,kk)
 
    TBL$Fullname$V = xTBL$Fullname$V
    if(TBL$Fullname$V > " ")
        {
        call smovv("  ",aircraft_msg,kk)
        call smovvt(TBL$Fullname$V, aircraft_msg,kk)
        }
 
    while (kk < 38)
        call smovv(" ",aircraft_msg,kk)
 
    call smovib(in0, 4, aircraft_msg, kk)
    call smovv("        ",aircraft_msg,kk)
    call smovib(inMNT, 4, aircraft_msg, kk)
    call smovv("        ",aircraft_msg,kk)
    call smovib(infly, 4, aircraft_msg, kk)
    call smovv("        ",aircraft_msg,kk)
    call smovib(idestroyed, 4, aircraft_msg, kk)
    call smov(EOS,aircraft_msg,kk)
    call echoh (aircraft_msg, kk)
    call echor
 
   }
 
 
return
end

 
Subroutine LISTAC(own$pointer,none)
##################################################################
#$%
#$% Purpose:   LISTAC generates list of available aircraft.
#$%
#$% Called By: AVAENT
#$%
#$% Calls:     INVENT
#$%
#$% Tables:    OWN     INV
#$%
#$% Date:      25 JAN 82
#$%
#$% Author:    F. Jones
#$%
##################################################################
 
BBcommon
InventoryCommon
 
integer inext, n, itype, number, none       # MJC 4/20/2000
BBDeclare  (own$firstinvindx$I,
            own$pointer,
            inv$exp$index,
            inv$pointer)                    # MJC 4/20/2000
Literal name
 
repeat
   {
    #$% get aircraft inventory
    own$FirstInvIndx$i = xown$FirstInvIndx$i
 
    inext = own$FirstInvIndx$i
    inv$exp$index = 0
 
    #$% initialize counters
    n = 0
    nbreq = 0
 
    #$% loop through aircraft inventory
    repeat
       {
        #$% get name and number of expendable equipment remaining
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
 
        #$% if null is reached, break from loop
        if (itype == $null$code) break
 
        if (itype != $AcNow$code) next
 
        n = n + 1
 
        #$% if counter greater than 40, break loop
        if (n > 40) break
 
        #$% save aircraft name
        namac[n] = name
 
        #$% load number ready
        nbrrdy[n,1] = number
 
        #$% get name and number of expendable equipment remaining
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $AcIn4$code) break
 
        #$% load number ready
        nbrrdy[n,2] = number
 
        #$% call to get name and number of expendable equipment remaining
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $AcIn8$code) break
 
        #$% load number ready
        nbrrdy[n,3] = number
 
        #$% call to get name and number of expendable equipment remaining
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $AcIn12$code) break
 
        #$% load number ready
        nbrrdy[n,4] = number
 
        ####  Added for A/C in MAINT (for AVAIL board only) jb  4/29/87
        #$% call to get name and number of expendable equipment remaining
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $MAINT$code) break
 
        #$% load number in MAINTENANCE
       # if(nbrrdy[n,4] > 0) nbrrdy[n,5] = number        # jb    7/29/87
       # else    nbrrdy[n,5] = number + 1                # jb    7/28/87
 
        nbrrdy[n,5] = number        # av  5/25/93
 
        #$% call to get name and number of expendable equipment remaining
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $AcIn16$code) break
 
        #$% load number ready
        nbrrdy[n,6] = number                        # av 5/19/93
 
        #$% call to get name and number of flying aircraft
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $AcFlying$code) break
 
        #$% load number ready
        nbrrdy[n,7] = number                        # av 5/19/93
 
      #$% call to get name and number of flying aircraft
        call INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
        if (itype != $AcDestroyed$code) break
 
        #$% load number ready
        nbrrdy[n,8] = number                        # av 5/19/93
 
        nbreq = n
       }
 
     #$% repeat until inventory is matched
   } until (xown$FirstInvIndx$i == own$FirstInvIndx$i)
 
if (nbreq > 0) none = $no
else           none = $yes
 
return
end

 
Subroutine INVENT (inv$pointer,inv$exp$index,inext,itype,name,number)
#######################################################################
#$%
#$% Purpose:   INVENT gets name of expendable equipment and number
#$%            remaining for display.
#$%
#$% Called By: LSTEXP     LISTAC     CAPENT
#$%
#$% Calls:     None
#$%
#$% Tables:    INV
#$%
#$% Date:      28 JAN 82
#$%
#$% Author:    F. Jones
#$%
#######################################################################
 
BBcommon
 
BBDeclare  (inv$exp$index,
            inv$pointer)                 # MJC 4/20/2000
integer inext, itype, number             # MJC 4/20/2000
literal cstrip8                          # MJC 4/20/2000
Literal name
 
#$% increment expendables index
inv$exp$index = inv$exp$index + 1
 
#$% if greater than number of slots
if (inv$exp$index > inv$exp$slots)
   {
    #$% set index to one
    inv$exp$index = 1
   }
 
#$% if index equals one
if (inv$exp$index == 1)
   {
    #$% if next index equals zero
    if (inext == 0)
       {
        #$% set type to null and return
        itype = $null$code
        return
       }
 
    #$% set inventory pointer
    inv$pointer$to inext
 
    #$% save next index
    inext = xinv$nextindx$i
   }
 
#$% get expendable type
itype = xinv$exp$type$i
 
#$% if null, return
if (itype == $null$code)  return
 
#$% get number remaining
number = xinv$exp$remaining$i
 
#$% get name of expendable
name = xinv$exp$name$c
 
return
end

 
Subroutine NXTAC(jname,in0,in4,in8,in12,inMNT,in16,infly,idestroyed)  # jb inMNT   4/29/87
#################################################################
#$%
#$% Purpose:   NXTAC puts aircraft names in order for output.
#$%
#$% Called By: FMTAC
#$%
#$% Calls:     None
#$%
#$% Tables:    None
#$%
#$% Date:      25 JAN 82
#$%
#$% Author:    F. Jones
#$%
##################################################################
 
InventoryCommon
StatusCommon
 
Literal jname,INAME
Integer nres
integer i, litcmp, inxt, in0, in4       # MJC 4/20/2000
integer in8, in12, inmnt, in16, infly   # MJC 4/20/2000
integer idestroyed                      # MJC 4/20/2000
 
#$% save highest name
jname = $highest$ascii
 
#$% search array
for (i=1 ; i<=nbreq ; i=i+1)
   {
    #$% get aircraft names
    iname = namac[i]
    #$% if none, get next
    if (iname == 0) next
     #$% if greater than highest, get next
#    if (iname >= jname) next
 
    NRES = LITCMP(INAME,JNAME)
 
    IF  (NRES >= JNAME) NEXT
 
    #$% save name
    jname = iname                               # at this point, have
                                                # best candidate so far
    #$% save index
    inxt = i
   }
 
#$% if highest
if (jname == $highest$ascii)
   {
    #$% clear name
    jname = 0
    return
   }
 
#$% get name
jname = namac[inxt]
 
#$% get number
in0   = nbrrdy[inxt,1]
in4   = nbrrdy[inxt,2]
in8   = nbrrdy[inxt,3]
in12  = nbrrdy[inxt,4]
inMNT  = nbrrdy[inxt,5] # jb - Count of this type in MAINT      4/29/87
in16 = nbrrdy[inxt,6]   # av
infly = nbrrdy[inxt,7]  # av 5/24/93
idestroyed = nbrrdy[inxt,8] #av 5/24/93
 
#$% clear aircraft name
namac[inxt] = 0
 
return
end

 
subroutine  get_expendables(unt$pointer, expendable_code, exp_name, exp_qty, nfound)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBcommon
 
integer unt$pointer, expendable_code
VMSchar*(*) exp_name[100]
integer     exp_qty[100]
integer     nfound
BBDeclare  (DEQ$Pointer,
            TBL$Pointer, TBL$Name$V, TBL$FullName$V)
VMSchar     VSTRIP*ARB
 
nfound = 0
FOR_DEQ_CHAIN
    {
    if (expendable_code != xDEQ$ident$i) next
 
    nfound = nfound + 1
    exp_qty [nfound] = xDEQ$Remaining$i
 
    tbl$pointer = xDEQ$pntr$i
 
    TBL$Name$V = xTBL$Name$V
    TBL$FullName$V = xTBL$FullName$V
    Exp_name[nfound] = TBL$Name$V
 
    if (TBL$FullName$V > " ")
        Exp_name[nfound] = TBL$Name$V // "-" // TBL$FullName$V
 
    } #end for loop
 
return
end

 
subroutine  get_ground(unt$pointer, ground_code, ground_name, ground_qty, nfound)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       August 2005
#$%
#$% Author:    James O. Allen
#$%
###########################################################################
BBcommon
 
integer unt$pointer, ground_code
VMSchar*(*) ground_name[100]
integer     ground_qty[100]
integer     nfound
BBDeclare  (DEQ$Pointer,gnd$pointer,
            TBL$Pointer, TBL$Name$V, TBL$FullName$V)
VMSchar     VSTRIP*ARB
 
nfound = 0
FOR_DEQ_CHAIN
    {
    if ($gnd$code != xDEQ$ident$i) next
 
    gnd$pointer = XDEQ$pntr$i
 
    if (ground_code != xGND$category$i) next
 
    nfound = nfound + 1
    ground_qty [nfound] = xDEQ$Remaining$i
 
    tbl$pointer = xDEQ$pntr$i
 
    TBL$Name$V = xTBL$Name$V
    TBL$FullName$V = xTBL$FullName$V
    ground_name[nfound] = TBL$Name$V
 
    if (TBL$FullName$V > " ")
        ground_name[nfound] = TBL$Name$V // "-" // TBL$FullName$V
 
    } #end for loop
 
return
end

 
subroutine  get_all_expendables(unt$pointer, exp_deq, exp_code, exp_name, exp_qty, nfound)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       January 2005
#$%
#$% Author:    James Allen
#$%
###########################################################################
BBcommon
 
integer unt$pointer
VMSchar*(*) exp_name[100]
integer     exp_code[100]
integer     exp_deq[100]
integer     exp_qty[100]
integer     nfound
integer     isexp
BBDeclare  (DEQ$Pointer,
            TBL$Pointer, TBL$Name$V, TBL$FullName$V)
VMSchar     VSTRIP*ARB
 
nfound = 0
FOR_DEQ_CHAIN
{
    call EXPTST ( Xdeq$ident$i , isexp )
 
    if (isexp == $NO) next
 
    nfound = nfound + 1
    exp_deq [nfound] = deq$pointer
    exp_code [nfound] = XDeq$ident$i
    exp_qty [nfound] = xDEQ$Remaining$i
 
    tbl$pointer = xDEQ$pntr$i
 
    TBL$Name$V = xTBL$Name$V
    TBL$FullName$V = xTBL$FullName$V
    Exp_name[nfound] = TBL$Name$V
 
    if (TBL$FullName$V > " ")
        Exp_name[nfound] = TBL$Name$V // "-" // TBL$FullName$V
 
} #end for loop
 
call sort_explist (nfound, exp_deq, exp_code, exp_qty, exp_name)
 
return
end
 
subroutine sort_explist (items, exp_deq, exp_code, exp_qty, exp_name) # sort expendable list by ident
 
 
########################################################
#$%
#$% Purpose:   sort_explist sorts the ITEMS rows in exp arrarys
#$%            in ascending order based on the values in
#$%            column exp_code.
#$%
#$% Called By:
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$%
#$% Date:      January 2005
#$%
#$% Author:    James Allen
#$%
########################################################
implicit none
 
VMSchar*(*) exp_name[100]
integer     exp_deq[100]
integer     exp_code[100]
integer     exp_qty[100]
integer		n, m, items, isave
VMSchar*34 vsave
 
for (n = 1; n < items; n = n+1)
    {
    for (m = n+1; m <= items; m = m+1)
        {
        if (exp_code[n] <= exp_code[m]) next
 
        isave=exp_code[n]; exp_code[n]=exp_code[m]; exp_code[m]=isave
        isave=exp_deq[n];  exp_deq[n] =exp_deq[m];  exp_deq[m]=isave
        isave=exp_qty[n];  exp_qty[n] =exp_qty[m];  exp_qty[m]=isave
        vsave=exp_name[n]; exp_name[n] =exp_name[m]; exp_name[m]=vsave
        }
    }
 
return
end                     # end of sort_explist
 

 
subroutine  get_systems_inoperable(unt$pointer, array_inoperable, nfound)
###########################################################################
#$%
#$% Purpose:
#$%
#$% Called By:
#$%
#$% Calls:     none
#$%
#$% Tables:
#$%
#$% Date       October 1996
#$%
#$% Author:    Alex Vagus
#$%
###########################################################################
BBcommon
 
integer unt$pointer
VMSchar*(*) array_inoperable[200]
integer     nfound
BBDeclare  (DEQ$Pointer,
            TBL$Pointer, TBL$Name$V, TBL$FullName$V)
VMSchar     VSTRIP*ARB
 
nfound = 0
FOR_DEQ_CHAIN
    {
    if ( xDEQ$TimeWhenUse$F > Game$Time)   # if Equipment can not be used
        {
        nfound = nfound + 1
 
        tbl$pointer = xDEQ$pntr$i
 
        TBL$Name$V = xTBL$Name$V
        TBL$FullName$V = xTBL$FullName$V
        array_inoperable[nfound] = TBL$Name$V
 
        if (TBL$FullName$V > " ")
            array_inoperable[nfound] = TBL$Name$V // "-" // TBL$FullName$V
 
        } #end IF statement
    } #end FOR loop
 
return
end
 
 

 
literal function sidecode2str(iside)
 
literal sidestr
 
if (iside == $blue$code)
    sidestr = 'BLUE'
else if (iside == $orange$code)
    sidestr = 'ORANGE'
else if (iside == $neutral$code)
    sidestr = 'NEUTRAL'
else
    sidestr = '??????'
 
return(sidestr)
end

literal function reportcode2str(unt$OtgCode$i)
 
literal reportstr
        if      (UNT$OtgCode$I == $NAV$otg_code  ) reportstr = 'NAV'
        else if (UNT$OtgCode$I == $NAVNP$otg_code) reportstr = 'NAVNP'
        else if (UNT$OtgCode$I == $NAVNRU$otg_code)reportstr = 'NAVNRU'
        else if (UNT$OtgCode$I == $OTH$otg_code)   reportstr = 'OTH'
        else if (UNT$OtgCode$I == $OTHNP$otg_code) reportstr = 'OTHNP'
        else if (UNT$OtgCode$I == $STS$otg_code)   reportstr = 'STS'
        else if (UNT$OtgCode$I == $STSNP$otg_code) reportstr = 'STSNP'
        else if (UNT$OtgCode$I == $MER$otg_code)   reportstr = 'MER'
        else if (UNT$OtgCode$I == $FSH$otg_code)   reportstr = 'FSH'
        else if (UNT$OtgCode$I == $TOM$otg_code)   reportstr = 'TOM'
        else if (UNT$OtgCode$I == $OBG$otg_code)   reportstr = 'OBG'
        else if (UNT$OtgCode$I == $RTH$otg_code)   reportstr = 'RTH'
        else if (UNT$OtgCode$I == $UNK$otg_code)   reportstr = 'UNK'
        else                                       reportstr = '???'
 
 
return(reportstr)
end
 

literal function EQCode2str(deq$ident$i)
 
literal EQstr
integer     I_switch_1
integer     deq$ident$i
 
switch (deq$ident$i)
{
    case $Radar$Code:          EQstr = 'RADAR'
    case $Sonar$Code:          EQstr = 'SONAR'
    case $ESM$Code:            EQstr = 'ESM'
    case $Jammer$Code:         EQstr = 'Jammer'
    case $CruiseMissile$Code:  EQstr = 'CM'
    case $AAM$Code:            EQstr = 'AAM'
    case $ASM$Code:            EQstr = 'ASM'
    case $SAM$Code:            EQstr = 'SAM'
    case $Commbuoy$Code:       EQstr = 'CommBuoy'
    case $Sonobuoy$Code:       EQstr = 'SonoBuoy'
    case $Mine$Code:           EQstr = 'Mine'
    case $Bomb$Code:           EQstr = 'Bomb'
    case $Torpedo$Code:        EQstr = 'Torpedo'
    case $CommSuite$Code:      EQstr = 'Radio'
    case $Wire$Code:           EQstr = 'Wire'
    case $Wbuoy$Code:          EQstr = 'WireBuoy'
    case $RBOC$Code:           EQstr = 'RBOC'
    case $DECM$Code:           EQstr = 'DECM'
    case $Blip$Code:           EQstr = 'BLIP'
    case $Aircraft$Code:       EQstr = 'Aircraft'
    case $NavSensor$Code:      EQstr = 'Nav'
    case $CIWS$Code:           EQstr = 'CIWS'
    case $AcousticComm$Code:   EQstr = 'SonoComm'
    case $PasSonar$Code:       EQstr = 'PSONAR'
    case $TowedArray$Code:     EQstr = 'TowedAry'
    case $VDS$Code:            EQstr = 'VDS'
    case $ActiveBarrier$Code:  EQstr = 'ASonoBar'
    case $PassiveBarrier$Code: EQstr = 'PSonoBar'
    case $HFDF$Code:           EQstr = 'HFDF'
    case $Gun$Code:            EQstr = 'Gun'
    case $CommunicationJammer$Code: EQstr = 'CommJam'
    case $Fuel$Code:           EQstr = 'Fuel'
    case $BOAT$Code:           EQstr = 'Boat'
    case $GND$Code:            EQstr = 'Ground'
    case $EOIR$code:           EQstr = 'EOIR'
    case $SmartTorpedo$Code:   EQstr = 'STorpedo'
    case $Countermeasure$Code: EQstr = 'CM'
    case $CHAFF$Code:          EQstr = 'Chaff'
    case $MAD$Code:            EQstr = 'MAD'
    case $LIDAR$Code:          EQstr = 'LIDAR'
    case $IFF$Code:            EQstr = 'IFF'
    case $SSM$Code:            EQstr = 'SSM'
    case $HHM$Code:            EQstr = 'HHM'
    case $vehicle$code:        EQstr = 'Vehicle'
    case $mogas$code:          EQstr = 'Mogas'
    case $diesal$code:         EQstr = 'Diesel'
    case $otherfuel$code:      EQstr = 'Fuel'
    case $ASMD$Code:           EQstr = 'ASMD'
    case $AdvancedSAM$Code:    EQstr = 'AdvSAM'
    case $RadComJammer$code:   EQstr = 'RadComJm'
    case $RadarJammer$code:    EQstr = 'RadJam'
    case $TV$code:             EQstr = 'TV'
    default:                   EQstr = '????????'
}
 
return(EQstr)
end
 
subroutine clear_str (msg, isize)
character msg[ARB]
integer isize
integer i
 
for (i=1; i<=isize; i=i+1)
{
    msg[i] = BLANK
}
 
return
end
 
 

 
subroutine report_aircraft_sensors(unt$pointer)
 
########################################################
#$%
#$% Purpose:   report_aircraft_sensors (derived from xorder_sensors)
#$%
#$% Called By:
#$%
#$% Calls:
#$%
#$% Tables:
#$%
#$% Date:      January 2005
#$%
#$% Author:    James Allen
#$%
########################################################
 
BBcommon
 
BBDeclare  (DEQ$Pointer, DEQ$Ident$I, DEQ$Emitterindx$I,
            JEW$OR$Index, JEW$Pointer, JEW$BLL$Index,
            JEW$OR$lat$F, JEW$OR$long$F, JEW$OR$bearing$F,
            RAD$Pointer, RAD$Radartype$I,
            IFF$Pointer, UNT$Pointer)                           # MJC 4/24/2000
integer     GAME_DTG                                            # MJC 4/24/2000
literal     CSTRIP8                                             # MJC 4/24/2000
integer     JJ, ICHAN, KK, I_SWITCH_1, I_SWITCH_2
real*4       mth$alog2, allbands
character    msg2[ARB]
Character msg1[ARB]
integer   isave
 
integer mode
integer Base_10_to_Base_8
integer UNT$View$I, only_mode3, display_modes
 
jj = 0
DEQ$Pointer$To  (UNT$Pointer$Index)
if (xDEQ$Ident$I == $Null$Code) # clk 2/9/93 (E1106)
  {
   Call smovv  ("No sensors aboard ", msg1, jj)
   call smovhn (xunt$name$c,$$MaxLit, msg1, jj)
   call smov   (EOS, msg1, jj)
   call echoh (msg1, jj)
   call echor
   return
  }
 
if (jecewsi$game == $yes) jew$pointer$to (Unt$Pointer$Index) # set JEW table pointer - JFR 8/10/94
 
for_DEQ_CHAIN
    {
    deq$ident$i = Xdeq$ident$i
 
    kk = 0
    call smovhn(xDEQ$Type$C,$$MaxLit,msg2,kk)
    call smovv (" ",msg2,kk)
 
    deq$ident$i = Xdeq$ident$i
    deq$EmitterIndx$I = xdeq$EmitterIndx$I # (index to OR subtable for bearing) JFR 8/10/94
    JEW$BLL$Index = deq$EmitterIndx$I # set index to flag for position vs. bearing - JFR 8/10/94
    switch (deq$ident$i)
        {
        case $Radar$Code               :
            {
            rad$pointer = Xdeq$Pntr$i
            rad$RadarType$i = Xrad$RadarType$i
            switch (rad$RadarType$i)
                {
                case $Air$Code         : call smovv("Air Search ",msg2,kk)
                case $Surface$Code     : call smovv("Surface Search ",msg2,kk)
                case $FireControl$Code : call smovv("F/C ",msg2,kk)
                case $Approach$Code    : call smovv("Approach ",msg2,kk)
                }
            call smovv("Radar",msg2,kk)
            }
        case $Sonar$Code               : call smovv("Active Sonar",msg2,kk)
        case $ESM$Code                 : call smovv("ESM",msg2,kk)
        case $Jammer$Code              : call smovv("Jammer",msg2,kk)
        case $RadarJammer$Code         : call smovv("Radar Jammer",msg2,kk) # JFR 8/10/94
        case $RADComJammer$Code        : call smovv("Radar/Comm Jammer",msg2,kk) # JFR 8/10/94
        case $CommunicationJammer$Code : call smovv("Comm Jammer",msg2,kk)
        case $PasSonar$Code            : call smovv("Passive Sonar",msg2,kk)
        case $IFF$Code                 :
            {
             call smovv("IFF",msg2,kk)
             IFF$Pointer = xDEQ$Pntr$i
             if (xIFF$Function$i == $INTERROGATOR$CODE)
               call smovv(" Interrogate",msg2,kk)
             else
               call smovv(" Transponder",msg2,kk)
            }
        case $MAD$Code                 : continue
        case $LIDAR$Code               : continue
        case $EOIR$Code                :                # clf 1/26/93
            {
            if (level$ir == 1) call smovv("Infra-Red",msg2,kk)
            }
        default: NEXT
        }
 
     if (xdeq$on$i == $yes)
        {
         if ((jecewsi$game == $yes) &                     # JFR 9/15/94
             (deq$ident$i == $RadarJammer$Code   |         # display the jammer bearing/position
              deq$ident$i == $RadComJammer$Code  |
              deq$ident$i == $CommunicationJammer$Code |
              deq$ident$i == $Jammer$Code))
            {
             # display the jammer bearing/position
             # get index to BLL subtable - JFR 8/10/94
             JEW$BLL$INDEX = deq$EmitterIndx$I
             if (xJEW$BLL$Flags$I == $yes) # JFR 8/10/94 (jecewsi)
                { # activated with respect to an absolute position - JFR 8/10/94
                 JEW$OR$INDEX = deq$EmitterIndx$I # get index to OR subtable - JFR 8/10/94
                 JEW$OR$Lat$F = xJEW$OR$Lat$F   # get lat jammer pointer at  - JFR 8/10/94
                 JEW$OR$Long$F = xJEW$OR$Long$F # get long jammer pointer at - JFR 8/10/94
 
                 call smovv(" Lat= ",msg2,kk)
                 call smovll(JEW$OR$Lat$F,"NS",msg2,kk)
                 call smovv(" Long= ",msg2,kk)
                 call smovll(JEW$OR$Long$F,"EW",msg2,kk)
                }
             else
                { # activated with respect to a bearing relative to course - JFR 8/10/94
                 JEW$OR$INDEX = deq$EmitterIndx$I # get index to OR subtable - JFR 8/10/94
                 JEW$OR$Bearing$F = (xJEW$OR$Bearing$F)*(180.0/$PI)    # find bearing
 
                 call smovv(" Bearing= ",msg2,kk)
                 call smovf(JEW$OR$Bearing$F,702,msg2,kk)
                }
            }
 
        call smovv(" <ON>",msg2,kk)
 
        if ((DEQ$Ident$I == $IFF$Code) &   # SMM 1/97 (E1732)
            (xIFF$Function$i != $INTERROGATOR$Code))  # IFF$Pointer set above
            {
             UNT$View$I = xUNT$View$I
             only_mode3 = $no
             display_modes = $yes
             # if its neutral or orange and its not an aircraft return
             if ((UNT$View$I == $Neutral$View) |
                 (UNT$View$I >= $FirstOrange$View &
                  UNT$View$I <= $LastOrange$View))
               {
                only_mode3 = $yes
               }
 
             if ((only_mode3 == $yes) & (xUNT$Type$I != $Air$Code))
               {
                display_modes = $no
               }
 
             if (only_mode3 == $no)
               {
                call smovv ("   MODE 1:  ",msg2,kk)
                call smovi (xDEQ$IFFMode1_Digit1$I,msg2,kk)
                call smovi (xDEQ$IFFMode1_Digit2$I,msg2,kk)
 
                call smovv ("   MODE 2:  ",msg2,kk)
                mode = base_10_to_Base_8(xDEQ$IFFMode2$I)
                call smovi (mode,msg2,kk)
               }
 
             if (((only_mode3 == $yes) &
                  (xUNT$Type$I == $Air$Code)) |
                  (only_mode3 == $no))
               {
                call smovv ("   MODE 3:  ",msg2,kk)
                mode = base_10_to_Base_8(xDEQ$IFFMode3$I)
                call smovi (mode,msg2,kk)
               }
            }
 
        if (DEQ$Ident$I == $EOIR$Code & level$ir == 1 &  # clf 1/26/93
            xUNT$GhostedUnit$I == $NO)
            {
            call ord_ir_status(DEQ$Pointer, msg2, kk)
            }
        } # end if device is on
     else
        {
        call smovv(" <off>",msg2,kk)
        }
 
    if (xdeq$TimeWhenUse$f > Game$time )
        {
        call smovv(" <----DISABLED---->",msg2,kk)
        }
 
    call smov   (EOS, msg2, kk)
    call echoh (msg2, kk)
    call echor
    }
 
return
end

 
subroutine report_aircraft_tasking (unt$pointer)            # unt pointer
 
########################################################
#$%
#$% Purpose:   report_aircraft_tasking (derived from xorder)
#$%
#$%
#$% Called By:
#$%
#$% Calls:
#$%
#$% Tables:    UNT         DEQ
#$%            SHC         JAM
#$%            RAD
#$%
#$% Date:      January 2005
#$%
#$% Author:    James Allen
#$%
########################################################
 
BBcommon          # I          I
 
define(Max_Frequencies,40)
define(Max_Equipments,70)
 
BBDeclare  (UNT$Pointer, UNT$Type$I, UNT$Attackindx$I,
            UNT$Hidestatus$I, UNT$Assignedtarget$I,
            UNT$Targettype$I, UNT$Bttindx$I,
            UNT$Supertype$I, UNT$Pimindx$I,
            UNT$Rulesofengage$I, UNT$Caplongitude$F,
            UNT$Orderedlatitude$F, UNT$Orderedlongitude$F,
            UNT$Orderedspeed$F, UNT$Caplatitude$F)
BBDeclare  (DEQ$Pointer, DEQ$EM$Index, DEQ$Ident$I,
            PIM$Pointer, PIM$PTS$Index, PIM$Orbitradius$I,
            PIM$PTS$latitude$F, PIM$PTS$longitude$F,
            RAD$Pointer, RAD$CH$Index, RAD$CH$frequency$F,
            SUI$Pointer, SUI$CH$Index)
BBDeclare  (JAM$Pointer, JAM$FQ$Index,
            CJC$Pointer, CJC$FQ$Index,
            AML$Pointer, RMT$Pointer,
            BTT$Pointer, SHC$Pointer,
            SUI$CH$frequency$F,
            UNT2$Pointer)
real*4    mth$alog2, allbands
real*4    MinDelay, MinGone
integer   icatdev
integer   I, IUNDX, IHEAD, KLEN, JLEN, ICSE, IFLAG,
          KK, MLEN, IDEG, IMIN, K, KDEG, KMIN, ILEN,
          IUPI, IJK, IPNT, I_SWITCH_1, ICNT, ISEND4,
          NAIRBORNE, NLOST, NONDECKS, NTOTL,
          IFOUND_TRACK
literal   CSTRIP8, CSTRIP, CTRACK_NUMBER, CNAME,
          ADDR_NAME
literal msg[70],ival,eq[4,Max_Equipments],iroe[9,4]
integer neq,nfreq,kfreq,freq[Max_Frequencies]
 
integer icode[2,8],iblip,irboc,idecm,iEOIR,iMAD, iLIDAR
integer game_DTG, dest [arith($max$args,*,8)]
literal covered_track_num,    # track number of unit which is being COVERed      # clk 1/94 (E1085)
        target_name           # literal function to determine the track number   # clk 1/94 (E1085)
literal   value
character target_string
integer   target_len
 
data icode/$Radar$code                ,$lex$Radar$,
           $ESM$code                  ,$lex$ESM$  ,
           $PasSonar$code             ,$lex$Sonar$,
           $Sonar$code                ,$lex$Sonar$,
           $RadarJammer$Code          ,$lex$Jammer$,
           $RadComJammer$Code         ,$lex$Jammer$,
           $CommunicationJammer$Code  ,$lex$Jammer$,
           $jammer$code               ,$lex$Jammer$/
 
data (iroe[$AllEnemy$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Enemy$,$lex$All$/
data (iroe[$AirEnemy$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Enemy$,$lex$Air$/
data (iroe[$SurfaceEnemy$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Enemy$,$lex$Surface$/
data (iroe[$SubEnemy$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Enemy$,$lex$Submarine$/
data (iroe[$SpecTarget$code,i],i=1,4)/_
                          $lex$weapons$,$lex$Take$,$lex$$track$no$,$BLANKLIT/
data (iroe[$AirNonFriendly$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Air$,$BLANKLIT/
data (iroe[$AllNonFriendly$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$All$,$BLANKLIT/
data (iroe[$SurfaceNonFriendly$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Surface$,$BLANKLIT/
data (iroe[$SubNonFriendly$code,i],i=1,4)/_
                          $lex$weapons$,$lex$free$,$lex$Submarine$,$BLANKLIT/
 
 
 
String msg1 "Current orders for         "
String msg2 " are available on the status boards."
String msg3 "Seeker     ; Cse     ;          ;         "
String msg4 " Aircraft in maintenance for more than 30 minutes [min]:"
String msg5 "                                                                      "
#            1   5   0   5    0    5    0    5    0
String msg6 "          aircraft now AIRBORNE."
String msg7 "      of       aircraft are LOST."
String msg8 "     aircraft now AVAILABLE/ON DECK."
 
iundx = unt$pointer$index
#$% set view and get unit type
#iview = nview
unt$type$i = Xunt$type$i
iflag = $no
if (xUNT$CoverFlag$I == $yes)
  {
    UNT$AttackIndx$I = xUNT$AttackIndx$I
    covered_track_num = target_name (UNT$Pointer, UNT$AttackIndx$I)
 
    kk = 0
    call smovv  ("COVER ", msg, kk)
    call smovhn (covered_track_num, $$MaxLit, msg, kk)
    call smov   (EOS, msg, kk)
    call echoh (msg, kk)
    call echor
 
    iflag = $yes
  }
 
if (xUNT$DroppingMineFlag$I == $yes)
  {
    kk = 0
    call smovv   ("DROP MINE (on) ", msg, kk)
    UNT$AssignedTarget$I = xUNT$AssignedTarget$I
    if (UNT$AssignedTarget$I == UNT$Engaging$Position)
      {
       call smovv ("POSITION ", msg, kk)
       call smovlls (xUNT$OrderedLatitude$F, "NS", msg, kk)
       call smovv   (" ", msg, kk)
       call smovlls (xUNT$OrderedLongitude$F, "EW", msg, kk)
      }
    else
      {
       call smovv ("TRACK", msg, kk)
       call find_active_rmt (UNT$AssignedTarget$I, RMT$Pointer,
                             xUNT$View$I, ifound_track, ctrack_number)
       if (ifound_track == $yes)
         call smovhn (ctrack_number, $$MaxLit, msg, kk)
      }
    call smov   (EOS, msg, kk)
    call echoh (msg, kk)
    call echor
  }   # end of if processing a DROP MINE command
 
else if (xUNT$AssignedTarget$I == UNT$Engaging$Position)
  {
    kk = 0
    if (xUNT$AGDIndex$i == 0)
    {
        call smovh   (dest, ihead, msg, kk)
        call smovv   ("STRIKE POSITION ", msg, kk)
        call smovlls (xUNT$TargetLatitude$F, "NS", msg, kk)
        call smovv   (" ", msg, kk)
        call smovlls (xUNT$TargetLongitude$F, "EW", msg, kk)
    }
    else
    {
        call smovh   (dest, ihead, msg, kk)
        call smovv   ("STRIKE GROUND ", msg, kk)
        call smovi   (xUNT$AGDIndex$I, msg, kk)
    }
 
    UNT$OrderedSpeed$F = xUNT$OrderedSpeed$F
    call smovv   (" SPEED ", msg, kk)
    call smovi   (INT(UNT$OrderedSpeed$F), msg, kk)
 
    UNT$TargetType$I = xUNT$TargetType$I
    if (UNT$TargetType$I != $NoTarget$TargetCode)
      {
       call smovv  (" TARGET ", msg, kk)
       call Display_Targeting (UNT$TargetType$I, target_string, target_len)
       call smovh  (target_string, target_len, msg, kk)
      }
 
    UNT$BTTIndx$I = xUNT$BTTIndx$I
    if (UNT$BTTIndx$I != 0)
      {
       if (kk >= (ARB - 30))   # if the full BE and TIN info was entered
         {                     # the max string length of msg may be encountered
          call smov   (EOS, msg, kk)
          call echoh (msg, kk)
          call echor
          kk = 0
         }
 
       BTT$Pointer$To  (UNT$BTTIndx$I)
       value = xBTT$BEnumber1$C
       if (value != $Blank_Literal)
         {
          call smovv  (" BE ", msg, kk)
          call smovhn (value, $$MaxLit, msg, kk)
          value = xBTT$BEnumber2$C
          call smovhn (value, $$MaxLit, msg, kk)
         }
       value = xBTT$TINnumber$C
       if (value != $Blank_Literal)
         {
          call smovv  (" TIN ", msg, kk)
          call smovhn (xBTT$TINnumber$C, $$MaxLit, msg, kk)
         }
      }
 
      call smov   (EOS, msg, kk)
      call echoh (msg, kk)
      call echor
 
    iflag = $yes
  }
 
#$% initialize messages
msg[1] = 0
msg[2] = 0
msg[3] = 0
 
#$% set length
mlen = 3
 
#$% If the unit is an aircraft
if (UNT$Type$I == $Air$Code)
  {
   if (xUNT$AssignedCap$I == $yes) # and assigned cap is $yes
      {
       #$% increment counter & get proceed & position data
       mlen=mlen+1; msg[mlen] = $lex$CAP$
       mlen=mlen+1; msg[mlen] = $lex$Position$
       UNT$CapLatitude$F = xUNT$CapLatitude$F
       ival = int(abs(UNT$CapLatitude$f * (180.0/$pi) * 60) + 0.5)  # determine latitude
       ideg = ival / 60
       imin = ival - (ideg * 60)
       ival = ideg * 100 + imin
       if (UNT$CapLatitude$F < 0)
         ival = -ival
       mlen=mlen+1; msg[mlen] = ival
 
       UNT$CapLongitude$F = xUNT$CapLongitude$F
       ival = int(abs(UNT$CapLongitude$f * (180.0/$pi) * 60) + 0.5)   # determine longitude
       ideg = ival / 60
       imin = ival - (ideg * 60)
       ival = ideg * 100 + imin
       if (UNT$CapLongitude$F < 0)
         ival = -ival
       mlen=mlen+1; msg[mlen] = ival
 
       mlen=mlen+1; msg[mlen] = $lex$Altitude$
       mlen=mlen+1; msg[mlen] = xUNT$CapAltitude$I
       mlen=mlen+1; msg[mlen] = $lex$Range$
       mlen=mlen+1; msg[mlen] = xUNT$CapRange$I
 
        ilen = 0
 
        call synbld (int(msg[2]),      # time of execution
                     $no,               # search plan order
                     msg[3],              # order number
                     mlen-3,             # number of quad-words of lex data
                     msg[4],           # lex array
                     dest,              # output array
                     ilen)              # returned length
 
        call smov   (EOS, dest, kk)
        call echoh (dest, kk)
        call echor
 
        #$% set flag
        iflag = $yes
        mlen = 3
       } # end if a/c on cap
 
   # is the a/c orbiting?
   unt$pimindx$i = xunt$pimindx$i
   if (unt$pimindx$i != $no)
      {
       pim$pointer$to (unt$pimindx$i)
 
       mlen=mlen+1; msg[mlen] = $lex$ORBIT$
       mlen=mlen+1; msg[mlen] = $lex$Position$
 
       #$%   The lat/lon of the orbit coords are in slots 7 & 8
       for (pim$PTS$index=7; pim$PTS$index <9; pim$PTS$index=pim$PTS$index +1)
          {
           pim$PTS$latitude$f = xpim$PTS$latitude$f
           ival = int(abs(pim$PTS$Latitude$f * (180.0/$pi) * 60) + 0.5)  # determine latitude
           ideg = ival / 60
           imin = ival - (ideg * 60)
           ival = ideg * 100 + imin
           if (pim$PTS$Latitude$f < 0)
               ival = -ival
           mlen=mlen+1; msg[mlen] = ival
 
           pim$pts$longitude$f   = xpim$pts$longitude$f
           ival = int(abs(pim$pts$Longitude$f * (180.0/$pi) * 60) + 0.5)   # determine longitude
           ideg = ival / 60
           imin = ival - (ideg * 60)
           ival = ideg * 100 + imin
           if (pim$pts$Longitude$f < 0)
               ival = -ival
           mlen=mlen+1; msg[mlen] = ival
          }
 
       #$% radius info
       pim$orbitradius$i =  xpim$orbitradius$i    # get the radius of the orbit
       mlen=mlen+1; msg[mlen] = $lex$radius$
       mlen=mlen+1; msg[mlen] = PIM$orbitradius$i
       ilen = 0
 
       call synbld (int(msg[2]),      # time of execution
                    $no,              # search plan order
                    Orbit$order,      # order number
                    mlen-3,           # number of quad-words of lex data
                    msg[4],           # lex array
                    dest,             # output array
                    ilen)             # returned length
 
        call smov   (EOS, dest, kk)
        call echoh (dest, kk)
        call echor
 
       #$% set flag
       iflag = $yes
       mlen = 3
      } # end if on a/c is orbiting
  } # end if a/c
 
unt$OrderedLatitude$f = Xunt$OrderedLatitude$f
#$% if ordered latitude is within limits & the unit isn't a shorebase
if (unt$OrderedLatitude$f < $pi/2 & unt$type$i != $ShoreBase$code)
   {
    #$% increment counter & get proceed & position data
    mlen=mlen+1; msg[mlen] = $lex$Proceed$
    mlen=mlen+1; msg[mlen] = $lex$Position$
 
    #$% determine ordered latitude
    k = abs(int(unt$OrderedLatitude$f * 180/$pi*60 ))
    kdeg = k/60
    kmin = k- kdeg*60
    ival = kdeg * 100 + kmin
 
    if (unt$OrderedLatitude$f < 0) ival = -ival
 
    mlen=mlen+1; msg[mlen] = ival
 
 
    unt$OrderedLongitude$f = Xunt$OrderedLongitude$f
    k = abs(int(unt$OrderedLongitude$f * 180/$pi*60 ))
    kdeg = k/60
    kmin = k- kdeg*60
 
    ival = kdeg * 100 + kmin
 
    if (unt$OrderedLongitude$f < 0) ival = -ival
 
    mlen=mlen+1; msg[mlen] = ival
   }
 
#$% if assumed course is not ordered course
if (xunt$AssumedCourse$f != Xunt$OrderedCourse$f)
   {
    #$% increment counter and save course and ordered course
    mlen=mlen+1; msg[mlen] = $lex$Course$
    mlen=mlen+1; msg[mlen] = abs(int(xunt$OrderedCourse$f * 180/$pi +.5))
   }
 
#$% if assumed speed is not ordered speed
if (xunt$AssumedSpeed$f != Xunt$OrderedSpeed$f)
   {
    #$% increment counter, save speed and ordered speed
    mlen=mlen+1; msg[mlen] = $lex$Speed$
    mlen=mlen+1; msg[mlen] = int(xunt$OrderedSpeed$f + .5)
   }
 
#$% if true altitude/depth is not ordered altitude/depth
if ((xUNT$Type$I == $Sub$code | xUNT$Type$I == $Air$code)
     & (xUNT$TrueAltDepth$I != xUNT$OrderedAltDepth$I))
   {
    #$% increment counter
    mlen=mlen+1
    #$% if aircraft, save altitude, else save depth
    if (unt$type$i == $air$code) msg[mlen] = $lex$Altitude$
    else                         msg[mlen] = $lex$Depth$
 
    #$% increment counter, save ordered altitude depth
    mlen=mlen+1; msg[mlen] = Xunt$OrderedAltDepth$i
   }
 
#$% if ordered to sweep minefields
if (Xunt$MineSweeping$i == $yes)
   {
    mlen=mlen+1; msg[mlen] = $lex$Sweeping$
    mlen=mlen+1; msg[mlen] = $lex$MineField$
   }
 
 
if (mlen > 3)
   {
    ilen = 0
    call synbld (int(msg[2]),      # time of execution
                 $no,               # search plan order
                 msg[3],              # order number
                 mlen-3,             # number of quad-words of lex data
                 msg[4],           # lex array
                 dest,              # output array
                 ilen)              # returned length
 
        call smov   (EOS, dest, kk)
        call echoh (dest, kk)
        call echor
 
      #$% set flag
      iflag = $yes
      mlen = 3
   }
 
  # if the unit is on a route, display the leg and the order
  # it is currently processing on that leg.  SMM 6/97 (E1819)
  if (xUNT$RteIndx$I != $No)
    call route_tasking(UNT$Pointer)
 
return
end        # End report_aircraft_tasking
 

 
 
 
subroutine route_tasking(UNT$Pointer) # unt pointer
 
########################################################
#$%
#$% Purpose:   route_tasking (derived from xorder_process_route_display)
#$%
#$% Called By:
#$%
#$% Calls:
#$%
#$% Tables:    UNT    RTE
#$%
#$% Date:      January 2005
#$%
#$% Author:    James Allen
#$%
########################################################
BBcommon
 
integer UNT$Pointer
integer RTE$Pointer, msg_len
character msg[70]
integer game_DTG, dest [120], head_len
BBDeclare  (ord$pointer)
literal CSTRIP8
 
 msg_len = 0
 
 rte$pointer$to Xunt$RTEIndx$i
 
 call smovv("CURRENTLY ON ",msg,msg_len)
 call smovv("ROUTE NAMED ",msg,msg_len)
 call smovh(xRTE$Name$C,$$MaxLit,msg,msg_len)
 
 call smov  (EOS, msg, msg_len)
 call echoh (msg, msg_len)
 call echor
 
return
end
 
