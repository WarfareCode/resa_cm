###############################
define (BUFSIZE,200)

define(cdefio_common,
    common /cdefio/ bp, buf[BUFSIZE]
    integer bp      # next available character; init = 0
    character buf   # pushed-back characters
    )
##############################

include "ddmain.inc"

program ddl_main
integer         getarg3
character       buf[FILENAMESIZE]
logical         flag

call initr4
call setchtype(RAW,STDOUT)
call setchfd(STDOUT,STDOUT)
call setchtype(RAW,ERROUT)
call setchfd(ERROUT,ERROUT)

call init

flag = .false.
for (i=1; getarg3(i, buf, FILENAMESIZE) != EOF; i=i+1)
    {
    if (buf[1] == MINUS & buf[2] != EOS) next
	if (buf[1] == EOS) break

    flag = .true.
    call ddl (buf)
    }

if (! flag) call ddl ("-")

call endr4

end


subroutine ddl(name)
d_common
integer         in, 
                equal, 
                create, 
		#delete_file_version,
		#rc,
                open_, 
                out1, 
                out2, 
                out3, 
                out4, 
                out5, 
                out6,
                out7,
                out8,
                out9
character       name[FILENAMESIZE],
                workin[FILENAMESIZE],
                work1[FILENAMESIZE],
                work2[FILENAMESIZE],
                work3[FILENAMESIZE],
                work4[FILENAMESIZE],
                work5[FILENAMESIZE],
                work6[FILENAMESIZE],
                work7[FILENAMESIZE],
                work8[FILENAMESIZE],
                work9[FILENAMESIZE]

eofflag = .false.
call ddl_init                           # init data structures

out1 = STDOUT
out2 = STDOUT
out3 = STDOUT
out4 = STDOUT
out5 = STDOUT
out6 = STDOUT
out7 = STDOUT
out8 = STDOUT
out9 = STDOUT

call scopy (name,1, d_file,1)

idot = index(d_file,'.')
if (idot != 0) d_file[idot] = EOS

if (d_file[1] == PERIOD)
    {
    in  = STDIN
    }
else
    {
    j=1
    call stcopy (name,1, workin,j)

    in = open_ (workin,READ)

    if (in == ERR & idot == 0)
        {
        call stcopy_vh (".def",1, workin,j)

        in = open_ (workin,READ)
        }    

    if (in == ERR) call cant (workin)
#    else
#        {
#        call putch (NEWLINE,ERROUT)
#        call putlin_v ("Input is from: ",ERROUT)
#        call remark (workin)
#        }        

    ilen = length(d_file)+1

    call scopy (d_file, 1, work1, 1)
    call scopy_vh (".inc", 1, work1, ilen)

    call scopy (d_file, 1, work2, 1)
    call scopy_vh (".dbd", 1, work2, ilen)

    call scopy (d_file, 1, work3, 1)
    call scopy_vh (".tst", 1, work3, ilen)

    call scopy (d_file, 1, work4, 1)
    call scopy_vh (".lis", 1, work4, ilen)

    call scopy (d_file, 1, work5, 1)
    call scopy_vh (".dmp", 1, work5, ilen)

    call scopy (d_file, 1, work6, 1)
    call scopy_vh (".vec", 1, work6, ilen)

    call scopy (d_file, 1, work7, 1)
    call scopy_vh (".ln3", 1, work7, ilen)

    call scopy (d_file, 1, work8, 1)
    call scopy_vh (".ps",  1, work8, ilen)

    call scopy (d_file, 1, work9, 1)
    call scopy_vh (".h",   1, work9, ilen)
    }

ierr = NO

call ddl_load (in,ierr)

call ddl_verify (ierr)

if (ierr != NO)
    {
    call putch (NEWLINE,ERROUT)
    call remark_v ("Validation Errors/Warnings....  Output Restricted.")

    opt_inc  = .false.
    opt_head = .false.
#   opt_dbd = .false.
    opt_tst = .false.
#   opt_pic = .false.
#   opt_ln3 = .false.
#   opt_ps  = .false.
    }


if (opt_Inc) 
    {
    if (d_file[1] != MINUS)
        {
	#rc = delete_file_version(work1)
        out1 = create (work1,WRITE)
		call setchtype (RAW, out1)

        #call putlin_v ("Output of Defines is to: ",ERROUT)
        #call remark (work1)
        }

    call ddl_defines (in,out1)
    }

if (opt_Head) 
    {
    if (d_file[1] != MINUS)
        {
        out9 = create (work9,WRITE)
		call setchtype (RAW, out9)

        #call putlin_v ("Output of Header is to: ",ERROUT)
        #call remark (work9)
        }

    call ddl_header (in,out9)
    }

if (opt_DBD) 
    {
    if (d_file[1] != MINUS)
        {
        out2 = create (work2,WRITE)
		call setchtype (RAW, out2)


        #call putlin_v ("Output of DBD info is to: ",ERROUT)
        #call remark (work2)
        }

    call ddl_dbd     (in,out2)
    }

if (opt_LN3) 
    {
    out7 = create (work7,WRITE)
	call setchtype (RAW, out7)

    #call putlin_v ("Output of PIC (LN03+) info is to: ",ERROUT)
    #call remark (work7)

    call ddl_pic (in,work7,out7)
    }

else if (opt_PS)
    {
    out8 = create (work8,WRITE)
	call setchtype (RAW, out8)

    #call putlin_v ("Output of PIC (PostScript) info is to: ",ERROUT)
    #call remark (work8)

    call ddl_pic (in,work8,out8)
    }

else if (opt_PIC)
    {
    #call putlin_v ("Output of PIC (PLXY) info is to: ",ERROUT)
    #call remark (work6)

    call ddl_pic (in,work6,0)
    }

if (opt_TST) 
    {
    if (d_file[1] != MINUS)
        {
	#rc = delete_file_version(work3)
        out3 = create (work3,WRITE)
		call setchtype (RAW, out3)

        #call putlin_v ("Output of BBTEST info is to: ",ERROUT)
        #call remark (work3)
        }
    
    call ddl_BBTest (in,out3)
    }

if (opt_VER) 
    {
    if (d_file[1] != MINUS)
        {
        out4 = create (work4,WRITE)
		call setchtype (RAW, out4)

        #call putlin_v ("Output of Verification list is to: ",ERROUT)
        #call remark (work4)
        }

    call ddl_VerLst (in,out4)
    }

if (opt_DMP) 
    {
    if (d_file[1] != MINUS)
        {
        out5 = create (work5,WRITE)
		call setchtype (RAW, out5)

        #call putlin_v ("Output of internal (Garbage) dump is to: ",ERROUT)
        #call remark (work5)
        }

    call ddl_Dump (in,out5)
    }


if (in   != STDIN ) call close (in)
if (out1 != STDOUT) call close (out1)
if (out2 != STDOUT) call close (out2)
if (out3 != STDOUT) call close (out3)
if (out4 != STDOUT) call close (out4)
if (out5 != STDOUT) call close (out5)
if (out7 != STDOUT) call close (out7)
if (out9 != STDOUT) call close (out9)

end


subroutine init
d_common

call init_args                  # read in options
call init_lex                   # load Lexical/Keywords

return
end


subroutine init_args            # read in options
d_common

integer getarg3, open_
character buf[FILENAMESIZE]
integer i,opened,ctoi

opt_Inc = .false.
opt_Head= .false.
opt_dbd = .false.
opt_pic = .false.
opt_ln3 = .false.
opt_ps  = .false.
opt_tst = .false.
opt_ver = .false.
opt_dmp = .false.
opt_xxx = .false.
opt_prefix = .true.
opt_mask = .true.

for (i=1; getarg3(i, buf, FILENAMESIZE) != EOF; i=i+1)
    {
    if (buf[1] == QMARK & buf[2] == EOS)
        {
        call usage
        }
    else if (buf[1] == EOS & i == 1)
        {
        call usage
        }
    else if (buf[1] == MINUS) 
        {
		call upper(buf)
        for (kk=2; buf[kk] != EOS; kk=kk+1) 
        switch (buf[kk]) 
            {
            case QMARK:                 # Usage
                {
                call usage
                }       
            case BIGW:                  # Use bit width (vs/mask)
                {
                opt_mask = .false.
                }       
            case BIGM:                  # Use bit mask (vs/width)
                {
                opt_mask = .true.
                }       
            case BIGI:                  # Generate Include files (default)
                {
                opt_Inc = .true.
                }        
            case BIGH:                  # Generate Header files (for C)
                {
                opt_Head = .true.
                }        
            case BIGD:                  # Generate DBD file
                {
                opt_DBD = .true.
                }       
            case BIGS:                  # Generate Picture file (PostScript)
                {
                opt_PS  = .true.
                opt_PIC = .false.
                opt_LN3 = .false.
                }       
            case BIGP:                  # Generate Picture file (LN03)
                {
                opt_LN3 = .true.
                opt_PIC = .false.
                opt_PS  = .false.
                }       
            case BIGL:                  # Generate Picture file (LNXY)
                {
                opt_PIC = .true.
                opt_PS  = .false.
                opt_LN3 = .false.
                }       
            case BIGT:                  # Generate TEST Tools input (BBTEST)
                {
                opt_TST = .true.
                }       
            case DOLLAR:                # Generate HI/LO/SIZE Macros with $ prefix
                {
                opt_Prefix = .true.
                }       
            case BIGN:                  # Generate Old style Macros no $ prefix
                {
                opt_Prefix = .false.
                }       
            case BIGV:                  # Generate Verification List
                {
                opt_VER = .true.
                }       
            case BIGG:                  # Generate Internal table dump 
                {
                opt_DMP = .true.
                }       
            case BIGX:                  # Verify input.  No Output.
                {
                opt_XXX = .true.
                }       
            default:
                {
                continue
                }
            }
        }
    }

if (! (opt_DBD | opt_TST | opt_ver | opt_dmp | 
       opt_pic | opt_ps  | opt_ln3 | opt_head ) ) 
    {
    opt_Inc = .true.
    }

if (opt_XXX)
    {
    opt_Inc = .false.
    opt_Head= .false.
    opt_dbd = .false.
    opt_pic = .false.
    opt_ln3 = .false.
    opt_dmp = .false.
    opt_tst = .false.
    opt_ver = .false.
    }

return
end
 

subroutine usage 

call remark_v ("usage:  ddl [-IWMDPSLTVX] name [ name ...] ")
call remark_v ("Opts:   I  Generate Include files (default)")
call remark_v ("        H  Generate Header files (for C)")
call remark_v ("        W  Use bit width (vs/mask) for bit field extractions")
call remark_v ("        M  Use bit mask (vs/width) for bit field extractions (default)")
call remark_v ("        $  Use $ prefix on HI/LO/SIZE macros (default)")
call remark_v ("        N  Do not use $ prefix on HI/LO/SIZE macros")
call remark_v ("        D  Generate DBD file")
call remark_v ("        P  Generate Picture file for an LN03 Laser printer")
call remark_v ("        S  Generate Picture file for a PostScript printer")
call remark_v ("        L  Generate Picture file for LNXY printer")
call remark_v ("        T  Generate TEST Tools input for BBTEST")
call remark_v ("        V  Generate Verification List")
call remark_v ("        X  Verify input Only.  No Output.")
#call remark_v ("        G  Generate Internal table dump ")

call endr4

return
end


subroutine error (msg)
d_common
VMSchar*(*)	       msg

call putlin_v ("Error: ",ERROUT)
call remark (msg)

call putlin_v ("while processing ",ERROUT)
call remark (d_where)

call endr4

return
end




subroutine warning (icount,msg)
d_common
VMSchar*(*)	      msg

icount = icount + 1

call putlin_v ("Warning: ",ERROUT)
call putlin (d_where,ERROUT)
call putlin_v (": --      ",ERROUT)
call remark (msg)

return
end

subroutine warning_w_int (icount,msg,int)
d_common
character       msg[ARB], emsg[ARB]
integer         int

icount = icount + 1

call putlin_v ("Warning: ",ERROUT)
call putlin (d_where,ERROUT)
call putlin_v (": --      ",ERROUT)

call make_msg_w_int (msg,int,emsg)
call remark (emsg)

return
end




subroutine info_only (icount,msg)
d_common
VMSchar*(*)       msg

#Suppress info
if (0==1) {
call putlin_v ("Info: ",ERROUT)
call putlin (d_where,ERROUT)
call putlin_v (": --      ",ERROUT)
call remark_v (msg)
}
return
end


subroutine make_msg_w_int (msg,int,emsg)
implicit none
character       msg[ARB],emsg[ARB]
integer         int, j, i, once

once = 0
j = 0
for (i=1; msg[i] != EOS; i=i+1)
    {
    if (msg[i] == SHARP & once == 0)  
        {
        call smovi (int,emsg,j)
        once = 1
        }
    else
        {
        call smov (msg[i],emsg,j)
        }
    }

call smov (EOS,emsg,j)

return
end


function ifindtext (str,pnt,max,text)   # look for string in text array
character       str[ARB],text[ARB]
integer         pnt, max, equal

for (i=1; i<max; i=i+length(text[i])+1 )
    {
    if (equal(str, text[i]) == YES) return(i)
    }

return (NO)
end


function install (str,pnt,max,text)     # install text string into text array
character       str[ARB], text[ARB]
integer         pnt*2, max, ifindtext
VMSchar         str_v*ARB
#install = ifindtext(str,pnt,max,text) 
#if (install != NO) return

len = length(str)+1
if (mod(len,2) != 0) len = len + 1

if (pnt+len >= max)
    {
    call putlin_v ("Text Array Overflow, with: ",ERROUT)
	call rs2fs (str, str_v)
    call error (str_v)
    }    

install = pnt + 1

call scopy (str, 1, text, install)

pnt = pnt + len

return
end


# ngetch - get a (possibly pushed back) character

character function ngetch(c, fd)
character getchar
character c
integer fd
# include commonblocks
cdefio_common
 
if (bp > 0)
    {
    c = buf[bp]
    bp = bp - 1
    }
else
    c = getchar(c, fd)

ngetch = c

return
end


# pbstr - push string back onto input
subroutine pbstr(in)
character in[ARB]
integer length
integer i
 
for (i = length(in); i > 0; i = i - 1)
    call putbak(in[i])

return
end


# putbak - push character back onto input

subroutine putbak(c)
character c
# include commonblocks
cdefio_common
 
bp = bp + 1

if (bp > BUFSIZE)
    call error ("Too many Characters pushed back.")

buf[bp] = c

return
end


character function gettok (buf,int)
d_common
character       buf[MAXLINE], char, gtok, term, lex

gettok = gtok(buf,int)

if (gettok == EOF)
    {
    eofflag = .true.
    }
else if (gettok == SQUOTE | gettok == DQUOTE)
    {
    gettok = $$LEX_string
    }
else if (gettok == DIGIT)
    {
    gettok = $$LEX_other
    }
else 
    {
    gettok = lex(buf)
    }

#call echor
#call echoh ("<<gettok:",ARB)
#call echoi (gettok)
#call echoh (":",ARB)
#call echoh (buf,MAXLINE)
#call echoh (">>",ARB)
#call echor

return
end


character function lex(buf)
d_common
character       buf[MAXLINE], work[MAXLINE], char
integer         len, equal, almostequal

lex = 0
call scopy (buf,1,work,1)
call upper (work)

for (i=1; i <= MAXLEX; i=i+1)
    {
    if (lexhead[i] == 0) next

    if (equal(work,lextext[lexhead[i]]) == YES) return (i)

    if (almostequal(work,lextext[lexhead[i]]) == YES) 
        {
        if (lex != 0) return ($$LEX_maybe)
        
        lex=i
        }
    }

if (lex == 0) lex = $$LEX_other

return
end


character function gtok (buf,int)
d_common
character       buf[MAXLINE], char, ngetch, term, type
integer         int

i=1
while (ngetch(buf[i],int) == BLANK) ;
char = buf[i]

gtok = type(char)

if (gtok == LETTER | gtok == DOLLAR)
    {
    for (i=1; i <= MAXLINE - 2; i=i+1)
        {
        gtok = type(ngetch(buf[i+1],int))
        if (gtok != LETTER & gtok != DIGIT & 
            gtok != DOLLAR & gtok != UNDERLINE) break
        }

    call putbak (buf[i+1])
    gtok = LETTER
    }
else if (gtok == DIGIT)
    {
    for (i=1; i <= MAXLINE - 2; i=i+1)
        {
        gtok = type(ngetch(buf[i+1],int))
        if (gtok != PERIOD & gtok != DIGIT) break
        }

    call putbak (buf[i+1])
    gtok = DIGIT
    }
else if (gtok == SQUOTE | gtok == DQUOTE)
    {
    for (i = 2; i <= MAXLINE-2               &
                ngetch(buf[i],int) != buf[1] &
                buf[i] != EOF                 ; i=i+1)
        {
        if (buf[i] == COLON |
            buf[i] == SEMICOL  )
            {
            call putbak (buf[i])
            break
            }

        if (buf[i] == BLANK & buf[i-1] == BLANK) i=i-1
        }
    buf[i] = buf[1]
    }

buf[i+1] = EOS

return
end


character function getchar (char,int)
character       char
integer         int
logical         cmmnt
integer			getch, istat
data            cmmnt /.false./


istat = getch (char,int)

switch (char)
    {
    case NEWLINE:
        {
        cmmnt = .false.
        char = BLANK
        }
    case TAB, FF:
        {
        char = BLANK
        }
    case SHARP:
        {
        cmmnt = .true.
        }
    }

if (cmmnt) char = BLANK

return (char)
end


subroutine ddl_init                     # init data structures
d_common

sys$id = 0
sys$title = 0
sys$text = 0
sys$tbl_count = 0

for (i=1; i<= MAXARRAY; i=i+1) ddl_array[i] = 0

return
end


subroutine init_lex             # load Lexical/Keywords
d_common
integer*2       i

string address_kw     "ADDRESS"
string alternate_kw   "ALTERNATE" 
string character_kw   "CHARACTER"
string class_kw       "CLASS"
string comments_kw    "COMMENTS" 
string date_kw        "DATE"
string define_kw      "DEFINE"
string description_kw "DESCRIPTION"
string duplicate_kw   "DUPLICATE"
string entry_size_kw  "ENTRY_SIZE"
string field_kw       "FIELD"
string flag_kw        "FLAG" 
string floating_kw    "FLOATING"
string format_kw      "FORMAT"
string index_kw       "INDEX"
string indicator_kw   "INDICATOR"
string indirect_kw    "INDIRECT" 
string integer_kw     "INTEGER" 
#string name_kw       "NAME"
string offset_kw      "OFFSET" 
string pointer_kw     "POINTER" 
string position_kw    "POSITION"
string precision_kw   "PRECISION"
string range_kw       "RANGE"
string record_kw      "RECORD" 
string save_kw        "SAVE" 
string scaling_kw     "SCALING"
string signed_kw      "SIGNED"
string size_kw        "SIZE"
string slots_kw       "SLOTS" 
string specific_kw    "SPECIFIC"
string subtable_kw    "SUBTABLE"
string system_kw      "SYSTEM" 
string table_kw       "TABLE" 
string title_kw       "TITLE" 
string type_kw        "TYPE"
string variable_kw    "VARIABLE"
string word_kw        "WORD" 
string half_kw        "HALF" 
string byte_kw        "BYTE" 
string vaxchar_kw     "VAXCHAR" 
string zero_kw        "ZERO" 
string bits_kw        "BITS"
string table_offset_kw "TABLE_OFFSET"
string word_offset_kw "WORD_OFFSET"
string flag_updates_kw "FLAG_UPDATES"
string flag_changes_kw "FLAG_CHANGES"
string all_kw         "ALL"
string colon_kw       ":"
string semicolon_kw   ";" 
string comma_kw       "," 

for (i=1; i <= MAXLEX; i=i+1) lexhead[i] = 0

i = 0 

lexhead[$$LEX_ADDRESS     ]=install(ADDRESS_KW    ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_ALTERNATE   ]=install(ALTERNATE_KW  ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_CHARACTER   ]=install(CHARACTER_KW  ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_CLASS       ]=install(CLASS_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_COMMENTS    ]=install(COMMENTS_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_DEFINE      ]=install(DEFINE_KW     ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_DESCRIPTION ]=install(DESCRIPTION_KW,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_DUPLICATE   ]=install(DUPLICATE_KW  ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_ENTRY_SIZE  ]=install(ENTRY_SIZE_KW ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_FIELD       ]=install(FIELD_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_FLAG        ]=install(FLAG_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_FLOATING    ]=install(FLOATING_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_FORMAT      ]=install(FORMAT_KW     ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_INDEX       ]=install(INDEX_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_INDICATOR   ]=install(INDICATOR_KW  ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_INDIRECT    ]=install(INDIRECT_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_INTEGER     ]=install(INTEGER_KW    ,i,MAXLEXTEXT,lextext)
#lexhead[$$LEX_NAME       ]=install(NAME_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_OFFSET      ]=install(OFFSET_KW     ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_POINTER     ]=install(POINTER_KW    ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_POSITION    ]=install(POSITION_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_PRECISION   ]=install(PRECISION_KW  ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_RANGE       ]=install(RANGE_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_RECORD      ]=install(RECORD_KW     ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SAVE        ]=install(SAVE_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SCALING     ]=install(SCALING_KW    ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SIGNED      ]=install(SIGNED_KW     ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SIZE        ]=install(SIZE_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SLOTS       ]=install(SLOTS_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SPECIFIC    ]=install(SPECIFIC_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SUBTABLE    ]=install(SUBTABLE_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_SYSTEM      ]=install(SYSTEM_KW     ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_TABLE       ]=install(TABLE_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_TITLE       ]=install(TITLE_KW      ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_TYPE        ]=install(TYPE_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_VARIABLE    ]=install(VARIABLE_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_WORD        ]=install(WORD_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_HALF        ]=install(HALF_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_BYTE        ]=install(BYTE_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_VAXCHAR     ]=install(VAXCHAR_KW    ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_ZERO        ]=install(ZERO_KW       ,i,MAXLEXTEXT,lextext)

lexhead[$$LEX_BITS        ]=install(BITS_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_TABLE_OFFSET]=install(TABLE_OFFSET_KW,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_WORD_OFFSET ]=install(WORD_OFFSET_KW,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_DATE        ]=install(DATE_KW       ,i,MAXLEXTEXT,lextext)

lexhead[$$LEX_FLAG_UPDATES]=install(FLAG_UPDATES_KW,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_FLAG_CHANGES]=install(FLAG_CHANGES_KW,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_ALL         ]=install(ALL_KW        ,i,MAXLEXTEXT,lextext)


lexhead[$$LEX_seperator   ]=install(COLON_KW       ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_terminator  ]=install(SEMICOLON_KW   ,i,MAXLEXTEXT,lextext)
lexhead[$$LEX_comma       ]=install(COMMA_KW       ,i,MAXLEXTEXT,lextext)

# $$LEX_string
# $$LEX_maybe
# $$LEX_other

lextextpnt = i

end



subroutine ddl_verify (istat)
d_common
character       type, fld_type, fld_types[3], clower, fld_size
character       token[ARB], token2[ARB]
integer         EqualLen, equal, fld_pos, ctoi, nbits
equivalence     (fld_type,fld_types[1])
data            fld_types/ EOS, EOS, EOS/
real            max_hi
integer*4       islots, woffset, toffset, isize, lastword
logical*4       bitentry, contained


string n0_str   "0"
string n8_str   "8"
string n16_str  "16"
string n24_str  "24"
string pointer_str "POINTER"
string index_str "INDEX"
string warning_msg1 "Field Size too small for Pointer value (must hold #)."


for (itbl = 1; itbl <= sys$tbl_count; itbl = itbl+1)
    {
    tbl$Pointer$to itbl

    d_w2 = 1 # d_w
    call stcopy_vh ("  ",1, d_where, d_w2)

    #if      (tbl$Record == 0 ) call stcopy_vh ("Table: ",1, d_where, d_w2)
    #else if (tbl$Record == 1 ) call stcopy_vh ("Record: ",1, d_where, d_w2)
    #else if (tbl$Record == 2 ) call stcopy_vh ("Variables: ",1, d_where, d_w2)
    #else if (tbl$Record == 3 ) call stcopy_vh ("Constants: ",1, d_where, d_w2)
    #else                       call stcopy_vh ("????????: ",1, d_where, d_w2)

    call stcopy (ddl_text[tbl$id],1, d_where, d_w2)

    if (tbl$Entry == 0)
        call warning(istat,"ENTRY size not specified.")

    if (tbl$Slots == 0 & tbl$record == 0)
        call warning(istat,"Number of SLOTS (entries) not specified.")

    for (tbl$sav$Index = 1; tbl$sav$Index <= tbl$sav_count; 
        tbl$sav$Index=tbl$sav$Index+1)
        {
        d_w3 = d_w2
        #call stcopy_vh (", Save Field: ",1, d_where, d_w3)

        call stcopy_vh ("$",1, d_where, d_w3)

        call stcopy (ddl_text[tbl$sav$name],1, d_where, d_w3)

        if (clower(ddl_text[tbl$sav$Name]) == LETX )
            call warning(istat,"Extraction Macro may not be used in SAVE.")
        }

    for (tbl$sub$Index = 1; tbl$sub$Index <= tbl$sub_count; 
        tbl$sub$Index=tbl$sub$Index+1)
        {
        d_w3 = d_w2
        #call stcopy_vh (", Sub-Table: ",1, d_where, d_w3)

        call stcopy_vh ("$",1, d_where, d_w3)

        call stcopy (ddl_text[tbl$sub$id],1, d_where, d_w3)

        if (tbl$sub$Slots == 0)
            call warning(istat,"Number of SLOTS (entries) not specified.")
        else if (EqualLen(ddl_text[tbl$id],ddl_text[tbl$sub$slots]) == YES)
            call warning(istat,"The Extraction Macro must be used for SLOTS.")
            

        if (tbl$sub$add == 0 | tbl$sub$pos == 0)        # ??????
            {
            call ddl_gen_address (tbl$Pointer,tbl$sub$Index)
            }

        if (tbl$sub$add == 0)           # ??????
            call warning(istat,"Address not specified.")

        if (tbl$entry != 0)
            {
            call ddl_sub_findout (tbl$Pointer, tbl$sub$Index,
                                  islots, woffset, toffset, isize, 
                                  bitentry, contained, lastword)

            i = tbl$entry
            isize = ctoi (ddl_text,i)

            if (tbl$variable == YES)
                {
                i1 = tbl$var_size
                i2 = tbl$var_max

                isize = isize + ctoi (ddl_text,i1) * ctoi (ddl_text,i2)
                }
        
            if (lastword > isize)
                call warning(istat,"The Sub-Table extends beyond the Table entry.")
            }
        }

    for (loop = 1; loop <= tbl$fld_count; loop = loop + 1)
        {
        tbl$fld$Index = loop

        d_w3 = d_w2
        #call stcopy_vh (", Field: ",1, d_where, d_w3)
        call stcopy_vh ("$",1, d_where, d_w3)

        call stcopy (ddl_text[tbl$fld$name],1, d_where, d_w3)

        if (tbl$fld$type == 0)
            {
            call warning(istat,"TYPE not specified.")
            fld_type = BLANK
            }
        else
            {
            fld_type = ddl_text[tbl$fld$type]

            call stcopy_vh ("$",1, d_where, d_w3)
            call stcopy (fld_type,1, d_where, d_w3)
            }

        k = 1
        call stcopy (ddl_text[tbl$fld$name],1, token, k)
        call upper (token)

        for (k=1; k < loop; k=k+1)      # search all fields for name
            {   
            tbl$fld$Index = k
        
            if (fld_type != ddl_text[tbl$fld$type]) next   # same type ?

            k2 = 1
            call stcopy (ddl_text[tbl$fld$name],1, token2, k2)
            call upper (token2)
            if (equal (token, token2) != YES) next

            call warning(istat,"Duplicate Field Name/Type.")
            }

        tbl$fld$Index = loop

        if (tbl$fld$Word == 0 & tbl$fld$WrdSub == 0 & tbl$fld$Indir == 0)
            call warning(istat,"WORD not specified.")

        isub_word = 0
        if (tbl$fld$WrdSub != 0)
            {
            call fnd_subtbl (tbl$Pointer,isub_word ,tbl$fld$WrdSub)

            if (isub_word == 0)
                call warning(istat,"Invalid Subtable reference for WORD.")
            }


        fld_pos = 1            # this is a valid default position (used below)

        if (tbl$fld$pos == 0 & tbl$fld$PosSub == 0)
            call warning(istat,"POSITION not specified.")

#       else if (type(ddl_text[tbl$fld$pos]) == LETTER)
        else if (tbl$fld$PosSub != 0)
            {
            call fnd_subtbl (tbl$Pointer,tbl$sub$Index,tbl$fld$PosSub)

            if (fld_type == BIGC)
                call warning(istat,"POSITION of Character type must be numeric.")

            else if (fld_type == BIGV)
                call warning(istat,"POSITION of VaxChar type must be numeric.")

            else if (tbl$sub$Index == 0)
                call warning(istat,"Invalid Subtable reference for POSITION.")

            else if (tbl$sub$pos == 0)
                call warning(istat,"POSITION of Subtable for POSITION is undefined.")

            }
        else
            {
            i = tbl$fld$pos 
            fld_pos = ctoi (ddl_text,i)
            }

        isub_pos = 0
        if (tbl$fld$PosSub != 0)
            {
            call fnd_subtbl (tbl$Pointer,isub_pos ,tbl$fld$PosSub)

            if (isub_pos == 0)
                call warning(istat,"Invalid Subtable reference for POSITION.")
            }

        if (tbl$fld$WrdSub != 0 & tbl$fld$PosSub != 0)
            {
            if (isub_word != isub_pos)
                call warning (istat,"Subtable Mis-Match for WORD/POSITION.")
            }

        nbits = 0
        fld_size = BLANK
        if (tbl$fld$Size == 0)
            call warning(istat,"SIZE not specified.")

        else if (type(ddl_text[tbl$fld$size]) == LETTER) # must be 'WORD',
                                                         # 'HALF', or 'BYTE'
            {
            if (fld_type == BIGC)
                call warning(istat,"SIZE of Character type must be numeric.")

            if (fld_type == BIGV)
                call warning(istat,"SIZE of VaxChar type must be numeric.")

            fld_size = ddl_text[tbl$fld$size]
            if (fld_size == BIGW)
              {
              nbits = 32
              if (tbl$fld$Scale != 0)
                call warning(istat,"Whole WORD fields are not allowed SCALING.")

              if (tbl$fld$Off != 0)
                call warning(istat,"Whole WORD fields are not allowed OFFSET.")

              if (tbl$fld$prec  != 0 & fld_type == BIGI)
                call warning(istat,"INTEGER WORD fields are not allowed PRECISION.")

              if (fld_pos < 0 | fld_pos > 1) 
                call warning(istat,"WORD fields must be at position 1 (or 0).")
              }

            if (fld_size == BIGH)
              {
              nbits = 16
              if (fld_pos < 1 | fld_pos > 2)
                call warning(istat,"HALF fields must be at position 1 or 2.")

              tbl$fld$size=install(n16_str,sys$text,MAXTEXT,ddl_text)
              if (type(ddl_text[tbl$fld$pos]) != LETTER)
                {
                if (fld_pos == 1)
                    tbl$fld$pos=install(n0_str,sys$text,MAXTEXT,ddl_text)
                else
                    tbl$fld$pos=install(n16_str,sys$text,MAXTEXT,ddl_text)
                }
              }

            if (fld_size == BIGB)
              {
              nbits = 8
              if (fld_pos < 1 | fld_pos > 4)
                call warning(istat,"BYTE fields must be at position 1, 2, 3 or 4.")
              tbl$fld$Size =install(n8_str,sys$text,MAXTEXT,ddl_text)
              if (type(ddl_text[tbl$fld$pos]) != LETTER)
                {
                if (fld_pos == 1)
                    tbl$fld$pos=install(n0_str,sys$text,MAXTEXT,ddl_text)
                else if (fld_pos == 2)
                    tbl$fld$pos=install(n8_str,sys$text,MAXTEXT,ddl_text)
                else if (fld_pos == 3)
                    tbl$fld$pos=install(n16_str,sys$text,MAXTEXT,ddl_text)
                else
                    tbl$fld$pos=install(n24_str,sys$text,MAXTEXT,ddl_text)

                }
              }
            }

        else    # Packed (nbits given) Field (or Character)
            {
             i = tbl$fld$size
             nbits = ctoi (ddl_text,i)

             if (tbl$fld$Scale == 0 & fld_type == BIGF)
                call warning(istat,"Packed Floating types require SCALING.")

             if (tbl$fld$Off   == 0                  &
                 (fld_type == BIGF | fld_type == BIGI) &
                 tbl$fld$Range != 0                  &
                 tbl$fld$Signed != YES               &
                 ddl_text[tbl$fld$range] == MINUS)
                call warning(istat,"Negative packed types require OFFSET.")
            }

        if (fld_type == BIGC)
            {
            if (tbl$fld$range != 0)
                call warning(istat,"Character types do not have RANGE.")

            if (tbl$fld$scale != 0)
                call warning(istat,"Character types do not have SCALING.")

            if (tbl$fld$off   != 0)
                call warning(istat,"Character types do not have OFFSET.")

            if (tbl$fld$prec  != 0)
                call warning(istat,"Character types do not have PRECISION.")

            if (tbl$fld$Class != 0)
                call warning(istat,"Character types do not have CLASS.")
            }
        if (fld_type == BIGV)
            {
            if (tbl$fld$range != 0)
                call warning(istat,"VaxChar types do not have RANGE.")

            if (tbl$fld$scale != 0)
                call warning(istat,"VaxChar types do not have SCALING.")

            if (tbl$fld$off   != 0)
                call warning(istat,"VaxChar types do not have OFFSET.")

            if (tbl$fld$prec  != 0)
                call warning(istat,"VaxChar types do not have PRECISION.")

            if (tbl$fld$Class != 0)
                call warning(istat,"VaxChar types do not have CLASS.")
            }

        if (tbl$fld$Range != 0 & fld_type  == BIGI)
            {
            i = tbl$fld$Range 
            irange_lo = ctoi (ddl_text,i)
            i=i+1 
            irange_hi = ctoi (ddl_text,i)

            if (tbl$fld$Scale != 0)
                {
                i = tbl$fld$Scale
                iscale = ctoi (ddl_text,i)
                irange_lo = irange_lo / iscale
                irange_hi = irange_hi / iscale
                }
            
            if (tbl$fld$off != 0)
                {
                i = tbl$fld$off
                ioffset = ctoi (ddl_text,i)
                irange_lo = irange_lo - ioffset
                irange_hi = irange_hi - ioffset
                }
            
            if (tbl$fld$Signed == YES) max_hi = (2.0 ** (nbits-1) ) - 1.0
            else                       max_hi = (2.0 ** (nbits  ) ) - 1.0

            if (irange_hi > max_hi) 
                call warning(istat,"Field Size too small for specified Range.")
            }

        if (tbl$fld$Class != 0)
            {
            nslots = 0
            nsize = 0
            irange_hi = nslots * nsize

            if (tbl$fld$Signed == YES) max_hi = (2.0 ** (nbits-1) ) - 1.0
            else                       max_hi = (2.0 ** (nbits  ) ) - 1.0

            if (equal(ddl_text[tbl$fld$class],POINTER_str) == YES)
                {
                if (tbl$fld$scale != 0)
                  call warning(istat,"CLASS POINTER does not allow SCALING.")

                if (tbl$fld$off   != 0)
                  call warning(istat,"CLASS POINTER does not allow OFFSET.")

                if (tbl$fld$prec  != 0)
                  call warning(istat,"CLASS POINTER does not allow PRECISION.")

                call read_external_slots (tbl$fld$CDesc,nslots,nsize,istat)
                irange_hi = nslots * nsize

                if (irange_hi > max_hi) 
                    {
                    call warning_w_int(istat,
                      warning_msg1,
                      irange_hi)
                    }
                else if (irange_hi == 0)
                    call info_only(istat,"Could not verify Size for Pointer field.")

                }
            else if (equal(ddl_text[tbl$fld$class],INDEX_str) == YES)
                {
                if (tbl$fld$scale != 0)
                    call warning(istat,"CLASS INDEX does not allow SCALING.")

                if (tbl$fld$off   != 0)
                    call warning(istat,"CLASS INDEX does not allow OFFSET.")

                if (tbl$fld$prec  != 0)
                    call warning(istat,"CLASS INDEX does not allow PRECISION.")

                call read_external_slots (tbl$fld$CDesc,nslots,nsize,istat)
                irange_hi = nslots
                if (irange_hi > max_hi) 
                    {
                    call warning_w_int(istat,
                      warning_msg1,
                      irange_hi)
                    }
                else if (nslots == 0)
                    call info_only(istat,"Could not verify Size for Index field.")
                }

            }

        if (tbl$record == 1 & tbl$fld$indir != NO)
            call warning(istat,"Fields in Records are not allowed to be INDIRECT.")

        } # end of loop thru all fields
    }

return
end



subroutine ddl_sub_findout (tbl$Pointer, tbl$sub$Index,
                            islots, woffset, toffset, isize, 
                            bitentry, contained, lastword)
d_common
# ??? pic_common
character       work1[40], work2[40]
integer         equal, ctoi, woffset, toffset, lastword
logical         contained, bitentry

########################################
# statement functions:

#ifig_add(ndx) = (ndx - 1 + (woffset/isize)) / (32/isize)
ifig_add(ndx) = (ndx - 1 + ((woffset-iwaste)/isize)) / ((32-iwaste)/isize)
#ifig_pos(ndx) = mod( ndx*isize + woffset - isize, ibitsused)

########################################

bitentry = (tbl$sub$EntBit == YES)      # Is this a bit size entry

if (tbl$sub$EntSize != 0)       # get Size of the entry (words/bits)
    { 
    i = tbl$sub$EntSize

    isize = ctoi (ddl_text,i)
    }
else
    {
    isize = 0
    }

if (tbl$sub$TblOff != 0)        # get the Table offset 
    { 
    i = tbl$sub$TblOff

    TOffSet = ctoi (ddl_text,i)
    }
else
    TOffSet = 0

#if (tbl$sub$SubTbl != 0)       # get the Table name if this is sub-sub-tbl
#    { 
#    call scopy (ddl_text[tbl$sub$subtbl],1,name,1)
#    }
#else
#    name[1] = EOS

if (tbl$sub$WrdOff != 0)        # get the Word offset (n bits)
    { 
    i = tbl$sub$WrdOff

    WOffSet = ctoi (ddl_text,i)
    }
else
    WOffSet = 0

if (isize > 0)
    {
    iwaste    = mod(Woffset, isize)  # number of un-usable bits preceeding
    }                                # entries in each word
else
    {
    iwaste    = 0
    }

if (tbl$sub$Slots != 0)                 # get number of entries
    { 
    i = tbl$sub$Slots

    islots = ctoi (ddl_text,i)
    }
else
    islots = 0

if (islots == 0 & tbl$sub$Slots != 0)   # get number of entries again
    {
    call scopy (ddl_text[tbl$sub$slots],1, work1,1)
    call fold (work1)

    call scopy (ddl_text[tbl$Var_name],1, work2,1)
    call fold (work2)

    if (tbl$Var_size != 0)      # get Size of the tbl Var len entry
        { 
        i = tbl$Var_size

        ksize = ctoi (ddl_text,i)
        }
    else
        ksize = 0

    if (equal(work1,work2) == YES & isize == ksize & tbl$var_max != 0)
        {
        i = tbl$Var_max

        islots = ctoi (ddl_text,i)
        }
    }

contained = (bitentry & (islots * isize + WOffset) <= 32) # all in one word ?

if (Bitentry)
    {
    iadd = 0
    if (isize != 0)
        {
        iadd =  ifig_add(islots) 
        }

    kadd = iadd + toffset                   # first word of last entry

    lastword = kadd                         # last word of last entry
    }
else
    {    
    iadd = 0
    kadd = (islots-1) * isize + toffset     # first word of last entry

    lastword = kadd + isize - 1             # last word of last entry
    }

return
end

undefine read

subroutine read_external_slots (sindex , nslots, nsize, istat)
d_common

integer         sindex, 
                nslots, 
                nsize,
                istat,
				kk,
				ctoi

character		clower, char_code

VMSchar         aline*200,
                uline*200,
                anum*10,
                filename*20

string          inc ".inc"

filename = " "
n = 0
nslots = 0
nsize = 0
nentB = 0
nents = 0
nmax  = 0

for (i=sys$id; ddl_text[i] != 0; i=i+1)
    {
    n = n + 1
	char_code = clower(ddl_text[i])
	kk = char_code		# Convert char to int
    filename[n:n] = char(kk)
    }

len_sys = n

for (i=sindex; ddl_text[i] != 0; i=i+1)
    {
    n = n + 1
	char_code = clower(ddl_text[i])
	kk = char_code		# Convert char to int
    filename[n:n] = char(kk)
    }

for (i=1 ; INC[i] != 0; i=i+1)
    {
    n = n + 1
	char_code = INC[i]
	kk = char_code		# Convert char to int
    filename[n:n] = char(kk)
    }

open (unit            = 93,                 # try in the default directory
      file            = filename, 
      status          = "OLD",
      %err%           = 9901)

if (1 == 2)
    {
    9901 continue                           # if open did not work....
    #call putlin_v ("Unable to open external input file ", ERROUT)
	#call putlin_v (filename, ERROUT)
	#call putch (NEWLINE,ERROUT)

	return


    }
      
repeat
    {
    read (unit = 93, %err% = 9900, %end% = 9900, fmt = 9001) aline
    9001 format (A)

    ix = %index% (aline, "#") # length prior to comments

    if (ix == 0) ix = len(aline)    
    call str_upcase (uline,aline[:ix])    # force into uppercase

#    ifound = str$Find_First_Substring (uline, ix, 
#                    ix2, "$SLOTS,", 
#                         "$ENTB,",
#                         "$ENTS,",
#                         "$MAXSUB,",
#                         "$ENTRY,")
	if      (%index% (uline, "$SLOTS,") != 0) ix2=1
	else if (%index% (uline, "$ENTB,")  != 0) ix2=2
	else if (%index% (uline, "$ENTS,")  != 0) ix2=3
	else if (%index% (uline, "$MAXSUB,")!= 0) ix2=4
	else if (%index% (uline, "$ENTRY,") != 0) ix2=5
	else ix2=0
	if (ix2 == 0) ifound = 0
	else          ifound = 1

    if (ifound == 1) 
        {
        call str_element ( anum, 1, ",", uline)

        n2 = max(2,%index%(anum, ")") ) - 1
        
        num = 0
		kk = 1
        #n3 = ots$cvt_tu_l ( anum[1:n2], num, %%val(4), %%val(-1) )        
        num = ctoi(%%ref(anum),kk)
        switch (ix2)
            {
            case 1:  
                {
                if (nslots == 0) nslots = num
                }    
            case 2:  
                {
                if (nentb == 0) nentb = num
                }    
            case 3:  
                {
                if (nents == 0) nents = num
                }    
            case 4:  
                {
                if (nmax == 0) 
                    {
                    nmax = num
                    nsize = nentb + (nents * nmax)
                    }
                }    
            case 5:  
                {
                if (nsize == 0) nsize = num
                }
            }
        }
 
    } until ((nslots != 0) & (nsize != 0))


9900 close (unit = 93, %err% = 9910)

# type *, filename[1:n], nslots, nsize

9910 return
end


subroutine ddl_gen_address (tbl$Pointer, tbl$sub$Index)
d_common
character       calc_add[100], calc_pos[100]
integer         equal       # function to compare strings for equality
integer         ctoi        # function to translate ascii value to Integer
integer         islots      # number of slots in the sub table
integer         isize       # size of each entry in the sub-table (words/bits)
integer         Toffset     # Table Offset
integer         Woffset     # word offset
integer         BitsUsed    # number of bits/words used
integer         ival        # number of entries/word or words/entry

logical         bitentry    # True if each slot is bitwise
logical         contained   # True if the entire table is within a single word



if (tbl$sub$EntSize != 0)               # get Size of the entry (words/bits)
    { 
    i = tbl$sub$EntSize

    isize = ctoi (ddl_text,i)
    }
else
    isize = 0

if (isize <= 0) return                  # check if required fields entered

if (tbl$sub$subtbl == 0 & 
    tbl$sub$TblOff == 0  ) return

#
# get all of the required values and set appropriate state
#

calc_add[1] = EOS                       # initialize ADD and POS strings
len_add = 1

calc_pos[1] = EOS
len_pos = 1

if (tbl$sub$Slots != 0)                 # get number of entries
    { 
    i = tbl$sub$Slots

    islots = ctoi (ddl_text,i)
    }
else
    islots = 0


if (tbl$sub$TblOff != 0)                # get the table offset (n words)
    { 
    i = tbl$sub$TblOff

    TOffSet = ctoi (ddl_text,i)
    }
else
    TOffSet = 0

bitentry = (tbl$sub$EntBit == YES)      # Is this a bit size entry


if (bitentry & tbl$sub$WrdOff != 0)     # get the Word offset (n bits)
    { 
    i = tbl$sub$WrdOff

    WOffSet = ctoi (ddl_text,i)
    }
else
    WOffSet = 0


contained = bitentry &                          # all within one word ?
            ((islots * isize + WOffset) <= 32)


# all set, lets do it!                  # start making 'ADDRESS'

# string should start as:  "(tbl$Pointer        + tbloffset-1 " (if a TABLE)
#                     or:  "(1                  + tbloffset-1 " (if a RECORD)
#                     or:  "(tbl$subtbl$Address + tbloffset   "

call stcopy_vh ('(',1, calc_add, len_add)

if (tbl$sub$SubTbl == 0)
    {
    if (tbl$record == 1)
        {
        call stcopy_vh ("1",1, calc_add,len_add)
        }
    else
        {
        call stcopy (ddl_text[tbl$id],1, calc_add,len_add)
        call stcopy_vh ("$Pointer",1, calc_add,len_add)
        }

    TOffSet = TOffSet - 1
    }    
else
    {
    call stcopy (ddl_text[tbl$id],1, calc_add,len_add)
    call stcopy_vh ("$",1, calc_add,len_add)
    call stcopy (ddl_text[tbl$sub$subtbl],1, calc_add,len_add)
    call stcopy_vh ("$Address",1, calc_add,len_add)
    }

if (TOffSet != 0)
    {
    if (TOffSet < 0) call stcopy_vh ('-',1, calc_add,len_add)
    else             call stcopy_vh ('+',1, calc_add,len_add)

    ilen = itoc(abs(TOffSet),calc_add[len_add], 9)
    len_add = len_add + ilen
    }


# string should continue with:  " + (tbl$subtbl$Index - 1                 ) "
#                          or:  " + (tbl$subtbl$Index - 1 + (woffset/size)) "
#                          or:  "    "  (nothing at this point)

if (! contained)
    {
    if (! bitentry)                     # multiple words per 1 entry ??
        {    
        ival     = isize                # YES, 
        BitsUsed = ival                 # number of words per entry
        iwaste   = 0
        }       
    else
        {                               # NO, 
        iwaste   = mod(Woffset, isize)  # number of un-usable bits preceeding
                                        # entries in each word

        ival     = (32-iwaste) / isize  # number entries/word
        BitsUsed = ival * isize         # bits used per word (w/zero Woffset)
        }       

    modindex = (((woffset - iwaste) + isize - 1) / isize) - 1  

    call stcopy_vh ("+(",1, calc_add,len_add)
    call stcopy (ddl_text[tbl$id],1, calc_add,len_add)
    call stcopy_vh ("$",1, calc_add,len_add)
    call stcopy (ddl_text[tbl$sub$id],1, calc_add,len_add)
    call stcopy_vh ("$Index",1, calc_add,len_add)

    if (modindex < 0) call stcopy_vh ('-',1, calc_add,len_add)
    else              call stcopy_vh ('+',1, calc_add,len_add)

    ilen = itoc(abs(modindex),calc_add[len_add], 9)
    len_add = len_add + ilen

    call stcopy_vh (")",1, calc_add,len_add)

    # continue with:  " * ival "  for WORD entries
    #            or:  " / ival "  for multi-entries/word

    if (! bitentry)                     # multiple words per 1 entry ??
        {
        call stcopy_vh ("*",1, calc_add,len_add)       # YES
        }
    else
        {
        call stcopy_vh ("/",1, calc_add,len_add)       # NO
        }

    ilen = itoc(ival,calc_add[len_add], 9)
    len_add = len_add + ilen
    }

call stcopy_vh (')',1, calc_add, len_add)          # done making 'ADDRESS'



if (BitEntry)                                   #############################
    {
    call stcopy_vh ('(',1, calc_pos, len_pos)      # start making 'POSITION'

    # string S/B:  "(    tbl$subtbl$Index * isize + woffset-isize) "
    #         or:  "(MOD(tbl$subtbl$Index * isize + woffset-isize),bitsused)) "

    if (! contained) 
        call stcopy_vh ('MOD(',1, calc_pos, len_pos)

    call stcopy (ddl_text[tbl$id],1, calc_pos,len_pos)
    call stcopy_vh ("$",1, calc_pos,len_pos)
    call stcopy (ddl_text[tbl$sub$id],1, calc_pos,len_pos)
    call stcopy_vh ("$Index",1, calc_pos,len_pos)

    if (isize != 1)
        {
        call stcopy_vh ('*',1, calc_pos, len_pos)

        ilen = itoc(isize,calc_pos[len_pos], 9)
        len_pos = len_pos + ilen
        }

    nval = WOffSet - isize
    if (nval != 0)
        {
        if (nval < 0) call stcopy_vh ('-',1, calc_pos,len_pos)
        else          call stcopy_vh ('+',1, calc_pos,len_pos)

        ilen = itoc(abs(nval),calc_pos[len_pos], 9)
        len_pos = len_pos + ilen
        }

    if (! contained) 
        {
        call stcopy_vh (',',1, calc_pos, len_pos)

        ilen = itoc(BitsUsed,calc_pos[len_pos], 9)
        len_pos = len_pos + ilen

        call stcopy_vh (')',1, calc_pos, len_pos)
        }

    call stcopy_vh (')',1, calc_pos, len_pos)      # done making 'POSITION'
    }


#if (tbl$sub$add == 0 & tbl$sub$pos == 0)
#    {
#    if (length(calc_add) != 0)
#        tbl$sub$add= install(calc_add,sys$text,MAXTEXT,ddl_text)
#
#    if (length(calc_pos) != 0) 
#        tbl$sub$pos= install(calc_pos,sys$text,MAXTEXT,ddl_text)
#    }

if (tbl$sub$add == 0)
    {
    if (length(calc_add) != 0)
        tbl$sub$add= install(calc_add,sys$text,MAXTEXT,ddl_text)
    }

if (tbl$sub$pos == 0)
    {
    if (length(calc_pos) != 0) 
        tbl$sub$pos= install(calc_pos,sys$text,MAXTEXT,ddl_text)
    }

return
end


subroutine fnd_subtbl (tbl$Pointer, tbl$sub$Index, ipnt)
d_common
character       name1[ARB], name2[ARB]
integer         equal, ipnt*2

call scopy (ddl_text[ipnt],1, name1,1)
call fold (name1)


for (tbl$sub$Index = 1; tbl$sub$Index <= tbl$sub_count; 
     tbl$sub$Index=tbl$sub$Index+1)
    {
    call scopy (ddl_text[tbl$sub$id],1, name2,1)
    call fold (name2)

    if (equal(name1,name2) == YES) return
    }

tbl$sub$Index = 0

return
end


subroutine ddl_load (int,ierr)
d_common
character       token[MAXLINE], gettok, itype, type
integer         int, state, count, marks[2]

#call markl (int,marks) # MARKL called at the beginning returns 0,0.

state = $$init

itype = gettok (token,int)

repeat 
    {
    if (eofflag) break

    switch (state)
        {
        case $$init:
            {
            if (itype == $$LEX_System) 
                call proc_system (itype,state,token,int,ierr)
            else
                call error ("Missing SYSTEM Keyword.")
            }

        case $$sys:
            {
            if (itype == $$LEX_System) 
                call error ("Extraneous SYSTEM Keyword.")

            else if (itype == $$LEX_Table) 
                call proc_table  (itype,state,token,int,ierr)

            else if (itype == $$LEX_Record) 
                call proc_record (itype,state,token,int,ierr)

            else
                call error ("Missing TABLE/RECORD Keyword.")
            }

        case $$tbl1:
            {
            if (itype == $$LEX_System) 
                call error ("Extraneous SYSTEM Keyword.")

            else if (itype == $$LEX_Define) 
                call proc_define(itype,state,token,int,ierr)

            else if (itype == $$LEX_SubTable) 
                call proc_SubTbl(itype,state,token,int,ierr)

            else if (itype == $$LEX_Format) 
                call proc_format (itype,state,token,int,ierr)

            else if (itype == $$LEX_Field) 
                call proc_field (itype,state,token,int,ierr)

            else
                call error ("Missing SUBTABLE/FORMAT/FIELD Keyword.")
            }

        case $$fmt1:
            {
            if (itype == $$LEX_System) 
                call error ("Extranous SYSTEM Keyword.")

            else if (itype == $$LEX_Table) 
                call error ("Extraneous TABLE Keyword.")

            else if (itype == $$LEX_Record) 
                call error ("Extraneous RECORD Keyword.")

            else if (itype == $$LEX_SubTable) 
                call proc_SubTbl(itype,state,token,int,ierr)

            else if (itype == $$LEX_Define) 
                call proc_define (itype,state,token,int,ierr)

            else if (itype == $$LEX_Format) 
                call proc_format (itype,state,token,int,ierr)

            else if (itype == $$LEX_Field) 
                call proc_field (itype,state,token,int,ierr)

            else
                call proc_fmt_fld (itype,state,token,int,ierr)
            }

        default:
            {
            itype = gettok (token,int)
            }
        }

    if (itype == $$LEX_Terminator) itype = gettok (token,int)
    } 

return
end

subroutine proc_system (itype,state,token,int,ierr)
d_common
integer         state, int
character       token[ARB], gettok, gtok, type, itype, charx

d_w = 1
call stcopy_vh ("System: "//char(EOS),1, d_where,d_w)

itype = gettok (token,int)

charx = type(token) 
if (charx == LETTER) 
    sys$id=install(token,sys$text,MAXTEXT,ddl_text)
else 
    call error ("Missing System-identifier")

call stcopy (token ,1, d_where,d_w)

itype = gettok (token,int)

if (itype == $$LEX_string)
    {
    ilen = length(token)
    token[ilen] = EOS   # remove the Quotes
    
    sys$Title=install(token[2],sys$text,MAXTEXT,ddl_text)
    
    itype = gettok (token,int)
    }

if (itype == $$LEX_Date)
    {
    itype = gettok (token,int)

    if (itype == $$LEX_string)
        {
        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
    
        sys$Date =install(token[2],sys$text,MAXTEXT,ddl_text)
        }
    else
        {
        sys$Date =install(token,sys$text,MAXTEXT,ddl_text)
        }
    
    itype = gettok (token,int)
    }

state = $$SYS
    
return
end

subroutine proc_table (itype,state,token,int,ierr)
d_common
integer         state, int, equal
character       token[ARB], gettok, gtok, type, itype
VMSchar			token_v*ARB	
d_w2 = d_w
call stcopy_vh (", Table: ",1, d_where,d_w2)

itype = gettok (token,int)

if (type(token) != LETTER) 
    call error ("Missing Table-identifier")
        
call stcopy (token,1, d_where,d_w2)

for (k=1; k <= sys$tbl_count; k=k+1)    # search all tables for match on name
    {   
    tbl$Pointer$to k

    if (equal (token, ddl_text[tbl$id]) == YES)
        call error ("Duplicate Table-identifier.")
    }

if (sys$tbl_count >= MAXTBL)
        call error ("Too many Table Declarations.")

sys$tbl_count = sys$tbl_count + 1
tbl$Pointer$to sys$tbl_count

tbl$id = install(token,sys$text,MAXTEXT,ddl_text)

tbl$record = 0

itype = gettok (token,int)

if (itype == $$LEX_string)
    {
    ilen = length(token)
    token[ilen] = EOS   # remove the Quotes
    
    tbl$Title=install(token[2],sys$text,MAXTEXT,ddl_text)

    itype = gettok (token,int)
    }

repeat
    {
    if (itype == $$LEX_Terminator) break

    else if (itype == $$LEX_Description)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_string)
            call error ("Missing String after DESCRIPTION Keyword.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
            
        tbl$Description = install(token[2],sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)              # get the next token
        }

    else if (itype == $$LEX_Comments)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_string)
            call error ("Missing String after COMMENT Keyword.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
            
        tbl$Comment = install(token[2],sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)              # get the next token
        }

    else if (itype == $$LEX_Entry_Size)
        {
        itype = gettok (token,int)

        if (type(token) != DIGIT)
            call error ("Non-Numeric Table Entry Size.")

        tbl$entry = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        
        if (itype == $$LEX_Variable)
            {
            tbl$variable = YES

            itype = gettok (token,int)

            if (type(token) != LETTER)
                call error ("Missing Name of Variable-Length-Indicator.")

            tbl$var_name = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (type(token) != DIGIT)
                call error ("Invalid Size for Variable-Length element.")

            tbl$var_size = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (type(token) != DIGIT)
                call error ("Invalid Max for Variable-Length element.")

            tbl$var_max = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        }

    else if (itype == $$LEX_Slots)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_Other)
            call error ("Improper entry for SLOTS value.")

        tbl$slots = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        }

    else if (itype == $$LEX_Zero)
        {
        tbl$zero = YES
        tbl$sav_count = 0

        itype = gettok (token,int)

        if (itype == $$LEX_Save)
            {
            repeat
                {
                itype = gettok (token,int)

                if (itype != $$LEX_Other)
                    call error ("Improper entry for SAVE Name.")

                if (tbl$sav_count >= MAXSAVE)
                    call error ("Too many SAVEd fields.")

                tbl$sav_count = tbl$sav_count + 1
                tbl$sav$Index = tbl$sav_count

                tbl$sav$name = install(token,sys$text,MAXTEXT,ddl_text)
            
                itype = gettok (token,int)

                } until (itype != $$LEX_comma)
            }
        }

    else if (itype == $$LEX_Alternate)
        {
        itype = gettok (token,int)

        if (type(token) != DIGIT)
            call error ("Improper value for ALTERNATE.")

        tbl$Alternate = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)

        if (itype == $$LEX_Duplicate) 
            {
            tbl$Duplicate = YES
            itype = gettok (token,int)
            }
        }

    else if (itype == $$LEX_Range) 
        {
        tbl$Gen_Ranges = YES
        itype = gettok (token,int)
        }

    else if (itype == $$LEX_Flag_Updates | itype == $$LEX_Flag_Changes)
        {
		tbl$Flag_Changes = (itype == $$LEX_Flag_Changes)
        itype = gettok (token,int)

        if (type(token) != LETTER) 
            call error ("Improper name for FLAG UPDATES.")

        tbl$Flag_Updates = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)

        if (itype == $$LEX_All) 
            {
            tbl$Flag_All = YES
            itype = gettok (token,int)
            }
        }

    else 
        {
        call remark_v ("Unknown Table Parameter......")
		call rs2fs (token, token_v)
        call error (token_v)
        }
    }

state = $$TBL1
    
return
end

subroutine proc_record (itype,state,token,int,ierr)
d_common
integer         state, int, equal
character       token[ARB], gettok, gtok, type, itype
VMSchar			token_v*ARB
d_w2 = d_w
call stcopy_vh (", Record: ",1, d_where,d_w2)

itype = gettok (token,int)

if (type(token) != LETTER) 
    call error ("Missing Record-identifier")
        
call stcopy (token,1, d_where,d_w2)

for (k=1; k <= sys$tbl_count; k=k+1)    # search all tables for match on name
    {   
    tbl$Pointer$to k

    if (equal (token, ddl_text[tbl$id]) == YES)
        call error ("Duplicate Record-identifier.")
    }

if (sys$tbl_count >= MAXTBL)
        call error ("Too many Record Declarations.")

sys$tbl_count = sys$tbl_count + 1
tbl$Pointer$to sys$tbl_count

tbl$id = install(token,sys$text,MAXTEXT,ddl_text)

tbl$record = 1

itype = gettok (token,int)

if (itype == $$LEX_string)
    {
    ilen = length(token)
    token[ilen] = EOS   # remove the Quotes
    
    tbl$Title=install(token[2],sys$text,MAXTEXT,ddl_text)

    itype = gettok (token,int)
    }

repeat
    {
    if (itype == $$LEX_Terminator) break

    else if (itype == $$LEX_Description)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_string)
            call error ("Missing String after DESCRIPTION Keyword.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
            
        tbl$Description = install(token[2],sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)              # get the next token
        }

    else if (itype == $$LEX_Comments)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_string)
            call error ("Missing String after COMMENT Keyword.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
            
        tbl$Comment = install(token[2],sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)              # get the next token
        }

    else if (itype == $$LEX_Entry_Size)
        {
        itype = gettok (token,int)

        if (type(token) != DIGIT)
            call error ("Non-Numeric Table Entry Size.")

        tbl$entry = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        
        if (itype == $$LEX_Variable)
            {
            tbl$variable = YES

            itype = gettok (token,int)

            if (type(token) != LETTER)
                call error ("Missing Name of Variable-Length-Indicator.")

            tbl$var_name = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (type(token) != DIGIT)
                call error ("Invalid Size for Variable-Length element.")

            tbl$var_size = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (type(token) != DIGIT)
                call error ("Invalid Max for Variable-Length element.")

            tbl$var_max = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        }

    else if (itype == $$LEX_Zero)
        {
        tbl$zero = YES
        tbl$sav_count = 0

        itype = gettok (token,int)

        if (itype == $$LEX_Save)
            {
            repeat
                {
                itype = gettok (token,int)

                if (itype != $$LEX_Other)
                    call error ("Improper entry for SAVE Name.")

                if (tbl$sav_count >= MAXSAVE)
                    call error ("Too many SAVEd fields.")

                tbl$sav_count = tbl$sav_count + 1
                tbl$sav$Index = tbl$sav_count

                tbl$sav$name = install(token,sys$text,MAXTEXT,ddl_text)
            
                itype = gettok (token,int)

                } until (itype != $$LEX_comma)
            }
        }

    else if (itype == $$LEX_Alternate)
        {
        itype = gettok (token,int)

        if (type(token) != DIGIT)
            call error ("Improper value for ALTERNATE.")

        tbl$Alternate = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)

        if (itype == $$LEX_Duplicate) 
            {
            tbl$Duplicate = YES
            itype = gettok (token,int)
            }
        }

    else if (itype == $$LEX_Range ) 
        {
        tbl$Gen_Ranges = YES
        itype = gettok (token,int)
        }

    else 
        {
        call remark_v ("Unknown RECORD Parameter......")
		call rs2fs (token, token_v)
        call error (token_v)
        }
    }

state = $$TBL1
    
return
end


subroutine proc_subtbl (itype,state,token,int,ierr)
d_common
integer         state, int, equal
character       token[ARB], gettok, gtok, type, itype, work[MAXLINE]
VMSchar			token_v*ARB
d_w3 = d_w2
call stcopy_vh (", Sub-Table: ",1, d_where, d_w3)

itype = gettok (token,int)

if (type(token) != LETTER) 
    call error ("Missing Sub-Table-identifier")
        
call stcopy (token,1, d_where, d_w3)

tbl$Pointer$to sys$tbl_count

for (k=1; k <= tbl$Sub_count; k=k+1)    # search all sub-tbls for name
    {   
    tbl$sub$Index = k

    if (equal (token, ddl_text[tbl$Sub$id]) == YES)
        call error ("Duplicate Sub-Table-identifier.")
    }

if (tbl$sub_count >= MAXSUBTBL)
        call error ("Too many Sub-Table Declarations.")

tbl$sub_count = tbl$sub_count + 1
tbl$sub$Index = tbl$sub_count

tbl$sub$id = install(token,sys$text,MAXTEXT,ddl_text)

itype = gettok (token,int)

if (itype == $$LEX_string)
    {
    ilen = length(token)
    token[ilen] = EOS   # remove the Quotes
    
    tbl$sub$Title=install(token[2],sys$text,MAXTEXT,ddl_text)

    itype = gettok (token,int)
    }

repeat
    {
    if (itype == $$LEX_Terminator) break

    else if (itype == $$LEX_Description)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_string)
            call error ("Missing String after DESCRIPTION Keyword.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
            
        tbl$sub$Desc = install(token[2],sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)              # get the next token
        }

    else if (itype == $$LEX_Comments)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_string)
            call error ("Missing String after COMMENT Keyword.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
            
        tbl$sub$Com = install(token[2],sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)              # get the next token
        }

    else if (itype == $$LEX_Entry_Size)
        {
        itype = gettok (token,int)

        if (type(token) != DIGIT)
            call error ("Non-Numeric Sub-Table Entry Size.")

        tbl$sub$entSize= install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)

        if (itype == $$LEX_Bits)
            {
            tbl$sub$EntBit= YES

            itype = gettok (token,int)
            }
        }

    else if (itype == $$LEX_Slots)
        {
        itype = gettok (token,int)

        if (itype != $$LEX_Other)
            call error ("Improper entry for SLOTS value.")

        tbl$sub$slots = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        }

    else if (itype == $$LEX_Table_Offset)
        {
        itype = gettok (token,int)

        if (type(token) == LETTER)
            {
            tbl$sub$subtbl =install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (token[1] == PLUS) itype = gettok (token,int)

            if (type(token) == DIGIT)
                {
                tbl$sub$TblOff= install(token,sys$text,MAXTEXT,ddl_text)
    
                itype = gettok (token,int)
                }
            }
        else if (type(token) == DIGIT)
            {
            tbl$sub$TblOff= install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        else 
            {
            call error ("Invalid Table-Offset entry.")
            }
        }

    else if (itype == $$LEX_Word_Offset)
        {
        itype = gettok (token,int)

        if (type(token) != DIGIT)
            call error ("Non-Numeric Word-Offset.")

        tbl$sub$WrdOff= install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        }

    else if (itype == $$LEX_Address)
        {
        itype = gettok (token,int)

        call get_exp (itype,token,work,int)

        if (work[1] == EOS)
            call error ("Improper ADDRESS Expression")

        tbl$sub$add = install(work,sys$text,MAXTEXT,ddl_text)
        }

    else if (itype == $$LEX_Position)
        {
        itype = gettok (token,int)

        call get_exp (itype,token,work,int)

        if (work[1] == EOS)
            call error ("Improper POSITION Expression")

        tbl$sub$pos = install(work,sys$text,MAXTEXT,ddl_text)
        }

    else 
        {
        call remark_v ("Unknown Table Parameter......")
		call rs2fs (token, token_v)
        call error (token_v)
        }
    }

state = $$TBL1
    
return
end


subroutine proc_define (itype,state,token,int,ierr)
d_common
integer         state, int, ipos, getch
character       token[ARB], gettok, gtok, type, itype,
                char, work[MAXDefinition]

d_w3 = d_w2
call stcopy_vh (", Define: "//char(0),1, d_where,d_w3)

ipos = 1
itype = gettok (token,int)

if (token[1] != LPAREN) 
    call error ("Missing Left Paren for DEFINE")

call stcopy (token, 1, work, ipos)

itype = gettok (token,int)

if (type(token) != LETTER) 
    call error ("Missing Macro Name for DEFINE")
        
call stcopy (token,1, d_where, d_w3)
call stcopy (token,1, work, ipos)

tbl$Pointer$to sys$tbl_count

for (k=1; k <= tbl$def_count; k=k+1)    # search all defines for name
    {   
    tbl$def$Index = k

    if (equal (token, ddl_text[tbl$def$indx]) == YES)
        call error ("Duplicate Macro Name.")
    }

if (tbl$def_count >= MAXDEFINE)
	call error ("Too many Definition Declarations.")

tbl$def_count = tbl$def_count + 1
tbl$def$Index = tbl$def_count

itype = gettok (token,int)

if (token[1] != COMMA) 
    call error ("Missing Comma after macro-name for DEFINE.")

call stcopy (token, 1, work, ipos)

###################
#
# At this point, WORK contains '(macro-name,' 

nparen = 1
token[2] = EOS
while (getch(token[1],int) != EOF)      # NGETCH would normally be called 
	{                                   # but it removes TABS and NEWLINES.
	if (istat == EOF) break
    if (eofflag) break

    if      (token[1] == LPAREN) nparen = nparen+1
    else if (token[1] == RPAREN) nparen = nparen-1

    if (ipos >= MAXDefinition)
        call error ("Definition is Too long.")

    call stcopy (token, 1, work, ipos)

    if (nparen == 0) break
	}

if (nparen != 0)
    call error ("Un-Expected End-Of-File.")

####################

tbl$def$indx = install(work,sys$text,MAXTEXT,ddl_text)

itype = gettok (token,int)      # this should be a semicolon

state = $$tbl1
    
return
end


subroutine proc_format (itype,state,token,int,ierr)
d_common
integer         state, int
character       token[ARB], gettok, gtok, type, itype

d_w3 = d_w2
call stcopy_vh (", Format: ",1, d_where,d_w3)

itype = gettok (token,int)
fmt_cnt = 1
fmt_list[fmt_cnt] = 0

repeat
    {
    if (itype == $$LEX_terminator) break

    else if (itype == $$LEX_Seperator) 
        {
        if (fmt_list[fmt_cnt] == 0)
            call error ("FORMAT columns require a field (except the last).")
        
        fmt_cnt = fmt_cnt + 1
        fmt_list[fmt_cnt] = 0
        }

    switch (itype)
        {
        case    $$LEX_Class,
                $$LEX_Comments,
                $$LEX_Description,
                $$LEX_Field,
                $$LEX_Flag,
                $$LEX_Offset,
                $$LEX_Position,
                $$LEX_Precision,
                $$LEX_Range,
                $$LEX_Scaling,
                $$LEX_Size,
                $$LEX_Signed,
                $$LEX_Title,
                $$LEX_Type,
                $$LEX_Word:
                {
                if (fmt_list[fmt_cnt] != 0)
                    call error ("Too many fields in one FORMAT column.")

                fmt_list[fmt_cnt] = itype
                }
        }

    itype = gettok (token,int)
    }

if (fmt_list[1] != $$LEX_Field)
    call error ("The first FORMAT column must be FIELD.")

state = $$fmt1
    
return
end

subroutine proc_fmt_fld (itype,state,token,int,ierr)
d_common
integer         state, int, equal, almostequal, isnear, ctoi
character       token[ARB], work[ARB], gettok, gtok, type, itype

string character_kw "CHARACTER"
string floating_kw "FLOATING"
string vaxchar_kw "VAXCHAR"
string integer_kw "INTEGER"
string word_kw "WORD"
string half_kw "HALF"
string byte_kw "BYTE"
string indicator_kw "INDICATOR"
string flag_kw "FLAG"
string pointer_kw "POINTER"
string index_kw "INDEX"

d_w3 = d_w2
call stcopy_vh (", Formatted Field: ",1, d_where,d_w3)

ifld = 0
fmt_list[fmt_cnt+1] = -1

repeat
    {
    if (eofflag) break

    ifld = ifld + 1
    if (ifld > fmt_cnt)
        {
        if (fmt_list[fmt_cnt] == 0) ifld = fmt_cnt
        else                        ifld = fmt_cnt + 1
        }

    ifmt = fmt_list[ifld]

    if (ifmt == 0)
        {
        ifmt = itype

        switch (ifmt)
            {
            case $$LEX_Class,   $$LEX_Comments, $$LEX_Description,
                 $$LEX_Field,   $$LEX_Offset,   $$LEX_Position,
                 $$LEX_Precision,$$LEX_Range,   $$LEX_Scaling,
                 $$LEX_Size,    $$LEX_Title,    $$LEX_Type,
                 $$LEX_Signed,  $$LEX_Flag,     $$LEX_Word:
                {
                continue
                }
            default:
                {
                call error ("Invalid Keyword for a Blank column.")
                }
            }

        itype = gettok (token,int)      # get the "="

        if (token[1] == EQUALS)
            itype = gettok (token,int)
        }

    if (ifmt == $$LEX_Flag & tbl$Flag_Updates != NO) # ???????
        {
        if (type(token) == DIGIT)
            {
            kk = 1
            tbl$fld$Flag = ctoi (token,kk) + 1

            itype = gettok (token,int)
            }
        else 
            {
            tbl$fld$Flag = 1
            }
        }

    else if (ifmt == $$LEX_Signed)
        {
        tbl$fld$Signed = YES
        }

    else if (itype == $$LEX_seperator)
        {
        itype = gettok (token,int)

        next
        }
    else if (ifmt == $$LEX_field)
        {
        if (type(token) != LETTER) 
            call error ("Missing FIELD Name.")
                
        call stcopy (token ,1, d_where,d_w3)

        tbl$Pointer$to sys$tbl_count
        
        ##for (k=1; k <= tbl$fld_count; k=k+1)  # search all fields for name
        ##    { 
        ##    tbl$fld$Index = k
        ##
        ##    if (equal (token, ddl_text[tbl$fld$name]) == YES)
        ##      call error ("Duplicate Field Name.")
        ##    }

        if (tbl$fld_count >= MAXFIELD)
            call error ("Too many Field Declarations.")

        tbl$fld_count = tbl$fld_count + 1
        tbl$fld$Index = tbl$fld_count

        tbl$fld$name = install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        }
    
    else if (ifmt == $$LEX_Title)
        {
        if (itype != $$LEX_string)
            call error ("Missing String for TITLE column.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
    
        tbl$fld$Title =install(token[2],sys$text,MAXTEXT,ddl_text)
            
        itype = gettok (token,int)
        }
    
    else if (ifmt == $$LEX_Description)
        {
        if (itype != $$LEX_string)
            call error ("Missing String for DESCRIPTION column.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
    
        tbl$fld$Desc =install(token[2],sys$text,MAXTEXT,ddl_text)
            
        itype = gettok (token,int)
        }
    
    else if (ifmt == $$LEX_Comments)
        {
        if (itype != $$LEX_string)
            call error ("Missing String for COMMENTS column.")

        ilen = length(token)
        token[ilen] = EOS       # remove the Quotes
    
        tbl$fld$com =install(token[2],sys$text,MAXTEXT,ddl_text)
            
        itype = gettok (token,int)
        }
    
    else if (ifmt == $$LEX_Type)
        {
        if (almostequal(token,lextext[lexhead[$$LEX_Character]]) == YES)
            tbl$fld$Type =install(CHARACTER_KW,sys$text,MAXTEXT,ddl_text)

        else if (almostequal(token,lextext[lexhead[$$LEX_Floating ]]) == YES)
            tbl$fld$Type =install(FLOATING_KW,sys$text,MAXTEXT,ddl_text)

        else if (almostequal(token,lextext[lexhead[$$LEX_VaxChar]]) == YES)
            tbl$fld$Type =install(VAXCHAR_KW,sys$text,MAXTEXT,ddl_text)

        else if (almostequal(token,lextext[lexhead[$$LEX_Integer  ]]) == YES)
            tbl$fld$Type =install(INTEGER_KW,sys$text,MAXTEXT,ddl_text)

        else
            call error ("Invalid option for TYPE column.")


        itype = gettok (token,int)
        }
    
    else if (ifmt == $$LEX_Word)
        {
		isnear= almostequal(token,lextext[lexhead[$$LEX_Indirect]] == YES)
        if ((itype == $$LEX_Indirect) |
            (token[1] == STAR)        |
            (isnear == YES))           
            {
            itype = gettok (token,int)

            if (itype != $$LEX_other & type(token) == LETTER)
                call error ("Invalid indirect reference in WORD column.")

            tbl$fld$indir =install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        else if (type(token) == LETTER)
            {
            tbl$fld$WrdSub =install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (token[1] == PLUS) itype = gettok (token,int)

            if (type(token) == DIGIT)
                {
                tbl$fld$word = install(token,sys$text,MAXTEXT,ddl_text)
    
                itype = gettok (token,int)
                }
            }
        else if (type(token) == DIGIT)
            {
            tbl$fld$word = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        else 
            {
            call error ("Invalid Address for WORD column.")
            }
        }
    
    else if (ifmt == $$LEX_Position)
        {
        if (type(token) != DIGIT & type(token) != LETTER)
            {
            call error ("Invalid entry for POSITION column.")
            }

#        tbl$fld$pos =install(token,sys$text,MAXTEXT,ddl_text)
#        itype = gettok (token,int)

        #  OLD ^^    NEW vv

        if (type(token) == LETTER)
            {
            tbl$fld$PosSub =install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (token[1] == PLUS) itype = gettok (token,int)

            if (type(token) == DIGIT)
                {
                tbl$fld$pos = install(token,sys$text,MAXTEXT,ddl_text)
    
                itype = gettok (token,int)
                }
            }
        else if (type(token) == DIGIT)
            {
            tbl$fld$pos = install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        }

    else if (ifmt == $$LEX_Size)
        {
        if (type(token) == DIGIT)
            {
            tbl$fld$Size =install(token,sys$text,MAXTEXT,ddl_text)
            }
        else if (itype == $$LEX_WORD)
            {
            tbl$fld$Size =install(WORD_KW,sys$text,MAXTEXT,ddl_text)
            }
        else if (itype == $$LEX_HALF)
            {
            tbl$fld$Signed = YES
            tbl$fld$Size =install(HALF_KW,sys$text,MAXTEXT,ddl_text)
            }
        else if (itype == $$LEX_BYTE)
            {
            tbl$fld$Signed = YES
            tbl$fld$Size =install(BYTE_KW,sys$text,MAXTEXT,ddl_text)
            }
        else 
            {
            call error ("Invalid entry for SIZE column.")
            }

        itype = gettok (token,int)
        }

    else if (ifmt == $$LEX_Class)
        {
        if (itype == $$LEX_Indicator) 
            {
            tbl$fld$Class =install(INDICATOR_KW,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }

        else if (itype == $$LEX_Flag) 
            {
            tbl$fld$Class =install(FLAG_KW,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }

        else if (itype == $$LEX_Pointer) 
            {
            tbl$fld$Class =install(POINTER_KW,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            if (type(token) == LETTER)
                {
                tbl$fld$CDesc =install(token,sys$text,MAXTEXT,ddl_text)

                itype = gettok (token,int)
                }
            else 
                {
                call error ("Missing table name for CLASS POINTER column.")
                }
            }

        else if (itype == $$LEX_Index) 
            {
            tbl$fld$Class =install(INDEX_KW,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)

            call get_tbls (itype,token,work,int)

            if (work[1] == EOS)
                call error ("Missing table names for CLASS INDEX column.")

            tbl$fld$CDesc =install(work,sys$text,MAXTEXT,ddl_text)
            }

        else 
            {
            tbl$fld$Class =install(token,sys$text,MAXTEXT,ddl_text)
            }
        }

    else if (ifmt == $$LEX_Offset)
        {
        if (type(token) == DIGIT | token[1] == MINUS)
            {
            call get_offset (itype,token,work,int)

            if (work[1] == EOS)
                call error ("Improper value for OFFSET column.")

            tbl$fld$Off =install(work,sys$text,MAXTEXT,ddl_text)
            }
        else 
            {
            call error ("Invalid entry for OFFSET column.")
            }
        }

    else if (ifmt == $$LEX_Scaling)
        {
        if (token[1] == LPAREN)
            {
            call get_exp (itype,token,work,int)

            if (work[1] == EOS)
                call error ("Invalid expression for SCALING column.")

            tbl$fld$Scale =install(work,sys$text,MAXTEXT,ddl_text)
            }
        else if (type(token) == DIGIT)
            {
            tbl$fld$Scale =install(token,sys$text,MAXTEXT,ddl_text)

            itype = gettok (token,int)
            }
        else 
            {
            call error ("Invalid entry for SCALING column.")
            }
        }

    else if (ifmt == $$LEX_Range)
        {
        if (token[1] == LPAREN)
            {
            call get_exp (itype,token,work,int)

            if (work[1] == EOS)
                call error ("Invalid list for RANGE column.")

            tbl$fld$Range =install(work,sys$text,MAXTEXT,ddl_text)
            }
        else if (type(token) == DIGIT | token[1] == MINUS)
            {
            call get_range (itype,token,work,int)

            if (work[1] == EOS)
                call error ("Invalid range for RANGE column.")

            tbl$fld$Range =install(work,sys$text,MAXTEXT,ddl_text)
            }
        else 
            {
            call error ("Invalid entry for RANGE column.")
            }
        }

    else if (ifmt == $$LEX_Precision)
        {
        if (type(token) != DIGIT)
            {
            call error ("Invalid entry for PRECISION column.")
            }

        tbl$fld$Prec =install(token,sys$text,MAXTEXT,ddl_text)

        itype = gettok (token,int)
        }



    while (itype != $$LEX_seperator & itype != $$LEX_terminator)
        {
        if (eofflag) break

        call putlin_v ("Extraneous Data in the Formatted line: ",ERROUT)
        call remark (token)

        itype = gettok (token,int)
        }

    if (itype != $$LEX_terminator) itype = gettok (token,int)

    } until (itype == $$LEX_terminator)

return
end

subroutine get_exp (itype,token,work,int)
d_common
character       token[ARB], work[ARB], gettok, gtok, type, itype
integer         int, ipos, nparen

nparen = 0
ipos = 1

repeat
    {
    call stcopy (token,1,work,ipos)

    if      (token[1] == LPAREN) nparen = nparen + 1
    else if (token[1] == RPAREN) nparen = nparen - 1

    if (itype == $$LEX_terminator |
        eofflag                   |
        itype == $$LEX_string     |
        itype == $$LEX_seperator   )
        {
        work[1] = EOS
        break
        }       # call error ("Improper Expression")

    itype = gettok (token,int)

    } until (nparen <= 0)

return
end

subroutine get_tbls (itype,token,work,int)
d_common
character       token[ARB], work[ARB], gettok, gtok, type, itype
integer         int, ipos, ntbls

ntbls = 0
ipos = 1

while (type(token) == LETTER)
    {
    if (ntbls > 0) call stcopy_vh (" ",1,work,ipos)

    ntbls = ntbls + 1

    call stcopy (token,1,work,ipos)

    itype = gettok (token,int)
    }

return
end

subroutine get_range (itype,token,work,int)
d_common
character       token[ARB], work[ARB], gettok, gtok, type, itype
integer         int, ipos, equal
#
# Format for Ranges:    1-1000  ==      1       -->     1000
#                       0.0-1.0 ==      0.0     -->     1.0
#                       -30-0   ==      -30     -->     0
#                       -30-30  ==      -30     -->     30
#
# NOTE: negative Upper-bounds are not allowed.
#

ipos = 1

call stcopy (token,1,work,ipos)

itype = gettok (token,int)

if (work[1] == MINUS)                     # lower bound is Negative
    {
    if (type(token) != DIGIT)
        {
        work[1] = EOS
        return
        }        
    
    call stcopy (token,1,work,ipos)

    itype = gettok (token,int)
    }

if (token[1] != MINUS) 
    {
    work[1] = EOS
    return
    }

call stcopy (token,1,work,ipos)

itype = gettok (token,int)

if (type(token) != DIGIT) 
    {
    work[1] = EOS
    return
    }

call stcopy (token,1,work,ipos)

itype = gettok (token,int)

return
end


subroutine get_offset (itype,token,work,int)
d_common
character       token[ARB], work[ARB], gettok, gtok, type, itype
integer         int, ipos

#
# Format for Offset:    20      ==      1       -->     1000
#                       -30     ==      -30     -->     0
#
#

ipos = 1

call stcopy (token,1,work,ipos)

itype = gettok (token,int)

if (work[1] == MINUS)                     # value is Negative
    {
    if (type(token) != DIGIT)
        {
        work[1] = EOS
        return
        }        
    
    call stcopy (token,1,work,ipos)

    itype = gettok (token,int)
    }

return
end


subroutine proc_field (itype,state,token,int,ierr)
d_common
integer         state, int
character       token[ARB], gettok, gtok, type, itype

d_w3 = d_w2
call stcopy_vh (", Field: ",1, d_where,d_w3)

itype = gettok (token,int)

if (type(token) == LETTER) 
    call error ("Missing Field Name")

call stcopy (token, 1, d_where,d_w3)


call error ("Expanded FIELD definition is not enabled at this time.")

state = $$tbl1
    
return
end
